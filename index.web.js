module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _NSColor = __webpack_require__(1);

	var _NSColor2 = _interopRequireDefault(_NSColor);

	var _NSColorSpaceModel = __webpack_require__(12);

	var _NSColorSpaceModel2 = _interopRequireDefault(_NSColorSpaceModel);

	var _AVAudioMixerNode = __webpack_require__(13);

	var _AVAudioMixerNode2 = _interopRequireDefault(_AVAudioMixerNode);

	var _AVAudioNode = __webpack_require__(14);

	var _AVAudioNode2 = _interopRequireDefault(_AVAudioNode);

	var _CGBlendMode = __webpack_require__(15);

	var _CGBlendMode2 = _interopRequireDefault(_CGBlendMode);

	var _CGLineCap = __webpack_require__(16);

	var _CGLineCap2 = _interopRequireDefault(_CGLineCap);

	var _CGLineJoin = __webpack_require__(17);

	var _CGLineJoin2 = _interopRequireDefault(_CGLineJoin);

	var _CGMutablePath = __webpack_require__(18);

	var _CGMutablePath2 = _interopRequireDefault(_CGMutablePath);

	var _CGPath = __webpack_require__(19);

	var _CGPath2 = _interopRequireDefault(_CGPath);

	var _CGPathApplierFunction = __webpack_require__(21);

	var _CGPathApplierFunction2 = _interopRequireDefault(_CGPathApplierFunction);

	var _CGPathFillRule = __webpack_require__(20);

	var _CGPathFillRule2 = _interopRequireDefault(_CGPathFillRule);

	var _CGPoint = __webpack_require__(7);

	var _CGPoint2 = _interopRequireDefault(_CGPoint);

	var _CGRect = __webpack_require__(8);

	var _CGRect2 = _interopRequireDefault(_CGRect);

	var _CGSize = __webpack_require__(9);

	var _CGSize2 = _interopRequireDefault(_CGSize);

	var _CGVector = __webpack_require__(22);

	var _CGVector2 = _interopRequireDefault(_CGVector);

	var _DispatchObject = __webpack_require__(23);

	var _DispatchObject2 = _interopRequireDefault(_DispatchObject);

	var _DispatchQueue = __webpack_require__(24);

	var _DispatchQueue2 = _interopRequireDefault(_DispatchQueue);

	var _DispatchTime = __webpack_require__(25);

	var _DispatchTime2 = _interopRequireDefault(_DispatchTime);

	var _DispatchTimeInterval = __webpack_require__(26);

	var _DispatchTimeInterval2 = _interopRequireDefault(_DispatchTimeInterval);

	var _NSArray = __webpack_require__(27);

	var _NSArray2 = _interopRequireDefault(_NSArray);

	var _NSCoder = __webpack_require__(28);

	var _NSCoder2 = _interopRequireDefault(_NSCoder);

	var _NSColorSpace = __webpack_require__(29);

	var _NSColorSpace2 = _interopRequireDefault(_NSColorSpace);

	var _NSData = __webpack_require__(30);

	var _NSData2 = _interopRequireDefault(_NSData);

	var _NSDictionary = __webpack_require__(31);

	var _NSDictionary2 = _interopRequireDefault(_NSDictionary);

	var _NSKeyedArchiver = __webpack_require__(32);

	var _NSKeyedArchiver2 = _interopRequireDefault(_NSKeyedArchiver);

	var _NSKeyedUnarchiver = __webpack_require__(33);

	var _NSKeyedUnarchiver2 = _interopRequireDefault(_NSKeyedUnarchiver);

	var _NSMutableArray = __webpack_require__(38);

	var _NSMutableArray2 = _interopRequireDefault(_NSMutableArray);

	var _NSMutableData = __webpack_require__(39);

	var _NSMutableData2 = _interopRequireDefault(_NSMutableData);

	var _NSMutableDictionary = __webpack_require__(40);

	var _NSMutableDictionary2 = _interopRequireDefault(_NSMutableDictionary);

	var _NSURL = __webpack_require__(41);

	var _NSURL2 = _interopRequireDefault(_NSURL);

	var _NSValue = __webpack_require__(42);

	var _NSValue2 = _interopRequireDefault(_NSValue);

	var _NSObject = __webpack_require__(2);

	var _NSObject2 = _interopRequireDefault(_NSObject);

	var _CAAction = __webpack_require__(47);

	var _CAAction2 = _interopRequireDefault(_CAAction);

	var _CAAnimation = __webpack_require__(48);

	var _CAAnimation2 = _interopRequireDefault(_CAAnimation);

	var _CAAnimationDelegate = __webpack_require__(52);

	var _CAAnimationDelegate2 = _interopRequireDefault(_CAAnimationDelegate);

	var _CAAnimationGroup = __webpack_require__(54);

	var _CAAnimationGroup2 = _interopRequireDefault(_CAAnimationGroup);

	var _CABasicAnimation = __webpack_require__(55);

	var _CABasicAnimation2 = _interopRequireDefault(_CABasicAnimation);

	var _CACurrentMediaTime = __webpack_require__(58);

	var _CACurrentMediaTime2 = _interopRequireDefault(_CACurrentMediaTime);

	var _CAKeyframeAnimation = __webpack_require__(59);

	var _CAKeyframeAnimation2 = _interopRequireDefault(_CAKeyframeAnimation);

	var _CAMediaTiming = __webpack_require__(50);

	var _CAMediaTiming2 = _interopRequireDefault(_CAMediaTiming);

	var _CAMediaTimingFunction = __webpack_require__(51);

	var _CAMediaTimingFunction2 = _interopRequireDefault(_CAMediaTimingFunction);

	var _CAPropertyAnimation = __webpack_require__(56);

	var _CAPropertyAnimation2 = _interopRequireDefault(_CAPropertyAnimation);

	var _CATransform3D = __webpack_require__(43);

	var _CATransform3D2 = _interopRequireDefault(_CATransform3D);

	var _SCNAction = __webpack_require__(60);

	var _SCNAction2 = _interopRequireDefault(_SCNAction);

	var _SCNActionable = __webpack_require__(62);

	var _SCNActionable2 = _interopRequireDefault(_SCNActionable);

	var _SCNActionCustom = __webpack_require__(63);

	var _SCNActionCustom2 = _interopRequireDefault(_SCNActionCustom);

	var _SCNActionFade = __webpack_require__(64);

	var _SCNActionFade2 = _interopRequireDefault(_SCNActionFade);

	var _SCNActionGroup = __webpack_require__(149);

	var _SCNActionGroup2 = _interopRequireDefault(_SCNActionGroup);

	var _SCNActionHide = __webpack_require__(150);

	var _SCNActionHide2 = _interopRequireDefault(_SCNActionHide);

	var _SCNActionJavaScript = __webpack_require__(151);

	var _SCNActionJavaScript2 = _interopRequireDefault(_SCNActionJavaScript);

	var _SCNActionMove = __webpack_require__(152);

	var _SCNActionMove2 = _interopRequireDefault(_SCNActionMove);

	var _SCNActionPerformSelector = __webpack_require__(153);

	var _SCNActionPerformSelector2 = _interopRequireDefault(_SCNActionPerformSelector);

	var _SCNActionPlaySound = __webpack_require__(154);

	var _SCNActionPlaySound2 = _interopRequireDefault(_SCNActionPlaySound);

	var _SCNActionReference = __webpack_require__(155);

	var _SCNActionReference2 = _interopRequireDefault(_SCNActionReference);

	var _SCNActionRemove = __webpack_require__(156);

	var _SCNActionRemove2 = _interopRequireDefault(_SCNActionRemove);

	var _SCNActionRepeat = __webpack_require__(157);

	var _SCNActionRepeat2 = _interopRequireDefault(_SCNActionRepeat);

	var _SCNActionRotate = __webpack_require__(158);

	var _SCNActionRotate2 = _interopRequireDefault(_SCNActionRotate);

	var _SCNActionRunAction = __webpack_require__(159);

	var _SCNActionRunAction2 = _interopRequireDefault(_SCNActionRunAction);

	var _SCNActionRunBlock = __webpack_require__(160);

	var _SCNActionRunBlock2 = _interopRequireDefault(_SCNActionRunBlock);

	var _SCNActionScale = __webpack_require__(161);

	var _SCNActionScale2 = _interopRequireDefault(_SCNActionScale);

	var _SCNActionSequence = __webpack_require__(162);

	var _SCNActionSequence2 = _interopRequireDefault(_SCNActionSequence);

	var _SCNActionTimingFunction = __webpack_require__(163);

	var _SCNActionTimingFunction2 = _interopRequireDefault(_SCNActionTimingFunction);

	var _SCNActionTimingMode = __webpack_require__(61);

	var _SCNActionTimingMode2 = _interopRequireDefault(_SCNActionTimingMode);

	var _SCNActionWait = __webpack_require__(164);

	var _SCNActionWait2 = _interopRequireDefault(_SCNActionWait);

	var _SCNAnimatable = __webpack_require__(66);

	var _SCNAnimatable2 = _interopRequireDefault(_SCNAnimatable);

	var _SCNAnimationEvent = __webpack_require__(53);

	var _SCNAnimationEvent2 = _interopRequireDefault(_SCNAnimationEvent);

	var _SCNAnimationEventBlock = __webpack_require__(165);

	var _SCNAnimationEventBlock2 = _interopRequireDefault(_SCNAnimationEventBlock);

	var _SCNAntialiasingMode = __webpack_require__(124);

	var _SCNAntialiasingMode2 = _interopRequireDefault(_SCNAntialiasingMode);

	var _SCNAudioPlayer = __webpack_require__(147);

	var _SCNAudioPlayer2 = _interopRequireDefault(_SCNAudioPlayer);

	var _SCNAudioSource = __webpack_require__(148);

	var _SCNAudioSource2 = _interopRequireDefault(_SCNAudioSource);

	var _SCNBillboardAxis = __webpack_require__(166);

	var _SCNBillboardAxis2 = _interopRequireDefault(_SCNBillboardAxis);

	var _SCNBillboardConstraint = __webpack_require__(167);

	var _SCNBillboardConstraint2 = _interopRequireDefault(_SCNBillboardConstraint);

	var _SCNBindingBlock = __webpack_require__(87);

	var _SCNBindingBlock2 = _interopRequireDefault(_SCNBindingBlock);

	var _SCNBlendMode = __webpack_require__(83);

	var _SCNBlendMode2 = _interopRequireDefault(_SCNBlendMode);

	var _SCNBoundingVolume = __webpack_require__(67);

	var _SCNBoundingVolume2 = _interopRequireDefault(_SCNBoundingVolume);

	var _SCNBox = __webpack_require__(91);

	var _SCNBox2 = _interopRequireDefault(_SCNBox);

	var _SCNBufferBindingBlock = __webpack_require__(128);

	var _SCNBufferBindingBlock2 = _interopRequireDefault(_SCNBufferBindingBlock);

	var _SCNBufferFrequency = __webpack_require__(127);

	var _SCNBufferFrequency2 = _interopRequireDefault(_SCNBufferFrequency);

	var _SCNBufferStream = __webpack_require__(129);

	var _SCNBufferStream2 = _interopRequireDefault(_SCNBufferStream);

	var _SCNCamera = __webpack_require__(130);

	var _SCNCamera2 = _interopRequireDefault(_SCNCamera);

	var _SCNCapsule = __webpack_require__(168);

	var _SCNCapsule2 = _interopRequireDefault(_SCNCapsule);

	var _SCNChamferMode = __webpack_require__(169);

	var _SCNChamferMode2 = _interopRequireDefault(_SCNChamferMode);

	var _SCNCone = __webpack_require__(170);

	var _SCNCone2 = _interopRequireDefault(_SCNCone);

	var _SCNConstraint = __webpack_require__(141);

	var _SCNConstraint2 = _interopRequireDefault(_SCNConstraint);

	var _SCNCullMode = __webpack_require__(69);

	var _SCNCullMode2 = _interopRequireDefault(_SCNCullMode);

	var _SCNCylinder = __webpack_require__(171);

	var _SCNCylinder2 = _interopRequireDefault(_SCNCylinder);

	var _SCNDebugOptions = __webpack_require__(120);

	var _SCNDebugOptions2 = _interopRequireDefault(_SCNDebugOptions);

	var _SCNFieldForceEvaluator = __webpack_require__(145);

	var _SCNFieldForceEvaluator2 = _interopRequireDefault(_SCNFieldForceEvaluator);

	var _SCNFilterMode = __webpack_require__(77);

	var _SCNFilterMode2 = _interopRequireDefault(_SCNFilterMode);

	var _SCNFloor = __webpack_require__(172);

	var _SCNFloor2 = _interopRequireDefault(_SCNFloor);

	var _SCNGeometry = __webpack_require__(68);

	var _SCNGeometry2 = _interopRequireDefault(_SCNGeometry);

	var _SCNGeometryElement = __webpack_require__(72);

	var _SCNGeometryElement2 = _interopRequireDefault(_SCNGeometryElement);

	var _SCNGeometryPrimitiveType = __webpack_require__(73);

	var _SCNGeometryPrimitiveType2 = _interopRequireDefault(_SCNGeometryPrimitiveType);

	var _SCNGeometrySource = __webpack_require__(71);

	var _SCNGeometrySource2 = _interopRequireDefault(_SCNGeometrySource);

	var _SCNHitTestOption = __webpack_require__(122);

	var _SCNHitTestOption2 = _interopRequireDefault(_SCNHitTestOption);

	var _SCNHitTestResult = __webpack_require__(106);

	var _SCNHitTestResult2 = _interopRequireDefault(_SCNHitTestResult);

	var _SCNIKConstraint = __webpack_require__(173);

	var _SCNIKConstraint2 = _interopRequireDefault(_SCNIKConstraint);

	var _SCNLayer = __webpack_require__(174);

	var _SCNLayer2 = _interopRequireDefault(_SCNLayer);

	var _SCNLevelOfDetail = __webpack_require__(74);

	var _SCNLevelOfDetail2 = _interopRequireDefault(_SCNLevelOfDetail);

	var _SCNLight = __webpack_require__(84);

	var _SCNLight2 = _interopRequireDefault(_SCNLight);

	var _SCNLookAtConstraint = __webpack_require__(175);

	var _SCNLookAtConstraint2 = _interopRequireDefault(_SCNLookAtConstraint);

	var _SCNMaterial = __webpack_require__(75);

	var _SCNMaterial2 = _interopRequireDefault(_SCNMaterial);

	var _SCNMaterialProperty = __webpack_require__(76);

	var _SCNMaterialProperty2 = _interopRequireDefault(_SCNMaterialProperty);

	var _SCNMatrix = __webpack_require__(46);

	var _SCNMatrix2 = _interopRequireDefault(_SCNMatrix);

	var _SCNMatrix4EqualToMatrix = __webpack_require__(176);

	var _SCNMatrix4EqualToMatrix2 = _interopRequireDefault(_SCNMatrix4EqualToMatrix);

	var _SCNMatrix4FromGLKMatrix = __webpack_require__(177);

	var _SCNMatrix4FromGLKMatrix2 = _interopRequireDefault(_SCNMatrix4FromGLKMatrix);

	var _SCNMatrix4FromMat = __webpack_require__(178);

	var _SCNMatrix4FromMat2 = _interopRequireDefault(_SCNMatrix4FromMat);

	var _SCNMatrix4Invert = __webpack_require__(179);

	var _SCNMatrix4Invert2 = _interopRequireDefault(_SCNMatrix4Invert);

	var _SCNMatrix4IsIdentity = __webpack_require__(180);

	var _SCNMatrix4IsIdentity2 = _interopRequireDefault(_SCNMatrix4IsIdentity);

	var _SCNMatrix4MakeRotation = __webpack_require__(181);

	var _SCNMatrix4MakeRotation2 = _interopRequireDefault(_SCNMatrix4MakeRotation);

	var _SCNMatrix4MakeScale = __webpack_require__(140);

	var _SCNMatrix4MakeScale2 = _interopRequireDefault(_SCNMatrix4MakeScale);

	var _SCNMatrix4MakeTranslation = __webpack_require__(78);

	var _SCNMatrix4MakeTranslation2 = _interopRequireDefault(_SCNMatrix4MakeTranslation);

	var _SCNMatrix4Mult = __webpack_require__(182);

	var _SCNMatrix4Mult2 = _interopRequireDefault(_SCNMatrix4Mult);

	var _SCNMatrix4Rotate = __webpack_require__(183);

	var _SCNMatrix4Rotate2 = _interopRequireDefault(_SCNMatrix4Rotate);

	var _SCNMatrix4Scale = __webpack_require__(184);

	var _SCNMatrix4Scale2 = _interopRequireDefault(_SCNMatrix4Scale);

	var _SCNMatrix4ToGLKMatrix = __webpack_require__(185);

	var _SCNMatrix4ToGLKMatrix2 = _interopRequireDefault(_SCNMatrix4ToGLKMatrix);

	var _SCNMatrix4ToMat = __webpack_require__(186);

	var _SCNMatrix4ToMat2 = _interopRequireDefault(_SCNMatrix4ToMat);

	var _SCNMatrix4Translate = __webpack_require__(187);

	var _SCNMatrix4Translate2 = _interopRequireDefault(_SCNMatrix4Translate);

	var _SCNMorpher = __webpack_require__(137);

	var _SCNMorpher2 = _interopRequireDefault(_SCNMorpher);

	var _SCNMorpherCalculationMode = __webpack_require__(138);

	var _SCNMorpherCalculationMode2 = _interopRequireDefault(_SCNMorpherCalculationMode);

	var _SCNMovabilityHint = __webpack_require__(142);

	var _SCNMovabilityHint2 = _interopRequireDefault(_SCNMovabilityHint);

	var _SCNNode = __webpack_require__(65);

	var _SCNNode2 = _interopRequireDefault(_SCNNode);

	var _SCNNodeRendererDelegate = __webpack_require__(143);

	var _SCNNodeRendererDelegate2 = _interopRequireDefault(_SCNNodeRendererDelegate);

	var _SCNOrderedDictionary = __webpack_require__(79);

	var _SCNOrderedDictionary2 = _interopRequireDefault(_SCNOrderedDictionary);

	var _SCNParticleBirthDirection = __webpack_require__(109);

	var _SCNParticleBirthDirection2 = _interopRequireDefault(_SCNParticleBirthDirection);

	var _SCNParticleBirthLocation = __webpack_require__(108);

	var _SCNParticleBirthLocation2 = _interopRequireDefault(_SCNParticleBirthLocation);

	var _SCNParticleBlendMode = __webpack_require__(111);

	var _SCNParticleBlendMode2 = _interopRequireDefault(_SCNParticleBlendMode);

	var _SCNParticleEvent = __webpack_require__(114);

	var _SCNParticleEvent2 = _interopRequireDefault(_SCNParticleEvent);

	var _SCNParticleEventBlock = __webpack_require__(115);

	var _SCNParticleEventBlock2 = _interopRequireDefault(_SCNParticleEventBlock);

	var _SCNParticleImageSequenceAnimationMode = __webpack_require__(110);

	var _SCNParticleImageSequenceAnimationMode2 = _interopRequireDefault(_SCNParticleImageSequenceAnimationMode);

	var _SCNParticleInputMode = __webpack_require__(117);

	var _SCNParticleInputMode2 = _interopRequireDefault(_SCNParticleInputMode);

	var _SCNParticleModifierBlock = __webpack_require__(119);

	var _SCNParticleModifierBlock2 = _interopRequireDefault(_SCNParticleModifierBlock);

	var _SCNParticleModifierStage = __webpack_require__(118);

	var _SCNParticleModifierStage2 = _interopRequireDefault(_SCNParticleModifierStage);

	var _SCNParticleOrientationMode = __webpack_require__(112);

	var _SCNParticleOrientationMode2 = _interopRequireDefault(_SCNParticleOrientationMode);

	var _SCNParticlePropertyController = __webpack_require__(116);

	var _SCNParticlePropertyController2 = _interopRequireDefault(_SCNParticlePropertyController);

	var _SCNParticleSortingMode = __webpack_require__(113);

	var _SCNParticleSortingMode2 = _interopRequireDefault(_SCNParticleSortingMode);

	var _SCNParticleSystem = __webpack_require__(107);

	var _SCNParticleSystem2 = _interopRequireDefault(_SCNParticleSystem);

	var _SCNPhysicsBallSocketJoint = __webpack_require__(188);

	var _SCNPhysicsBallSocketJoint2 = _interopRequireDefault(_SCNPhysicsBallSocketJoint);

	var _SCNPhysicsBehavior = __webpack_require__(100);

	var _SCNPhysicsBehavior2 = _interopRequireDefault(_SCNPhysicsBehavior);

	var _SCNPhysicsBody = __webpack_require__(103);

	var _SCNPhysicsBody2 = _interopRequireDefault(_SCNPhysicsBody);

	var _SCNPhysicsBodyType = __webpack_require__(104);

	var _SCNPhysicsBodyType2 = _interopRequireDefault(_SCNPhysicsBodyType);

	var _SCNPhysicsCollisionCategory = __webpack_require__(189);

	var _SCNPhysicsCollisionCategory2 = _interopRequireDefault(_SCNPhysicsCollisionCategory);

	var _SCNPhysicsContact = __webpack_require__(102);

	var _SCNPhysicsContact2 = _interopRequireDefault(_SCNPhysicsContact);

	var _SCNPhysicsContactDelegate = __webpack_require__(101);

	var _SCNPhysicsContactDelegate2 = _interopRequireDefault(_SCNPhysicsContactDelegate);

	var _SCNPhysicsField = __webpack_require__(144);

	var _SCNPhysicsField2 = _interopRequireDefault(_SCNPhysicsField);

	var _SCNPhysicsFieldScope = __webpack_require__(146);

	var _SCNPhysicsFieldScope2 = _interopRequireDefault(_SCNPhysicsFieldScope);

	var _SCNPhysicsHingeJoint = __webpack_require__(190);

	var _SCNPhysicsHingeJoint2 = _interopRequireDefault(_SCNPhysicsHingeJoint);

	var _SCNPhysicsShape = __webpack_require__(105);

	var _SCNPhysicsShape2 = _interopRequireDefault(_SCNPhysicsShape);

	var _SCNPhysicsSliderJoint = __webpack_require__(191);

	var _SCNPhysicsSliderJoint2 = _interopRequireDefault(_SCNPhysicsSliderJoint);

	var _SCNPhysicsVehicle = __webpack_require__(192);

	var _SCNPhysicsVehicle2 = _interopRequireDefault(_SCNPhysicsVehicle);

	var _SCNPhysicsVehicleWheel = __webpack_require__(193);

	var _SCNPhysicsVehicleWheel2 = _interopRequireDefault(_SCNPhysicsVehicleWheel);

	var _SCNPhysicsWorld = __webpack_require__(99);

	var _SCNPhysicsWorld2 = _interopRequireDefault(_SCNPhysicsWorld);

	var _SCNPlane = __webpack_require__(194);

	var _SCNPlane2 = _interopRequireDefault(_SCNPlane);

	var _SCNProgram = __webpack_require__(125);

	var _SCNProgram2 = _interopRequireDefault(_SCNProgram);

	var _SCNProgramDelegate = __webpack_require__(126);

	var _SCNProgramDelegate2 = _interopRequireDefault(_SCNProgramDelegate);

	var _SCNPyramid = __webpack_require__(195);

	var _SCNPyramid2 = _interopRequireDefault(_SCNPyramid);

	var _SCNQuaternion = __webpack_require__(57);

	var _SCNQuaternion2 = _interopRequireDefault(_SCNQuaternion);

	var _SCNReferenceLoadingPolicy = __webpack_require__(196);

	var _SCNReferenceLoadingPolicy2 = _interopRequireDefault(_SCNReferenceLoadingPolicy);

	var _SCNReferenceNode = __webpack_require__(197);

	var _SCNReferenceNode2 = _interopRequireDefault(_SCNReferenceNode);

	var _SCNRenderer = __webpack_require__(88);

	var _SCNRenderer2 = _interopRequireDefault(_SCNRenderer);

	var _SCNRenderingAPI = __webpack_require__(121);

	var _SCNRenderingAPI2 = _interopRequireDefault(_SCNRenderingAPI);

	var _SCNScene = __webpack_require__(90);

	var _SCNScene2 = _interopRequireDefault(_SCNScene);

	var _SCNSceneExportDelegate = __webpack_require__(92);

	var _SCNSceneExportDelegate2 = _interopRequireDefault(_SCNSceneExportDelegate);

	var _SCNSceneExportProgressHandler = __webpack_require__(93);

	var _SCNSceneExportProgressHandler2 = _interopRequireDefault(_SCNSceneExportProgressHandler);

	var _SCNSceneRenderer = __webpack_require__(89);

	var _SCNSceneRenderer2 = _interopRequireDefault(_SCNSceneRenderer);

	var _SCNSceneRendererDelegate = __webpack_require__(123);

	var _SCNSceneRendererDelegate2 = _interopRequireDefault(_SCNSceneRendererDelegate);

	var _SCNSceneSource = __webpack_require__(94);

	var _SCNSceneSource2 = _interopRequireDefault(_SCNSceneSource);

	var _SCNSceneSourceStatus = __webpack_require__(96);

	var _SCNSceneSourceStatus2 = _interopRequireDefault(_SCNSceneSourceStatus);

	var _SCNSceneSourceStatusHandler = __webpack_require__(95);

	var _SCNSceneSourceStatusHandler2 = _interopRequireDefault(_SCNSceneSourceStatusHandler);

	var _SCNShadable = __webpack_require__(70);

	var _SCNShadable2 = _interopRequireDefault(_SCNShadable);

	var _SCNShadableHelper = __webpack_require__(198);

	var _SCNShadableHelper2 = _interopRequireDefault(_SCNShadableHelper);

	var _SCNShaderModifierEntryPoint = __webpack_require__(199);

	var _SCNShaderModifierEntryPoint2 = _interopRequireDefault(_SCNShaderModifierEntryPoint);

	var _SCNShadowMode = __webpack_require__(136);

	var _SCNShadowMode2 = _interopRequireDefault(_SCNShadowMode);

	var _SCNShape = __webpack_require__(200);

	var _SCNShape2 = _interopRequireDefault(_SCNShape);

	var _SCNSkinner = __webpack_require__(139);

	var _SCNSkinner2 = _interopRequireDefault(_SCNSkinner);

	var _SCNSphere = __webpack_require__(201);

	var _SCNSphere2 = _interopRequireDefault(_SCNSphere);

	var _SCNTechnique = __webpack_require__(86);

	var _SCNTechnique2 = _interopRequireDefault(_SCNTechnique);

	var _SCNTechniqueSupport = __webpack_require__(85);

	var _SCNTechniqueSupport2 = _interopRequireDefault(_SCNTechniqueSupport);

	var _SCNText = __webpack_require__(202);

	var _SCNText2 = _interopRequireDefault(_SCNText);

	var _SCNTorus = __webpack_require__(203);

	var _SCNTorus2 = _interopRequireDefault(_SCNTorus);

	var _SCNTransaction = __webpack_require__(80);

	var _SCNTransaction2 = _interopRequireDefault(_SCNTransaction);

	var _SCNTransformConstraint = __webpack_require__(204);

	var _SCNTransformConstraint2 = _interopRequireDefault(_SCNTransformConstraint);

	var _SCNTransparencyMode = __webpack_require__(82);

	var _SCNTransparencyMode2 = _interopRequireDefault(_SCNTransparencyMode);

	var _SCNTube = __webpack_require__(205);

	var _SCNTube2 = _interopRequireDefault(_SCNTube);

	var _SCNVector = __webpack_require__(44);

	var _SCNVector2 = _interopRequireDefault(_SCNVector);

	var _SCNVector3EqualToVector = __webpack_require__(206);

	var _SCNVector3EqualToVector2 = _interopRequireDefault(_SCNVector3EqualToVector);

	var _SCNVector3FromFloat = __webpack_require__(207);

	var _SCNVector3FromFloat2 = _interopRequireDefault(_SCNVector3FromFloat);

	var _SCNVector3FromGLKVector = __webpack_require__(208);

	var _SCNVector3FromGLKVector2 = _interopRequireDefault(_SCNVector3FromGLKVector);

	var _SCNVector3Make = __webpack_require__(209);

	var _SCNVector3Make2 = _interopRequireDefault(_SCNVector3Make);

	var _SCNVector3ToFloat = __webpack_require__(210);

	var _SCNVector3ToFloat2 = _interopRequireDefault(_SCNVector3ToFloat);

	var _SCNVector3ToGLKVector = __webpack_require__(211);

	var _SCNVector3ToGLKVector2 = _interopRequireDefault(_SCNVector3ToGLKVector);

	var _SCNVector3Zero = __webpack_require__(212);

	var _SCNVector3Zero2 = _interopRequireDefault(_SCNVector3Zero);

	var _SCNVector3 = __webpack_require__(45);

	var _SCNVector4 = _interopRequireDefault(_SCNVector3);

	var _SCNVector4EqualToVector = __webpack_require__(213);

	var _SCNVector4EqualToVector2 = _interopRequireDefault(_SCNVector4EqualToVector);

	var _SCNVector4FromFloat = __webpack_require__(214);

	var _SCNVector4FromFloat2 = _interopRequireDefault(_SCNVector4FromFloat);

	var _SCNVector4FromGLKVector = __webpack_require__(215);

	var _SCNVector4FromGLKVector2 = _interopRequireDefault(_SCNVector4FromGLKVector);

	var _SCNVector4Make = __webpack_require__(216);

	var _SCNVector4Make2 = _interopRequireDefault(_SCNVector4Make);

	var _SCNVector4ToFloat = __webpack_require__(217);

	var _SCNVector4ToFloat2 = _interopRequireDefault(_SCNVector4ToFloat);

	var _SCNVector4ToGLKVector = __webpack_require__(218);

	var _SCNVector4ToGLKVector2 = _interopRequireDefault(_SCNVector4ToGLKVector);

	var _SCNView = __webpack_require__(219);

	var _SCNView2 = _interopRequireDefault(_SCNView);

	var _SCNWrapMode = __webpack_require__(81);

	var _SCNWrapMode2 = _interopRequireDefault(_SCNWrapMode);

	var _SKAction = __webpack_require__(220);

	var _SKAction2 = _interopRequireDefault(_SKAction);

	var _SKActionTimingMode = __webpack_require__(221);

	var _SKActionTimingMode2 = _interopRequireDefault(_SKActionTimingMode);

	var _SKBlendMode = __webpack_require__(132);

	var _SKBlendMode2 = _interopRequireDefault(_SKBlendMode);

	var _SKColor = __webpack_require__(11);

	var _SKColor2 = _interopRequireDefault(_SKColor);

	var _SKEffectNode = __webpack_require__(222);

	var _SKEffectNode2 = _interopRequireDefault(_SKEffectNode);

	var _SKFade = __webpack_require__(223);

	var _SKFade2 = _interopRequireDefault(_SKFade);

	var _SKGroup = __webpack_require__(224);

	var _SKGroup2 = _interopRequireDefault(_SKGroup);

	var _SKLabelHorizontalAlignmentMode = __webpack_require__(225);

	var _SKLabelHorizontalAlignmentMode2 = _interopRequireDefault(_SKLabelHorizontalAlignmentMode);

	var _SKLabelNode = __webpack_require__(226);

	var _SKLabelNode2 = _interopRequireDefault(_SKLabelNode);

	var _SKLabelVerticalAlignmentMode = __webpack_require__(227);

	var _SKLabelVerticalAlignmentMode2 = _interopRequireDefault(_SKLabelVerticalAlignmentMode);

	var _SKNode = __webpack_require__(133);

	var _SKNode2 = _interopRequireDefault(_SKNode);

	var _SKScale = __webpack_require__(228);

	var _SKScale2 = _interopRequireDefault(_SKScale);

	var _SKScene = __webpack_require__(229);

	var _SKScene2 = _interopRequireDefault(_SKScene);

	var _SKSceneScaleMode = __webpack_require__(230);

	var _SKSceneScaleMode2 = _interopRequireDefault(_SKSceneScaleMode);

	var _SKSequence = __webpack_require__(231);

	var _SKSequence2 = _interopRequireDefault(_SKSequence);

	var _SKShapeNode = __webpack_require__(232);

	var _SKShapeNode2 = _interopRequireDefault(_SKShapeNode);

	var _SKSpriteNode = __webpack_require__(131);

	var _SKSpriteNode2 = _interopRequireDefault(_SKSpriteNode);

	var _SKTexture = __webpack_require__(134);

	var _SKTexture2 = _interopRequireDefault(_SKTexture);

	var _SKTextureFilteringMode = __webpack_require__(135);

	var _SKTextureFilteringMode2 = _interopRequireDefault(_SKTextureFilteringMode);

	var _SKWait = __webpack_require__(233);

	var _SKWait2 = _interopRequireDefault(_SKWait);

	var _AjaxRequest2 = __webpack_require__(98);

	var _AjaxRequest3 = _interopRequireDefault(_AjaxRequest2);

	var _BinaryReader2 = __webpack_require__(36);

	var _BinaryReader3 = _interopRequireDefault(_BinaryReader2);

	var _BinaryRequest2 = __webpack_require__(97);

	var _BinaryRequest3 = _interopRequireDefault(_BinaryRequest2);

	var _Buffer2 = __webpack_require__(234);

	var _Buffer3 = _interopRequireDefault(_Buffer2);

	var _ClassList2 = __webpack_require__(10);

	var _ClassList3 = _interopRequireDefault(_ClassList2);

	var _File2 = __webpack_require__(34);

	var _File3 = _interopRequireDefault(_File2);

	var _FileReader2 = __webpack_require__(35);

	var _FileReader3 = _interopRequireDefault(_FileReader2);

	var _HTMLCanvasElement2 = __webpack_require__(236);

	var _HTMLCanvasElement3 = _interopRequireDefault(_HTMLCanvasElement2);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	_ClassList3.default.registerClass(_NSColor2.default);
	_ClassList3.default.registerClass(_NSColorSpaceModel2.default);
	_ClassList3.default.registerClass(_AVAudioMixerNode2.default);
	_ClassList3.default.registerClass(_AVAudioNode2.default);
	_ClassList3.default.registerClass(_CGBlendMode2.default);
	_ClassList3.default.registerClass(_CGLineCap2.default);
	_ClassList3.default.registerClass(_CGLineJoin2.default);
	_ClassList3.default.registerClass(_CGMutablePath2.default);
	_ClassList3.default.registerClass(_CGPath2.default);
	_ClassList3.default.registerClass(_CGPathApplierFunction2.default);
	_ClassList3.default.registerClass(_CGPathFillRule2.default);
	_ClassList3.default.registerClass(_CGPoint2.default);
	_ClassList3.default.registerClass(_CGRect2.default);
	_ClassList3.default.registerClass(_CGSize2.default);
	_ClassList3.default.registerClass(_CGVector2.default);
	_ClassList3.default.registerClass(_DispatchObject2.default);
	_ClassList3.default.registerClass(_DispatchQueue2.default);
	_ClassList3.default.registerClass(_DispatchTime2.default);
	_ClassList3.default.registerClass(_DispatchTimeInterval2.default);
	_ClassList3.default.registerClass(_NSArray2.default);
	_ClassList3.default.registerClass(_NSCoder2.default);
	_ClassList3.default.registerClass(_NSColorSpace2.default);
	_ClassList3.default.registerClass(_NSData2.default);
	_ClassList3.default.registerClass(_NSDictionary2.default);
	_ClassList3.default.registerClass(_NSKeyedArchiver2.default);
	_ClassList3.default.registerClass(_NSKeyedUnarchiver2.default);
	_ClassList3.default.registerClass(_NSMutableArray2.default);
	_ClassList3.default.registerClass(_NSMutableData2.default);
	_ClassList3.default.registerClass(_NSMutableDictionary2.default);
	_ClassList3.default.registerClass(_NSURL2.default);
	_ClassList3.default.registerClass(_NSValue2.default);
	_ClassList3.default.registerClass(_NSObject2.default);
	_ClassList3.default.registerClass(_CAAction2.default);
	_ClassList3.default.registerClass(_CAAnimation2.default);
	_ClassList3.default.registerClass(_CAAnimationDelegate2.default);
	_ClassList3.default.registerClass(_CAAnimationGroup2.default);
	_ClassList3.default.registerClass(_CABasicAnimation2.default);
	_ClassList3.default.registerClass(_CACurrentMediaTime2.default);
	_ClassList3.default.registerClass(_CAKeyframeAnimation2.default);
	_ClassList3.default.registerClass(_CAMediaTiming2.default);
	_ClassList3.default.registerClass(_CAMediaTimingFunction2.default);
	_ClassList3.default.registerClass(_CAPropertyAnimation2.default);
	_ClassList3.default.registerClass(_CATransform3D2.default);
	_ClassList3.default.registerClass(_SCNAction2.default);
	_ClassList3.default.registerClass(_SCNActionable2.default);
	_ClassList3.default.registerClass(_SCNActionCustom2.default);
	_ClassList3.default.registerClass(_SCNActionFade2.default);
	_ClassList3.default.registerClass(_SCNActionGroup2.default);
	_ClassList3.default.registerClass(_SCNActionHide2.default);
	_ClassList3.default.registerClass(_SCNActionJavaScript2.default);
	_ClassList3.default.registerClass(_SCNActionMove2.default);
	_ClassList3.default.registerClass(_SCNActionPerformSelector2.default);
	_ClassList3.default.registerClass(_SCNActionPlaySound2.default);
	_ClassList3.default.registerClass(_SCNActionReference2.default);
	_ClassList3.default.registerClass(_SCNActionRemove2.default);
	_ClassList3.default.registerClass(_SCNActionRepeat2.default);
	_ClassList3.default.registerClass(_SCNActionRotate2.default);
	_ClassList3.default.registerClass(_SCNActionRunAction2.default);
	_ClassList3.default.registerClass(_SCNActionRunBlock2.default);
	_ClassList3.default.registerClass(_SCNActionScale2.default);
	_ClassList3.default.registerClass(_SCNActionSequence2.default);
	_ClassList3.default.registerClass(_SCNActionTimingFunction2.default);
	_ClassList3.default.registerClass(_SCNActionTimingMode2.default);
	_ClassList3.default.registerClass(_SCNActionWait2.default);
	_ClassList3.default.registerClass(_SCNAnimatable2.default);
	_ClassList3.default.registerClass(_SCNAnimationEvent2.default);
	_ClassList3.default.registerClass(_SCNAnimationEventBlock2.default);
	_ClassList3.default.registerClass(_SCNAntialiasingMode2.default);
	_ClassList3.default.registerClass(_SCNAudioPlayer2.default);
	_ClassList3.default.registerClass(_SCNAudioSource2.default);
	_ClassList3.default.registerClass(_SCNBillboardAxis2.default);
	_ClassList3.default.registerClass(_SCNBillboardConstraint2.default);
	_ClassList3.default.registerClass(_SCNBindingBlock2.default);
	_ClassList3.default.registerClass(_SCNBlendMode2.default);
	_ClassList3.default.registerClass(_SCNBoundingVolume2.default);
	_ClassList3.default.registerClass(_SCNBox2.default);
	_ClassList3.default.registerClass(_SCNBufferBindingBlock2.default);
	_ClassList3.default.registerClass(_SCNBufferFrequency2.default);
	_ClassList3.default.registerClass(_SCNBufferStream2.default);
	_ClassList3.default.registerClass(_SCNCamera2.default);
	_ClassList3.default.registerClass(_SCNCapsule2.default);
	_ClassList3.default.registerClass(_SCNChamferMode2.default);
	_ClassList3.default.registerClass(_SCNCone2.default);
	_ClassList3.default.registerClass(_SCNConstraint2.default);
	_ClassList3.default.registerClass(_SCNCullMode2.default);
	_ClassList3.default.registerClass(_SCNCylinder2.default);
	_ClassList3.default.registerClass(_SCNDebugOptions2.default);
	_ClassList3.default.registerClass(_SCNFieldForceEvaluator2.default);
	_ClassList3.default.registerClass(_SCNFilterMode2.default);
	_ClassList3.default.registerClass(_SCNFloor2.default);
	_ClassList3.default.registerClass(_SCNGeometry2.default);
	_ClassList3.default.registerClass(_SCNGeometryElement2.default);
	_ClassList3.default.registerClass(_SCNGeometryPrimitiveType2.default);
	_ClassList3.default.registerClass(_SCNGeometrySource2.default);
	_ClassList3.default.registerClass(_SCNHitTestOption2.default);
	_ClassList3.default.registerClass(_SCNHitTestResult2.default);
	_ClassList3.default.registerClass(_SCNIKConstraint2.default);
	_ClassList3.default.registerClass(_SCNLayer2.default);
	_ClassList3.default.registerClass(_SCNLevelOfDetail2.default);
	_ClassList3.default.registerClass(_SCNLight2.default);
	_ClassList3.default.registerClass(_SCNLookAtConstraint2.default);
	_ClassList3.default.registerClass(_SCNMaterial2.default);
	_ClassList3.default.registerClass(_SCNMaterialProperty2.default);
	_ClassList3.default.registerClass(_SCNMatrix2.default);
	_ClassList3.default.registerClass(_SCNMatrix4EqualToMatrix2.default);
	_ClassList3.default.registerClass(_SCNMatrix4FromGLKMatrix2.default);
	_ClassList3.default.registerClass(_SCNMatrix4FromMat2.default);
	_ClassList3.default.registerClass(_SCNMatrix4Invert2.default);
	_ClassList3.default.registerClass(_SCNMatrix4IsIdentity2.default);
	_ClassList3.default.registerClass(_SCNMatrix4MakeRotation2.default);
	_ClassList3.default.registerClass(_SCNMatrix4MakeScale2.default);
	_ClassList3.default.registerClass(_SCNMatrix4MakeTranslation2.default);
	_ClassList3.default.registerClass(_SCNMatrix4Mult2.default);
	_ClassList3.default.registerClass(_SCNMatrix4Rotate2.default);
	_ClassList3.default.registerClass(_SCNMatrix4Scale2.default);
	_ClassList3.default.registerClass(_SCNMatrix4ToGLKMatrix2.default);
	_ClassList3.default.registerClass(_SCNMatrix4ToMat2.default);
	_ClassList3.default.registerClass(_SCNMatrix4Translate2.default);
	_ClassList3.default.registerClass(_SCNMorpher2.default);
	_ClassList3.default.registerClass(_SCNMorpherCalculationMode2.default);
	_ClassList3.default.registerClass(_SCNMovabilityHint2.default);
	_ClassList3.default.registerClass(_SCNNode2.default);
	_ClassList3.default.registerClass(_SCNNodeRendererDelegate2.default);
	_ClassList3.default.registerClass(_SCNOrderedDictionary2.default);
	_ClassList3.default.registerClass(_SCNParticleBirthDirection2.default);
	_ClassList3.default.registerClass(_SCNParticleBirthLocation2.default);
	_ClassList3.default.registerClass(_SCNParticleBlendMode2.default);
	_ClassList3.default.registerClass(_SCNParticleEvent2.default);
	_ClassList3.default.registerClass(_SCNParticleEventBlock2.default);
	_ClassList3.default.registerClass(_SCNParticleImageSequenceAnimationMode2.default);
	_ClassList3.default.registerClass(_SCNParticleInputMode2.default);
	_ClassList3.default.registerClass(_SCNParticleModifierBlock2.default);
	_ClassList3.default.registerClass(_SCNParticleModifierStage2.default);
	_ClassList3.default.registerClass(_SCNParticleOrientationMode2.default);
	_ClassList3.default.registerClass(_SCNParticlePropertyController2.default);
	_ClassList3.default.registerClass(_SCNParticleSortingMode2.default);
	_ClassList3.default.registerClass(_SCNParticleSystem2.default);
	_ClassList3.default.registerClass(_SCNPhysicsBallSocketJoint2.default);
	_ClassList3.default.registerClass(_SCNPhysicsBehavior2.default);
	_ClassList3.default.registerClass(_SCNPhysicsBody2.default);
	_ClassList3.default.registerClass(_SCNPhysicsBodyType2.default);
	_ClassList3.default.registerClass(_SCNPhysicsCollisionCategory2.default);
	_ClassList3.default.registerClass(_SCNPhysicsContact2.default);
	_ClassList3.default.registerClass(_SCNPhysicsContactDelegate2.default);
	_ClassList3.default.registerClass(_SCNPhysicsField2.default);
	_ClassList3.default.registerClass(_SCNPhysicsFieldScope2.default);
	_ClassList3.default.registerClass(_SCNPhysicsHingeJoint2.default);
	_ClassList3.default.registerClass(_SCNPhysicsShape2.default);
	_ClassList3.default.registerClass(_SCNPhysicsSliderJoint2.default);
	_ClassList3.default.registerClass(_SCNPhysicsVehicle2.default);
	_ClassList3.default.registerClass(_SCNPhysicsVehicleWheel2.default);
	_ClassList3.default.registerClass(_SCNPhysicsWorld2.default);
	_ClassList3.default.registerClass(_SCNPlane2.default);
	_ClassList3.default.registerClass(_SCNProgram2.default);
	_ClassList3.default.registerClass(_SCNProgramDelegate2.default);
	_ClassList3.default.registerClass(_SCNPyramid2.default);
	_ClassList3.default.registerClass(_SCNQuaternion2.default);
	_ClassList3.default.registerClass(_SCNReferenceLoadingPolicy2.default);
	_ClassList3.default.registerClass(_SCNReferenceNode2.default);
	_ClassList3.default.registerClass(_SCNRenderer2.default);
	_ClassList3.default.registerClass(_SCNRenderingAPI2.default);
	_ClassList3.default.registerClass(_SCNScene2.default);
	_ClassList3.default.registerClass(_SCNSceneExportDelegate2.default);
	_ClassList3.default.registerClass(_SCNSceneExportProgressHandler2.default);
	_ClassList3.default.registerClass(_SCNSceneRenderer2.default);
	_ClassList3.default.registerClass(_SCNSceneRendererDelegate2.default);
	_ClassList3.default.registerClass(_SCNSceneSource2.default);
	_ClassList3.default.registerClass(_SCNSceneSourceStatus2.default);
	_ClassList3.default.registerClass(_SCNSceneSourceStatusHandler2.default);
	_ClassList3.default.registerClass(_SCNShadable2.default);
	_ClassList3.default.registerClass(_SCNShadableHelper2.default);
	_ClassList3.default.registerClass(_SCNShaderModifierEntryPoint2.default);
	_ClassList3.default.registerClass(_SCNShadowMode2.default);
	_ClassList3.default.registerClass(_SCNShape2.default);
	_ClassList3.default.registerClass(_SCNSkinner2.default);
	_ClassList3.default.registerClass(_SCNSphere2.default);
	_ClassList3.default.registerClass(_SCNTechnique2.default);
	_ClassList3.default.registerClass(_SCNTechniqueSupport2.default);
	_ClassList3.default.registerClass(_SCNText2.default);
	_ClassList3.default.registerClass(_SCNTorus2.default);
	_ClassList3.default.registerClass(_SCNTransaction2.default);
	_ClassList3.default.registerClass(_SCNTransformConstraint2.default);
	_ClassList3.default.registerClass(_SCNTransparencyMode2.default);
	_ClassList3.default.registerClass(_SCNTube2.default);
	_ClassList3.default.registerClass(_SCNVector2.default);
	_ClassList3.default.registerClass(_SCNVector3EqualToVector2.default);
	_ClassList3.default.registerClass(_SCNVector3FromFloat2.default);
	_ClassList3.default.registerClass(_SCNVector3FromGLKVector2.default);
	_ClassList3.default.registerClass(_SCNVector3Make2.default);
	_ClassList3.default.registerClass(_SCNVector3ToFloat2.default);
	_ClassList3.default.registerClass(_SCNVector3ToGLKVector2.default);
	_ClassList3.default.registerClass(_SCNVector3Zero2.default);
	_ClassList3.default.registerClass(_SCNVector4.default);
	_ClassList3.default.registerClass(_SCNVector4EqualToVector2.default);
	_ClassList3.default.registerClass(_SCNVector4FromFloat2.default);
	_ClassList3.default.registerClass(_SCNVector4FromGLKVector2.default);
	_ClassList3.default.registerClass(_SCNVector4Make2.default);
	_ClassList3.default.registerClass(_SCNVector4ToFloat2.default);
	_ClassList3.default.registerClass(_SCNVector4ToGLKVector2.default);
	_ClassList3.default.registerClass(_SCNView2.default);
	_ClassList3.default.registerClass(_SCNWrapMode2.default);
	_ClassList3.default.registerClass(_SKAction2.default);
	_ClassList3.default.registerClass(_SKActionTimingMode2.default);
	_ClassList3.default.registerClass(_SKBlendMode2.default);
	_ClassList3.default.registerClass(_SKColor2.default);
	_ClassList3.default.registerClass(_SKEffectNode2.default);
	_ClassList3.default.registerClass(_SKFade2.default);
	_ClassList3.default.registerClass(_SKGroup2.default);
	_ClassList3.default.registerClass(_SKLabelHorizontalAlignmentMode2.default);
	_ClassList3.default.registerClass(_SKLabelNode2.default);
	_ClassList3.default.registerClass(_SKLabelVerticalAlignmentMode2.default);
	_ClassList3.default.registerClass(_SKNode2.default);
	_ClassList3.default.registerClass(_SKScale2.default);
	_ClassList3.default.registerClass(_SKScene2.default);
	_ClassList3.default.registerClass(_SKSceneScaleMode2.default);
	_ClassList3.default.registerClass(_SKSequence2.default);
	_ClassList3.default.registerClass(_SKShapeNode2.default);
	_ClassList3.default.registerClass(_SKSpriteNode2.default);
	_ClassList3.default.registerClass(_SKTexture2.default);
	_ClassList3.default.registerClass(_SKTextureFilteringMode2.default);
	_ClassList3.default.registerClass(_SKWait2.default);

	/*global exports*/
	exports.NSColor = _NSColor2.default;
	exports.NSColorSpaceModel = _NSColorSpaceModel2.default;
	exports.AVAudioMixerNode = _AVAudioMixerNode2.default;
	exports.AVAudioNode = _AVAudioNode2.default;
	exports.CGBlendMode = _CGBlendMode2.default;
	exports.CGLineCap = _CGLineCap2.default;
	exports.CGLineJoin = _CGLineJoin2.default;
	exports.CGMutablePath = _CGMutablePath2.default;
	exports.CGPath = _CGPath2.default;
	exports.CGPathApplierFunction = _CGPathApplierFunction2.default;
	exports.CGPathFillRule = _CGPathFillRule2.default;
	exports.CGPoint = _CGPoint2.default;
	exports.CGRect = _CGRect2.default;
	exports.CGSize = _CGSize2.default;
	exports.CGVector = _CGVector2.default;
	exports.DispatchObject = _DispatchObject2.default;
	exports.DispatchQueue = _DispatchQueue2.default;
	exports.DispatchTime = _DispatchTime2.default;
	exports.DispatchTimeInterval = _DispatchTimeInterval2.default;
	exports.NSArray = _NSArray2.default;
	exports.NSCoder = _NSCoder2.default;
	exports.NSColorSpace = _NSColorSpace2.default;
	exports.NSData = _NSData2.default;
	exports.NSDictionary = _NSDictionary2.default;
	exports.NSKeyedArchiver = _NSKeyedArchiver2.default;
	exports.NSKeyedUnarchiver = _NSKeyedUnarchiver2.default;
	exports.NSMutableArray = _NSMutableArray2.default;
	exports.NSMutableData = _NSMutableData2.default;
	exports.NSMutableDictionary = _NSMutableDictionary2.default;
	exports.NSURL = _NSURL2.default;
	exports.NSValue = _NSValue2.default;
	exports.NSObject = _NSObject2.default;
	exports.CAAction = _CAAction2.default;
	exports.CAAnimation = _CAAnimation2.default;
	exports.CAAnimationDelegate = _CAAnimationDelegate2.default;
	exports.CAAnimationGroup = _CAAnimationGroup2.default;
	exports.CABasicAnimation = _CABasicAnimation2.default;
	exports.CACurrentMediaTime = _CACurrentMediaTime2.default;
	exports.CAKeyframeAnimation = _CAKeyframeAnimation2.default;
	exports.CAMediaTiming = _CAMediaTiming2.default;
	exports.CAMediaTimingFunction = _CAMediaTimingFunction2.default;
	exports.CAPropertyAnimation = _CAPropertyAnimation2.default;
	exports.CATransform3D = _CATransform3D2.default;
	exports.SCNAction = _SCNAction2.default;
	exports.SCNActionable = _SCNActionable2.default;
	exports.SCNActionCustom = _SCNActionCustom2.default;
	exports.SCNActionFade = _SCNActionFade2.default;
	exports.SCNActionGroup = _SCNActionGroup2.default;
	exports.SCNActionHide = _SCNActionHide2.default;
	exports.SCNActionJavaScript = _SCNActionJavaScript2.default;
	exports.SCNActionMove = _SCNActionMove2.default;
	exports.SCNActionPerformSelector = _SCNActionPerformSelector2.default;
	exports.SCNActionPlaySound = _SCNActionPlaySound2.default;
	exports.SCNActionReference = _SCNActionReference2.default;
	exports.SCNActionRemove = _SCNActionRemove2.default;
	exports.SCNActionRepeat = _SCNActionRepeat2.default;
	exports.SCNActionRotate = _SCNActionRotate2.default;
	exports.SCNActionRunAction = _SCNActionRunAction2.default;
	exports.SCNActionRunBlock = _SCNActionRunBlock2.default;
	exports.SCNActionScale = _SCNActionScale2.default;
	exports.SCNActionSequence = _SCNActionSequence2.default;
	exports.SCNActionTimingFunction = _SCNActionTimingFunction2.default;
	exports.SCNActionTimingMode = _SCNActionTimingMode2.default;
	exports.SCNActionWait = _SCNActionWait2.default;
	exports.SCNAnimatable = _SCNAnimatable2.default;
	exports.SCNAnimationEvent = _SCNAnimationEvent2.default;
	exports.SCNAnimationEventBlock = _SCNAnimationEventBlock2.default;
	exports.SCNAntialiasingMode = _SCNAntialiasingMode2.default;
	exports.SCNAudioPlayer = _SCNAudioPlayer2.default;
	exports.SCNAudioSource = _SCNAudioSource2.default;
	exports.SCNBillboardAxis = _SCNBillboardAxis2.default;
	exports.SCNBillboardConstraint = _SCNBillboardConstraint2.default;
	exports.SCNBindingBlock = _SCNBindingBlock2.default;
	exports.SCNBlendMode = _SCNBlendMode2.default;
	exports.SCNBoundingVolume = _SCNBoundingVolume2.default;
	exports.SCNBox = _SCNBox2.default;
	exports.SCNBufferBindingBlock = _SCNBufferBindingBlock2.default;
	exports.SCNBufferFrequency = _SCNBufferFrequency2.default;
	exports.SCNBufferStream = _SCNBufferStream2.default;
	exports.SCNCamera = _SCNCamera2.default;
	exports.SCNCapsule = _SCNCapsule2.default;
	exports.SCNChamferMode = _SCNChamferMode2.default;
	exports.SCNCone = _SCNCone2.default;
	exports.SCNConstraint = _SCNConstraint2.default;
	exports.SCNCullMode = _SCNCullMode2.default;
	exports.SCNCylinder = _SCNCylinder2.default;
	exports.SCNDebugOptions = _SCNDebugOptions2.default;
	exports.SCNFieldForceEvaluator = _SCNFieldForceEvaluator2.default;
	exports.SCNFilterMode = _SCNFilterMode2.default;
	exports.SCNFloor = _SCNFloor2.default;
	exports.SCNGeometry = _SCNGeometry2.default;
	exports.SCNGeometryElement = _SCNGeometryElement2.default;
	exports.SCNGeometryPrimitiveType = _SCNGeometryPrimitiveType2.default;
	exports.SCNGeometrySource = _SCNGeometrySource2.default;
	exports.SCNHitTestOption = _SCNHitTestOption2.default;
	exports.SCNHitTestResult = _SCNHitTestResult2.default;
	exports.SCNIKConstraint = _SCNIKConstraint2.default;
	exports.SCNLayer = _SCNLayer2.default;
	exports.SCNLevelOfDetail = _SCNLevelOfDetail2.default;
	exports.SCNLight = _SCNLight2.default;
	exports.SCNLookAtConstraint = _SCNLookAtConstraint2.default;
	exports.SCNMaterial = _SCNMaterial2.default;
	exports.SCNMaterialProperty = _SCNMaterialProperty2.default;
	exports.SCNMatrix4 = _SCNMatrix2.default;
	exports.SCNMatrix4EqualToMatrix4 = _SCNMatrix4EqualToMatrix2.default;
	exports.SCNMatrix4FromGLKMatrix4 = _SCNMatrix4FromGLKMatrix2.default;
	exports.SCNMatrix4FromMat4 = _SCNMatrix4FromMat2.default;
	exports.SCNMatrix4Invert = _SCNMatrix4Invert2.default;
	exports.SCNMatrix4IsIdentity = _SCNMatrix4IsIdentity2.default;
	exports.SCNMatrix4MakeRotation = _SCNMatrix4MakeRotation2.default;
	exports.SCNMatrix4MakeScale = _SCNMatrix4MakeScale2.default;
	exports.SCNMatrix4MakeTranslation = _SCNMatrix4MakeTranslation2.default;
	exports.SCNMatrix4Mult = _SCNMatrix4Mult2.default;
	exports.SCNMatrix4Rotate = _SCNMatrix4Rotate2.default;
	exports.SCNMatrix4Scale = _SCNMatrix4Scale2.default;
	exports.SCNMatrix4ToGLKMatrix4 = _SCNMatrix4ToGLKMatrix2.default;
	exports.SCNMatrix4ToMat4 = _SCNMatrix4ToMat2.default;
	exports.SCNMatrix4Translate = _SCNMatrix4Translate2.default;
	exports.SCNMorpher = _SCNMorpher2.default;
	exports.SCNMorpherCalculationMode = _SCNMorpherCalculationMode2.default;
	exports.SCNMovabilityHint = _SCNMovabilityHint2.default;
	exports.SCNNode = _SCNNode2.default;
	exports.SCNNodeRendererDelegate = _SCNNodeRendererDelegate2.default;
	exports.SCNOrderedDictionary = _SCNOrderedDictionary2.default;
	exports.SCNParticleBirthDirection = _SCNParticleBirthDirection2.default;
	exports.SCNParticleBirthLocation = _SCNParticleBirthLocation2.default;
	exports.SCNParticleBlendMode = _SCNParticleBlendMode2.default;
	exports.SCNParticleEvent = _SCNParticleEvent2.default;
	exports.SCNParticleEventBlock = _SCNParticleEventBlock2.default;
	exports.SCNParticleImageSequenceAnimationMode = _SCNParticleImageSequenceAnimationMode2.default;
	exports.SCNParticleInputMode = _SCNParticleInputMode2.default;
	exports.SCNParticleModifierBlock = _SCNParticleModifierBlock2.default;
	exports.SCNParticleModifierStage = _SCNParticleModifierStage2.default;
	exports.SCNParticleOrientationMode = _SCNParticleOrientationMode2.default;
	exports.SCNParticlePropertyController = _SCNParticlePropertyController2.default;
	exports.SCNParticleSortingMode = _SCNParticleSortingMode2.default;
	exports.SCNParticleSystem = _SCNParticleSystem2.default;
	exports.SCNPhysicsBallSocketJoint = _SCNPhysicsBallSocketJoint2.default;
	exports.SCNPhysicsBehavior = _SCNPhysicsBehavior2.default;
	exports.SCNPhysicsBody = _SCNPhysicsBody2.default;
	exports.SCNPhysicsBodyType = _SCNPhysicsBodyType2.default;
	exports.SCNPhysicsCollisionCategory = _SCNPhysicsCollisionCategory2.default;
	exports.SCNPhysicsContact = _SCNPhysicsContact2.default;
	exports.SCNPhysicsContactDelegate = _SCNPhysicsContactDelegate2.default;
	exports.SCNPhysicsField = _SCNPhysicsField2.default;
	exports.SCNPhysicsFieldScope = _SCNPhysicsFieldScope2.default;
	exports.SCNPhysicsHingeJoint = _SCNPhysicsHingeJoint2.default;
	exports.SCNPhysicsShape = _SCNPhysicsShape2.default;
	exports.SCNPhysicsSliderJoint = _SCNPhysicsSliderJoint2.default;
	exports.SCNPhysicsVehicle = _SCNPhysicsVehicle2.default;
	exports.SCNPhysicsVehicleWheel = _SCNPhysicsVehicleWheel2.default;
	exports.SCNPhysicsWorld = _SCNPhysicsWorld2.default;
	exports.SCNPlane = _SCNPlane2.default;
	exports.SCNProgram = _SCNProgram2.default;
	exports.SCNProgramDelegate = _SCNProgramDelegate2.default;
	exports.SCNPyramid = _SCNPyramid2.default;
	exports.SCNQuaternion = _SCNQuaternion2.default;
	exports.SCNReferenceLoadingPolicy = _SCNReferenceLoadingPolicy2.default;
	exports.SCNReferenceNode = _SCNReferenceNode2.default;
	exports.SCNRenderer = _SCNRenderer2.default;
	exports.SCNRenderingAPI = _SCNRenderingAPI2.default;
	exports.SCNScene = _SCNScene2.default;
	exports.SCNSceneExportDelegate = _SCNSceneExportDelegate2.default;
	exports.SCNSceneExportProgressHandler = _SCNSceneExportProgressHandler2.default;
	exports.SCNSceneRenderer = _SCNSceneRenderer2.default;
	exports.SCNSceneRendererDelegate = _SCNSceneRendererDelegate2.default;
	exports.SCNSceneSource = _SCNSceneSource2.default;
	exports.SCNSceneSourceStatus = _SCNSceneSourceStatus2.default;
	exports.SCNSceneSourceStatusHandler = _SCNSceneSourceStatusHandler2.default;
	exports.SCNShadable = _SCNShadable2.default;
	exports.SCNShadableHelper = _SCNShadableHelper2.default;
	exports.SCNShaderModifierEntryPoint = _SCNShaderModifierEntryPoint2.default;
	exports.SCNShadowMode = _SCNShadowMode2.default;
	exports.SCNShape = _SCNShape2.default;
	exports.SCNSkinner = _SCNSkinner2.default;
	exports.SCNSphere = _SCNSphere2.default;
	exports.SCNTechnique = _SCNTechnique2.default;
	exports.SCNTechniqueSupport = _SCNTechniqueSupport2.default;
	exports.SCNText = _SCNText2.default;
	exports.SCNTorus = _SCNTorus2.default;
	exports.SCNTransaction = _SCNTransaction2.default;
	exports.SCNTransformConstraint = _SCNTransformConstraint2.default;
	exports.SCNTransparencyMode = _SCNTransparencyMode2.default;
	exports.SCNTube = _SCNTube2.default;
	exports.SCNVector3 = _SCNVector2.default;
	exports.SCNVector3EqualToVector3 = _SCNVector3EqualToVector2.default;
	exports.SCNVector3FromFloat3 = _SCNVector3FromFloat2.default;
	exports.SCNVector3FromGLKVector3 = _SCNVector3FromGLKVector2.default;
	exports.SCNVector3Make = _SCNVector3Make2.default;
	exports.SCNVector3ToFloat3 = _SCNVector3ToFloat2.default;
	exports.SCNVector3ToGLKVector3 = _SCNVector3ToGLKVector2.default;
	exports.SCNVector3Zero = _SCNVector3Zero2.default;
	exports.SCNVector4 = _SCNVector4.default;
	exports.SCNVector4EqualToVector4 = _SCNVector4EqualToVector2.default;
	exports.SCNVector4FromFloat4 = _SCNVector4FromFloat2.default;
	exports.SCNVector4FromGLKVector4 = _SCNVector4FromGLKVector2.default;
	exports.SCNVector4Make = _SCNVector4Make2.default;
	exports.SCNVector4ToFloat4 = _SCNVector4ToFloat2.default;
	exports.SCNVector4ToGLKVector4 = _SCNVector4ToGLKVector2.default;
	exports.SCNView = _SCNView2.default;
	exports.SCNWrapMode = _SCNWrapMode2.default;
	exports.SKAction = _SKAction2.default;
	exports.SKActionTimingMode = _SKActionTimingMode2.default;
	exports.SKBlendMode = _SKBlendMode2.default;
	exports.SKColor = _SKColor2.default;
	exports.SKEffectNode = _SKEffectNode2.default;
	exports.SKFade = _SKFade2.default;
	exports.SKGroup = _SKGroup2.default;
	exports.SKLabelHorizontalAlignmentMode = _SKLabelHorizontalAlignmentMode2.default;
	exports.SKLabelNode = _SKLabelNode2.default;
	exports.SKLabelVerticalAlignmentMode = _SKLabelVerticalAlignmentMode2.default;
	exports.SKNode = _SKNode2.default;
	exports.SKScale = _SKScale2.default;
	exports.SKScene = _SKScene2.default;
	exports.SKSceneScaleMode = _SKSceneScaleMode2.default;
	exports.SKSequence = _SKSequence2.default;
	exports.SKShapeNode = _SKShapeNode2.default;
	exports.SKSpriteNode = _SKSpriteNode2.default;
	exports.SKTexture = _SKTexture2.default;
	exports.SKTextureFilteringMode = _SKTextureFilteringMode2.default;
	exports.SKWait = _SKWait2.default;
	exports._AjaxRequest = _AjaxRequest3.default;
	exports._BinaryReader = _BinaryReader3.default;
	exports._BinaryRequest = _BinaryRequest3.default;
	exports._Buffer = _Buffer3.default;
	exports._ClassList = _ClassList3.default;
	exports._File = _File3.default;
	exports._FileReader = _FileReader3.default;
	exports._HTMLCanvasElement = _HTMLCanvasElement3.default;

	// constants
	/*global exports*/

	// 
	exports.kCAFillModeRemoved = 'removed';
	exports.kCAFillModeForwards = 'forwards';
	exports.kCAFillModeBackwards = 'backwards';
	exports.kCAFillModeBoth = 'both';

	// 
	exports.kCAMediaTimingFunctionLinear = 'linear';
	exports.kCAMediaTimingFunctionEaseIn = 'easeIn';
	exports.kCAMediaTimingFunctionEaseOut = 'easeOut';
	exports.kCAMediaTimingFunctionEaseInEaseOut = 'easeInEaseOut';
	exports.kCAMediaTimingFunctionDefault = 'default';

	// Value calculation modes
	exports.kCAAnimationLinear = 'linear';
	exports.kCAAnimationDiscrete = 'discrete';
	exports.kCAAnimationPaced = 'paced';
	exports.kCAAnimationCubic = 'cubic';
	exports.kCAAnimationCubicPaced = 'cubicPaced';

	// Rotation Mode Values
	exports.kCAAnimationRotateAuto = 'auto';
	exports.kCAAnimationRotateAutoReverse = 'autoReverse';

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _NSObject2 = __webpack_require__(2);

	var _NSObject3 = _interopRequireDefault(_NSObject2);

	var _SKColor = __webpack_require__(11);

	var _SKColor2 = _interopRequireDefault(_SKColor);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * dummy class for NSKeyedArchiver/Unarchiver
	 * @access public
	 * @extends {NSObject}
	 */
	var NSColor = function (_NSObject) {
	  _inherits(NSColor, _NSObject);

	  function NSColor() {
	    _classCallCheck(this, NSColor);

	    return _possibleConstructorReturn(this, (NSColor.__proto__ || Object.getPrototypeOf(NSColor)).apply(this, arguments));
	  }

	  _createClass(NSColor, null, [{
	    key: 'initWithCoder',

	    /**
	     * @access public
	     * @param {NSCoder} coder -
	     * @returns {_Buffer} -
	     */
	    value: function initWithCoder(coder) {
	      return _SKColor2.default.initWithCoder(coder);
	    }
	  }]);

	  return NSColor;
	}(_NSObject3.default);

	exports.default = NSColor;

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _CGPoint = __webpack_require__(7);

	var _CGPoint2 = _interopRequireDefault(_CGPoint);

	var _CGRect = __webpack_require__(8);

	var _CGRect2 = _interopRequireDefault(_CGRect);

	var _ClassList2 = __webpack_require__(10);

	var _ClassList3 = _interopRequireDefault(_ClassList2);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	/*global Buffer*/

	/**
	 * The root class of most Objective-C class hierarchies, from which subclasses inherit a basic interface to the runtime system and the ability to behave as Objective-C objects.
	 * @access public
	 * @see https://developer.apple.com/reference/objectivec/nsobject
	 */
	var NSObject = function () {
	  _createClass(NSObject, null, [{
	    key: 'initialize',


	    // Initializing a Class

	    /**
	     * Initializes the class before it receives its first message.
	     * @access public
	     * @returns {void}
	     * @desc The runtime sends initialize() to each class in a program just before the class, or any class that inherits from it, is sent its first message from within the program. Superclasses receive this message before their subclasses.The runtime sends the initialize() message to classes in a thread-safe manner. That is, initialize() is run by the first thread to send a message to a class, and any other thread that tries to send a message to that class will block until initialize() completes.The superclass implementation may be called multiple times if subclasses do not implement initialize()the runtime will call the inherited implementationor if subclasses explicitly call [super initialize]. If you want to protect yourself from being run multiple times, you can structure your implementation along these lines:+ (void)initialize {
	    if (self == [ClassName self]) {
	      // ... do the initialization ...
	    }
	    }
	    Because initialize() is called in a blocking manner, its important to limit method implementations to the minimum amount of work necessary possible. Specifically, any code that takes locks that might be required by other classes in their initialize() methods is liable to lead to deadlocks. Therefore, you should not rely on initialize() for complex initialization, and should instead limit it to straightforward, class local initialization.Special Considerationsinitialize() is invoked only once per class. If you want to perform independent initialization for the class and for categories of the class, you should implement load() methods.+ (void)initialize {
	    if (self == [ClassName self]) {
	      // ... do the initialization ...
	    }
	    }
	      * @see https://developer.apple.com/reference/objectivec/nsobject/1418639-initialize
	     */
	    value: function initialize() {}

	    /**
	     * Invoked whenever a class or category is added to the Objective-C runtime; implement this method to perform class-specific behavior upon loading.
	     * @access public
	     * @returns {void}
	     * @desc The load() message is sent to classes and categories that are both dynamically loaded and statically linked, but only if the newly loaded class or category implements a method that can respond.The order of initialization is as follows:All initializers in any framework you link to.All +load methods in your image.All C++ static initializers and C/C++ __attribute__(constructor) functions in your image.All initializers in frameworks that link to you.In addition:A classs +load method is called after all of its superclasses +load methods.A category +load method is called after the classs own +load method.In a custom implementation of load() you can therefore safely message other unrelated classes from the same image, but any load() methods implemented by those classes may not have run yet.ImportantCustom implementations of the load method for Swift classes bridged to Objective-C are not called automatically.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1418815-load
	     */

	  }, {
	    key: 'load',
	    value: function load() {}

	    // Creating, Copying, and Deallocating Objects

	    /**
	     * Implemented by subclasses to initialize a new object (the receiver) immediately after memory for it has been allocated.
	     * @access public
	     * @constructor
	     * @desc An init() message is coupled with an alloc (or allocWithZone:) message in the same line of code:SomeClass *object = [[SomeClass alloc] init];
	    An object isnt ready to be used until it has been initialized.The init() method defined in the NSObject class does no initialization; it simply returns self. In terms of nullability, callers can assume that the NSObject implemetation of init() does not return nil.In a custom implementation of this method, you must invoke supers Initialization then initialize and return the new object. If the new object cant be initialized, the method should return nil. For example, a hypothetical BuiltInCamera class might return nil from its init method if run on a device that has no camera.- (instancetype)init {
	      self = [super init];
	      if (self) {
	          // Initialize self
	      }
	      return self;
	    }
	    In some cases, a custom implementation of the init() method might return a substitute object. You must therefore always use the object returned by init(), and not the one returned by alloc or allocWithZone:, in subsequent code.SomeClass *object = [[SomeClass alloc] init];
	    - (instancetype)init {
	      self = [super init];
	      if (self) {
	          // Initialize self
	      }
	      return self;
	    }
	      * @see https://developer.apple.com/reference/objectivec/nsobject/1418641-init
	     */

	  }, {
	    key: '_propTypes',
	    get: function get() {
	      return {};
	    }
	  }]);

	  function NSObject() {
	    _classCallCheck(this, NSObject);

	    // Discardable Content Proxy Support

	    this._autoContentAccessingProxy = null;

	    // Archiving

	    this._classForArchiver = null;
	    this._classForCoder = null;
	    this._classForKeyedArchiver = null;

	    // Working with Class Descriptions

	    this._attributeKeys = null;
	    this._classDescription = null;
	    this._toManyRelationshipKeys = null;
	    this._toOneRelationshipKeys = null;

	    // Scripting

	    /**
	     * An NSString-keyed dictionary of the receiver's scriptable properties.
	     * @type {?Map<string, Object>}
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1417254-scriptingproperties
	     */
	    this.scriptingProperties = null;

	    this._classCode = 0;

	    // Instance Properties

	    /**
	     * Returns a pointer that identifies information about all of the observers that are registered with the observed object.
	     * @type {?Object}
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1414009-observationinfo
	     */
	    this.observationInfo = null;

	    /**
	     * The activation point for the accessibility element, in screen coordinates.
	     * @type {CGPoint}
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1615179-accessibilityactivationpoint
	     */
	    this.accessibilityActivationPoint = null;

	    /**
	     * An array of custom actions to display along with the built-in actions.
	     * @type {?UIAccessibilityCustomAction[]}
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1615150-accessibilitycustomactions
	     */
	    this.accessibilityCustomActions = null;

	    /**
	     * 
	     * @type {?UIAccessibilityCustomRotor[]}
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1649788-accessibilitycustomrotors
	     */
	    this.accessibilityCustomRotors = null;

	    /**
	     * An array of the accessibility elements in the container. 
	     * @type {?Object[]}
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1615147-accessibilityelements
	     */
	    this.accessibilityElements = null;

	    /**
	     * A Boolean value indicating whether the accessibility elements contained within this accessibility element are hidden.
	     * @type {boolean}
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1615080-accessibilityelementshidden
	     */
	    this.accessibilityElementsHidden = false;

	    /**
	     * The frame of the accessibility element, in screen coordinates.
	     * @type {CGRect}
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1615111-accessibilityframe
	     */
	    this.accessibilityFrame = null;

	    /**
	     * 
	     * @type {?Object[]}
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1627578-accessibilityheaderelements
	     */
	    this.accessibilityHeaderElements = null;

	    /**
	     * A brief description of the result of performing an action on the accessibility element, in a localized string.
	     * @type {?string}
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1615093-accessibilityhint
	     */
	    this.accessibilityHint = null;

	    /**
	     * A succinct label that identifies the accessibility element, in a localized string.
	     * @type {?string}
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1615181-accessibilitylabel
	     */
	    this.accessibilityLabel = null;

	    /**
	     * The language in which to speak the accessibility element's label, value, and hint.
	     * @type {?string}
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1615192-accessibilitylanguage
	     */
	    this.accessibilityLanguage = null;

	    /**
	     * The navigation style to apply to the object and its elements.
	     * @type {UIAccessibilityNavigationStyle}
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1615200-accessibilitynavigationstyle
	     */
	    this.accessibilityNavigationStyle = null;

	    /**
	     * The path of the element, in screen coordinates.
	     * @type {?UIBezierPath}
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1615159-accessibilitypath
	     */
	    this.accessibilityPath = null;

	    /**
	     * The combination of accessibility traits that best characterize the accessibility element. 
	     * @type {UIAccessibilityTraits}
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1615202-accessibilitytraits
	     */
	    this.accessibilityTraits = null;

	    /**
	     * The value of the accessibility element, in a localized string.
	     * @type {?string}
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1615117-accessibilityvalue
	     */
	    this.accessibilityValue = null;

	    /**
	     * A Boolean value indicating whether VoiceOver should ignore the elements within views that are siblings of the receiver.
	     * @type {boolean}
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1615089-accessibilityviewismodal
	     */
	    this.accessibilityViewIsModal = false;

	    /**
	     * A Boolean value indicating whether the receiver is an accessibility element that an assistive application can access.
	     * @type {boolean}
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1615141-isaccessibilityelement
	     */
	    this.isAccessibilityElement = false;

	    /**
	     * A Boolean value indicating whether VoiceOver should group together the elements that are children of the receiver, regardless of their positions on the screen.
	     * @type {boolean}
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1615143-shouldgroupaccessibilitychildren
	     */
	    this.shouldGroupAccessibilityChildren = false;

	    this._hashValue = 0;
	    this._accessibilityFocusedUIElement = null;
	    this._accessibilityNotifiesWhenDestroyed = false;
	    this._exposedBindings = null;
	    this._objectForWebScript = null;
	    this._objectSpecifier = null;
	    this._webFrame = null;
	    this._webPlugInContainerSelectionColor = null;
	    this._isSelectable = false;

	    /**
	     * @access private
	     * @type {boolean}
	     */
	    this._destroyed = false;
	  }

	  /**
	   * Returns the object returned by copy(with:).
	   * @access public
	   * @returns {Object} - 
	   * @desc This is a convenience method for classes that adopt the NSCopying protocol. An exception is raised if there is no implementation for copy(with:).NSObject does not itself support the NSCopying protocol. Subclasses must support the protocol and implement the copy(with:) method. A subclass version of the copy(with:) method should send the message to super first, to incorporate its implementation, unless the subclass descends directly from NSObject.
	   * @see https://developer.apple.com/reference/objectivec/nsobject/1418807-copy
	   */


	  _createClass(NSObject, [{
	    key: 'copy',
	    value: function copy() {
	      var obj = new this.constructor();
	      // TODO: copy variables
	      return obj;
	    }

	    /**
	     * Returns the object returned by mutableCopy(with:) where the zone is nil.
	     * @access public
	     * @returns {Object} - 
	     * @desc This is a convenience method for classes that adopt the NSMutableCopying protocol. An exception is raised if there is no implementation for mutableCopy(with:).
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1418978-mutablecopy
	     */

	  }, {
	    key: 'mutableCopy',
	    value: function mutableCopy() {
	      return null;
	    }

	    // Identifying Classes

	    /**
	     * Returns the class object for the receivers superclass.
	     * @access public
	     * @returns {?Object} - 
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1418803-superclass
	     */

	  }, {
	    key: 'methodFor',


	    // Obtaining Information About Methods

	    /**
	     * Locates and returns the address of the receivers implementation of a method so it can be called as a function.
	     * @access public
	     * @param {!function} aSelector - A Selector that identifies the method for which to return the implementation address. The selector must be a valid and non-NULL. If in doubt, use the responds(to:) method to check before passing the selector to method(for:).
	     * @returns {!function} - 
	     * @desc If the receiver is an instance, aSelector should refer to an instance method; if the receiver is a class, it should refer to a class method.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1418863-method
	     */
	    value: function methodFor(aSelector) {
	      return null;
	    }

	    /**
	     * Locates and returns the address of the implementation of the instance method identified by a given selector.
	     * @access public
	     * @param {!function} aSelector - A Selector that identifies the method for which to return the implementation address. The selector must be non-NULL and valid for the receiver. If in doubt, use the responds(to:) method to check before passing the selector to method(for:).
	     * @returns {!function} - 
	     * @desc An error is generated if instances of the receiver cant respond to aSelector messages.Use this method to ask the class object for the implementation of instance methods only. To ask the class for the implementation of a class method, send the method(for:) instance method to the class instead.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1418713-instancemethod
	     */

	  }, {
	    key: 'performWithAfterDelay',


	    // Sending Messages

	    /**
	     * Invokes a method of the receiver on the current thread using the default mode after a delay.
	     * @access public
	     * @param {function} aSelector - A Selector that identifies the method to invoke. The method should not have a significant return value and should take a single argument of type id, or no arguments.
	     * @param {?Object} anArgument - The argument to pass to the method when it is invoked. Pass nil if the method does not take an argument. 
	     * @param {number} delay - The minimum time before which the message is sent. Specifying a delay of 0 does not necessarily cause the selector to be performed immediately. The selector is still queued on the threads run loop and performed as soon as possible.
	     * @returns {void}
	     * @desc This method sets up a timer to perform the aSelector message on the current threads run loop. The timer is configured to run in the default mode (NSDefaultRunLoopMode). When the timer fires, the thread attempts to dequeue the message from the run loop and perform the selector. It succeeds if the run loop is running and in the default mode; otherwise, the timer waits until the run loop is in the default mode. If you want the message to be dequeued when the run loop is in a mode other than the default mode, use the perform(_:with:afterDelay:inModes:) method instead. If you are not sure whether the current thread is the main thread, you can use the performSelector(onMainThread:with:waitUntilDone:) or performSelector(onMainThread:with:waitUntilDone:modes:) method to guarantee that your selector executes on the main thread. To cancel a queued message, use the cancelPreviousPerformRequests(withTarget:) or cancelPreviousPerformRequests(withTarget:selector:object:) method. Special ConsiderationsThis method registers with the runloop of its current context, and depends on that runloop being run on a regular basis to perform correctly. One common context where you might call this method and end up registering with a runloop that is not automatically run on a regular basis is when being invoked by a dispatch queue. If you need this type of functionality when running on a dispatch queue, you should use dispatch_after(_:_:_:) and related methods to get the behavior you want.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1416176-perform
	     */
	    value: function performWithAfterDelay(aSelector, anArgument, delay) {}

	    /**
	     * Invokes a method of the receiver on the current thread using the specified modes after a delay.
	     * @access public
	     * @param {function} aSelector - A Selector that identifies the method to invoke. The method should not have a significant return value and should take a single argument of type id, or no arguments.
	     * @param {?Object} anArgument - The argument to pass to the method when it is invoked. Pass nil if the method does not take an argument. 
	     * @param {number} delay - The minimum time before which the message is sent. Specifying a delay of 0 does not necessarily cause the selector to be performed immediately. The selector is still queued on the threads run loop and performed as soon as possible.
	     * @param {RunLoopMode[]} modes - An array of strings that identify the modes to associate with the timer that performs the selector. This array must contain at least one string. If you specify nil or an empty array for this parameter, this method returns without performing the specified selector. For information about run loop modes, see Run Loops in Threading Programming Guide.
	     * @returns {void}
	     * @desc This method sets up a timer to perform the aSelector message on the current threads run loop. The timer is configured to run in the modes specified by the modes parameter. When the timer fires, the thread attempts to dequeue the message from the run loop and perform the selector. It succeeds if the run loop is running and in one of the specified modes; otherwise, the timer waits until the run loop is in one of those modes. If you want the message to be dequeued when the run loop is in a mode other than the default mode, use the perform(_:with:afterDelay:inModes:) method instead. If you are not sure whether the current thread is the main thread, you can use the performSelector(onMainThread:with:waitUntilDone:) or performSelector(onMainThread:with:waitUntilDone:modes:) method to guarantee that your selector executes on the main thread. To cancel a queued message, use the cancelPreviousPerformRequests(withTarget:) or cancelPreviousPerformRequests(withTarget:selector:object:) method. Special ConsiderationsThis method registers with the runloop of its current context, and depends on that runloop being run on a regular basis to perform correctly. One common context where you might call this method and end up registering with a runloop that is not automatically run on a regular basis is when being invoked by a dispatch queue. If you need this type of functionality when running on a dispatch queue, you should use dispatch_after(_:_:_:) and related methods to get the behavior you want.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1415652-perform
	     */

	  }, {
	    key: 'performWithAfterDelayInModes',
	    value: function performWithAfterDelayInModes(aSelector, anArgument, delay, modes) {}

	    /**
	     * Invokes a method of the receiver on the main thread using the default mode.
	     * @access public
	     * @param {function} aSelector - A Selector that identifies the method to invoke. The method should not have a significant return value and should take a single argument of type id, or no arguments.
	     * @param {?Object} arg - The argument to pass to the method when it is invoked. Pass nil if the method does not take an argument.
	     * @param {boolean} wait - A Boolean that specifies whether the current thread blocks until after the specified selector is performed on the receiver on the main thread. Specify true to block this thread; otherwise, specify false to have this method return immediately.If the current thread is also the main thread, and you specify true for this parameter, the message is delivered and processed immediately. 
	     * @returns {void}
	     * @desc You can use this method to deliver messages to the main thread of your application. The main thread encompasses the applications main run loop, and is where the NSApplication object receives events. The message in this case is a method of the current object that you want to execute on the thread. This method queues the message on the run loop of the main thread using the common run loop modesthat is, the modes associated with the commonModes constant. As part of its normal run loop processing, the main thread dequeues the message (assuming it is running in one of the common run loop modes) and invokes the desired method. Multiple calls to this method from the same thread cause the corresponding selectors to be queued and performed in the same same order in which the calls were made.You cannot cancel messages queued using this method. If you want the option of canceling a message on the current thread, you must use either the perform(_:with:afterDelay:) or perform(_:with:afterDelay:inModes:) method.Special ConsiderationsThis method registers with the runloop of its current context, and depends on that runloop being run on a regular basis to perform correctly. One common context where you might call this method and end up registering with a runloop that is not automatically run on a regular basis is when being invoked by a dispatch queue. If you need this type of functionality when running on a dispatch queue, you should use dispatch_after(_:_:_:) and related methods to get the behavior you want.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1414900-performselector
	     */

	  }, {
	    key: 'performSelectorOnMainThreadWithWaitUntilDone',
	    value: function performSelectorOnMainThreadWithWaitUntilDone(aSelector, arg, wait) {}

	    /**
	     * Invokes a method of the receiver on the main thread using the specified modes.
	     * @access public
	     * @param {function} aSelector - A Selector that identifies the method to invoke. The method should not have a significant return value and should take a single argument of type id, or no arguments.
	     * @param {?Object} arg - The argument to pass to the method when it is invoked. Pass nil if the method does not take an argument.
	     * @param {boolean} wait - A Boolean that specifies whether the current thread blocks until after the specified selector is performed on the receiver on the main thread. Specify true to block this thread; otherwise, specify false to have this method return immediately.If the current thread is also the main thread, and you pass true, the message is performed immediately, otherwise the perform is queued to run the next time through the run loop.
	     * @param {?string[]} array - An array of strings that identifies the modes in which it is permissible to perform the specified selector. This array must contain at least one string. If you specify nil or an empty array for this parameter, this method returns without performing the specified selector. For information about run loop modes, see Run Loops in Threading Programming Guide.
	     * @returns {void}
	     * @desc You can use this method to deliver messages to the main thread of your application. The main thread encompasses the applications mai run loop, and is where the NSApplication object receives events. The message in this case is a method of the current object that you want to execute on the thread. This method queues the message on the run loop of the main thread using the run loop modes specified in the array parameter. As part of its normal run loop processing, the main thread dequeues the message (assuming it is running in one of the specified modes) and invokes the desired method. Multiple calls to this method from the same thread cause the corresponding selectors to be queued and performed in the same same order in which the calls were made, assuming the associated run loop modes for each selector are the same. If you specify different modes for each selector, any selectors whose associated mode does not match the current run loop mode are skipped until the run loop subsequently executes in that mode.You cannot cancel messages queued using this method. If you want the option of canceling a message on the current thread, you must use either the perform(_:with:afterDelay:) or perform(_:with:afterDelay:inModes:) method.Special ConsiderationsThis method registers with the runloop of its current context, and depends on that runloop being run on a regular basis to perform correctly. One common context where you might call this method and end up registering with a runloop that is not automatically run on a regular basis is when being invoked by a dispatch queue. If you need this type of functionality when running on a dispatch queue, you should use dispatch_after(_:_:_:) and related methods to get the behavior you want.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1411637-performselector
	     */

	  }, {
	    key: 'performSelectorOnMainThreadWithWaitUntilDoneModes',
	    value: function performSelectorOnMainThreadWithWaitUntilDoneModes(aSelector, arg, wait, array) {}

	    /**
	     * Invokes a method of the receiver on the specified thread using the default mode.
	     * @access public
	     * @param {function} aSelector - A Selector that identifies the method to invoke. The method should not have a significant return value and should take a single argument of type id, or no arguments.
	     * @param {Thread} thr - 
	     * @param {?Object} arg - The argument to pass to the method when it is invoked. Pass nil if the method does not take an argument.
	     * @param {boolean} wait - A Boolean that specifies whether the current thread blocks until after the specified selector is performed on the receiver on the specified thread. Specify true to block this thread; otherwise, specify false to have this method return immediately.If the current thread and target thread are the same, and you specify true for this parameter, the selector is performed immediately on the current thread. If you specify false, this method queues the message on the threads run loop and returns, just like it does for other threads. The current thread must then dequeue and process the message when it has an opportunity to do so.
	     * @returns {void}
	     * @desc You can use this method to deliver messages to other threads in your application. The message in this case is a method of the current object that you want to execute on the target thread. This method queues the message on the run loop of the target thread using the default run loop modesthat is, the modes associated with the commonModes constant. As part of its normal run loop processing, the target thread dequeues the message (assuming it is running in one of the default run loop modes) and invokes the desired method.You cannot cancel messages queued using this method. If you want the option of canceling a message on the current thread, you must use either the perform(_:with:afterDelay:) or perform(_:with:afterDelay:inModes:) method.Special ConsiderationsThis method registers with the runloop of its current context, and depends on that runloop being run on a regular basis to perform correctly. One common context where you might call this method and end up registering with a runloop that is not automatically run on a regular basis is when being invoked by a dispatch queue. If you need this type of functionality when running on a dispatch queue, you should use dispatch_after(_:_:_:) and related methods to get the behavior you want.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1414476-perform
	     */

	  }, {
	    key: 'performOnWithWaitUntilDone',
	    value: function performOnWithWaitUntilDone(aSelector, thr, arg, wait) {}

	    /**
	     * Invokes a method of the receiver on the specified thread using the specified modes.
	     * @access public
	     * @param {function} aSelector - A Selector that identifies the method to invoke. It should not have a significant return value and should take a single argument of type id, or no arguments.
	     * @param {Thread} thr - 
	     * @param {?Object} arg - The argument to pass to the method when it is invoked. Pass nil if the method does not take an argument.
	     * @param {boolean} wait - A Boolean that specifies whether the current thread blocks until after the specified selector is performed on the receiver on the specified thread. Specify true to block this thread; otherwise, specify false to have this method return immediately. If the current thread and target thread are the same, and you specify true for this parameter, the selector is performed immediately. If you specify false, this method queues the message and returns immediately, regardless of whether the threads are the same or different.
	     * @param {?string[]} array - An array of strings that identifies the modes in which it is permissible to perform the specified selector. This array must contain at least one string. If you specify nil or an empty array for this parameter, this method returns without performing the specified selector. For information about run loop modes, see Run Loops in Threading Programming Guide.
	     * @returns {void}
	     * @desc You can use this method to deliver messages to other threads in your application. The message in this case is a method of the current object that you want to execute on the target thread. This method queues the message on the run loop of the target thread using the run loop modes specified in the array parameter. As part of its normal run loop processing, the target thread dequeues the message (assuming it is running in one of the specified modes) and invokes the desired method. You cannot cancel messages queued using this method. If you want the option of canceling a message on the current thread, you must use either the perform(_:with:afterDelay:) or perform(_:with:afterDelay:inModes:) method instead. Special ConsiderationsThis method registers with the runloop of its current context, and depends on that runloop being run on a regular basis to perform correctly. One common context where you might call this method and end up registering with a runloop that is not automatically run on a regular basis is when being invoked by a dispatch queue. If you need this type of functionality when running on a dispatch queue, you should use dispatch_after(_:_:_:) and related methods to get the behavior you want.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1417922-perform
	     */

	  }, {
	    key: 'performOnWithWaitUntilDoneModes',
	    value: function performOnWithWaitUntilDoneModes(aSelector, thr, arg, wait, array) {}

	    /**
	     * Invokes a method of the receiver on a new background thread.
	     * @access public
	     * @param {function} aSelector - A Selector that identifies the method to invoke. The method should not have a significant return value and should take a single argument of type id, or no arguments.
	     * @param {?Object} arg - The argument to pass to the method when it is invoked. Pass nil if the method does not take an argument.
	     * @returns {void}
	     * @desc This method creates a new thread in your application, putting your application into multithreaded mode if it was not already. The method represented by aSelector must set up the thread environment just as you would for any other new thread in your program. For more information about how to configure and run threads, see Threading Programming Guide. 
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1412390-performselector
	     */

	  }, {
	    key: 'performSelectorInBackgroundWith',
	    value: function performSelectorInBackgroundWith(aSelector, arg) {}

	    /**
	     * Cancels perform requests previously registered with the perform(_:with:afterDelay:) instance method.
	     * @access public
	     * @param {Object} aTarget - The target for requests previously registered with the perform(_:with:afterDelay:) instance method.
	     * @returns {void}
	     * @desc All perform requests having the same target aTarget are canceled. This method removes perform requests only in the current run loop, not all run loops.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1417611-cancelpreviousperformrequests
	     */

	  }, {
	    key: 'forwardingTargetFor',


	    // Forwarding Messages

	    /**
	     * Returns the object to which unrecognized messages should first be directed.
	     * @access public
	     * @param {!function} aSelector - A Selector for a method that the receiver does not implement.
	     * @returns {?Object} - 
	     * @desc If an object implements (or inherits) this method, and returns a non-nil (and non-self) result, that returned object is used as the new receiver object and the message dispatch resumes to that new object. (Obviously if you return self from this method, the code would just fall into an infinite loop.)If you implement this method in a non-root class, if your class has nothing to return for the given selector then you should return the result of invoking supers implementation. This method gives an object a chance to redirect an unknown message sent to it before the much more expensive forwardInvocation: machinery takes over. This is useful when you simply want to redirect messages to another object and can be an order of magnitude faster than regular forwarding. It is not useful where the goal of the forwarding is to capture the NSInvocation, or manipulate the arguments or return value during the forwarding.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1418855-forwardingtarget
	     */
	    value: function forwardingTargetFor(aSelector) {
	      return null;
	    }

	    // Dynamically Resolving Methods

	    /**
	     * Dynamically provides an implementation for a given selector for a class method.
	     * @access public
	     * @param {!function} sel - 
	     * @returns {boolean} - 
	     * @desc This method allows you to dynamically provide an implementation for a given selector. See resolveInstanceMethod(_:) for further discussion.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1418889-resolveclassmethod
	     */

	  }, {
	    key: 'doesNotRecognizeSelector',


	    // Error Handling

	    /**
	     * Handles messages the receiver doesnt recognize.
	     * @access public
	     * @param {!function} aSelector - A Selector that identifies a method not implemented or recognized by the receiver.
	     * @returns {void}
	     * @desc The runtime system invokes this method whenever an object receives an aSelector message it cant respond to or forward. This method, in turn, raises an NSInvalidArgumentException, and generates an error message. Any doesNotRecognizeSelector(_:) messages are generally sent only by the runtime system. However, they can be used in program code to prevent a method from being inherited. For example, an NSObject subclass might renounce the copy() or init() method by re-implementing it to include a doesNotRecognizeSelector(_:) message as follows:- (id)copy
	    {
	      [self doesNotRecognizeSelector:_cmd];
	    }
	    The _cmd variable is a hidden argument passed to every method that is the current selector; in this example, it identifies the selector for the copy method. This code prevents instances of the subclass from responding to copy messages or superclasses from forwarding copy messagesalthough responds(to:) will still report that the receiver has access to a copy method.If you override this method, you must call super or raise an invalidArgumentException exception at the end of your implementation. In other words, this method must not return normally; it must always result in an exception being thrown. - (id)copy
	    {
	      [self doesNotRecognizeSelector:_cmd];
	    }
	      * @see https://developer.apple.com/reference/objectivec/nsobject/1418637-doesnotrecognizeselector
	     */
	    value: function doesNotRecognizeSelector(aSelector) {}

	    // Archiving

	    /**
	     * Overridden by subclasses to substitute another object in place of the object that was decoded and subsequently received this message.
	     * @access public
	     * @param {NSCoder} aDecoder - The decoder used to decode the receiver.
	     * @returns {?Object} - 
	     * @desc You can use this method to eliminate redundant objects created by the coder. For example, if after decoding an object you discover that an equivalent object already exists, you can return the existing object. If a replacement is returned, your overriding method is responsible for releasing the receiver. This method is invoked by NSCoder. NSObjects implementation simply returns self.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1417074-awakeafter
	     */

	  }, {
	    key: 'awakeAfterUsing',
	    value: function awakeAfterUsing(aDecoder) {
	      return null;
	    }

	    /**
	     * Overridden to return the names of classes that can be used to decode objects if their class is unavailable.
	     * @access public
	     * @returns {string[]} - 
	     * @desc NSKeyedArchiver calls this method and stores the result inside the archive. If the actual class of an object doesnt exist at the time of unarchiving, NSKeyedUnarchiver goes through the stored list of classes and uses the first one that does exists as a substitute class for decoding the object. The default implementation of this method returns nil.You can use this method if you introduce a new class into your application to provide some backwards compatibility in case the archive will be read on a system that does not have that class. Sometimes there may be another class which may work nearly as well as a substitute for the new class, and the archive keys and archived state for the new class can be carefully chosen (or compatibility written out) so that the object can be unarchived as the substitute class if necessary.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1411048-classfallbacksforkeyedarchiver
	     */

	  }, {
	    key: 'replacementObjectFor',


	    /**
	     * Overridden by subclasses to substitute another object for itself during encoding.
	     * @access public
	     * @param {NSCoder} aCoder - The coder encoding the receiver.
	     * @returns {?Object} - 
	     * @desc An object might encode itself into an archive, but encode a proxy for itself if its being encoded for distribution. This method is invoked by NSCoder. NSObjects implementation returns self.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1416843-replacementobject
	     */
	    value: function replacementObjectFor(aCoder) {
	      return null;
	    }

	    /**
	     * Sets the receiver's version number.
	     * @access public
	     * @param {number} aVersion - The version number for the receiver.
	     * @returns {void}
	     * @desc The version number is helpful when instances of the class are to be archived and reused later. The default version is 0.Special ConsiderationsThe version number applies to NSArchiver/NSUnarchiver, but not to NSKeyedArchiver/NSKeyedUnarchiver.  A keyed archiver does not encode class version numbers.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1416538-setversion
	     */

	  }, {
	    key: 'inverseForRelationshipKey',


	    // Working with Class Descriptions

	    /**
	     * For a given key that defines the name of the relationship from the receivers class to another class, returns the name of the relationship from the other class to the receivers class.
	     * @access public
	     * @param {string} relationshipKey - The name of the relationship from the receivers class to another class.
	     * @returns {?string} - 
	     * @desc NSObjects implementation of inverseForRelationshipKey: simply invokes [[self classDescription] inverseForRelationshipKey:relationshipKey].  To make use of the default implementation, you must therefore implement and register a suitable class descriptionsee NSClassDescription.For example, suppose an Employee class has a relationship named department to a Department class, and that Department has a relationship called employees to Employee. The statement:employee inverseForRelationshipKey:@"department"];
	    returns the string employees.employee inverseForRelationshipKey:@"department"];
	      * @see https://developer.apple.com/reference/objectivec/nsobject/1411046-inverse
	     */
	    value: function inverseForRelationshipKey(relationshipKey) {
	      return null;
	    }
	    /**
	     * An array of NSString objects containing the names of immutable values that instances of the receiver's class contain.
	     * @type {string[]}
	     * @desc NSObjects implementation of attributeKeys simply calls [[self classDescription] attributeKeys]. To make use of the default implementation, you must therefore implement and register a suitable class descriptionsee NSClassDescription. 
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1415656-attributekeys
	     */

	  }, {
	    key: 'copyScriptingValueForKeyWithProperties',


	    // Scripting

	    /**
	     * Creates and returns one or more scripting objects to be inserted into the specified relationship by copying the passed-in value and setting the properties in the copied object or objects.
	     * @access public
	     * @param {Object} value - An object or objects to be copied. The type must match the type of the property identified by key. (See also the Discussion section.)For example, if the property is a to-many relationship, value will always be an array of objects to be copied, and this method must therefore return an array of objects.
	     * @param {string} key - A key that identifies the relationship into which to insert the copied object or objects.
	     * @param {Map<string, Object>} properties - The properties to be set in the copied object or objects.  Derived from the "with properties" parameter of a duplicate command. (See also the Discussion section.)
	     * @returns {?Object} - 
	     * @desc You can override the copyScriptingValue method to take more control when your application is sent a duplicate command. This method is invoked on the prospective container of the copied object or objects. The properties are derived from the with properties parameter of the duplicate command. The returned objects or objects are then inserted into the container using key-value coding. When this method is invoked by Cocoa, neither the value nor the properties will have yet been coerced using the NSScriptKeyValueCoding method coerceValue(_:forKey:). For sdef-declared scriptability, however, the types of the passed-in objects reliably match the relevant sdef declarations.The default implementation of this method copies scripting objects by sending copyWithZone: to the object or objects specified by value. You override this method for situations where this is not sufficient, such as in Core Data applications, in which new objects must be initialized with [NSManagedObjectinitWithEntity:insertIntoManagedObjectContext:].
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1410291-copyscriptingvalue
	     */
	    value: function copyScriptingValueForKeyWithProperties(value, key, properties) {
	      return null;
	    }

	    /**
	     * Creates and returns an instance of a scriptableclass, setting its contents andproperties, for insertion into the relationship identified by the key.
	     * @access public
	     * @param {Object} objectClass - 
	     * @param {string} key - A key that identifies the relationship into which the newclass object will be inserted.
	     * @param {?Object} contentsValue - Specifies the contents of theobject to be created. This may be nil. (See also the Discussion section.)
	     * @param {Map<string, Object>} properties - The properties to be set in the new object. (See also the Discussion section.)
	     * @returns {?Object} - 
	     * @desc You can override the newScriptingObjectOfClass method to take more control when your application is sent a make command. This method is invoked on the prospective container of the new object. ThecontentsValue and properties are derived from the with contents and with properties parameters of the make command. The returned objects or objects are then inserted into the container using key-value coding.When this method is invoked by Cocoa, neither the contents value nor the properties will have yet been coerced using the NSScriptKeyValueCoding method coerceValue(_:forKey:). For sdef-declared scriptability, however, the types of the passed-in objects reliably match the relevant sdef declarations.The default implementation of this method creates new scripting objects by sending alloc to a class and init to the resulting object. You override this method for situations where this is not sufficient, such as in Core Data applications, in which new objects must be initialized with [NSManagedObjectinitWithEntity:insertIntoManagedObjectContext:].
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1418458-newscriptingobject
	     */

	  }, {
	    key: 'newScriptingObjectOfForValueForKeyWithContentsValue',
	    value: function newScriptingObjectOfForValueForKeyWithContentsValue(objectClass, key, contentsValue, properties) {
	      return null;
	    }

	    /**
	     * Given an object specifier, returns the specified object or objects in the receiving container.
	     * @access public
	     * @param {NSScriptObjectSpecifier} objectSpecifier - An object specifier to be evaluated.
	     * @returns {?Object} - 
	     * @desc You can override this method to customize the evaluation of object specifiers without requiring that the scripting container make up indexes for contained objects that don't naturally have indexes (as can be the case if you implement indicesOfObjects(byEvaluatingObjectSpecifier:) instead).Your override of this method doesn't need to also invoke any of the NSScriptCommand error signaling methods, though it can, to record very specific information. The NSUnknownKeySpecifierError and NSInvalidIndexSpecifierError numbers are special, in that Cocoa may continue evaluating an outer specifier if they're encountered, for the convenience of scripters.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1409268-scriptingvalue
	     */

	  }, {
	    key: 'scriptingValueFor',
	    value: function scriptingValueFor(objectSpecifier) {
	      return null;
	    }
	    /**
	     * The receiver's Apple event type code, as stored in the NSScriptClassDescription object for the objects class.
	     * @type {number}
	     * @desc This property is used by Cocoas scripting support classes.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1413991-classcode
	     */

	  }, {
	    key: 'finalize',


	    // Deprecated Methods

	    /**
	     * The garbage collector invokes this method on the receiver before disposing of the memory it uses.
	     * @deprecated
	     * @access public
	     * @returns {void}
	     * @desc The garbage collector invokes this method on the receiver before disposing of the memory it uses. When garbage collection is enabled, this method is invoked instead of dealloc.You can override this method to relinquish resources the receiver has obtained, as shown in the following example:- (void)finalize {
	      if (log_file != NULL) {
	          fclose(log_file);
	          log_file = NULL;
	      }
	      [super finalize];
	    }
	    Typically, however, you are encouraged to relinquish resources prior to finalization if at all possible. For more details, see Implementing a finalize Method.Special ConsiderationsIt is an error to store self into a new or existing live object (colloquially known as resurrection), which implies that this method will be called only once. However, the receiver may be messaged after finalization by other objects also being finalized at this time, so your override should guard against future use of resources that have been reclaimed, as shown by the log_file = NULL statement in the example. The finalize method itself will never be invoked more than once for a given object.Importantfinalize methods must be thread-safe.- (void)finalize {
	      if (log_file != NULL) {
	          fclose(log_file);
	          log_file = NULL;
	      }
	      [super finalize];
	    }
	      * @see https://developer.apple.com/reference/objectivec/nsobject/1418513-finalize
	     */
	    value: function finalize() {}

	    // Instance Properties
	    /**
	     * 
	     * @type {number}
	     * @desc 
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1418615-hashvalue
	     */

	  }, {
	    key: 'addObserverForKeyPath',


	    // Instance Methods

	    /**
	     * Registers the observer object to receive KVO notifications for the key path relative to the object receiving this message.
	     * @access public
	     * @param {NSObject} observer - The object to register for KVO notifications. The observer must implement the key-value observing method observeValue(forKeyPath:of:change:context:).
	     * @param {string} keyPath - The key path, relative to the object receiving this message, of the property to observe. This value must not be nil.
	     * @param {NSKeyValueObservingOptions} [options = []] - A combination of the NSKeyValueObservingOptions values that specifies what is included in observation notifications. For possible values, see NSKeyValueObservingOptions.
	     * @param {?Object} context - Arbitrary data that is passed to observer in observeValue(forKeyPath:of:change:context:).
	     * @returns {void}
	     * @desc Neither the object receiving this message, nor observer, are retained. An object that calls this method must also eventually call either the removeObserver(_:forKeyPath:) or removeObserver(_:forKeyPath:context:) method to unregister the observer when participating in KVO.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1412787-addobserver
	     */
	    value: function addObserverForKeyPath(observer, keyPath) {
	      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
	      var context = arguments[3];
	    }

	    /**
	     * Implemented to attempt a recovery from an error noted in an application-modal dialog.
	     * @access public
	     * @param {Error} error - An NSError object that describes the error, including error recovery options.
	     * @param {number} recoveryOptionIndex - The index of the user selected recovery option in error's localized recovery array.
	     * @returns {boolean} - 
	     * @desc Invoked when an error alert is been presented to the user in an application-modal dialog, and the user has selected an error recovery option specified by error.  
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1416402-attemptrecovery
	     */

	  }, {
	    key: 'attemptRecoveryFromErrorOptionIndex',
	    value: function attemptRecoveryFromErrorOptionIndex(error, recoveryOptionIndex) {
	      return false;
	    }

	    /**
	     * Returns a dictionary containing the property values identified by each of the keys in a given array.
	     * @access public
	     * @param {string[]} keys - An array containing NSString objects that identify properties of the receiver.
	     * @returns {Map<string, Object>} - 
	     * @desc The default implementation invokes value(forKey:) for each key in keys and substitutes NSNull values in the dictionary for returned nil values.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1411319-dictionarywithvalues
	     */

	  }, {
	    key: 'dictionaryWithValuesForKeys',
	    value: function dictionaryWithValuesForKeys(keys) {
	      return null;
	    }

	    /**
	     * Informs the observed object that the specified change has occurred on the indexes for a specified ordered to-many relationship.
	     * @access public
	     * @param {NSKeyValueChange} changeKind - 
	     * @param {Set} indexes - The indexes of the to-many relationship that were affected by the change.
	     * @param {string} key - The name of a property that is an ordered to-many relationship.
	     * @returns {void}
	     * @desc Use this method when implementing key-value-observing compliance manually.Special ConsiderationsYou rarely need to override this method in subclasses, but if you do, be sure to call super. Calls to this method are always paired with a matching call to willChange(_:valuesAt:forKey:).
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1415349-didchange
	     */

	  }, {
	    key: 'didChangeValuesAtForKey',
	    value: function didChangeValuesAtForKey(changeKind, indexes, key) {}

	    /**
	     * Informs the observed object that the value of a given property has changed.
	     * @access public
	     * @param {string} key - The name of the property that changed.
	     * @returns {void}
	     * @desc Use this method when implementing key-value observer compliance manually to inform the observed object that the value at key has just changed. Calls to this method are always paired with a matching call to willChangeValue(forKey:).Special ConsiderationsYou rarely need to override this method in subclasses, but if you do, be sure to call super.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1411809-didchangevalue
	     */

	  }, {
	    key: 'didChangeValueForKey',
	    value: function didChangeValueForKey(key) {}

	    /**
	     * Informs the observed object that the specified change was made to a specified unordered to-many relationship.
	     * @access public
	     * @param {string} key - The name of a property that is an unordered to-many relationship
	     * @param {NSKeyValueSetMutationKind} mutationKind - The type of change that was made.
	     * @param {Set<AnyHashable>} objects - The objects that were involved in the change (see NSKeyValueSetMutationKind).
	     * @returns {void}
	     * @desc Use this method when implementing key-value observer compliance manually. Calls to this method are always paired with a matching call to willChangeValue(forKey:withSetMutation:using:).Special ConsiderationsYou rarely need to override this method in subclasses, but if you do, be sure to call super.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1410539-didchangevalue
	     */

	  }, {
	    key: 'didChangeValueForKeyWithSetMutationUsing',
	    value: function didChangeValueForKeyWithSetMutationUsing(key, mutationKind, objects) {}

	    /**
	     * An NSFileManager object sends this message to its handler for each error it encounters when copying, moving, removing, or linking files or directories. 
	     * @deprecated
	     * @access public
	     * @param {FileManager} fm - 
	     * @param {Map<AnyHashable, Object>} errorInfo - A dictionary that contains two or three pieces of information (all NSString objects) related to the error:KeyValue@"Path"The path related to the error (usually the source path)@"Error"A description of the error@"ToPath" The destination path (not all errors)
	     * @returns {boolean} - 
	     * @desc An NSFileManager object, manager, sends this message for each error it encounters when copying, moving, removing, or linking files or directories. The return value is passed back to the invoker of copyPath:toPath:handler:, movePath:toPath:handler:, removeFileAtPath:handler:, or linkPath:toPath:handler:. If an error occurs and your handler has not implemented this method, the invoking method automatically returns false.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1557005-filemanager
	     */

	  }, {
	    key: 'fileManagerShouldProceedAfterError',
	    value: function fileManagerShouldProceedAfterError(fm, errorInfo) {
	      return false;
	    }

	    /**
	     * An NSFileManager object sends this message to a handler immediately before attempting to move, copy, rename, or delete, or before attempting to link to a given path.
	     * @deprecated
	     * @access public
	     * @param {FileManager} fm - 
	     * @param {string} path - The path or a file or directory that manager is about to attempt to move, copy, rename, delete, or link to.
	     * @returns {void}
	     * @desc You can implement this method in your handler to monitor file operations.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1557002-filemanager
	     */

	  }, {
	    key: 'fileManagerWillProcessPath',
	    value: function fileManagerWillProcessPath(fm, path) {}

	    /**
	     * Returns a mutable array proxy that provides read-write access to an ordered to-many relationship specified by a given key.
	     * @access public
	     * @param {string} key - The name of an ordered to-many relationship.
	     * @returns {Array} - 
	     * @desc Objects added to the mutable array become related to the receiver, and objects removed from the mutable array become unrelated. The default implementation recognizes the same simple accessor methods and array accessor methods as value(forKey:), and follows the same direct instance variable access policies, but always returns a mutable collection proxy object instead of the immutable collection that value(forKey:) would return. The search pattern that mutableArrayValueForKey: uses is described in Accessor Search Patterns in Key-Value Coding Programming Guide.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1416339-mutablearrayvalue
	     */

	  }, {
	    key: 'mutableArrayValueForKey',
	    value: function mutableArrayValueForKey(key) {
	      return null;
	    }

	    /**
	     * Returns a mutable array that provides read-write access to the ordered to-many relationship specified by a given key path.
	     * @access public
	     * @param {string} keyPath - A key path, relative to the receiver, to an ordered to-many relationship.
	     * @returns {Array} - 
	     * @desc See mutableArrayValue(forKey:) for additional details.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1414937-mutablearrayvalue
	     */

	  }, {
	    key: 'mutableArrayValueForKeyPath',
	    value: function mutableArrayValueForKeyPath(keyPath) {
	      return null;
	    }

	    /**
	     * Returns a mutable ordered set that provides read-write access to the uniquing ordered to-many relationship specified by a given key.
	     * @access public
	     * @param {string} key - The name of a uniquing ordered to-many relationship.
	     * @returns {Set} - 
	     * @desc Objects added to the mutable set proxy become related to the receiver, and objects removed from the mutable set become unrelated. The default implementation recognizes the same simple accessor methods and set accessor methods as value(forKey:), and follows the same direct instance variable access policies, but always returns a mutable collection proxy object instead of the immutable collection that value(forKey:) would return. The search pattern that mutableOrderedSetValueForKey: uses is described in Accessor Search Patterns in Key-Value Coding Programming Guide.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1415479-mutableorderedsetvalue
	     */

	  }, {
	    key: 'mutableOrderedSetValueForKey',
	    value: function mutableOrderedSetValueForKey(key) {
	      return null;
	    }

	    /**
	     * Returns a mutable ordered set that provides read-write access to the uniquing ordered to-many relationship specified by a given key path.
	     * @access public
	     * @param {string} keyPath - A key path, relative to the receiver, to a uniquing ordered to-many relationship represented by a set.
	     * @returns {Set} - 
	     * @desc See mutableOrderedSetValue(forKey:) for additional details.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1407188-mutableorderedsetvalue
	     */

	  }, {
	    key: 'mutableOrderedSetValueForKeyPath',
	    value: function mutableOrderedSetValueForKeyPath(keyPath) {
	      return null;
	    }

	    /**
	     * Returns a mutable set proxy that provides read-write access to the unordered to-many relationship specified by a given key.
	     * @access public
	     * @param {string} key - The name of an unordered to-many relationship.
	     * @returns {Set} - 
	     * @desc Objects added to the mutable set proxy become related to the receiver, and objects removed from the mutable set become unrelated. The default implementation recognizes the same simple accessor methods and set accessor methods as value(forKey:), and follows the same direct instance variable access policies, but always returns a mutable collection proxy object instead of the immutable collection that value(forKey:) would return. The search pattern that mutableSetValueForKey: uses is described in Accessor Search Patterns in Key-Value Coding Programming Guide.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1415105-mutablesetvalue
	     */

	  }, {
	    key: 'mutableSetValueForKey',
	    value: function mutableSetValueForKey(key) {
	      return null;
	    }

	    /**
	     * Returns a mutable set that provides read-write access to the unordered to-many relationship specified by a given key path.
	     * @access public
	     * @param {string} keyPath - A key path, relative to the receiver, to an unordered to-many relationship.
	     * @returns {Set} - 
	     * @desc See mutableSetValue(forKey:) for additional details.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1408115-mutablesetvalue
	     */

	  }, {
	    key: 'mutableSetValueForKeyPath',
	    value: function mutableSetValueForKeyPath(keyPath) {
	      return null;
	    }

	    /**
	     * Informs the observing object when the value at the specified key path relative to the observed object has changed.
	     * @access public
	     * @param {?string} keyPath - The key path, relative to object, to the value that has changed.
	     * @param {?Object} object - The source object of the key path keyPath. 
	     * @param {?Map<NSKeyValueChangeKey, Object>} change - A dictionary that describes the changes that have been made to the value of the property at the key path keyPath relative to object. Entries are described in Change Dictionary Keys.
	     * @param {?Object} context - The value that was provided when the observer was registered to receive key-value observation notifications.
	     * @returns {void}
	     * @desc For an object to begin sending change notification messages for the value at keyPath, you send it an addObserver(_:forKeyPath:options:context:) message, naming the observing object that should receive the messages. When you are done observing, and in particular before the observing object is deallocated, you send the observed object a removeObserver(_:forKeyPath:) or removeObserver(_:forKeyPath:context:) message to unregister the observer, and stop sending change notification messages.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1416553-observevalue
	     */

	  }, {
	    key: 'observeValueForKeyPathOf',
	    value: function observeValueForKeyPathOf(keyPath, object, change, context) {}

	    /**
	     * Stops the observer object from receiving change notifications for the property specified by the key path relative to the object receiving this message.
	     * @access public
	     * @param {NSObject} observer - The object to remove as an observer.
	     * @param {string} keyPath - A key-path, relative to the object receiving this message, for which observer is registered to receive KVO change notifications.
	     * @returns {void}
	     * @desc It is an error to call removeObserver(_:forKeyPath:) for an object that has not previously been registered as an observer.Be sure to invoke this method (or removeObserver(_:forKeyPath:context:)) before any object specified in addObserver(_:forKeyPath:options:context:) is deallocated.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1408054-removeobserver
	     */

	  }, {
	    key: 'removeObserverForKeyPath',
	    value: function removeObserverForKeyPath(observer, keyPath) {}

	    /**
	     * Invoked by setValue(_:forKey:) when its given a nil value for a scalar value (such as an int or float).
	     * @access public
	     * @param {string} key - The name of one of the receiver's properties.
	     * @returns {void}
	     * @desc Subclasses can override this method to handle the request in some other way, such as by substituting 0 or a sentinel value for nil and invoking setValue(_:forKey:) again or setting the variable directly. The default implementation raises an NSInvalidArgumentException. 
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1415174-setnilvalueforkey
	     */

	  }, {
	    key: 'setNilValueForKey',
	    value: function setNilValueForKey(key) {}

	    /**
	     * Sets the property of the receiver specified by a given key to a given value.
	     * @access public
	     * @param {?Object} value - The value for the property identified by key.
	     * @param {string} key - The name of one of the receiver's properties.
	     * @returns {void}
	     * @desc If key identifies a to-one relationship, relate the object specified by value to the receiver, unrelating the previously related object if there was one. Given a collection object and a key that identifies a to-many relationship, relate the objects contained in the collection to the receiver, unrelating previously related objects if there were any.  The search pattern that setValue:forKey: uses is described in Accessor Search Patterns in Key-Value Coding Programming Guide.In a reference-counted environment, if the instance variable is accessed directly, value is retained.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1415969-setvalue
	     */

	  }, {
	    key: 'setValueForKey',
	    value: function setValueForKey(value, key) {
	      if (typeof this[key] === 'undefined') {
	        this.setValueForUndefinedKey(value, key);
	      } else {
	        this[key] = value;
	      }
	    }

	    /**
	     * Sets the value for the property identified by a given key path to a given value.
	     * @access public
	     * @param {?Object} value - The value for the property identified by keyPath.
	     * @param {string} keyPath - A key path of the form relationship.property (with one or more relationships): for example department.name or department.manager.lastName. 
	     * @returns {void}
	     * @desc The default implementation of this method gets the destination object for each relationship using value(forKey:), and sends the final object a setValue(_:forKey:) message.Special ConsiderationsWhen using this method, and the destination object does not implement an accessor for the value, the default behavior is for that object to retain value rather than copy or assign value.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1418139-setvalue
	     */

	  }, {
	    key: 'setValueForKeyPath',
	    value: function setValueForKeyPath(value, keyPath) {
	      //console.log('NSObject.setValueForKeyPath: ' + keyPath)
	      if (typeof keyPath !== 'string') {
	        throw new Error('setValueForKeyPath: keyPath should be string');
	      }
	      var paths = keyPath.split('.');
	      var key = paths.shift();
	      if (paths.length === 0) {
	        this.setValueForKey(value, key);
	        return;
	      }
	      var target = this.valueForKey(key);
	      if (target === null) {
	        console.error('setValueForKeyPath: key ' + key + ' is null.');
	        return;
	      }
	      //console.log(`NSObject.setValueForKeyPath: ${keyPath}: key ${key} target ${target}`)
	      target.setValueForKeyPath(value, paths.join('.'));
	    }

	    /**
	     * Invoked by setValue(_:forKey:) when it finds no property for a given key.
	     * @access public
	     * @param {?Object} value - The value for the key identified by key.
	     * @param {string} key - A string that is not equal to the name of any of the receiver's properties.
	     * @returns {void}
	     * @desc Subclasses can override this method to handle the request in some other way. The default implementation raises an NSUndefinedKeyException.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1413490-setvalue
	     */

	  }, {
	    key: 'setValueForUndefinedKey',
	    value: function setValueForUndefinedKey(value, key) {
	      throw new Error('setValueForKey: undefined key: ' + key);
	    }

	    /**
	     * Sets properties of the receiver with values from a given dictionary, using its keys to identify the properties.
	     * @access public
	     * @param {Map<string, Object>} keyedValues - A dictionary whose keys identify properties in the receiver. The values of the properties in the receiver are set to the corresponding values in the dictionary.
	     * @returns {void}
	     * @desc The default implementation invokes setValue(_:forKey:) for each key-value pair, substituting nil for NSNull values in keyedValues.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1417515-setvaluesforkeys
	     */

	  }, {
	    key: 'setValuesForKeys',
	    value: function setValuesForKeys(keyedValues) {}

	    /**
	     * Returns a Boolean value that indicates whether the value specified by a given pointer is valid for the property identified by a given key.
	     * @access public
	     * @param {AutoreleasingUnsafeMutablePointer<AnyObject?>} ioValue - A pointer to a new value for the property identified by key. This method may modify or replace the value in order to make it valid.
	     * @param {string} inKey - 
	     * @returns {void}
	     * @throws {Error}
	     * @desc The default implementation of this method searches the class of the receiver for a validation method whose name matches the pattern validate<Key>:error:. If such a method is found it is invoked and the result is returned. If no such method is found, true is returned.The sender of the message is never given responsibility for releasing ioValue or outError. See Adding Validation for more information.Handling Errors in Swift:
	    In Swift, this method returns Void and is marked with the throws keyword to indicate that it throws an error in cases of failure.
	    You call this method in a try expression and handle any errors in the catch clauses of a do statement, as described in Error Handling in The Swift Programming Language (Swift 3.1) and Error Handling in Using Swift with Cocoa and Objective-C (Swift 3.1).
	      * @see https://developer.apple.com/reference/objectivec/nsobject/1416754-validatevalue
	     */

	  }, {
	    key: 'validateValueForKey',
	    value: function validateValueForKey(ioValue, inKey) {}

	    /**
	     * Returns a Boolean value that indicates whether the value specified by a given pointer is valid for a given key path relative to the receiver. 
	     * @access public
	     * @param {AutoreleasingUnsafeMutablePointer<AnyObject?>} ioValue - A pointer to a new value for the property identified by keyPath. This method may modify or replace the value in order to make it valid.
	     * @param {string} inKeyPath - 
	     * @returns {void}
	     * @throws {Error}
	     * @desc The default implementation gets the destination object for each relationship using value(forKey:) and returns the result of a validateValue(_:forKey:) message to the final object.Handling Errors in Swift:
	    In Swift, this method returns Void and is marked with the throws keyword to indicate that it throws an error in cases of failure.
	    You call this method in a try expression and handle any errors in the catch clauses of a do statement, as described in Error Handling in The Swift Programming Language (Swift 3.1) and Error Handling in Using Swift with Cocoa and Objective-C (Swift 3.1).
	      * @see https://developer.apple.com/reference/objectivec/nsobject/1416245-validatevalue
	     */

	  }, {
	    key: 'validateValueForKeyPath',
	    value: function validateValueForKeyPath(ioValue, inKeyPath) {}

	    /**
	     * Returns the value for the property identified by a given key.
	     * @access public
	     * @param {string} key - The name of one of the receiver's properties.
	     * @returns {?Object} - 
	     * @desc The search pattern that valueForKey: uses to find the correct value to return is described in Accessor Search Patterns in Key-Value Coding Programming Guide.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1412591-value
	     */

	  }, {
	    key: 'valueForKey',
	    value: function valueForKey(key) {
	      if (typeof key !== 'string') {
	        throw new Error('error: valueForKey(key): key should be string');
	      }
	      if (typeof this[key] === 'undefined') {
	        //console.log('valueForUndefinedKey func: ' + this.valueForUndefinedKey)
	        return this.valueForUndefinedKey(key);
	      }
	      return this[key];
	    }

	    /**
	     * Returns the value for the derived property identified by a given key path.
	     * @access public
	     * @param {string} keyPath - A key path of the form relationship.property (with one or more relationships); for example department.name or department.manager.lastName.
	     * @returns {?Object} - 
	     * @desc The default implementation gets the destination object for each relationship using value(forKey:) and returns the result of a value(forKey:) message to the final object.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1416468-value
	     */

	  }, {
	    key: 'valueForKeyPath',
	    value: function valueForKeyPath(keyPath) {
	      if (typeof keyPath !== 'string') {
	        throw new Error('valueForKeyPath(keyPath): keyPath should be string');
	      }
	      var paths = keyPath.split('.');
	      var key = paths.shift();
	      var value = this.valueForKey(key);
	      if (paths.length === 0) {
	        return value;
	      }
	      if (value === null) {
	        return null;
	      }
	      return value.valueForKeyPath(paths.join('.'));
	    }

	    /**
	     * Invoked by value(forKey:) when it finds no property corresponding to a given key.
	     * @access public
	     * @param {string} key - A string that is not equal to the name of any of the receiver's properties.
	     * @returns {?Object} - 
	     * @desc Subclasses can override this method to return an alternate value for undefined keys. The default implementation raises an NSUndefinedKeyException.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1413457-value
	     */

	  }, {
	    key: 'valueForUndefinedKey',
	    value: function valueForUndefinedKey(key) {
	      throw new Error('valueForKey: undefined key: ' + key);
	    }

	    /**
	     * Informs the observed object that the specified change is about to be executed at given indexes for a specified ordered to-many relationship.
	     * @access public
	     * @param {NSKeyValueChange} changeKind - 
	     * @param {Set} indexes - The indexes of the to-many relationship that will be affected by the change.
	     * @param {string} key - The name of a property that is an ordered to-many relationship.
	     * @returns {void}
	     * @desc Use this method when implementing key-value-observing compliance manually.ImportantAfter the values have been changed, a corresponding didChange(_:valuesAt:forKey:) must be invoked with the same parameters.Special ConsiderationsYou rarely need to override this method in subclasses, but if you do, be sure to call super.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1412271-willchange
	     */

	  }, {
	    key: 'willChangeValuesAtForKey',
	    value: function willChangeValuesAtForKey(changeKind, indexes, key) {}

	    /**
	     * Informs the observed object that the value of a given property is about to change.
	     * @access public
	     * @param {string} key - The name of the property that will change.
	     * @returns {void}
	     * @desc Use this method when implementing key-value observer compliance manually to inform the observed object that the value at key is about to change.The change type of this method is NSKeyValueChangeSetting.ImportantAfter the values have been changed, a corresponding didChangeValue(forKey:) must be invoked with the same parameter. Special ConsiderationsYou rarely need to override this method in subclasses, but if you do, be sure to call super.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1416222-willchangevalue
	     */

	  }, {
	    key: 'willChangeValueForKey',
	    value: function willChangeValueForKey(key) {}

	    /**
	     * Informs the observed object that the specified change is about to be made to a specified unordered to-many relationship.
	     * @access public
	     * @param {string} key - The name of a property that is an unordered to-many relationship
	     * @param {NSKeyValueSetMutationKind} mutationKind - The type of change that will be made.
	     * @param {Set<AnyHashable>} objects - The objects that are involved in the change (see NSKeyValueSetMutationKind).
	     * @returns {void}
	     * @desc Use this method when implementing key-value observer compliance manually.ImportantAfter the values have been changed, a corresponding didChangeValue(forKey:withSetMutation:using:) must be invoked with the same parameters.Special ConsiderationsYou rarely need to override this method in subclasses, but if you do, be sure to call super.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1412323-willchangevalue
	     */

	  }, {
	    key: 'willChangeValueForKeyWithSetMutationUsing',
	    value: function willChangeValueForKeyWithSetMutationUsing(key, mutationKind, objects) {}

	    /**
	     * 
	     * @access public
	     * @param {!QLPreviewPanel} panel - 
	     * @returns {boolean} - 
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1504653-acceptspreviewpanelcontrol
	     */

	  }, {
	    key: 'acceptsPreviewPanelControl',
	    value: function acceptsPreviewPanelControl(panel) {
	      return false;
	    }

	    /**
	     * Returns a localized description of the specified action.
	     * @deprecated
	     * @access public
	     * @param {string} action - The action attribute.
	     * @returns {?string} - 
	     * @desc User interface classes must implement this method to return descriptions for all actions returned from accessibilityActionNames(). A button, for example, might return the string "press for the NSAccessibilityPressAction action. Subclasses should invoke the superclass's implementation, if it exists, to obtain the descriptions of any inherited actions.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1533500-accessibilityactiondescription
	     */

	  }, {
	    key: 'accessibilityActionDescription',
	    value: function accessibilityActionDescription(action) {
	      return null;
	    }

	    /**
	     * Returns an array of action names supported by the accessibility element.
	     * @deprecated
	     * @access public
	     * @returns {Object[]} - 
	     * @desc User interface classes must implement this method. Subclasses should invoke the superclass's implementation, if it exists, and append additional action names or remove unsupported actions. See Constants for some common action names.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1527905-accessibilityactionnames
	     */

	  }, {
	    key: 'accessibilityActionNames',
	    value: function accessibilityActionNames() {
	      return null;
	    }

	    /**
	     * Returns the count of the specified accessibility array attribute.
	     * @access public
	     * @param {string} attribute - The accessibility array attribute.
	     * @returns {number} - 
	     * @desc If attribute is not an array, an exception is raised.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1527138-accessibilityarrayattributecount
	     */

	  }, {
	    key: 'accessibilityArrayAttributeCount',
	    value: function accessibilityArrayAttributeCount(attribute) {
	      return 0;
	    }

	    /**
	     * Returns a subarray of values of an accessibility array attribute.
	     * @access public
	     * @param {string} attribute - The accessibility array attribute.
	     * @param {number} index - The starting index.
	     * @param {number} maxCount - The maximum desired number of items requested.
	     * @returns {Object[]} - 
	     * @desc Note that this method does not take a range. The maximum count is the maximum desired number of items requested by an accessibility client. This number may be beyond the bounds of your array.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1535909-accessibilityarrayattributevalue
	     */

	  }, {
	    key: 'accessibilityArrayAttributeValues',
	    value: function accessibilityArrayAttributeValues(attribute, index, maxCount) {
	      return null;
	    }

	    /**
	     * Returns an array of attribute names supported by the receiver.
	     * @deprecated
	     * @access public
	     * @returns {Object[]} - 
	     * @desc User interface classes must implement this method. Subclasses should invoke the superclass's implementation, if it exists, and append additional attributes or remove unsupported attributes. See Constants for lists of attribute names.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1525181-accessibilityattributenames
	     */

	  }, {
	    key: 'accessibilityAttributeNames',
	    value: function accessibilityAttributeNames() {
	      return null;
	    }

	    /**
	     * Returns the value of the specified attribute in the receiver.
	     * @deprecated
	     * @access public
	     * @param {string} attribute - The name of the attribute. See Constants for lists of attribute names.
	     * @returns {?Object} - 
	     * @desc User interface classes must implement this method. Subclasses should invoke the superclass's implementation, if it exists, if attribute is not implemented in the subclass.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1532465-accessibilityattributevalue
	     */

	  }, {
	    key: 'accessibilityAttributeValue',
	    value: function accessibilityAttributeValue(attribute) {
	      return null;
	    }

	    /**
	     * Returns the value of the receiver's parameterized attribute corresponding to the specified attribute name and parameter.
	     * @deprecated
	     * @access public
	     * @param {string} attribute - The name of the attribute. See Constants for lists of attribute names.
	     * @param {?Object} parameter - The parameter.
	     * @returns {?Object} - 
	     * @desc If you implement this method, also implement accessibilityParameterizedAttributeNames().
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1524809-accessibilityattributevalue
	     */

	  }, {
	    key: 'accessibilityAttributeValueForParameter',
	    value: function accessibilityAttributeValueForParameter(attribute, parameter) {
	      return null;
	    }

	    /**
	     * Returns the deepest descendant of the accessibility hierarchy that contains the specified point.
	     * @access public
	     * @param {CGPoint} point - The point being hit-tested, in lower-left relative screen coordinates.
	     * @returns {?Object} - 
	     * @desc You can assume that the specified point has already been determined to lie within the accessibility element's frame. Override this method to do deeper hit-testing by identifying which child element, if any, contains the point. NSMatrix, for example, identifies which of its cells contains the point and propagates the hit-test to it. If the specified point is not contained within one of the accessibility element's children, either return self or, if available, invoke the superclass's implementation. The default NSView and NSCell implementations test whether the accessibility element is an ignored element and, if it is, return the receiver's first unignored parent; otherwise they return self.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1526136-accessibilityhittest
	     */

	  }, {
	    key: 'accessibilityHitTest',
	    value: function accessibilityHitTest(point) {
	      return null;
	    }

	    /**
	     * Returns the index of the specified accessibility child in the parent.
	     * @access public
	     * @param {Object} child - The accessibility child of an object.
	     * @returns {number} - 
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1533558-accessibilityindex
	     */

	  }, {
	    key: 'accessibilityIndexOfChild',
	    value: function accessibilityIndexOfChild(child) {
	      return 0;
	    }

	    /**
	     * Returns a Boolean value that indicates whether the value for the specified attribute in the receiver can be set.
	     * @deprecated
	     * @access public
	     * @param {string} attribute - The name of the attribute. See Constants for lists of attribute names.
	     * @returns {boolean} - 
	     * @desc User interface classes must implement this method. Subclasses should invoke the superclass's implementation, if it exists, if attribute is not implemented in the subclass.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1529207-accessibilityisattributesettable
	     */

	  }, {
	    key: 'accessibilityIsAttributeSettable',
	    value: function accessibilityIsAttributeSettable(attribute) {
	      return false;
	    }

	    /**
	     * Returns a Boolean value indicating whether the receiver should be ignored in the parent-child accessibility hierarchy.
	     * @deprecated
	     * @access public
	     * @returns {boolean} - 
	     * @desc When asking for an object's children, do not include ignored children; instead, replace the ignored children with their own unignored children. The same applies when asking for an object's parent: skip the ignored parent and treat the first unignored ancestor as the real parent.  Likewise, when a hit-test or focus test is satisfied by an ignored element, use the element's first unignored ancestor (or descendant in certain cases, such as single-celled controls) instead.Ignored elements let you provide a simplified version of the view and object ownership hierarchies. Accessibility clients can bypass intermediate objects, letting users access the real user interface objects more quickly. For example, NSControl objects are ignored when they are single-celled; the visible parent-child relationship is between the control's parent (or a higher ancestor if the parent is ignored, too) and the control's cell.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1526439-accessibilityisignored
	     */

	  }, {
	    key: 'accessibilityIsIgnored',
	    value: function accessibilityIsIgnored() {
	      return false;
	    }

	    /**
	     * Returns a list of parameterized attribute names supported by the receiver.
	     * @deprecated
	     * @access public
	     * @returns {Object[]} - 
	     * @desc If you implement this method, also implement accessibilityAttributeValue(_:forParameter:).
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1525455-accessibilityparameterizedattrib
	     */

	  }, {
	    key: 'accessibilityParameterizedAttributeNames',
	    value: function accessibilityParameterizedAttributeNames() {
	      return null;
	    }

	    /**
	     * Performs the action associated with the specified action.
	     * @deprecated
	     * @access public
	     * @param {string} action - The action to perform.
	     * @returns {void}
	     * @desc User interface classes must implement this method to handle all the actions returned from accessibilityActionNames(). Subclasses should invoke the superclass's implementation, if it exists, if action is not implemented in the subclass.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1533528-accessibilityperformaction
	     */

	  }, {
	    key: 'accessibilityPerformAction',
	    value: function accessibilityPerformAction(action) {}

	    /**
	     * Overrides the specified attribute in the receiver or adds it if it does not exist, and sets its value to the specified value.
	     * @deprecated
	     * @access public
	     * @param {?Object} value - The attribute value to be set. 
	     * @param {string} attribute - The name of the attribute. See Constants for lists of attribute names.
	     * @returns {boolean} - 
	     * @desc This method is for changing the set of attributes on an instance, as an alternative to subclassing.This method works only on objects whose class already implements the NSAccessibility protocol. If the specified attribute is already supported by the object, the value specified by this method wins.If the specified attribute does not exist, it is created outside the NSAccessibility protocol, so accessibilityAttributeNames still returns the old list, which does not contain the new attribute. Likewise, accessibilityAttributeValue does not return attributes created by the override process nor does it return their overridden values.The values of overridden attributes are not settable by accessibility clients.If you need to undo the effect of using this method, call it again, passing nil for the value.Ensure that you invoke this method on the actual object that represents the user interface element. For example, for NSButton, use the underlying NSButtonCell object. NSButton itself is ignored by accessibility.This method works only on an object representing a single user interface element. So, for example, you cannot use it when a single object represents multiple user interface elements, as with NSSegmentedCell, which has only a single object but provides user interface elements for each segment.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1535843-accessibilitysetoverridevalue
	     */

	  }, {
	    key: 'accessibilitySetOverrideValueForAttribute',
	    value: function accessibilitySetOverrideValueForAttribute(value, attribute) {
	      return false;
	    }

	    /**
	     * Sets the value of the specified attribute in the receiver to the specified value.
	     * @deprecated
	     * @access public
	     * @param {?Object} value - The attribute value to be set.
	     * @param {string} attribute - The name of the attribute. See Constants for lists of attribute names.
	     * @returns {void}
	     * @desc User interface classes must implement this method if any of its attributes are settable. Subclasses should invoke the superclass's implementation, if it exists, if attribute is not implemented in the subclass.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1528477-accessibilitysetvalue
	     */

	  }, {
	    key: 'accessibilitySetValueForAttribute',
	    value: function accessibilitySetValueForAttribute(value, attribute) {}

	    /**
	     * Sent to the delegate to request the property the action applies to.
	     * @access public
	     * @returns {!string} - 
	     * @desc See Table 1The documentation for property-list constants for the properties for person and group records.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1411302-actionproperty
	     */

	  }, {
	    key: 'actionProperty',
	    value: function actionProperty() {
	      return null;
	    }

	    /**
	     * Sent by Cocoas built-in scripting support during execution of get or set script commands to find out if the delegate can handle operations on the specified key-value key.
	     * @access public
	     * @param {NSApplication} sender - The app object associated with the delegate. 
	     * @param {string} key - The key to be handled.
	     * @returns {boolean} - 
	     * @desc The method should return true if the delegate for the app sender handles the key specified by key, which means it can get or set the scriptable property or element that corresponds to that key. The app implements methods for each of the keys that it handles, where the method name matches the key.For example, a scriptable app that doesnt use Cocoas document-based app architecture can implement this method to supply its own document ordering. Such an app might want to do this because the standard app delegate expects to work with a document-based app. The TextEdit app (whose source is distributed with macOS developer tools) provides the following implementation:return [key isEqualToString:@"orderedDocuments"];
	    TextEdit then implements the orderedDocuments method in its controller class to return an ordered list of documents. An app with its own window ordering might add a test for the key orderedWindows so that its delegate can provide its own version of orderedWindows.ImportantCocoa scripting does not invoke this method for script commands other than get or set. For information on working with other commands, see Script Commands in Cocoa Scripting Guide.return [key isEqualToString:@"orderedDocuments"];
	      * @see https://developer.apple.com/reference/objectivec/nsobject/1494285-application
	     */

	  }, {
	    key: 'applicationDelegateHandlesKey',
	    value: function applicationDelegateHandlesKey(sender, key) {
	      return false;
	    }

	    /**
	     * Sent to the delegate to indicate the authorization object has been created or changed. If you have saved a copy of the authorization object for your own purposes, you should discard it and call authorization for a new authorization object.
	     * @access public
	     * @param {!SFAuthorizationView} view - 
	     * @returns {void}
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1411010-authorizationviewcreatedauthoriz
	     */

	  }, {
	    key: 'authorizationViewCreatedAuthorization',
	    value: function authorizationViewCreatedAuthorization(view) {}

	    /**
	     * Sent to the delegate to indicate the user was authorized and the authorization view was changed to unlocked.
	     * @access public
	     * @param {!SFAuthorizationView} view - 
	     * @returns {void}
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1411002-authorizationviewdidauthorize
	     */

	  }, {
	    key: 'authorizationViewDidAuthorize',
	    value: function authorizationViewDidAuthorize(view) {}

	    /**
	     * Sent to the delegate to indicate the user was deauthorized and the authorization view was changed to locked.
	     * @access public
	     * @param {!SFAuthorizationView} view - 
	     * @returns {void}
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1411017-authorizationviewdiddeauthorize
	     */

	  }, {
	    key: 'authorizationViewDidDeauthorize',
	    value: function authorizationViewDidDeauthorize(view) {}

	    /**
	     * Sent to the delegate to indicate that the views visibility has changed.
	     * @access public
	     * @param {!SFAuthorizationView} view - 
	     * @returns {void}
	     * @desc This delegate method, if present, is called whenever the isHidden method is called to show or hide the view.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1411034-authorizationviewdidhide
	     */

	  }, {
	    key: 'authorizationViewDidHide',
	    value: function authorizationViewDidHide(view) {}

	    /**
	     * Sent to the delegate to indicate that deauthorization is about to occur.
	     * @access public
	     * @param {!SFAuthorizationView} view - 
	     * @returns {void}
	     * @desc This method is called after deauthorization has been approved (either you called the deauthorize: method, or the user clicked an open lock icon and the authorizationViewShouldDeauthorize: delegate method did not cancel the operation), and before the user is deauthorized (that is, before the authorizationViewDidDeauthorize: delegate method is called). 
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1410992-authorizationviewreleasedauthori
	     */

	  }, {
	    key: 'authorizationViewReleasedAuthorization',
	    value: function authorizationViewReleasedAuthorization(view) {}

	    /**
	     * Sent to the delegate when a user clicks the open lock icon.
	     * @access public
	     * @param {!SFAuthorizationView} view - 
	     * @returns {number} - 
	     * @desc  The delegate can react to this before deauthorization happens and avoid it by returning false. This delegate method is not called when you call the deauthorize: method.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1411006-authorizationviewshoulddeauthori
	     */

	  }, {
	    key: 'authorizationViewShouldDeauthorize',
	    value: function authorizationViewShouldDeauthorize(view) {
	      return 0;
	    }

	    /**
	     * Prepares the receiver for service after it has been loaded from an Interface Builder archive, or nib file.
	     * @access public
	     * @returns {void}
	     * @desc The nib-loading infrastructure sends an awakeFromNib message to each object recreated from a nib archive, but only after all the objects in the archive have been loaded and initialized. When an object receives an awakeFromNib message, it is guaranteed to have all its outlet and action connections already established.You must call the super implementation of awakeFromNib to give parent classes the opportunity to perform any additional initialization they require. Although the default implementation of this method does nothing, many UIKit classes provide non-empty implementations. You may call the super implementation at any point during your own awakeFromNib method.NoteDuring Interface Builders test mode, this message is also sent to objects instantiated from loaded Interface Builder plug-ins. Because plug-ins link against the framework containing the object definition code, Interface Builder is able to call their awakeFromNib method when present. The same is not true for custom objects that you create for your Xcode projects. Interface Builder knows only about the defined outlets and actions of those objects; it does not have access to the actual code for them.During the instantiation process, each object in the archive is unarchived and then initialized with the method befitting its type. Objects that conform to the NSCoding protocol (including all subclasses of UIView and UIViewController) are initialized using their initWithCoder: method. All objects that do not conform to the NSCoding protocol are initialized using their init method. After all objects have been instantiated and initialized, the nib-loading code reestablishes the outlet and action connections for all of those objects. It then calls the awakeFromNib method of the objects. For more detailed information about the steps followed during the nib-loading process, see Nib Files in Resource Programming Guide.ImportantBecause the order in which objects are instantiated from an archive is not guaranteed, your initialization methods should not send messages to other objects in the hierarchy. Messages to other objects can be sent safely from within an awakeFromNib method. Typically, you implement awakeFromNib for objects that require additional set up that cannot be done at design time. For example, you might use this method to customize the default configuration of any controls to match user preferences or the values in other controls. You might also use it to restore individual controls to some previous state of your application. 
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1402907-awakefromnib
	     */

	  }, {
	    key: 'awakeFromNib',
	    value: function awakeFromNib() {}

	    /**
	     * 
	     * @access public
	     * @param {!QLPreviewPanel} panel - 
	     * @returns {void}
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1504204-beginpreviewpanelcontrol
	     */

	  }, {
	    key: 'beginPreviewPanelControl',
	    value: function beginPreviewPanelControl(panel) {}

	    /**
	     * Establishes a binding between a given property of the receiver and the property of a given object specified by a given key path.
	     * @access public
	     * @param {string} binding - The key path for a property of the receiver previously exposed using the exposeBinding(_:) method.
	     * @param {Object} observable - 
	     * @param {string} keyPath - A key path to a property reachable from observableController. The elements in the path must be key-value observing compliant (see Key-Value Observing Programming Guide).
	     * @param {?Map<string, Object>} [options = null] - A dictionary containing options for the binding, such as placeholder objects or an NSValueTransformer identifier as described in Constants. This value is optionalpass nil to specify no options.
	     * @returns {void}
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1458185-bind
	     */

	  }, {
	    key: 'bindToWithKeyPath',
	    value: function bindToWithKeyPath(binding, observable, keyPath) {
	      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
	    }

	    /**
	     * Returns an array of candidates.
	     * @access public
	     * @param {!Object} sender - The client object requesting the candidates.
	     * @returns {!Object[]} - 
	     * @desc An input method should look up its currently composed string and return a list of candidate strings that that string might map to.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1385360-candidates
	     */

	  }, {
	    key: 'candidates',
	    value: function candidates(sender) {
	      return null;
	    }

	    /**
	     * Implements custom help behavior for the modal panel.
	     * @access public
	     * @param {!SFCertificatePanel} sender - The certificate panel for which to implement custom help.
	     * @returns {number} - 
	     * @desc You can use this delegate method to implement custom help if you call the setShowsHelp: method to display a help button in the sheet or panel. If you are not implementing custom help, do not implement this method.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1514145-certificatepanelshowhelp
	     */

	  }, {
	    key: 'certificatePanelShowHelp',
	    value: function certificatePanelShowHelp(sender) {
	      return 0;
	    }

	    /**
	     * Sent to the first responder when the user selects a color in an NSColorPanel object.
	     * @access public
	     * @param {?Object} sender - The NSColorPanel sending the message.
	     * @returns {void}
	     * @desc When the user selects a color in an NSColorPanel object, the panel sends a changeColor(_:) action message to the first responder. You can override this method in any responder that needs to respond to a color change. 
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1532638-changecolor
	     */

	  }, {
	    key: 'changeColor',
	    value: function changeColor(sender) {}

	    /**
	     * Informs responders of a font change.
	     * @access public
	     * @param {?Object} sender - The object that sent the message.
	     * @returns {void}
	     * @desc Generally this change is because the user changed the font either in the selection of a rich text field or in a whole plain text field. Any object that contains a font the user can change must respond to the changeFont(_:) message by sending a convert(_:) message back to sender (an NSFontManager object) for each font in the selection. For more information, see Responding to Font Changes.Be aware that selectedFont at this point may return unpredictable results. The font in this property may not be the last font selected, or there may be multiple fonts selected at the time changeFont(_:) is called. The use of selectedFont from within changeFont(_:) is strongly discouraged.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1462311-changefont
	     */

	  }, {
	    key: 'changeFont',
	    value: function changeFont(sender) {}

	    /**
	     * Implements custom help behavior for the modal panel.
	     * @access public
	     * @param {!SFChooseIdentityPanel} sender - The choose identity panel for which to implement custom help.
	     * @returns {number} - 
	     * @desc You can use this delegate method to implement custom help if you call the setShowsHelp: method to display a help button in the sheet or panel. If you are not implementing custom help, do not implement this method. 
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1514140-chooseidentitypanelshowhelp
	     */

	  }, {
	    key: 'chooseIdentityPanelShowHelp',
	    value: function chooseIdentityPanelShowHelp(sender) {
	      return 0;
	    }

	    /**
	     * 
	     * @deprecated
	     * @access public
	     * @param {Object} annotationClass - 
	     * @returns {Object} - 
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1436089-class
	     */

	  }, {
	    key: 'classForAnnotationClass',
	    value: function classForAnnotationClass(annotationClass) {
	      return null;
	    }

	    /**
	     * 
	     * @deprecated
	     * @access public
	     * @returns {Object} - 
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1436049-classforpage
	     */

	  }, {
	    key: 'classForPage',
	    value: function classForPage() {
	      return null;
	    }

	    /**
	     * Uses type info from the class description and NSScriptCoercionHandler to attempt to convert value for key to the proper type, if necessary.
	     * @access public
	     * @param {?Object} value - 
	     * @param {string} key - 
	     * @returns {?Object} - 
	     * @desc  The method coerceValueFor<Key>: is used if it exists.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1416527-coercevalue
	     */

	  }, {
	    key: 'coerceValueForKey',
	    value: function coerceValueForKey(value, key) {
	      return null;
	    }

	    /**
	     * Informs the controller that the composition should be committed.
	     * @access public
	     * @param {!Object} sender - The client object requesting the input method to commit the composition.
	     * @returns {void}
	     * @desc If an input method implements this method, it is called when the client wants to end the composition session immediately. A typical response would be to call the insertText method of the client and then clean up any per-session buffers and variables. After receiving this message an input method should consider the given composition session finished.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1385539-commitcomposition
	     */

	  }, {
	    key: 'commitComposition',
	    value: function commitComposition(sender) {}

	    /**
	     * Returns whether the receiver was able to commit any pending edits.
	     * @access public
	     * @returns {boolean} - 
	     * @desc A commit is denied if the receiver fails to apply the changes to the model object, perhaps due to a validation error.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1458190-commitediting
	     */

	  }, {
	    key: 'commitEditing',
	    value: function commitEditing() {
	      return false;
	    }

	    /**
	     * Attempt to commit pending edits, returning an error in the case of failure.
	     * @access public
	     * @returns {void}
	     * @throws {Error}
	     * @desc During autosaving, commit editing may fail, due to a pending edit. Rather than interrupt the user with an unexpected alert, this method provides the caller with the option to either present the error or fail silently, leaving the pending edit in place and the user's editing uninterrupted. In your implementation of this method, you should attempt to commit editing, but if there is a failure return false and in error an error object to be presented or ignored as appropriate. Handling Errors in Swift:
	    In Swift, this method returns Void and is marked with the throws keyword to indicate that it throws an error in cases of failure.
	    You call this method in a try expression and handle any errors in the catch clauses of a do statement, as described in Error Handling in The Swift Programming Language (Swift 3.1) and Error Handling in Using Swift with Cocoa and Objective-C (Swift 3.1).
	      * @see https://developer.apple.com/reference/objectivec/nsobject/1458181-commiteditingandreturnerror
	     */

	  }, {
	    key: 'commitEditingAndReturnError',
	    value: function commitEditingAndReturnError() {}

	    /**
	     * Attempt to commit any currently edited results of the receiver.
	     * @access public
	     * @param {?Object} delegate - 
	     * @param {?function} didCommitSelector - 
	     * @param {?Object} contextInfo - 
	     * @returns {void}
	     * @desc The receiver must have been registered as the editor of an object using objectDidBeginEditing:, and has not yet been unregistered by a subsequent invocation of objectDidEndEditing:. When the committing has either succeeded or failed, send the following message to the specified object. The didCommitSelector method must have the following method signature: - (void)editor:(id)editor didCommit:(BOOL)didCommit contextInfo:(void *)contextInfo
	    If an error occurs while attempting to commit, for example if key-value coding validation fails, an implementation of this method should typically send the NSView in which editing is being done a presentError:modalForWindow:delegate:didRecoverSelector:contextInfo: message, specifying the view's containing window.- (void)editor:(id)editor didCommit:(BOOL)didCommit contextInfo:(void *)contextInfo
	      * @see https://developer.apple.com/reference/objectivec/nsobject/1458179-commitediting
	     */

	  }, {
	    key: 'commitEditingWithDelegateDidCommit',
	    value: function commitEditingWithDelegateDidCommit(delegate, didCommitSelector, contextInfo) {}

	    /**
	     * Return the current composed string.
	     * @access public
	     * @param {!Object} sender - The client object requesting the string.
	     * @returns {!Object} - 
	     * @desc  A composed string refers to the buffer that an input method typically maintains to mirror the text contained in the active inline area. It is called the composed string to reflect the fact that the input method composed the string by converting the characters input by the user. In addition, using the term composed string makes it easier to differentiate between an input method  buffer and the text in the active inline area that the user sees. 
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1385416-composedstring
	     */

	  }, {
	    key: 'composedString',
	    value: function composedString(sender) {
	      return null;
	    }

	    /**
	     * Called after an input parameter in the composition parameter view has been edited.
	     * @access public
	     * @param {!QCCompositionParameterView} parameterView - The composition parameter view in which the parameter changed.
	     * @param {!string} portKey - A key for one of the composition parameters, which is provided to you by the Quartz Composer engine.
	     * @returns {void}
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1505265-compositionparameterview
	     */

	  }, {
	    key: 'compositionParameterViewDidChangeParameterWithKey',
	    value: function compositionParameterViewDidChangeParameterWithKey(parameterView, portKey) {}

	    /**
	     * Allows you to define which composition parameters are visible in the user interface when the composition parameter view refreshes.  
	     * @access public
	     * @param {!QCCompositionParameterView} parameterView - The composition parameter view in which the selection changed.
	     * @param {!string} portKey - A key for one of the composition parameters, which is provided to you by the Quartz Composer engine.
	     * @param {!Map<AnyHashable, Object>} [portAttributes = new Map()] - A dictionary of the attributes that you want to display in the user interface.
	     * @returns {boolean} - 
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1503523-compositionparameterview
	     */

	  }, {
	    key: 'compositionParameterViewShouldDisplayParameterWithKeyAttributes',
	    value: function compositionParameterViewShouldDisplayParameterWithKeyAttributes(parameterView, portKey) {
	      var portAttributes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Map();

	      return false;
	    }

	    /**
	     * Performs custom tasks when the selected composition in the composition picker view changes. 
	     * @access public
	     * @param {!QCCompositionPickerView} pickerView - The composition picker view in which the selection changed.
	     * @param {!QCComposition} composition - The selected composition or nil if the previously selected composition is no longer selected.
	     * @returns {void}
	     * @desc Quartz Composer invokes this method when the selected composition in the composition picker view changes. Implement this method if you want to perform custom tasks at that time.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1447352-compositionpickerview
	     */

	  }, {
	    key: 'compositionPickerViewDidSelect',
	    value: function compositionPickerViewDidSelect(pickerView, composition) {}

	    /**
	     * Performs custom tasks when the composition picker view starts animating a composition.
	     * @access public
	     * @param {!QCCompositionPickerView} pickerView - The composition picker view in which the composition started animating.
	     * @returns {void}
	     * @desc Quartz Composer invokes  this method when  the composition picker view starts animating a composition. Implement this method if you want to perform custom tasks at that time.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1447342-compositionpickerviewdidstartani
	     */

	  }, {
	    key: 'compositionPickerViewDidStartAnimating',
	    value: function compositionPickerViewDidStartAnimating(pickerView) {}

	    /**
	     * Performs custom tasks when the composition picker view stops animating a composition.
	     * @access public
	     * @param {!QCCompositionPickerView} pickerView - The composition picker view in which the composition stopped animating.
	     * @returns {void}
	     * @desc Quartz Composer invokes  this method whenever the composition picker view stops animating a composition. Implement this method if you want to perform custom tasks at that time.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1447348-compositionpickerviewwillstopani
	     */

	  }, {
	    key: 'compositionPickerViewWillStopAnimating',
	    value: function compositionPickerViewWillStopAnimating(pickerView) {}

	    /**
	     * Sent when a control with editable text begins an editing session.
	     * @access public
	     * @param {Notification} obj - 
	     * @returns {void}
	     * @desc This method is invoked when the user begins editing text in a control such as a text field or a form field. The control posts a NSControlTextDidBeginEditing notification, and if the controls delegate implements this method, it is automatically registered to receive the notification. Use the key @"NSFieldEditor" to obtain the field editor from the userInfo dictionary of the notification object.  See controlTextDidEndEditing(_:) for an explanation of why you may not always get one invocation of controlTextDidBeginEditing(_:) for each invocation of controlTextDidEndEditing(_:).
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1428934-controltextdidbeginediting
	     */

	  }, {
	    key: 'controlTextDidBeginEditing',
	    value: function controlTextDidBeginEditing(obj) {}

	    /**
	     * Sent when the text in the receiving control changes. 
	     * @access public
	     * @param {Notification} obj - 
	     * @returns {void}
	     * @desc This method is invoked when text in a control such as a text field or form changes. The control posts a NSControlTextDidChange notification, and if the controls delegate implements this method, it is automatically registered to receive the notification. Use the key @"NSFieldEditor" to obtain the field editor from the userInfo dictionary of the notification object.  
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1428982-controltextdidchange
	     */

	  }, {
	    key: 'controlTextDidChange',
	    value: function controlTextDidChange(obj) {}

	    /**
	     * Sent when a control with editable text ends an editing session.
	     * @access public
	     * @param {Notification} obj - 
	     * @returns {void}
	     * @desc This method is invoked when the user stops editing text in a control such as a text field or form. The control posts a NSControlTextDidEndEditing notification, and if the controls delegate implements this method, it is automatically registered to receive the notification. Use the key @"NSFieldEditor" to obtain the field editor from the userInfo dictionary of the notification object.  WarningIn some cases, such as when editing within an instance of NSOutlineView, this method may be invoked without a previous invocation of controlTextDidBeginEditing(_:). You will only get the controlTextDidBeginEditing: notification if the user actually types something, but you can get the controlTextDidEndEditing: notification if the user just double-clicks the field and then clicks outside the field, without typing.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1428847-controltextdidendediting
	     */

	  }, {
	    key: 'controlTextDidEndEditing',
	    value: function controlTextDidEndEditing(obj) {}

	    /**
	     * Processes a command  generated by user action such as typing certain keys or pressing the mouse button.
	     * @access public
	     * @param {!function} aSelector - The action associated with the key down event. The selector can be an action specified in the input method  dictionary of keys and actions (that is, an action specific to the input method) or one of the NSResponder action methods such as insertNewline: or deleteBackward:. By definition such action methods do not return a value.
	     * @param {!Object} sender - The client object sending the key down event.
	     * @returns {boolean} - 
	     * @desc This method is called when the system binds a key down event to an action method. If you implement this method you should test if it is appropriate to call the action method before actually calling it, because calling the action method implies that you agree to handle the command. Suppose you have implemented a version of insertNewline:  that terminates the conversion session and sends the fully converted text to the client. However, if you conversion buffer is empty, you want the application to receive the return key that triggered the call to insertNewline:. In that case, when didCommandBySelector:client: is called you should test your buffer before calling your implementation of insertNewline:. If the buffer is empty, return false to indicate that the return key should be passed on to the application. If the buffer is not empty, call insertNewline: and then return true as the result of didCommandBySelector:client:.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1385394-didcommand
	     */

	  }, {
	    key: 'didCommandByClient',
	    value: function didCommandByClient(aSelector, sender) {
	      return false;
	    }

	    /**
	     * Called for every match found during a find operation.
	     * @access public
	     * @param {PDFSelection} instance - 
	     * @returns {void}
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1436046-didmatchstring
	     */

	  }, {
	    key: 'didMatchString',
	    value: function didMatchString(instance) {}

	    /**
	     * Causes the receiver to discard any changes, restoring the previous values.
	     * @access public
	     * @returns {void}
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1458076-discardediting
	     */

	  }, {
	    key: 'discardEditing',
	    value: function discardEditing() {}

	    /**
	     * Called when the PDFDocumentDidBeginFindNotification notification is posted. 
	     * @access public
	     * @param {Notification} notification - 
	     * @returns {void}
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1436080-documentdidbegindocumentfind
	     */

	  }, {
	    key: 'documentDidBeginDocumentFind',
	    value: function documentDidBeginDocumentFind(notification) {}

	    /**
	     * Called when the PDFDocumentDidBeginPageFindNotification notification is posted.
	     * @access public
	     * @param {Notification} notification - 
	     * @returns {void}
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1436094-documentdidbeginpagefind
	     */

	  }, {
	    key: 'documentDidBeginPageFind',
	    value: function documentDidBeginPageFind(notification) {}

	    /**
	     * Called when the PDFDocumentDidEndFindNotification notification is posted.
	     * @access public
	     * @param {Notification} notification - 
	     * @returns {void}
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1436068-documentdidenddocumentfind
	     */

	  }, {
	    key: 'documentDidEndDocumentFind',
	    value: function documentDidEndDocumentFind(notification) {}

	    /**
	     * Called when the PDFDocumentDidEndPageFindNotification notification is posted. 
	     * @access public
	     * @param {Notification} notification - 
	     * @returns {void}
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1436064-documentdidendpagefind
	     */

	  }, {
	    key: 'documentDidEndPageFind',
	    value: function documentDidEndPageFind(notification) {}

	    /**
	     * Called when the PDFDocumentDidFindMatchNotification notification is posted.
	     * @access public
	     * @param {Notification} notification - 
	     * @returns {void}
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1436044-documentdidfindmatch
	     */

	  }, {
	    key: 'documentDidFindMatch',
	    value: function documentDidFindMatch(notification) {}

	    /**
	     * Called when the PDFDocumentDidUnlockNotification notification is posted.
	     * @access public
	     * @param {Notification} notification - 
	     * @returns {void}
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1436029-documentdidunlock
	     */

	  }, {
	    key: 'documentDidUnlock',
	    value: function documentDidUnlock(notification) {}

	    /**
	     * Returns a Boolean value that indicates whether the receiver contains a given object.
	     * @access public
	     * @param {Object} object - The object to search for in the receiver.
	     * @returns {boolean} - 
	     * @desc Currently, doesContain(_:) messages are never sent to any object from within Cocoa itself. The default implementation for this method provided by NSObject returns true if the receiver is actually an NSArray object and an indexOfObjectIdentical(to:) message sent to the same object would return something other than NSNotFound.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1393848-doescontain
	     */

	  }, {
	    key: 'doesContain',
	    value: function doesContain(object) {
	      return false;
	    }

	    /**
	     * 
	     * @access public
	     * @param {!QLPreviewPanel} panel - 
	     * @returns {void}
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1505044-endpreviewpanelcontrol
	     */

	  }, {
	    key: 'endPreviewPanelControl',
	    value: function endPreviewPanelControl(panel) {}

	    /**
	     * Implemented by the delegate to evaluate whether the delegating NSExceptionHandler instance should handle a given exception.
	     * @access public
	     * @param {!NSExceptionHandler} sender - The NSExceptionHandler object sending the message.
	     * @param {!NSException} exception - An NSException object describing the exception to be evaluated.
	     * @param {number} aMask - The bit mask indicating the types of exceptions handled by the NSExceptionHandler object. See Logging and Handling Constants and System Hang Constants for descriptions of the possible enum constants.
	     * @returns {boolean} - 
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1489854-exceptionhandler
	     */

	  }, {
	    key: 'exceptionHandlerShouldHandleMask',
	    value: function exceptionHandlerShouldHandleMask(sender, exception, aMask) {
	      return false;
	    }

	    /**
	     * Implemented by the delegate to evaluate whether the delegating NSExceptionHandler instance should log a given exception.
	     * @access public
	     * @param {!NSExceptionHandler} sender - The NSExceptionHandler object sending the message.
	     * @param {!NSException} exception - An NSException object describing the exception to be evaluated.
	     * @param {number} aMask - The bit mask indicating the types of exceptions logged by the NSExceptionHandler object. See Logging and Handling Constants and System Hang Constants for descriptions of the possible enum constants.
	     * @returns {boolean} - 
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1489856-exceptionhandler
	     */

	  }, {
	    key: 'exceptionHandlerShouldLogExceptionMask',
	    value: function exceptionHandlerShouldLogExceptionMask(sender, exception, aMask) {
	      return false;
	    }

	    /**
	     * 
	     * @access public
	     * @param {!OBEXFileTransferServices} inServices - 
	     * @param {OBEXError} inError - 
	     * @returns {void}
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1430046-filetransferservicesabortcomplet
	     */

	  }, {
	    key: 'fileTransferServicesAbortCompleteError',
	    value: function fileTransferServicesAbortCompleteError(inServices, inError) {}

	    /**
	     * 
	     * @access public
	     * @param {!OBEXFileTransferServices} inServices - 
	     * @param {OBEXError} inError - 
	     * @returns {void}
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1428872-filetransferservicesconnectionco
	     */

	  }, {
	    key: 'fileTransferServicesConnectionCompleteError',
	    value: function fileTransferServicesConnectionCompleteError(inServices, inError) {}

	    /**
	     * 
	     * @access public
	     * @param {!OBEXFileTransferServices} inServices - 
	     * @param {OBEXError} inError - 
	     * @returns {void}
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1432094-filetransferservicescopyremotefi
	     */

	  }, {
	    key: 'fileTransferServicesCopyRemoteFileCompleteError',
	    value: function fileTransferServicesCopyRemoteFileCompleteError(inServices, inError) {}

	    /**
	     * 
	     * @access public
	     * @param {!OBEXFileTransferServices} inServices - 
	     * @param {!Map<AnyHashable, Object>} inProgressDescription - 
	     * @returns {void}
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1431422-filetransferservicescopyremotefi
	     */

	  }, {
	    key: 'fileTransferServicesCopyRemoteFileProgressTransferProgress',
	    value: function fileTransferServicesCopyRemoteFileProgressTransferProgress(inServices, inProgressDescription) {}

	    /**
	     * 
	     * @access public
	     * @param {!OBEXFileTransferServices} inServices - 
	     * @param {OBEXError} inError - 
	     * @param {!string} inFolderName - 
	     * @returns {void}
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1430913-filetransferservicescreatefolder
	     */

	  }, {
	    key: 'fileTransferServicesCreateFolderCompleteErrorFolder',
	    value: function fileTransferServicesCreateFolderCompleteErrorFolder(inServices, inError, inFolderName) {}

	    /**
	     * 
	     * @access public
	     * @param {!OBEXFileTransferServices} inServices - 
	     * @param {OBEXError} inError - 
	     * @returns {void}
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1434806-filetransferservicesdisconnectio
	     */

	  }, {
	    key: 'fileTransferServicesDisconnectionCompleteError',
	    value: function fileTransferServicesDisconnectionCompleteError(inServices, inError) {}

	    /**
	     * 
	     * @access public
	     * @param {!OBEXFileTransferServices} inServices - 
	     * @param {OBEXError} inError - 
	     * @returns {void}
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1432086-filetransferservicesfilepreparat
	     */

	  }, {
	    key: 'fileTransferServicesFilePreparationCompleteError',
	    value: function fileTransferServicesFilePreparationCompleteError(inServices, inError) {}

	    /**
	     * 
	     * @access public
	     * @param {!OBEXFileTransferServices} inServices - 
	     * @param {OBEXError} inError - 
	     * @param {!string} inPath - 
	     * @returns {void}
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1432583-filetransferservicespathchangeco
	     */

	  }, {
	    key: 'fileTransferServicesPathChangeCompleteErrorFinalPath',
	    value: function fileTransferServicesPathChangeCompleteErrorFinalPath(inServices, inError, inPath) {}

	    /**
	     * 
	     * @access public
	     * @param {!OBEXFileTransferServices} inServices - 
	     * @param {OBEXError} inError - 
	     * @param {!string} inItemName - 
	     * @returns {void}
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1434702-filetransferservicesremoveitemco
	     */

	  }, {
	    key: 'fileTransferServicesRemoveItemCompleteErrorRemovedItem',
	    value: function fileTransferServicesRemoveItemCompleteErrorRemovedItem(inServices, inError, inItemName) {}

	    /**
	     * 
	     * @access public
	     * @param {!OBEXFileTransferServices} inServices - 
	     * @param {OBEXError} inError - 
	     * @param {!Object[]} inListing - 
	     * @returns {void}
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1434777-filetransferservicesretrievefold
	     */

	  }, {
	    key: 'fileTransferServicesRetrieveFolderListingCompleteErrorListing',
	    value: function fileTransferServicesRetrieveFolderListingCompleteErrorListing(inServices, inError, inListing) {}

	    /**
	     * 
	     * @access public
	     * @param {!OBEXFileTransferServices} inServices - 
	     * @param {OBEXError} inError - 
	     * @returns {void}
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1434240-filetransferservicessendfilecomp
	     */

	  }, {
	    key: 'fileTransferServicesSendFileCompleteError',
	    value: function fileTransferServicesSendFileCompleteError(inServices, inError) {}

	    /**
	     * 
	     * @access public
	     * @param {!OBEXFileTransferServices} inServices - 
	     * @param {!Map<AnyHashable, Object>} inProgressDescription - 
	     * @returns {void}
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1430365-filetransferservicessendfileprog
	     */

	  }, {
	    key: 'fileTransferServicesSendFileProgressTransferProgress',
	    value: function fileTransferServicesSendFileProgressTransferProgress(inServices, inProgressDescription) {}

	    /**
	     * Performs cleanup when the scripting environment is reset.
	     * @access public
	     * @returns {void}
	     * @desc This method is invoked on objects exposed to the scripting environment just before the scripting environment is reset. After invocation, the receiving object will no longer be referenced by the scripting environment. Further references to WebScriptObject instances created by the exposed object will be invalid and may produce unpredictable results.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1528546-finalizeforwebscript
	     */

	  }, {
	    key: 'finalizeForWebScript',
	    value: function finalizeForWebScript() {}

	    /**
	     * Requests permission from the Font panel delegate to display the given font name in the Font panel.
	     * @deprecated
	     * @access public
	     * @param {Object} sender - 
	     * @param {string} fontName - The full PostScript name of the font to display, such as Helvetica-BoldOblique or Helvetica-Narrow-Bold.
	     * @returns {boolean} - 
	     * @desc In macOS versions 10.2 and earlier, this method is invoked repeatedly as necessary whenever the Font panel needs updating, such as when the Font panel is first loaded, and when the user selects a family name to see which typefaces in that family are available. Your implementation should execute fairly quickly to ensure the responsiveness of the Font panel.Important
	    This delegate method is not called in macOS versions 10.3 and later.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1462359-fontmanager
	     */

	  }, {
	    key: 'fontManagerWillIncludeFont',
	    value: function fontManagerWillIncludeFont(sender, fontName) {
	      return false;
	    }

	    /**
	     * Handles key down and mouse events.
	     * @access public
	     * @param {!NSEvent} event - The event to handle.
	     * @param {!Object} sender - The client object sending the event.
	     * @returns {boolean} - 
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1385363-handle
	     */

	  }, {
	    key: 'handleClient',
	    value: function handleClient(event, sender) {
	      return false;
	    }

	    /**
	     * Performs custom tasks when the user right-clicks the image browser view background.
	     * @access public
	     * @param {!IKImageBrowserView} aBrowser - An image browser view.
	     * @param {!NSEvent} event - The event that invoked the method.
	     * @returns {void}
	     * @desc This method signals  that the user either right-clicked the background or left-clicked it with the Alt key pressed. You can implement this method if you want to perform custom tasks at that time.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1503526-imagebrowser
	     */

	  }, {
	    key: 'imageBrowserBackgroundWasRightClickedWith',
	    value: function imageBrowserBackgroundWasRightClickedWith(aBrowser, event) {}

	    /**
	     * Performs custom tasks when the user double-clicks an item in the image browser view.
	     * @access public
	     * @param {!IKImageBrowserView} aBrowser - An image browser view.
	     * @param {number} index - The index of the cell.
	     * @returns {void}
	     * @desc This method signals that the user double-clicked an item in the image browser view. You can implement this method if you want to perform custom tasks at that time.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1504701-imagebrowser
	     */

	  }, {
	    key: 'imageBrowserCellWasDoubleClickedAt',
	    value: function imageBrowserCellWasDoubleClickedAt(aBrowser, index) {}

	    /**
	     * Performs custom tasks when the user right-clicks an item in the image browser view. 
	     * @access public
	     * @param {!IKImageBrowserView} aBrowser - An image browser view.
	     * @param {number} index - The index of the cell.
	     * @param {!NSEvent} event - The event that invoked the method.
	     * @returns {void}
	     * @desc This method signals that the user either right-clicked an item in the browser or left-clicked the item with the Alt key pressed. You can implement this method if you want to perform custom tasks at that time.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1503802-imagebrowser
	     */

	  }, {
	    key: 'imageBrowserCellWasRightClickedAtWith',
	    value: function imageBrowserCellWasRightClickedAtWith(aBrowser, index, event) {}

	    /**
	     * Returns the group at the specified index.
	     * @access public
	     * @param {!IKImageBrowserView} aBrowser - An image browser view.
	     * @param {number} index - The index of the group you want to retrieve.
	     * @returns {!Map<AnyHashable, Object>} - 
	     * @desc This method is optional.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1503488-imagebrowser
	     */

	  }, {
	    key: 'imageBrowserGroupAt',
	    value: function imageBrowserGroupAt(aBrowser, index) {
	      return null;
	    }

	    /**
	     * Returns an object for the item in an image browser view that corresponds to the specified index.
	     * @access public
	     * @param {!IKImageBrowserView} aBrowser - An image browser view.
	     * @param {number} index - The index of the item you want to retrieve.
	     * @returns {!Object} - 
	     * @desc Your data source must implement this method. The returned object must implement the required methods of the IKImageBrowserItem protocol. 
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1504064-imagebrowser
	     */

	  }, {
	    key: 'imageBrowserItemAt',
	    value: function imageBrowserItemAt(aBrowser, index) {
	      return null;
	    }

	    /**
	     * Signals that the specified items should be moved to the specified destination. 
	     * @access public
	     * @param {!IKImageBrowserView} aBrowser - An image browser view.
	     * @param {!Set} indexes - The indexes of the items that should be reordered.
	     * @param {number} destinationIndex - The starting index of the destination the items should be moved to.
	     * @returns {boolean} - 
	     * @desc This method is optional. It is invoked by the image browser view after  Image Kit determines  that a reordering operation should be applied. The data source should update itself by reordering its elements. 
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1503616-imagebrowser
	     */

	  }, {
	    key: 'imageBrowserMoveItemsAtTo',
	    value: function imageBrowserMoveItemsAtTo(aBrowser, indexes, destinationIndex) {
	      return false;
	    }

	    /**
	     * Signals that a remove operation should be applied to the specified items.
	     * @access public
	     * @param {!IKImageBrowserView} aBrowser - An image browser view.
	     * @param {!Set} indexes - The indexes of the items that should be removed.
	     * @returns {void}
	     * @desc This method is optional. It is invoked by the image browser after  Image Kit determines  that a remove operation should be applied. In response, the data source should update itself by removing the specified items.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1503834-imagebrowser
	     */

	  }, {
	    key: 'imageBrowserRemoveItemsAt',
	    value: function imageBrowserRemoveItemsAt(aBrowser, indexes) {}

	    /**
	     * Signals that a drag should begin.
	     * @access public
	     * @param {!IKImageBrowserView} aBrowser - An image browser view.
	     * @param {!Set} itemIndexes - The indexes of the items that should be dragged.
	     * @param {!NSPasteboard} pasteboard - The pasteboard to copy the items to.
	     * @returns {number} - 
	     * @desc This method is optional. It is invoked after Image Kit determines that a drag should begin, but before the drag has been started. 
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1504208-imagebrowser
	     */

	  }, {
	    key: 'imageBrowserWriteItemsAtTo',
	    value: function imageBrowserWriteItemsAtTo(aBrowser, itemIndexes, pasteboard) {
	      return 0;
	    }

	    /**
	     * Performs custom tasks when the selection changes.
	     * @access public
	     * @param {!IKImageBrowserView} aBrowser - An image browser view.
	     * @returns {void}
	     * @desc This method signals that the user changes the selection in the image browser view. You can implement this method if you want to perform custom tasks at that time.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1503765-imagebrowserselectiondidchange
	     */

	  }, {
	    key: 'imageBrowserSelectionDidChange',
	    value: function imageBrowserSelectionDidChange(aBrowser) {}

	    /**
	     * Returns the image to display.
	     * @access public
	     * @returns {!Object} - 
	     * @desc Your data source must implement this method. This method  is called frequently, so the receiver should cache the returned instance.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1504801-imagerepresentation
	     */

	  }, {
	    key: 'imageRepresentation',
	    value: function imageRepresentation() {
	      return null;
	    }

	    /**
	     * Returns the representation type of the image to display.
	     * @access public
	     * @returns {!string} - 
	     * @desc Your data source must implement this method.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1503547-imagerepresentationtype
	     */

	  }, {
	    key: 'imageRepresentationType',
	    value: function imageRepresentationType() {
	      return null;
	    }

	    /**
	     *  Returns the display subtitle of the image.
	     * @access public
	     * @returns {!string} - 
	     * @desc This method is optional.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1503725-imagesubtitle
	     */

	  }, {
	    key: 'imageSubtitle',
	    value: function imageSubtitle() {
	      return null;
	    }

	    /**
	     * Returns the display title of the image. 
	     * @access public
	     * @returns {!string} - 
	     * @desc This method is optional.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1504080-imagetitle
	     */

	  }, {
	    key: 'imageTitle',
	    value: function imageTitle() {
	      return null;
	    }

	    /**
	     * Returns a unique string that identifies the data source item.
	     * @access public
	     * @returns {!string} - 
	     * @desc Your data source must implement this method. The image browser view uses this identifier to associate the data source item and  its cache.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1503516-imageuid
	     */

	  }, {
	    key: 'imageUID',
	    value: function imageUID() {
	      return null;
	    }

	    /**
	     * Returns the version of the item. 
	     * @access public
	     * @returns {number} - 
	     * @desc This method is optional. The receiver can return a new version to let the image browser know that it should not use its cache for the item.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1504444-imageversion
	     */

	  }, {
	    key: 'imageVersion',
	    value: function imageVersion() {
	      return 0;
	    }

	    /**
	     * Returns the indices of the specified container objects.
	     * @access public
	     * @param {NSScriptObjectSpecifier} specifier - An object specifier for the container objects for which to obtain the indices.
	     * @returns {?number[]} - 
	     * @desc  Containers that want to evaluate some specifiers on their own should implement this method. If this method returns nil, the object specifier will go on to do its own evaluation, so you should only return nil if that's the behavior you want, or if an error occurs. If this method returns an array, the object specifier will use the NSNumber objects in it as the indices. So, if you evaluate the specifier and there are no objects that match, you should return an empty array, not nil. If you find only one object, you should still return its index in an array. Returning an array with a single index where the index is  is interpreted to mean all the objects.For an example implementation, see "Implementing Object Specifiers" in Object Specifiers in Cocoa Scripting Guide
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1417806-indicesofobjects
	     */

	  }, {
	    key: 'indicesOfObjectsByEvaluatingObjectSpecifier',
	    value: function indicesOfObjectsByEvaluatingObjectSpecifier(specifier) {
	      return null;
	    }

	    /**
	     * Returns a dictionary describing the receivers binding.
	     * @access public
	     * @param {string} binding - The name of a binding.
	     * @returns {?Map<string, Object>} - 
	     * @desc This method is mostly for use by subclasses which want to analyze the existing bindings of an object.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1458122-infoforbinding
	     */

	  }, {
	    key: 'infoForBinding',
	    value: function infoForBinding(binding) {
	      return null;
	    }

	    /**
	     * Handles key down events that do not map to an action method.
	     * @access public
	     * @param {!string} string - The key down event, which is the text input by the client.
	     * @param {!Object} sender - The client object sending the key down events.
	     * @returns {boolean} - 
	     * @desc An input method should implement this method when using key binding (that is, it implements didCommand(by:client:)).
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1385446-inputtext
	     */

	  }, {
	    key: 'inputTextClient',
	    value: function inputTextClient(string, sender) {
	      return false;
	    }

	    /**
	     * Receives Unicode, the key code that generated it, and any modifier flags.
	     * @access public
	     * @param {!string} string - The text input by the client.
	     * @param {number} keyCode - The key code for the associated Unicode.
	     * @param {number} flags - The modifier flags.
	     * @param {!Object} sender - The client object.
	     * @returns {boolean} - 
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1385436-inputtext
	     */

	  }, {
	    key: 'inputTextKeyModifiersClient',
	    value: function inputTextKeyModifiersClient(string, keyCode, flags, sender) {
	      return false;
	    }

	    /**
	     * Inserts an object at the specified index in the collection specified by the passed key.
	     * @access public
	     * @param {Object} value - 
	     * @param {number} index - 
	     * @param {string} key - 
	     * @returns {void}
	     * @desc  The method insertIn<Key>:atIndex: is invoked if it exists. If no corresponding scripting-KVC-compliant method (insertIn<Key>:atIndex: ) is found, this method invokes mutableArrayValueForKey: and mutates the result.Note Prior to OS X version 10.4, this method did not invoke -mutableArrayValueForKey:.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1417619-insertvalue
	     */

	  }, {
	    key: 'insertValueAtInPropertyWithKey',
	    value: function insertValueAtInPropertyWithKey(value, index, key) {}

	    /**
	     * Inserts an object in the collection specified by the passed key.
	     * @access public
	     * @param {Object} value - 
	     * @param {string} key - 
	     * @returns {void}
	     * @desc  The method insertIn<Key>: is used if it exists. Otherwise, raises an NSUndefinedKeyException. This is part of Cocoas scripting support for inserting newly-created objects into containers without explicitly specifying a location.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1416203-insertvalue
	     */

	  }, {
	    key: 'insertValueInPropertyWithKey',
	    value: function insertValueInPropertyWithKey(value, key) {}

	    /**
	     * Executes when a script attempts to invoke a method on an exposed object directly.
	     * @access public
	     * @param {!Object[]} _arguments - 
	     * @returns {!Object} - 
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1528543-invokedefaultmethod
	     */

	  }, {
	    key: 'invokeDefaultMethodWithArguments',
	    value: function invokeDefaultMethodWithArguments(_arguments) {
	      return null;
	    }

	    /**
	     * Handles undefined method invocation from the scripting environment.
	     * @access public
	     * @param {!string} name - The name of the undefined method.
	     * @param {!Object[]} _arguments - 
	     * @returns {!Object} - 
	     * @desc This method is invoked when a script attempts to invoke a method not directly exported to the scripting environment. You should return the result of the invocation, converted appropriately for the scripting environment.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1528562-invokeundefinedmethod
	     */

	  }, {
	    key: 'invokeUndefinedMethodFromWebScriptWithArguments',
	    value: function invokeUndefinedMethodFromWebScriptWithArguments(name, _arguments) {
	      return null;
	    }

	    /**
	     * Returns a Boolean value that indicates whether receiver is considered to be like a given string when the case of characters in the receiver is ignored.
	     * @access public
	     * @param {string} object - 
	     * @returns {boolean} - 
	     * @desc Currently, isCaseInsensitiveLike(_:) messages are never sent to any object from within Cocoa itself.The default implementation for this method provided by NSObject returns false. NSString also provides an implementation of this method, which returns true if the receiver matches a pattern described by aString, ignoring the case of the characters in the receiver.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1393837-iscaseinsensitivelike
	     */

	  }, {
	    key: 'isCaseInsensitiveLike',
	    value: function isCaseInsensitiveLike(object) {
	      return false;
	    }

	    /**
	     * Returns a Boolean value that indicates whether the receiver is equal to another given object.
	     * @access public
	     * @param {?Object} object - The object with which to compare the receiver.
	     * @returns {boolean} - 
	     * @desc During the evaluation of an NSWhoseSpecifier object that contains a test whose operator is NSEqualToComparison, an isEqual(to:) message may be sent to each potentially specified object, if neither the potentially specified object nor the object being tested against implements a scriptingIsEqual(to:) method.The default implementation for this method provided by NSObject returns true if an isEqualTo: message sent to the same object would return true.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1393823-isequal
	     */

	  }, {
	    key: 'isEqualTo',
	    value: function isEqualTo(object) {
	      return false;
	    }

	    /**
	     * Returns a Boolean value that indicates whether the receiver is greater than another given object.
	     * @access public
	     * @param {?Object} object - The object with which to compare the receiver.
	     * @returns {boolean} - 
	     * @desc During the evaluation of an NSWhoseSpecifier object that contains a test whose operator is NSGreaterThanComparison, an isGreaterThan(_:) message may be sent to each potentially specified object, if the potentially specified object does not implement a scriptingIsGreaterThan(_:) method and the object being tested against does not implement a scriptingIsLessThanOrEqual(to:) method.The default implementation for this method provided by NSObject returns true if a compare: message sent to the same object would return NSOrderedDescending.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1393885-isgreaterthan
	     */

	  }, {
	    key: 'isGreaterThan',
	    value: function isGreaterThan(object) {
	      return false;
	    }

	    /**
	     * Returns a Boolean value that indicates whether the receiver is greater than or equal to another given object.
	     * @access public
	     * @param {?Object} object - The object with which to compare the receiver.
	     * @returns {boolean} - 
	     * @desc During the evaluation of an NSWhoseSpecifier object that contains a test whose operator is NSGreaterThanOrEqualToComparison, anisGreaterThanOrEqual(to:) message may be sent to each potentially specified object, if the potentially specified object does not implement a scriptingIsGreaterThanOrEqual(to:) method and the object being tested against does not implement a scriptingIsLessThan(_:) method.The default implementation for this method provided by NSObject returns true if a compare: message sent to the same object would return NSOrderedSame or NSOrderedDescending.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1393862-isgreaterthanorequal
	     */

	  }, {
	    key: 'isGreaterThanOrEqualTo',
	    value: function isGreaterThanOrEqualTo(object) {
	      return false;
	    }

	    /**
	     * Returns a Boolean value that indicates whether the receiver is less than another given object.
	     * @access public
	     * @param {?Object} object - The object with which to compare the receiver.
	     * @returns {boolean} - 
	     * @desc During the evaluation of an NSWhoseSpecifier object that contains a test whose operator is NSLessThanComparison, an isLessThan(_:) message may be sent to each potentially specified object, if the potentially specified object does not implement a scriptingIsLessThan(_:) method and the object being tested against does not implement a scriptingIsGreaterThanOrEqual(to:) method.The default implementation for this method provided by NSObject method returns true if a compare: message sent to the same object would return NSOrderedAscending.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1393841-islessthan
	     */

	  }, {
	    key: 'isLessThan',
	    value: function isLessThan(object) {
	      return false;
	    }

	    /**
	     * Returns a Boolean value that indicates whether the receiver is less than or equal to another given object. 
	     * @access public
	     * @param {?Object} object - The object with which to compare the receiver.
	     * @returns {boolean} - 
	     * @desc During the evaluation of an NSWhoseSpecifier object that contains a test whose operator is NSLessThanOrEqualToComparison, an isLessThanOrEqual(to:) message may be sent to each potentially specified object, if the potentially specified object does not implement a scriptingIsLessThanOrEqual(to:) method and the object being tested against does not implement a scriptingIsGreaterThan(_:) method.The default implementation for this method provided by NSObject method returns true if a compare: message sent to the same object would return NSOrderedAscending or NSOrderedSame.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1393827-islessthanorequal
	     */

	  }, {
	    key: 'isLessThanOrEqualTo',
	    value: function isLessThanOrEqualTo(object) {
	      return false;
	    }

	    /**
	     * Returns a Boolean value that indicates whether the receiver is "like" another given object.
	     * @access public
	     * @param {string} object - The object with which to compare the receiver.
	     * @returns {boolean} - 
	     * @desc Currently, isLike(_:) messages are never sent to any object from within Cocoa itself.The default implementation for this method provided by NSObject method returns false. NSString also provides an implementation of this method, which returns true if the receiver matches a pattern described by object.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1393866-islike
	     */

	  }, {
	    key: 'isLike',
	    value: function isLike(object) {
	      return false;
	    }

	    /**
	     * Returns a Boolean value that indicates whether the receiver is not equal to another given object.
	     * @access public
	     * @param {?Object} object - The object with which to compare the receiver.
	     * @returns {boolean} - 
	     * @desc Currently, isNotEqual(to:) messages are never sent to any object from within Cocoa itself.The default implementation for this method provided by NSObject method returns true if an isEqual: message sent to the same object would return false.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1393843-isnotequal
	     */

	  }, {
	    key: 'isNotEqualTo',
	    value: function isNotEqualTo(object) {
	      return false;
	    }

	    /**
	     * Invoked when a resolution changes occurs for the window that hosts the layer.
	     * @access public
	     * @param {CALayer} layer - The layer whose scale and content might need updating.
	     * @param {number} newScale - The new scale of the window. 
	     * @param {NSWindow} window - The window that hosts the layer.
	     * @returns {boolean} - 
	     * @desc When a resolution change occurs for a given window, the system traverses the layer trees in that window to decide what action, if any, to take for each layer. The system queries the layers delegate to determine whether to change the layers contentsScale property to the new scale (either 2.0 or 1.0). Note that you dont need to manage NSImage contents and that this method is not called on the delegate of a layer whose content is an NSImage object.If the delegate returns true, it should make any corresponding changes to the layers properties, as required by the resolution change. For example, a layer whose contents contain a CGImage object needs to determine whether an alternate CGImage object is available for the new scale factor. If the delegate finds a suitable CGImage object, then in addition to returning true, it should set the appropriate CGImage object as the layers new contents.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1483574-layer
	     */

	  }, {
	    key: 'layerShouldInheritContentsScaleFrom',
	    value: function layerShouldInheritContentsScaleFrom(layer, newScale, window) {
	      return false;
	    }

	    /**
	     * Returns the names of the files that the receiver promises to create at a specified location.
	     * @deprecated
	     * @access public
	     * @param {string} dropDestination - A URL object that identifies the location at which the promised files will be created.
	     * @returns {?string[]} - 
	     * @desc This method is invoked when the drop has been accepted by the destination and the destination, in the case of another Cocoa application, invokes the NSDraggingInfo method namesOfPromisedFilesDropped(atDestination:). For long operations, you can cache dropDestination and defer the creation of the files until the draggedImage:endedAt:operation: method to avoid blocking the destination application.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1416082-namesofpromisedfilesdropped
	     */

	  }, {
	    key: 'namesOfPromisedFilesDroppedAtDestination',
	    value: function namesOfPromisedFilesDroppedAtDestination(dropDestination) {
	      return null;
	    }

	    /**
	     * Returns the number of groups in an image browser view.
	     * @access public
	     * @param {!IKImageBrowserView} aBrowser - An image browser view.
	     * @returns {number} - 
	     * @desc This method is optional.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1503514-numberofgroups
	     */

	  }, {
	    key: 'numberOfGroupsInImageBrowser',
	    value: function numberOfGroupsInImageBrowser(aBrowser) {
	      return 0;
	    }

	    /**
	     * Returns the number of records managed by the data source object.
	     * @access public
	     * @param {!IKImageBrowserView} aBrowser - An image browser view.
	     * @returns {number} - 
	     * @desc Your data source must implement this method. An  IKImageView object uses this method to determine how many cells it should create and display.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1503497-numberofitems
	     */

	  }, {
	    key: 'numberOfItemsInImageBrowser',
	    value: function numberOfItemsInImageBrowser(aBrowser) {
	      return 0;
	    }

	    /**
	     * This message should be sent to the receiver when editor has uncommitted changes that can affect the receiver.
	     * @access public
	     * @param {Object} editor - 
	     * @returns {void}
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1458092-objectdidbeginediting
	     */

	  }, {
	    key: 'objectDidBeginEditing',
	    value: function objectDidBeginEditing(editor) {}

	    /**
	     * This message should be sent to the receiver when editor has finished editing a property belonging to the receiver.
	     * @access public
	     * @param {Object} editor - 
	     * @returns {void}
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1458187-objectdidendediting
	     */

	  }, {
	    key: 'objectDidEndEditing',
	    value: function objectDidEndEditing(editor) {}

	    /**
	     * Returns an array describing the options for the specified binding.
	     * @access public
	     * @param {string} binding - The name of a binding
	     * @returns {NSAttributeDescription[]} - 
	     * @desc The NSAttributeDescription instances in the array are used by Interface Builder to build the options editor user interface of the bindings inspector.The option name displayed for the option in the bindings inspector is based on the value of the NSAttributeDescription method name. The type of editor displayed for the option in the bindings inspector is based on the value of the  NSAttributeDescription method attributeType.The default value displayed in the bindings inspector for the option is based on the value of the NSAttributeDescription method defaultValue.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1458174-optiondescriptionsforbinding
	     */

	  }, {
	    key: 'optionDescriptionsForBinding',
	    value: function optionDescriptionsForBinding(binding) {
	      return null;
	    }

	    /**
	     * Return the a string that consists of the precomposed unicode characters.
	     * @access public
	     * @param {!Object} sender - The client object requesting the original string.
	     * @returns {!string} - 
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1385400-originalstring
	     */

	  }, {
	    key: 'originalString',
	    value: function originalString(sender) {
	      return null;
	    }

	    /**
	     * Implemented by an owner object to provide promised data.
	     * @access public
	     * @param {NSPasteboard} sender - The pasteboard that requires the specified data for a paste operation.
	     * @param {string} type - The type of data the owner object must provide.
	     * @returns {void}
	     * @desc The receiver should have been previously declared in a declareTypes(_:owner:) message.The requested data should be written to sender using the setData(_:forType:), setPropertyList(_:forType:), or setString(_:forType:) method. The pasteboard(_:provideDataForType:) messages may also be sent to the owner when the application is shut down through an applications terminate(_:) method. This is the method that is invoked in response to a Quit command. Thus the user can copy something to the pasteboard, quit the application, and still paste the data that was copied. A pasteboard(_:provideDataForType:) message is sent only if the specified type of data has not already been supplied to the pasteboard. Instead of writing all data types when the cut or copy operation is done, an application can choose to implement this method to provide the data for certain types only when they are requested.If an application writes data to the pasteboard in the richest, and therefore most preferred, type at the time of a cut or copy operation, its pasteboard(_:provideDataForType:) method can simply read that data from the pasteboard, convert it to the requested type, and write it back to the pasteboard as the new type.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1525907-pasteboard
	     */

	  }, {
	    key: 'pasteboardProvideDataForType',
	    value: function pasteboardProvideDataForType(sender, type) {}

	    /**
	     * Notifies a prior owner of the specified pasteboard (and owners of representations on the pasteboard) that the pasteboard has changed owners.
	     * @access public
	     * @param {NSPasteboard} sender - The pasteboard object whose owner changed.
	     * @returns {void}
	     * @desc Pasteboard owners only need to implement this method if they need to know when they have lost ownership.The owner is not able to read the contents of the pasteboard when responding to this method. The owner should be prepared to receive this method at any time, even from within the declareTypes(_:owner:) method used to declare ownership.Once an owner has provided all of its data for declared types, it will not receive a pasteboardChangedOwner: message. If, therefore, you are maintaining an object just for the purpose of providing data lazily, rather than relying solely on receipt of a pasteboardChangedOwner: message you need to keep track of what types were promised and what types have been provided. When all the types have been provided, you may release the owner.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1532824-pasteboardchangedowner
	     */

	  }, {
	    key: 'pasteboardChangedOwner',
	    value: function pasteboardChangedOwner(sender) {}

	    /**
	     * Sent to the delegate to perform the action.
	     * @access public
	     * @param {!ABPerson} person - The person on which the action will be taken.
	     * @param {!string} identifier - The unique identifier of the selected value.
	     * @returns {void}
	     * @desc If the property returned by actionProperty() is a multivalue property, identifier contains the unique identifier of the value selected. The person being displayed in the Address Book applications card view when the rollover menu is accesses is passed as person.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1411298-performaction
	     */

	  }, {
	    key: 'performActionFor',
	    value: function performActionFor(person, identifier) {}

	    /**
	     * Called when a designable object is created in Interface Builder.
	     * @access public
	     * @returns {void}
	     * @desc When Interface Builder instantiates a class with the IB_DESIGNABLE attribute, it calls this method to let the resulting object know that it was created at design time. You can implement this method in your designable classes and use it to configure their design-time appearance. For example, you might use the method to configure a custom text control with a default string. The system does not call this method; only Interface Builder calls it.Interface Builder waits until all objects in a graph have been created and initialized before calling this method. So if your objects runtime configuration relies on subviews or parent views, those objects should exist by the time this method is called.Your implementation of this method must call super at some point so that parent classes can perform their own custom setup.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1402908-prepareforinterfacebuilder
	     */

	  }, {
	    key: 'prepareForInterfaceBuilder',
	    value: function prepareForInterfaceBuilder() {}

	    /**
	     * Supplies data to a CIImage object.
	     * @access public
	     * @param {Object} data - A pointer to image data. Note that data[0] refers to the first byte of the requested subimage, not the larger image buffer.
	     * @param {number} rowbytes - The number of bytes per row.
	     * @param {number} x - The x origin of the image data.
	     * @param {number} y - The y origin of the image data.
	     * @param {number} width - The width of the image data.
	     * @param {number} height - The height of the image data.
	     * @param {?Object} info - User supplied data, which is optional.
	     * @returns {void}
	     * @desc  You can supply the image provider to these methods of the CIImage class: imageWithImageProvider:size::format:colorSpace:options: to create a CIImage object from image datainit(imageProvider:size:_:format:colorSpace:options:) to initialize an existing CIImage with dataYou initialize the given bitmap with the subregion specified by the arguments x, y, width, and height. The subregion uses the local coordinate space of the image, with the origin at the upper-left corner of the image. If you change the virtual memory mapping of the buffer specified by the data argument (such as by using vm_copy to modify it), the behavior is undefined.That this callback always requests the full image data regardless of what is actually visible. All of the image is loaded or none of it is. The exception is when you create a tiled image by specifying the kCIImageProviderTileSize option. In this case, only the needed tiles are requested.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1438175-provideimagedata
	     */

	  }, {
	    key: 'provideImageDataBytesPerRowOriginSizeUserInfo',
	    value: function provideImageDataBytesPerRowOriginSizeUserInfo(data, rowbytes, x, y, width, height, info) {}

	    /**
	     * 
	     * @access public
	     * @param {!QuartzFilterManager} sender - 
	     * @param {!QuartzFilter} filter - 
	     * @returns {void}
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1504951-quartzfiltermanager
	     */

	  }, {
	    key: 'quartzFilterManagerDidAdd',
	    value: function quartzFilterManagerDidAdd(sender, filter) {}

	    /**
	     * 
	     * @access public
	     * @param {!QuartzFilterManager} sender - 
	     * @param {!QuartzFilter} filter - 
	     * @returns {void}
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1503494-quartzfiltermanager
	     */

	  }, {
	    key: 'quartzFilterManagerDidModifyFilter',
	    value: function quartzFilterManagerDidModifyFilter(sender, filter) {}

	    /**
	     * 
	     * @access public
	     * @param {!QuartzFilterManager} sender - 
	     * @param {!QuartzFilter} filter - 
	     * @returns {void}
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1503483-quartzfiltermanager
	     */

	  }, {
	    key: 'quartzFilterManagerDidRemove',
	    value: function quartzFilterManagerDidRemove(sender, filter) {}

	    /**
	     * 
	     * @access public
	     * @param {!QuartzFilterManager} sender - 
	     * @param {!QuartzFilter} filter - 
	     * @returns {void}
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1503484-quartzfiltermanager
	     */

	  }, {
	    key: 'quartzFilterManagerDidSelect',
	    value: function quartzFilterManagerDidSelect(sender, filter) {}

	    /**
	     * 
	     * @access public
	     * @param {!Object} controller - 
	     * @param {!IOBluetoothDevice} device - 
	     * @param {!UnsafeMutablePointer<BluetoothHCILinkQualityInfo>} info - 
	     * @param {IOReturn} error - 
	     * @returns {void}
	     * @desc This delegate gets invoked when an read link quality command complete event occurs. This could occur because you invoked it by issuing an -readLinkQualityForDevice: command, or someone else did from another app on the same controller.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1430075-readlinkquality
	     */

	  }, {
	    key: 'readLinkQualityForDeviceComplete',
	    value: function readLinkQualityForDeviceComplete(controller, device, info, error) {}

	    /**
	     * 
	     * @access public
	     * @param {!Object} controller - 
	     * @param {!IOBluetoothDevice} device - 
	     * @param {!UnsafeMutablePointer<BluetoothHCIRSSIInfo>} info - 
	     * @param {IOReturn} error - 
	     * @returns {void}
	     * @desc This delegate gets invoked when an RSSI command complete event occurs. This could occur because you invoked it by issuing an -readRSSIForDevice: command, or someone else did from another app on the same controller.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1428399-readrssi
	     */

	  }, {
	    key: 'readRSSIForDeviceComplete',
	    value: function readRSSIForDeviceComplete(controller, device, info, error) {}

	    /**
	     * Removes the object at the specified index from the collection specified by the passed key.
	     * @access public
	     * @param {number} index - 
	     * @param {string} key - 
	     * @returns {void}
	     * @desc  The method removeFrom<Key>AtIndex: is invoked if it exists. If no corresponding scripting-KVC-compliant method (-removeFrom<Key>AtIndex:) is found, this method invokes -mutableArrayValueForKey: and mutates the result.Note Prior to OS X version 10.4, this method did not invoke -mutableArrayValueForKey:.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1408773-removevalue
	     */

	  }, {
	    key: 'removeValueAtFromPropertyWithKey',
	    value: function removeValueAtFromPropertyWithKey(index, key) {}

	    /**
	     * Replaces the object at the specified index in the collection specified by the passed key.
	     * @access public
	     * @param {number} index - 
	     * @param {string} key - 
	     * @param {Object} value - 
	     * @returns {void}
	     * @desc  The method replaceIn<Key>:atIndex: is invoked if it exists. If no corresponding scripting-KVC-compliant method (-replaceIn<Key>atIndex:) is found, this method invokes -mutableArrayValueForKey: and mutates the result.Note Prior to OS X version 10.4, this method did not invoke -mutableArrayValueForKey:.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1411225-replacevalue
	     */

	  }, {
	    key: 'replaceValueAtInPropertyWithKeyWithValue',
	    value: function replaceValueAtInPropertyWithKeyWithValue(index, key, value) {}

	    /**
	     * Called to determine if the specified uniform type identifier should be shown in the save panel.
	     * @access public
	     * @param {!IKSaveOptions} saveOptions - The IKSaveOptions instance that called the delegate.
	     * @param {!string} utType - The uniform type identifier to test.
	     * @returns {boolean} - 
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1503501-saveoptions
	     */

	  }, {
	    key: 'saveOptionsShouldShowUTType',
	    value: function saveOptionsShouldShowUTType(saveOptions, utType) {
	      return false;
	    }

	    /**
	     * Returns true if, in a scripting comparison, the compared object matches the beginning of object. A default implementation is provided for NSString and NSAttributedString.
	     * @access public
	     * @param {Object} object - 
	     * @returns {boolean} - 
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1393858-scriptingbegins
	     */

	  }, {
	    key: 'scriptingBeginsWith',
	    value: function scriptingBeginsWith(object) {
	      return false;
	    }

	    /**
	     * Returns true if, in a scripting comparison, the compared object contains object. A default implementation is provided for NSString and NSAttributedString.
	     * @access public
	     * @param {Object} object - 
	     * @returns {boolean} - 
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1393821-scriptingcontains
	     */

	  }, {
	    key: 'scriptingContains',
	    value: function scriptingContains(object) {
	      return false;
	    }

	    /**
	     * Returns true if, in a scripting comparison, the compared object matches the end of object. A default implementation is provided for NSString and NSAttributedString.
	     * @access public
	     * @param {Object} object - 
	     * @returns {boolean} - 
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1393819-scriptingends
	     */

	  }, {
	    key: 'scriptingEndsWith',
	    value: function scriptingEndsWith(object) {
	      return false;
	    }

	    /**
	     * Returns true if, in a scripting comparison, the compared object is equal to object. A default implementation is provided for NSString and NSAttributedString.
	     * @access public
	     * @param {Object} object - 
	     * @returns {boolean} - 
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1393835-scriptingisequal
	     */

	  }, {
	    key: 'scriptingIsEqualTo',
	    value: function scriptingIsEqualTo(object) {
	      return false;
	    }

	    /**
	     * Returns true if, in a scripting comparison, the compared object is greater than object. A default implementation is provided for NSString and NSAttributedString.
	     * @access public
	     * @param {Object} object - 
	     * @returns {boolean} - 
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1393831-scriptingisgreaterthan
	     */

	  }, {
	    key: 'scriptingIsGreaterThan',
	    value: function scriptingIsGreaterThan(object) {
	      return false;
	    }

	    /**
	     * Returns true if, in a scripting comparison, the compared object is greater than or equal to object. A default implementation is provided for NSString and NSAttributedString.
	     * @access public
	     * @param {Object} object - 
	     * @returns {boolean} - 
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1393829-scriptingisgreaterthanorequal
	     */

	  }, {
	    key: 'scriptingIsGreaterThanOrEqualTo',
	    value: function scriptingIsGreaterThanOrEqualTo(object) {
	      return false;
	    }

	    /**
	     * Returns true if, in a scripting comparison, the compared object is less than object. A default implementation is provided for NSString and NSAttributedString.
	     * @access public
	     * @param {Object} object - 
	     * @returns {boolean} - 
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1393887-scriptingislessthan
	     */

	  }, {
	    key: 'scriptingIsLessThan',
	    value: function scriptingIsLessThan(object) {
	      return false;
	    }

	    /**
	     * Returns true if, in a scripting comparison, the compared object is less than or equal to object. A default implementation is provided for NSString and NSAttributedString.
	     * @access public
	     * @param {Object} object - 
	     * @returns {boolean} - 
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1393825-scriptingislessthanorequal
	     */

	  }, {
	    key: 'scriptingIsLessThanOrEqualTo',
	    value: function scriptingIsLessThanOrEqualTo(object) {
	      return false;
	    }

	    /**
	     * Sent to the delegate to determine whether the action should be enabled.
	     * @access public
	     * @param {!ABPerson} person - The person on which the action will be taken.
	     * @param {!string} identifier - The unique identifier of the selected value.
	     * @returns {boolean} - 
	     * @desc If the property returned by actionProperty() is a multivalue property, identifier contains the unique identifier of the value selected.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1411300-shouldenableaction
	     */

	  }, {
	    key: 'shouldEnableActionFor',
	    value: function shouldEnableActionFor(person, identifier) {
	      return false;
	    }

	    /**
	     * 
	     * @deprecated
	     * @access public
	     * @param {Notification} notification - 
	     * @returns {void}
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1532645-textstoragedidprocessediting
	     */

	  }, {
	    key: 'textStorageDidProcessEditing',
	    value: function textStorageDidProcessEditing(notification) {}

	    /**
	     * 
	     * @deprecated
	     * @access public
	     * @param {Notification} notification - 
	     * @returns {void}
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1533957-textstoragewillprocessediting
	     */

	  }, {
	    key: 'textStorageWillProcessEditing',
	    value: function textStorageWillProcessEditing(notification) {}

	    /**
	     * Sent to the delegate to request the title of the menu item for the action.
	     * @access public
	     * @param {!ABPerson} person - The person on which the action will be taken.
	     * @param {!string} identifier - The unique identifier of the value for which the menu item will be displayed.
	     * @returns {!string} - 
	     * @desc If the property returned by actionProperty() is a multivalue property, identifier contains the unique identifier of the value selected.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1411304-title
	     */

	  }, {
	    key: 'titleFor',
	    value: function titleFor(person, identifier) {
	      return null;
	    }

	    /**
	     * Removes a given binding between the receiver and a controller.
	     * @access public
	     * @param {string} binding - The name of a binding.
	     * @returns {void}
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1458088-unbind
	     */

	  }, {
	    key: 'unbind',
	    value: function unbind(binding) {}

	    /**
	     * Returns the mode mask corresponding to the expected font panel mode.
	     * @access public
	     * @param {NSFontPanel} fontPanel - 
	     * @returns {number} - 
	     * @desc The mode masks are defined in Mode Masks. The Font Panel has the ability to hide elements that are not applicable for a given context by having the target respond to validModesForFontPanel(_:). If the target desires a font panel mode other than the standard mode mask, it must respond to this method.This message is sent up the responder chain to the first responder implementing the method. Ideally that object should be the first responder found that also implements changeFont(_:).
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1534415-validmodesforfontpanel
	     */

	  }, {
	    key: 'validModesForFontPanel',
	    value: function validModesForFontPanel(fontPanel) {
	      return 0;
	    }

	    /**
	     * Implemented to override the default action of enabling or disabling a specific menu item.
	     * @access public
	     * @param {NSMenuItem} menuItem - An NSMenuItem object that represents the menu item.
	     * @returns {boolean} - 
	     * @desc The object implementing this method must be the target of menuItem. You can determine which menu item menuItem is by querying it for its tag or action. The following example disables the menu item associated with the nextRecord action method when the selected line in a table view is the last one; conversely, it disables the menu item with priorRecord as its action method when the selected row is the first one in the table view. (The countryKeys array contains names that appear in the table view.)- (BOOL)validateMenuItem:(NSMenuItem *)item {
	      int row = [tableView selectedRow];
	      if ([item action] == @selector(nextRecord) &&
	          (row == [countryKeys indexOfObject:[countryKeys lastObject]])) {
	          return NO;
	      }
	      if ([item action] == @selector(priorRecord) && row == 0) {
	          return NO;
	      }
	      return YES;
	    }
	    - (BOOL)validateMenuItem:(NSMenuItem *)item {
	      int row = [tableView selectedRow];
	      if ([item action] == @selector(nextRecord) &&
	          (row == [countryKeys indexOfObject:[countryKeys lastObject]])) {
	          return NO;
	      }
	      if ([item action] == @selector(priorRecord) && row == 0) {
	          return NO;
	      }
	      return YES;
	    }
	      * @see https://developer.apple.com/reference/objectivec/nsobject/1518160-validatemenuitem
	     */

	  }, {
	    key: 'validateMenuItem',
	    value: function validateMenuItem(menuItem) {
	      return false;
	    }

	    /**
	     * If this method is implemented and returns false, NSToolbar will disable theItem; returning true causes theItem to be enabled.
	     * @access public
	     * @param {NSToolbarItem} item - 
	     * @returns {boolean} - 
	     * @desc NSToolbar only calls this method for image items.Note
	    validateToolbarItem(_:) is called very frequently, so it must be efficient.If the receiver is the target for the actions of multiple toolbar items, its necessary to determine which toolbar item theItem refers to by testing the itemIdentifier.-(BOOL)validateToolbarItem:(NSToolbarItem *)toolbarItem
	    {
	      BOOL enable = NO;
	      if ([[toolbarItem itemIdentifier] isEqual:SaveDocToolbarItemIdentifier]) {
	          // We will return YES (enable the save item)
	          // only when the document is dirty and needs saving
	          enable = [self isDocumentEdited];
	      } else if ([[toolbarItem itemIdentifier] isEqual:NSToolbarPrintItemIdentifier]) {
	          // always enable print for this window
	          enable = YES;
	      }
	      return enable;
	    }
	    -(BOOL)validateToolbarItem:(NSToolbarItem *)toolbarItem
	    {
	      BOOL enable = NO;
	      if ([[toolbarItem itemIdentifier] isEqual:SaveDocToolbarItemIdentifier]) {
	          // We will return YES (enable the save item)
	          // only when the document is dirty and needs saving
	          enable = [self isDocumentEdited];
	      } else if ([[toolbarItem itemIdentifier] isEqual:NSToolbarPrintItemIdentifier]) {
	          // always enable print for this window
	          enable = YES;
	      }
	      return enable;
	    }
	      * @see https://developer.apple.com/reference/objectivec/nsobject/1524282-validatetoolbaritem
	     */

	  }, {
	    key: 'validateToolbarItem',
	    value: function validateToolbarItem(item) {
	      return false;
	    }

	    /**
	     * Retrieves an indexed object from the collection specified by the passed key.
	     * @access public
	     * @param {number} index - 
	     * @param {string} key - 
	     * @returns {?Object} - 
	     * @desc  This actually works with a single-value key as well if index is 0. The method valueIn<Key>AtIndex: is used if it exists.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1407605-value
	     */

	  }, {
	    key: 'valueAtInPropertyWithKey',
	    value: function valueAtInPropertyWithKey(index, key) {
	      return null;
	    }

	    /**
	     * Returns the class of the value that will be returned for the specified binding.
	     * @access public
	     * @param {string} binding - The name of a binding.
	     * @returns {?Object} - 
	     * @desc This method is used by Interface Builder to determine the appropriate transformers for a binding. Implementation of this method is optional.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1458101-valueclassforbinding
	     */

	  }, {
	    key: 'valueClassForBinding',
	    value: function valueClassForBinding(binding) {
	      return null;
	    }

	    /**
	     * Retrieves a named object from the collection specified by the passed key.
	     * @access public
	     * @param {string} name - 
	     * @param {string} key - 
	     * @returns {?Object} - 
	     * @desc  The method valueIn<Key>WithName: is used if it exists. Otherwise, raises an NSUndefinedKeyException.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1418031-value
	     */

	  }, {
	    key: 'valueWithNameInPropertyWithKey',
	    value: function valueWithNameInPropertyWithKey(name, key) {
	      return null;
	    }

	    /**
	     * Retrieves an object by ID from the collection specified by the passed key.
	     * @access public
	     * @param {Object} uniqueID - 
	     * @param {string} key - 
	     * @returns {?Object} - 
	     * @desc  The method valueIn<Key>WithUniqueID: is invoked if it exists. Otherwise, raises an NSUndefinedKeyException. The declared type of uniqueID in the constructed method must be id, NSNumber *, NSString *, or one of the scalar types that can be encapsulated by NSNumber.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1407321-value
	     */

	  }, {
	    key: 'valueWithUniqueIDInPropertyWithKey',
	    value: function valueWithUniqueIDInPropertyWithKey(uniqueID, key) {
	      return null;
	    }

	    /**
	     * Returns the tool tip string to be displayed due to the cursor pausing at location point within the tool tip rectangle identified by tag in the view view.
	     * @access public
	     * @param {NSView} view - 
	     * @param {NSToolTipTag} tag - 
	     * @param {CGPoint} point - 
	     * @param {?Object} data - 
	     * @returns {string} - 
	     * @desc  userData is additional information provided by the creator of the tool tip rectangle.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1483693-view
	     */

	  }, {
	    key: 'viewStringForToolTipUserData',
	    value: function viewStringForToolTipUserData(view, tag, point, data) {
	      return '';
	    }

	    /**
	     * Loads a URL into a web frame.
	     * @access public
	     * @param {!URLRequest} request - The request that specifies the URL.
	     * @param {!string} target - The frame into which the URL is loaded.
	     * @returns {void}
	     * @desc If the frame specified by target is not found, a new window is opened, loaded with the URL request, and given the specified frame name. If target is nil, the frame enclosing the plug-in is loaded with the URL request.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1536649-webplugincontainerload
	     */

	  }, {
	    key: 'webPlugInContainerLoadInFrame',
	    value: function webPlugInContainerLoadInFrame(request, target) {}

	    /**
	     * Tells the container to show a status message.
	     * @access public
	     * @param {!string} message - The status message to be displayed.
	     * @returns {void}
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1537604-webplugincontainershowstatus
	     */

	  }, {
	    key: 'webPlugInContainerShowStatus',
	    value: function webPlugInContainerShowStatus(message) {}

	    /**
	     * Prepares the plug-in for deallocation.
	     * @access public
	     * @returns {void}
	     * @desc Typically, this method frees the memory and other resources used by the plug-in. For example, if the plug-in had a copy of a WebPlugInContainer object, this method should relinquish ownership of that object. Do not send any other messages to the plug-in after invoking this method, because calling this method destroys the plug-in. No other methods in this interface may be called after the application has called this method.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1536659-webplugindestroy
	     */

	  }, {
	    key: 'webPlugInDestroy',
	    value: function webPlugInDestroy() {}

	    /**
	     * Initializes the plug-in.
	     * @access public
	     * @returns {void}
	     * @desc Tells the plug-in to perform one-time initialization. This method must be called only once per instance of the plug-in object, before any other methods in the protocol are called.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1537623-webplugininitialize
	     */

	  }, {
	    key: 'webPlugInInitialize',
	    value: function webPlugInInitialize() {}

	    /**
	     * Invoked when an error occurs loading the main resource.
	     * @access public
	     * @param {!Error} error - An error object containing details of why the connection failed to load the request successfully.
	     * @returns {void}
	     * @desc This message is invoked when the underlying NSURLConnection object for the main resource sends the connection:didFailWithError: message to its delegate.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1536829-webpluginmainresourcedidfailwith
	     */

	  }, {
	    key: 'webPlugInMainResourceDidFailWithError',
	    value: function webPlugInMainResourceDidFailWithError(error) {}

	    /**
	     * Invoked when the connection successfully finishes loading data.
	     * @access public
	     * @returns {void}
	     * @desc This message is invoked when the WebPlugInShouldLoadMainResourceKey plug-in command-line argument is set to false and the underlying NSURLConnection object for the main resource sends the connectionDidFinishLoading: message to its delegate.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1537693-webpluginmainresourcedidfinishlo
	     */

	  }, {
	    key: 'webPlugInMainResourceDidFinishLoading',
	    value: function webPlugInMainResourceDidFinishLoading() {}

	    /**
	     * Invoked when the connection receives sufficient data to construct the URL response for its request.
	     * @access public
	     * @param {!URLResponse} response - The URL response for the connection's request.
	     * @returns {void}
	     * @desc This message is invoked when the WebPlugInShouldLoadMainResourceKey plug-in command-line argument is set to false and the underlying NSURLConnection object for the main resource sends the connection:didReceiveResponse: message to its delegate.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1537895-webpluginmainresourcedidreceive
	     */

	  }, {
	    key: 'webPlugInMainResourceDidReceive',
	    value: function webPlugInMainResourceDidReceive(response) {}

	    /**
	     * Controls plug-in behavior based on its selection.
	     * @access public
	     * @param {boolean} isSelected - If true, the plug-in is currently selected. Otherwise, it is not selected.
	     * @returns {void}
	     * @desc This may be used, for example, to change the plug-ins appearance when it is selected by the user.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1536477-webpluginsetisselected
	     */

	  }, {
	    key: 'webPlugInSetIsSelected',
	    value: function webPlugInSetIsSelected(isSelected) {}

	    /**
	     * Tells the plug-in to start normal operation.
	     * @access public
	     * @returns {void}
	     * @desc The plug-in usually begins its primary task (such as drawing, playing sounds, or animating) in this method. This method may be called more than once, provided that the application has already called webPlugInInitialize() and that each call to this method is followed later by a call to webPlugInStop().
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1536197-webpluginstart
	     */

	  }, {
	    key: 'webPlugInStart',
	    value: function webPlugInStart() {}

	    /**
	     * Tells the plug-in to stop normal operation.
	     * @access public
	     * @returns {void}
	     * @desc This method may be called more than once, provided that the application has already called webPlugInInitialize() and that each call to this method is preceded by a call to webPlugInStart().
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1536433-webpluginstop
	     */

	  }, {
	    key: 'webPlugInStop',
	    value: function webPlugInStop() {}

	    /**
	     * Invoked when the receiver's workflow encounters an error.
	     * @access public
	     * @param {AMWorkflowController} controller - The controller object sending the message.
	     * @param {Error} error - If a workflow error occurs, upon return contains an instance of NSError that describes the problem.
	     * @returns {void}
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1419652-workflowcontroller
	     */

	  }, {
	    key: 'workflowControllerDidError',
	    value: function workflowControllerDidError(controller, error) {}

	    /**
	     * Invoked when an action in the receiver's workflow is finished running.
	     * @access public
	     * @param {AMWorkflowController} controller - The controller object sending the message.
	     * @param {AMAction} action - The workflow action that ran.
	     * @returns {void}
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1419675-workflowcontroller
	     */

	  }, {
	    key: 'workflowControllerDidRun',
	    value: function workflowControllerDidRun(controller, action) {}

	    /**
	     * Invoked when an action in the receiver's workflow is about to run.
	     * @access public
	     * @param {AMWorkflowController} controller - The controller object sending the message.
	     * @param {AMAction} action - The workflow action that will run.
	     * @returns {void}
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1419720-workflowcontroller
	     */

	  }, {
	    key: 'workflowControllerWillRun',
	    value: function workflowControllerWillRun(controller, action) {}

	    /**
	     * Tells the delegate that the workflow controller object has stopped.
	     * @access public
	     * @param {AMWorkflowController} controller - The workflow controller object that stopped.
	     * @returns {void}
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1419770-workflowcontrollerdidstop
	     */

	  }, {
	    key: 'workflowControllerDidStop',
	    value: function workflowControllerDidStop(controller) {}

	    /**
	     * Tells the delegate that the workflow controller object is about to stop.
	     * @access public
	     * @param {AMWorkflowController} controller - The workflow controller object to be stopped.
	     * @returns {void}
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1419598-workflowcontrollerwillstop
	     */

	  }, {
	    key: 'workflowControllerWillStop',
	    value: function workflowControllerWillStop(controller) {}

	    /**
	     * Tells the element to activate itself and report the success or failure of the operation.
	     * @access public
	     * @returns {boolean} - 
	     * @desc You can use this method to make complex controls more readily accessible to users. The accessibility system calls this method when a VoiceOver user double taps the selected element. Your implementation of this method should activate the element and perform whatever other tasks it deems appropriate. For example, you might use the method to activate a control that requires a complex gesture and would be difficult for VoiceOver users to perform, possibly because the gesture has a different meaning when VoiceOver is running.After performing any tasks, return an appropriate Boolean value to indicate success or failure.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1615165-accessibilityactivate
	     */

	  }, {
	    key: 'accessibilityActivate',
	    value: function accessibilityActivate() {
	      return false;
	    }

	    /**
	     * 
	     * @access public
	     * @returns {?Set<String>} - 
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1615206-accessibilityassistivetechnology
	     */

	  }, {
	    key: 'accessibilityAssistiveTechnologyFocusedIdentifiers',
	    value: function accessibilityAssistiveTechnologyFocusedIdentifiers() {
	      return null;
	    }

	    /**
	     * Tells the accessibility element to decrement the value of its content.
	     * @access public
	     * @returns {void}
	     * @desc If your element has the UIAccessibilityTraitAdjustable trait, you must implement this method. Use this method to decrement the value of the element. For example, a UISlider object uses this method to decrement its value by an appropriate amount. 
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1615169-accessibilitydecrement
	     */

	  }, {
	    key: 'accessibilityDecrement',
	    value: function accessibilityDecrement() {}

	    /**
	     * Returns the accessibility element at the specified index.
	     * @access public
	     * @param {number} index - The index of the accessibility element.
	     * @returns {?Object} - 
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1615084-accessibilityelement
	     */

	  }, {
	    key: 'accessibilityElementAt',
	    value: function accessibilityElementAt(index) {
	      return null;
	    }

	    /**
	     * Returns the number of accessibility elements in the container.
	     * @access public
	     * @returns {number} - 
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1615149-accessibilityelementcount
	     */

	  }, {
	    key: 'accessibilityElementCount',
	    value: function accessibilityElementCount() {
	      return 0;
	    }

	    /**
	     * Sent after an assistive technology has set its virtual focus on the accessibility element.
	     * @access public
	     * @returns {void}
	     * @desc Override accessibilityElementDidBecomeFocused if you need to know when an assistive technology has set its virtual focus on an accessibility element.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1615183-accessibilityelementdidbecomefoc
	     */

	  }, {
	    key: 'accessibilityElementDidBecomeFocused',
	    value: function accessibilityElementDidBecomeFocused() {}

	    /**
	     * Sent after an assistive technology has removed its virtual focus from an accessibility element.
	     * @access public
	     * @returns {void}
	     * @desc Override accessibilityElementDidLoseFocus if you need to know when an assistive technology has removed its virtual focus from an accessibility element. Note that accessibilityElementDidLoseFocus is sent before accessibilityElementDidBecomeFocused().
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1615082-accessibilityelementdidlosefocus
	     */

	  }, {
	    key: 'accessibilityElementDidLoseFocus',
	    value: function accessibilityElementDidLoseFocus() {}

	    /**
	     * Returns a Boolean value indicating whether an assistive technology is focused on the accessibility element.
	     * @access public
	     * @returns {boolean} - 
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1615190-accessibilityelementisfocused
	     */

	  }, {
	    key: 'accessibilityElementIsFocused',
	    value: function accessibilityElementIsFocused() {
	      return false;
	    }

	    /**
	     * Tells the accessibility element to increment the value of its content.
	     * @access public
	     * @returns {void}
	     * @desc If your element has the UIAccessibilityTraitAdjustable trait, you must implement this method. Use this method to increment the value of the element. For example, a UISlider object uses this method to increment its value by an appropriate amount. 
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1615076-accessibilityincrement
	     */

	  }, {
	    key: 'accessibilityIncrement',
	    value: function accessibilityIncrement() {}

	    /**
	     * Dismisses a modal view and returns the success or failure of the action.
	     * @access public
	     * @returns {boolean} - 
	     * @desc Implement this method on an element or containing view that can be revealed modally or in a hierarchy. When a VoiceOver user performs a dismiss action, this method dismisses the view. For example, you might implement this method for a popover in order to give users a deliberate dismiss action to perform that closes the popover.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1615091-accessibilityperformescape
	     */

	  }, {
	    key: 'accessibilityPerformEscape',
	    value: function accessibilityPerformEscape() {
	      return false;
	    }

	    /**
	     * Performs a salient action.
	     * @access public
	     * @returns {boolean} - 
	     * @desc The exact action performed by this method depends your app, typically toggling the most important state of the app. For example, in the Phone app it answers and ends phone calls, in the Music app it plays and pauses playback, in the Clock app it starts and stops a timer, and in the Camera app it takes a picture.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1615137-accessibilityperformmagictap
	     */

	  }, {
	    key: 'accessibilityPerformMagicTap',
	    value: function accessibilityPerformMagicTap() {
	      return false;
	    }

	    /**
	     * Scrolls screen content in an application-specific way and returns the success or failure of the action.
	     * @access public
	     * @param {UIAccessibilityScrollDirection} direction - A constant that specifies the direction of the scrolling action. See UIAccessibilityScrollDirection for descriptions of valid constants.
	     * @returns {boolean} - 
	     * @desc Implement this method if a view in the view hierarchy supports a scroll by page action.If the scrolling action succeeds for the specified direction, return true and post the UIAccessibilityPageScrolledNotification notification. If the scrolling action fails, accessibilityScroll: is called on a parent view in the hierarchy.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1615161-accessibilityscroll
	     */

	  }, {
	    key: 'accessibilityScroll',
	    value: function accessibilityScroll(direction) {
	      return false;
	    }

	    /**
	     * Returns the index of the specified accessibility element.
	     * @access public
	     * @param {Object} element - The accessibility element.
	     * @returns {number} - 
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1615078-index
	     */

	  }, {
	    key: 'indexOfAccessibilityElement',
	    value: function indexOfAccessibilityElement(element) {
	      return 0;
	    }

	    // Type Methods

	    /**
	     * Returns a Boolean value that indicates whether the observed object supports automatic key-value observation for the given key.
	     * @access public
	     * @param {string} key - 
	     * @returns {boolean} - 
	     * @desc The default implementation returns true. Starting in OS X 10.5, the default implementation of this method searches the receiving class for a method whose name matches the pattern +automaticallyNotifiesObserversOf<Key>, and returns the result of invoking that method if it is found. Any found methods must return BOOL. If no such method is found true is returned.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1409370-automaticallynotifiesobservers
	     */

	  }, {
	    key: '_destroy',
	    value: function _destroy() {
	      if (this._destroyed) {
	        throw new Error('_destroy() called twice');
	      }
	      this._destroyed = true;
	      this._execDestroy();
	    }
	  }, {
	    key: '_execDestroy',
	    value: function _execDestroy() {
	      // destroy objects
	    }
	  }, {
	    key: 'autoContentAccessingProxy',


	    // Discardable Content Proxy Support
	    /**
	     * A proxy for the receiving object
	     * @type {Object}
	     * @desc This property returns a proxy for the receiving object if the receiver adopts the NSDiscardableContent protocol and still has content that has not been discarded.The proxy calls beginContentAccess() on the receiver to keep the content available as long as the proxy lives, and calls endContentAccess() when the proxy is deallocated.The wrapper object is otherwise a subclass of NSProxy and forwards messages to the original receiver object as an NSProxy does.This method can be used to hide an NSDiscardableContent object's content volatility by creating an object that responds to the same messages but holds the contents of the original receiver available as long as the created proxy lives. Thus hidden, the NSDiscardableContent object (by way of the proxy) can be given out to unsuspecting recipients of the object who would otherwise not know they might have to call beginContentAccess() and endContentAccess() around particular usages (specific to each NSDiscardableContent object) of the NSDiscardableContent object.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1409224-autocontentaccessingproxy
	     */
	    get: function get() {
	      return this._autoContentAccessingProxy;
	    }
	  }, {
	    key: 'classForArchiver',

	    /**
	     * The class to substitute for the receiver's own class during archiving.
	     * @type {?Object}
	     * @desc 
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1411359-classforarchiver
	     */
	    get: function get() {
	      return this._classForArchiver;
	    }
	    /**
	     * Overridden by subclasses to substitute a class other than its own during coding.
	     * @type {Object}
	     * @desc This method is invoked by NSCoder. NSObjects implementation returns the receivers class. The private subclasses of a class cluster substitute the name of their public superclass when being archived.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1411876-classforcoder
	     */

	  }, {
	    key: 'classForCoder',
	    get: function get() {
	      return this._classForCoder;
	    }
	    /**
	     * Subclasses to substitute a new class for instances during keyed archiving.
	     * @type {?Object}
	     * @desc The object will be encoded as if it were a member of the class. This property is overridden by the encoder class and instance name to class encoding tables. If this property is nil, the result of this property is ignored.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1410512-classforkeyedarchiver
	     */

	  }, {
	    key: 'classForKeyedArchiver',
	    get: function get() {
	      return this._classForKeyedArchiver;
	    }
	  }, {
	    key: 'attributeKeys',
	    get: function get() {
	      return this._attributeKeys;
	    }
	    /**
	     * An object containing information about the attributes and relationships of the receivers class.
	     * @type {NSClassDescription}
	     * @desc 
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1411858-classdescription
	     */

	  }, {
	    key: 'classDescription',
	    get: function get() {
	      return this._classDescription;
	    }
	    /**
	     * An array containing the keys for the to-many relationship properties of the receiver.
	     * @type {string[]}
	     * @desc 
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1415662-tomanyrelationshipkeys
	     */

	  }, {
	    key: 'toManyRelationshipKeys',
	    get: function get() {
	      return this._toManyRelationshipKeys;
	    }
	    /**
	     * The keys for the to-one relationship properties of the receiver, if any.
	     * @type {string[]}
	     * @desc 
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1414814-toonerelationshipkeys
	     */

	  }, {
	    key: 'toOneRelationshipKeys',
	    get: function get() {
	      return this._toOneRelationshipKeys;
	    }
	  }, {
	    key: 'classCode',
	    get: function get() {
	      return this._classCode;
	    }

	    /**
	     * A string containing the name of the class.
	     * @type {string}
	     * @desc 
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1411337-classname
	     */

	  }, {
	    key: 'className',
	    get: function get() {
	      return this.constructor.name;
	    }

	    /**
	     * A string containing the name of the class.
	     * @type {string}
	     * @desc 
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1411337-classname
	     */

	  }, {
	    key: 'hashValue',
	    get: function get() {
	      return this._hashValue;
	    }
	    /**
	     * The deepest descendant of the accessibility hierarchy that has the focus.
	     * @type {?Object}
	     * @desc You can assume that the search for the focus has already been narrowed down to the accessibility element. Override this method to do deeper searching by identifying which child element, if any, may have the focus. If a child element does not have the focus, either return self or, if available, invoke the superclass's implementation. The default NSView and NSCell implementations test whether the accessibility element is an ignored element and, if so, return the elements first unignored parent; otherwise they return self
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1526100-accessibilityfocuseduielement
	     */

	  }, {
	    key: 'accessibilityFocusedUIElement',
	    get: function get() {
	      return this._accessibilityFocusedUIElement;
	    }
	    /**
	     * A Boolean value that indicates whether a custom accessibility object sends a notification when its corresponding UI element is destroyed.
	     * @type {boolean}
	     * @desc In macOS 10.9 and later, a custom accessibility object that is an NSObject subclass can post accessibility notifications if it meets the following criteria:The lifetime of the custom accessibility object must match the lifetime of the corresponding element in the app's UI.Typically, a custom accessibility object that acts as a proxy for an onscreen UI element gets autoreleased and deallocated immediately after the app responds to an accessibility request. Such an object cant post accessibility notifications, because all registered observers get removed as soon as the object is deallocated. To correct this, an app must guarantee that a custom accessibility object remains allocated for as long as its corresponding UI element remains visible.The object must post the NSAccessibilityUIElementDestroyedNotification  notification at the appropriate time. The appropriate time is most likely to be when the corresponding UI element is removed from the screen, but it can also be when the object itself is deallocated. The object must implement accessibilityNotifiesWhenDestroyed and return true.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1534050-accessibilitynotifieswhendestroy
	     */

	  }, {
	    key: 'accessibilityNotifiesWhenDestroyed',
	    get: function get() {
	      return this._accessibilityNotifiesWhenDestroyed;
	    }
	    /**
	     * Returns an array containing the bindings exposed by the receiver.
	     * @type {string[]}
	     * @desc A subclass can override this method to remove bindings that are exposed by a superclass that are not appropriate for the subclass.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1458048-exposedbindings
	     */

	  }, {
	    key: 'exposedBindings',
	    get: function get() {
	      return this._exposedBindings;
	    }
	    /**
	     * Returns an object that exposes the plug-ins scripting interface.
	     * @type {!Object}
	     * @desc The methods of the object are exposed to the script environment. Messages sent to the returned object will be invoked in the scripting environment. See the WebScripting Protocol Reference informal protocol for more details.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1537612-objectforwebscript
	     */

	  }, {
	    key: 'objectForWebScript',
	    get: function get() {
	      return this._objectForWebScript;
	    }
	    /**
	     * Returns an object specifier for the receiver.
	     * @type {?NSScriptObjectSpecifier}
	     * @desc 
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1409884-objectspecifier
	     */

	  }, {
	    key: 'objectSpecifier',
	    get: function get() {
	      return this._objectSpecifier;
	    }
	    /**
	     * Returns the WebFrame that contains the plug-in.
	     * @type {!WebFrame}
	     * @desc Only implemented by containers that are based on the WebKits plug-in architecture.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1537727-webframe
	     */

	  }, {
	    key: 'webFrame',
	    get: function get() {
	      return this._webFrame;
	    }
	    /**
	     * Returns the plug-in selection color.
	     * @type {!CGColor}
	     * @desc The color should be used for any special drawing when the plug-in is selected.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1536394-webplugincontainerselectioncolor
	     */

	  }, {
	    key: 'webPlugInContainerSelectionColor',
	    get: function get() {
	      return this._webPlugInContainerSelectionColor;
	    }
	    /**
	     * Returns a Boolean value that indicates whether the key-value coding methods should access the corresponding instance variable directly on finding no accessor method for a property.
	     * @type {boolean}
	     * @desc The default returns true. Subclasses can override it to return false, in which case the key-value coding methods wont access instance variables.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1415307-accessinstancevariablesdirectly
	     */

	  }, {
	    key: 'isSelectable',

	    /**
	     * 
	     * @type {boolean}
	     * @desc 
	     * @see https://developer.apple.com/reference/objectivec/nsobject/2369549-isselectable
	     */
	    get: function get() {
	      return this._isSelectable;
	    }
	  }], [{
	    key: 'superclass',
	    value: function superclass() {
	      return null;
	    }

	    /**
	     * Returns a Boolean value that indicates whether the receiving class is a subclass of, or identical to, a given class.
	     * @access public
	     * @param {Object} aClass - A class object.
	     * @returns {boolean} - 
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1418669-issubclass
	     */

	  }, {
	    key: 'isSubclassOf',
	    value: function isSubclassOf(aClass) {
	      return false;
	    }

	    // Testing Class Functionality

	    /**
	     * Returns a Boolean value that indicates whether instances of the receiver are capable of responding to a given selector.
	     * @access public
	     * @param {!function} aSelector - A Selector.
	     * @returns {boolean} - 
	     * @desc If aSelector messages are forwarded to other objects, instances of the class are able to receive those messages without error even though this method returns false.To ask the class whether it, rather than its instances, can respond to a particular message, send to the class instead the  NSObject protocol instance method responds(to:).
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1418555-instancesrespond
	     */

	  }, {
	    key: 'instancesRespondTo',
	    value: function instancesRespondTo(aSelector) {
	      return false;
	    }

	    // Testing Protocol Conformance

	    /**
	     * Returns a Boolean value that indicates whether the receiver conforms to a given protocol.
	     * @access public
	     * @param {Object} protocol - 
	     * @returns {boolean} - 
	     * @desc A class is said to conform to a protocol if it adopts the protocol or inherits from another class that adopts it. Protocols are adopted by listing them within angle brackets after the interface declaration. For example, here MyClass adopts the (fictitious) AffiliationRequests and Normalization protocols:@interface MyClass : NSObject <AffiliationRequests, Normalization>
	    A class also conforms to any protocols that are incorporated in the protocols it adopts or inherits. Protocols incorporate other protocols in the same way classes adopt them. For example, here the AffiliationRequests protocol incorporates the Joining protocol:@protocol AffiliationRequests <Joining>
	    If a class adopts a protocol that incorporates another protocol, it must also implement all the methods in the incorporated protocol or inherit those methods from a class that adopts it.This method determines conformance solely on the basis of the formal declarations in header files, as illustrated above. It doesnt check to see whether the methods declared in the protocol are actually implementedthats the programmers responsibility.The protocol required as this methods argument can be specified using the @protocol() directive:BOOL canJoin = [MyClass conformsToProtocol:@protocol(Joining)];
	    @interface MyClass : NSObject <AffiliationRequests, Normalization>
	    @protocol AffiliationRequests <Joining>
	    BOOL canJoin = [MyClass conformsToProtocol:@protocol(Joining)];
	      * @see https://developer.apple.com/reference/objectivec/nsobject/1418893-conforms
	     */

	  }, {
	    key: 'conformsTo',
	    value: function conformsTo(protocol) {
	      return false;
	    }
	  }, {
	    key: 'instanceMethodFor',
	    value: function instanceMethodFor(aSelector) {
	      return null;
	    }

	    // Describing Objects

	    /**
	     * Returns a string that represents the contents of the receiving class.
	     * @access public
	     * @returns {string} - 
	     * @desc The debuggers print-object command invokes this method to produce a textual description of an object.NSObject's implementation of this method simply prints the name of the class.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1418799-description
	     */

	  }, {
	    key: 'description',
	    value: function description() {
	      return '';
	    }
	  }, {
	    key: 'cancelPreviousPerformRequestsWithTarget',
	    value: function cancelPreviousPerformRequestsWithTarget(aTarget) {}

	    /**
	     * Cancels perform requests previously registered with perform(_:with:afterDelay:).
	     * @access public
	     * @param {Object} aTarget - The target for requests previously registered with the perform(_:with:afterDelay:) instance method
	     * @param {function} aSelector - The Selector for requests previously registered with the perform(_:with:afterDelay:) instance method.
	     * @param {?Object} anArgument - The argument for requests previously registered with the perform(_:with:afterDelay:) instance method. Argument equality is determined using isEqual(_:), so the value need not be the same object that was passed originally. Pass nil to match a request for nil that was originally passed as the argument.
	     * @returns {void}
	     * @desc All perform requests are canceled that have the same target as aTarget, argument as anArgument, and selector as aSelector. This method removes perform requests only in the current run loop, not all run loops.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1410849-cancelpreviousperformrequests
	     */

	  }, {
	    key: 'cancelPreviousPerformRequestsWithTargetSelectorObject',
	    value: function cancelPreviousPerformRequestsWithTargetSelectorObject(aTarget, aSelector, anArgument) {}
	  }, {
	    key: 'resolveClassMethod',
	    value: function resolveClassMethod(sel) {
	      return false;
	    }

	    /**
	     * Dynamically provides an implementation for a given selector for an instance method.
	     * @access public
	     * @param {!function} sel - 
	     * @returns {boolean} - 
	     * @desc This method and resolveClassMethod(_:) allow you to dynamically provide an implementation for a given selector.An Objective-C method is simply a C function that take at least two argumentsself and _cmd. Using the class_addMethod(_:_:_:_:) function, you can add a function to a class as a method. Given the following function:void dynamicMethodIMP(id self, SEL _cmd)
	    {
	      // implementation ....
	    }
	    you can use resolveInstanceMethod: to dynamically add it to a class as a method (called resolveThisMethodDynamically) like this:+ (BOOL) resolveInstanceMethod:(SEL)aSEL
	    {
	      if (aSEL == @selector(resolveThisMethodDynamically))
	      {
	            class_addMethod([self class], aSEL, (IMP) dynamicMethodIMP, "v@:");
	            return YES;
	      }
	      return [super resolveInstanceMethod:aSel];
	    }
	    Special ConsiderationsThis method is called before the Objective-C forwarding mechanism is invoked. If responds(to:) or instancesRespond(to:) is invoked, the dynamic method resolver is given the opportunity to provide an IMP for the given selector first.void dynamicMethodIMP(id self, SEL _cmd)
	    {
	      // implementation ....
	    }
	    + (BOOL) resolveInstanceMethod:(SEL)aSEL
	    {
	      if (aSEL == @selector(resolveThisMethodDynamically))
	      {
	            class_addMethod([self class], aSEL, (IMP) dynamicMethodIMP, "v@:");
	            return YES;
	      }
	      return [super resolveInstanceMethod:aSel];
	    }
	      * @see https://developer.apple.com/reference/objectivec/nsobject/1418500-resolveinstancemethod
	     */

	  }, {
	    key: 'resolveInstanceMethod',
	    value: function resolveInstanceMethod(sel) {
	      return false;
	    }
	  }, {
	    key: 'classFallbacksForKeyedArchiver',
	    value: function classFallbacksForKeyedArchiver() {
	      return null;
	    }

	    /**
	     * Overridden by subclasses to substitute a new class during keyed unarchiving.
	     * @access public
	     * @returns {Object} - 
	     * @desc During keyed unarchiving, instances of the receiver will be decoded as members of the returned class. This method overrides the results of the decoders class and instance name to class encoding tables.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1410547-classforkeyedunarchiver
	     */

	  }, {
	    key: 'classForKeyedUnarchiver',
	    value: function classForKeyedUnarchiver() {
	      return null;
	    }
	  }, {
	    key: 'setVersion',
	    value: function setVersion(aVersion) {}

	    /**
	     * Returns the version number assigned to the class.
	     * @access public
	     * @returns {number} - 
	     * @desc If no version has been set, the default is 0. Version numbers are needed for decoding or unarchiving, so older versions of an object can be detected and decoded correctly.Caution should be taken when obtaining the version from within an NSCoding protocol or other methods. Use the class name explicitly when getting a class version number:version = [MyClass version];
	    Dont simply send version to the return value of classa subclass version number may be returned instead.Special ConsiderationsThe version number applies to NSArchiver/NSUnarchiver, but not to NSKeyedArchiver/NSKeyedUnarchiver.  A keyed archiver does not encode class version numbers.version = [MyClass version];
	      * @see https://developer.apple.com/reference/objectivec/nsobject/1415151-version
	     */

	  }, {
	    key: 'version',
	    value: function version() {
	      return 0;
	    }
	  }, {
	    key: 'automaticallyNotifiesObserversForKey',
	    value: function automaticallyNotifiesObserversForKey(key) {
	      return false;
	    }

	    /**
	     * 
	     * @access public
	     * @returns {string} - 
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1418711-debugdescription
	     */

	  }, {
	    key: 'debugDescription',
	    value: function debugDescription() {
	      return '';
	    }

	    /**
	     * 
	     * @access public
	     * @returns {number} - 
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1418561-hash
	     */

	  }, {
	    key: 'hash',
	    value: function hash() {
	      return 0;
	    }

	    /**
	     * Returns a set of key paths for properties whose values affect the value of the specified key.
	     * @access public
	     * @param {string} key - The key whose value is affected by the key paths.
	     * @returns {Set<String>} - 
	     * @desc When an observer for the key is registered with an instance of the receiving class, key-value observing itself automatically observes all of the key paths for the same instance, and sends change notifications for the key to the observer when the value for any of those key paths changes.The default implementation of this method searches the receiving class for a method whose name matches the pattern +keyPathsForValuesAffecting<Key>, and returns the result of invoking that method if it is found. Any such method must return an NSSet. If no such method is found, an NSSet that is computed from information provided by previous invocations of the now-deprecated setKeys:triggerChangeNotificationsForDependentKey: method is returned, for backward binary compatibility.You can override this method when the getter method of one of your properties computes a value to return using the values of other properties, including those that are located by key paths. Your override should typically call super and return a set that includes any members in the set that result from doing that (so as not to interfere with overrides of this method in superclasses).NoteYou must not override this method when you add a computed property to an existing class using a category, overriding methods in categories is unsupported. In that case, implement a matching +keyPathsForValuesAffecting<Key> to take advantage of this mechanism.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1414299-keypathsforvaluesaffectingvalue
	     */

	  }, {
	    key: 'keyPathsForValuesAffectingValueForKey',
	    value: function keyPathsForValuesAffectingValueForKey(key) {
	      return null;
	    }

	    /**
	     * Returns an object that will be used as the placeholder for the binding, when a key value coding compliant property of an instance of the receiving class returns the value specified by marker, and no other placeholder has been specified. 
	     * @access public
	     * @param {?Object} marker - 
	     * @param {string} binding - 
	     * @returns {?Object} - 
	     * @desc The marker can be nil or one of the constants described in Selection Markers.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1458203-defaultplaceholder
	     */

	  }, {
	    key: 'defaultPlaceholderForMarkerWithBinding',
	    value: function defaultPlaceholderForMarkerWithBinding(marker, binding) {
	      return null;
	    }

	    /**
	     * Exposes the specified binding, advertising its availability. 
	     * @access public
	     * @param {string} binding - The key path for the property to be exposed.
	     * @returns {void}
	     * @desc The bound property will be accessed using key-value-coding compliant methods. This method is typically invoked in the classs initialize implementation.Bindings exposed using exposeBinding will be exposed automatically in exposedBindings unless that method explicitly filters them out, for example in subclasses.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1458184-exposebinding
	     */

	  }, {
	    key: 'exposeBinding',
	    value: function exposeBinding(binding) {}

	    /**
	     * Returns whether a key should be hidden from the scripting environment.
	     * @access public
	     * @param {!UnsafePointer<Int8>} name - The name of the attribute.
	     * @returns {boolean} - 
	     * @desc The default value is true.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1528545-iskeyexcluded
	     */

	  }, {
	    key: 'isKeyExcludedFromWebScript',
	    value: function isKeyExcludedFromWebScript(name) {
	      return false;
	    }

	    /**
	     * Returns whether a selector should be hidden from the scripting environment.
	     * @access public
	     * @param {!function} selector - 
	     * @returns {boolean} - 
	     * @desc Only methods with valid parameters and return types are exported to the WebKit JavaScript environment. The valid types are Objective-C objects and scalars. The default value is true.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1528532-isselectorexcluded
	     */

	  }, {
	    key: 'isSelectorExcludedFromWebScript',
	    value: function isSelectorExcludedFromWebScript(selector) {
	      return false;
	    }

	    /**
	     * Sets placeholder as the default placeholder for the binding, when a key value coding compliant property of an instance of the receiving class returns the value specified by marker, and no other placeholder has been specified.
	     * @access public
	     * @param {?Object} placeholder - 
	     * @param {?Object} marker - 
	     * @param {string} binding - 
	     * @returns {void}
	     * @desc The marker can be nil or one of the constants described in Selection Markers.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1458194-setdefaultplaceholder
	     */

	  }, {
	    key: 'setDefaultPlaceholderForMarkerWithBinding',
	    value: function setDefaultPlaceholderForMarkerWithBinding(placeholder, marker, binding) {}

	    /**
	     * Returns the scripting environment name for an attribute specified by a key.
	     * @access public
	     * @param {!UnsafePointer<Int8>} name - The name of the attribute.
	     * @returns {!string} - 
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1528541-webscriptname
	     */

	  }, {
	    key: 'webScriptNameForKey',
	    value: function webScriptNameForKey(name) {
	      return null;
	    }

	    /**
	     * Returns the scripting environment name for a selector.
	     * @access public
	     * @param {!function} selector - 
	     * @returns {!string} - 
	     * @desc It is your responsibility to ensure that the returned name is unique to the script invoking this method. If this method returns nil or you do not implement it, the default name for the selector is constructed as follows: A colon (:) in the Objective-C selector is replaced by an underscore (_).An underscore in the Objective-C selector is prefixed with a dollar sign ($).A dollar sign in the Objective-C selector is prefixed with another dollar sign.The following table shows examples of how the default name is constructed:Objective-C selectorDefault script name for selectorsetFlag:setFlag_setFlag:forKey:withAttributes:setFlag_forKey_withAttributes_propertiesForExample_Object:propertiesForExample$_Object_set_$_forKey:withDictionary:set$_$$_$_forKey_withDictionary_Since the default construction for a method name can be confusing depending on its Objective-C name, you should implement this method and return a more human-readable name.Objective-C selectorDefault script name for selectorsetFlag:setFlag_setFlag:forKey:withAttributes:setFlag_forKey_withAttributes_propertiesForExample_Object:propertiesForExample$_Object_set_$_forKey:withDictionary:set$_$$_$_forKey_withDictionary_
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1528539-webscriptname
	     */

	  }, {
	    key: 'webScriptNameFor',
	    value: function webScriptNameFor(selector) {
	      return null;
	    }
	  }, {
	    key: 'initWithCoder',
	    value: function initWithCoder(coder) {
	      //console.log('initWithCoder: ' + this.className)
	      var propTypes = {};

	      // check if all property names are registered
	      var _iteratorNormalCompletion = true;
	      var _didIteratorError = false;
	      var _iteratorError = undefined;

	      try {
	        for (var _iterator = Object.keys(coder._refObj)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	          var key = _step.value;

	          if (key.charAt(0) === '$') {
	            continue;
	          }
	          if (typeof this._propTypes[key] === 'undefined') {
	            //console.warn(`unknown key ${key}`)
	            if (this._propTypes.$unknownKey && this._propTypes.$unknownKey(key) !== null) {
	              propTypes[key] = this._propTypes.$unknownKey(key);
	              //console.warn(`unknown key: ${key} => ${propTypes[key]}`)
	            } else {
	              console.error(this.className + ': property ' + key + ' not registered');
	              throw new Error(this.className + ': property ' + key + ' not registered');
	            }
	          } else {
	            propTypes[key] = this._propTypes[key];
	          }
	        }
	      } catch (err) {
	        _didIteratorError = true;
	        _iteratorError = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion && _iterator.return) {
	            _iterator.return();
	          }
	        } finally {
	          if (_didIteratorError) {
	            throw _iteratorError;
	          }
	        }
	      }

	      var props = this._loadProperties(coder, propTypes);
	      var propNames = props.names;
	      var propValues = props.values;

	      var instance = null;
	      if (typeof this._propTypes.$constructor === 'function') {
	        instance = this._propTypes.$constructor(propNames, propValues, coder);
	      } else {
	        instance = new this();
	      }

	      this._setProperties(instance, propNames, propValues, coder);

	      return instance;
	    }

	    /**
	     * @access private
	     * @param {NSCoder} coder -
	     * @returns {Object} -
	     */

	  }, {
	    key: '_loadProperties',
	    value: function _loadProperties(coder, propTypes) {
	      var propNames = {};
	      var propValues = {};

	      var _iteratorNormalCompletion2 = true;
	      var _didIteratorError2 = false;
	      var _iteratorError2 = undefined;

	      try {
	        for (var _iterator2 = Object.keys(propTypes)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
	          var key = _step2.value;

	          //console.log(`key: ${key}`)
	          if (!coder.containsValueForKey(key)) {
	            console.log('!coder.containsValueForKey ' + key);
	            continue;
	          }
	          var def = propTypes[key];
	          var type = '';
	          var propName = key;
	          if (typeof def === 'string') {
	            type = def;
	          } else if (Array.isArray(def)) {
	            type = def[0];
	            if (def.length >= 2) {
	              propName = def[1];
	            }
	          }

	          //console.log(`type: ${type}, propName: ${propName}`)
	          var value = null;
	          switch (type) {
	            case 'boolean':
	              value = coder.decodeBoolForKey(key);
	              break;
	            case 'bytes':
	              value = coder.decodeBytesForKeyReturnedLength(key, null);
	              break;
	            case 'double':
	              value = coder.decodeDoubleForKey(key);
	              break;
	            case 'float':
	              value = coder.decodeFloatForKey(key);
	              break;
	            case 'integer':
	              value = coder.decodeCIntForKey(key);
	              break;
	            case 'int32':
	              value = coder.decodeInt32ForKey(key);
	              break;
	            case 'int64':
	              value = coder.decodeInt64ForKey(key);
	              break;
	            case 'point':
	              value = coder.decodePointForKey(key);
	              break;
	            case 'rect':
	              value = coder.decodeRectForKey(key);
	              break;
	            case 'size':
	              value = coder.decodeSizeForKey(key);
	              break;
	            case 'plist':
	              value = coder.decodePropertyListForKey(key);
	              break;
	            case 'string':
	              value = coder.decodeObjectForKey(key);
	              if (typeof value !== 'string') {
	                //console.error(`${key}: value is not String type`)
	                throw new Error(key + ': value is not String type');
	              }
	              break;
	            default:
	              {
	                var classObj = _ClassList3.default.get(type);
	                if (typeof classObj === 'undefined') {
	                  //console.error(`unknown class name: ${type}`)
	                  throw new Error('unknown class name: ' + type);
	                }
	                if (coder._refObj[key] instanceof Buffer) {
	                  value = coder.decodeObjectOfTypeForKey(classObj, key);
	                  if (!(value instanceof classObj)) {
	                    //console.error(`${key}: value is not an instance of ${type}`)
	                    throw new Error(key + ': value is not an instance of ' + type);
	                  }
	                } else {
	                  value = coder.decodeObjectForKey(key);
	                  if (value instanceof Promise) {
	                    // wait for loading
	                  } else if (!(value instanceof classObj)) {
	                    var exception = ['NSData', 'NSMutableData', // => Buffer
	                    'NSArray', 'NSMutableArray', // => Array
	                    'NSDictionary', 'NSMutableDictionary', // => Object
	                    'NSColor', // => SKColor
	                    'NSURL' // => String
	                    ];
	                    if (exception.indexOf(classObj.className) < 0) {
	                      //console.error(`${key}: value is not an instance of ${type}`)
	                      throw new Error(key + ': value is not an instance of ' + type);
	                    }
	                  }
	                }
	              }
	          }
	          //if(Array.isArray(value)){
	          //  console.log(`value: Array[${value.length}]`)
	          //}else if(typeof value === 'symbol'){
	          //  console.log('value: Symbol()')
	          //}else{
	          //  console.log(`value: ${value}`)
	          //}

	          propValues[key] = value;
	          propNames[key] = propName;
	        }
	      } catch (err) {
	        _didIteratorError2 = true;
	        _iteratorError2 = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion2 && _iterator2.return) {
	            _iterator2.return();
	          }
	        } finally {
	          if (_didIteratorError2) {
	            throw _iteratorError2;
	          }
	        }
	      }

	      return { names: propNames, values: propValues };
	    }

	    /**
	     * @access private
	     * @param {Object} instance -
	     * @param {string[]} propNames -
	     * @param {Object[]} propValues -
	     * @param {NSCoder} coder -
	     * @returns {void}
	     */

	  }, {
	    key: '_setProperties',
	    value: function _setProperties(instance, propNames, propValues, coder) {
	      var _iteratorNormalCompletion3 = true;
	      var _didIteratorError3 = false;
	      var _iteratorError3 = undefined;

	      try {
	        for (var _iterator3 = Object.keys(propValues)[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
	          var key = _step3.value;

	          this._setProperty(instance, propNames[key], propValues[key], key, coder);
	        }
	      } catch (err) {
	        _didIteratorError3 = true;
	        _iteratorError3 = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion3 && _iterator3.return) {
	            _iterator3.return();
	          }
	        } finally {
	          if (_didIteratorError3) {
	            throw _iteratorError3;
	          }
	        }
	      }
	    }

	    /**
	     * @access private
	     * @param {Object} instance -
	     * @param {string[]} propName -
	     * @param {Object[]} propValue -
	     * @param {string} key -
	     * @param {NSCoder} coder -
	     * @returns {void}
	     */

	  }, {
	    key: '_setProperty',
	    value: function _setProperty(instance, propName, propValue, key, coder) {
	      var _this = this;

	      if (propValue instanceof Promise) {
	        propValue.then(function (loadedValue) {
	          _this._setProperty(instance, propName, loadedValue, key, coder);
	        });
	      } else if (typeof propName === 'function') {
	        propName(instance, propValue, key, coder);
	      } else if (propName !== null) {
	        instance[propName] = propValue;
	      }
	    }
	  }, {
	    key: 'className',
	    get: function get() {
	      return this.prototype.constructor.name;
	    }
	  }, {
	    key: 'accessInstanceVariablesDirectly',
	    get: function get() {
	      return true;
	    }
	  }, {
	    key: 'supportsSecureCoding',
	    get: function get() {
	      return true;
	    }
	  }]);

	  return NSObject;
	}();

	exports.default = NSObject;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3).Buffer))

/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {/*!
	 * The buffer module from node.js, for the browser.
	 *
	 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
	 * @license  MIT
	 */
	/* eslint-disable no-proto */

	'use strict'

	var base64 = __webpack_require__(4)
	var ieee754 = __webpack_require__(5)
	var isArray = __webpack_require__(6)

	exports.Buffer = Buffer
	exports.SlowBuffer = SlowBuffer
	exports.INSPECT_MAX_BYTES = 50

	/**
	 * If `Buffer.TYPED_ARRAY_SUPPORT`:
	 *   === true    Use Uint8Array implementation (fastest)
	 *   === false   Use Object implementation (most compatible, even IE6)
	 *
	 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
	 * Opera 11.6+, iOS 4.2+.
	 *
	 * Due to various browser bugs, sometimes the Object implementation will be used even
	 * when the browser supports typed arrays.
	 *
	 * Note:
	 *
	 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
	 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
	 *
	 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
	 *
	 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
	 *     incorrect length in some situations.

	 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
	 * get the Object implementation, which is slower but behaves correctly.
	 */
	Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
	  ? global.TYPED_ARRAY_SUPPORT
	  : typedArraySupport()

	/*
	 * Export kMaxLength after typed array support is determined.
	 */
	exports.kMaxLength = kMaxLength()

	function typedArraySupport () {
	  try {
	    var arr = new Uint8Array(1)
	    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
	    return arr.foo() === 42 && // typed array instances can be augmented
	        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
	        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
	  } catch (e) {
	    return false
	  }
	}

	function kMaxLength () {
	  return Buffer.TYPED_ARRAY_SUPPORT
	    ? 0x7fffffff
	    : 0x3fffffff
	}

	function createBuffer (that, length) {
	  if (kMaxLength() < length) {
	    throw new RangeError('Invalid typed array length')
	  }
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    // Return an augmented `Uint8Array` instance, for best performance
	    that = new Uint8Array(length)
	    that.__proto__ = Buffer.prototype
	  } else {
	    // Fallback: Return an object instance of the Buffer class
	    if (that === null) {
	      that = new Buffer(length)
	    }
	    that.length = length
	  }

	  return that
	}

	/**
	 * The Buffer constructor returns instances of `Uint8Array` that have their
	 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
	 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
	 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
	 * returns a single octet.
	 *
	 * The `Uint8Array` prototype remains unmodified.
	 */

	function Buffer (arg, encodingOrOffset, length) {
	  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
	    return new Buffer(arg, encodingOrOffset, length)
	  }

	  // Common case.
	  if (typeof arg === 'number') {
	    if (typeof encodingOrOffset === 'string') {
	      throw new Error(
	        'If encoding is specified then the first argument must be a string'
	      )
	    }
	    return allocUnsafe(this, arg)
	  }
	  return from(this, arg, encodingOrOffset, length)
	}

	Buffer.poolSize = 8192 // not used by this implementation

	// TODO: Legacy, not needed anymore. Remove in next major version.
	Buffer._augment = function (arr) {
	  arr.__proto__ = Buffer.prototype
	  return arr
	}

	function from (that, value, encodingOrOffset, length) {
	  if (typeof value === 'number') {
	    throw new TypeError('"value" argument must not be a number')
	  }

	  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
	    return fromArrayBuffer(that, value, encodingOrOffset, length)
	  }

	  if (typeof value === 'string') {
	    return fromString(that, value, encodingOrOffset)
	  }

	  return fromObject(that, value)
	}

	/**
	 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
	 * if value is a number.
	 * Buffer.from(str[, encoding])
	 * Buffer.from(array)
	 * Buffer.from(buffer)
	 * Buffer.from(arrayBuffer[, byteOffset[, length]])
	 **/
	Buffer.from = function (value, encodingOrOffset, length) {
	  return from(null, value, encodingOrOffset, length)
	}

	if (Buffer.TYPED_ARRAY_SUPPORT) {
	  Buffer.prototype.__proto__ = Uint8Array.prototype
	  Buffer.__proto__ = Uint8Array
	  if (typeof Symbol !== 'undefined' && Symbol.species &&
	      Buffer[Symbol.species] === Buffer) {
	    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
	    Object.defineProperty(Buffer, Symbol.species, {
	      value: null,
	      configurable: true
	    })
	  }
	}

	function assertSize (size) {
	  if (typeof size !== 'number') {
	    throw new TypeError('"size" argument must be a number')
	  } else if (size < 0) {
	    throw new RangeError('"size" argument must not be negative')
	  }
	}

	function alloc (that, size, fill, encoding) {
	  assertSize(size)
	  if (size <= 0) {
	    return createBuffer(that, size)
	  }
	  if (fill !== undefined) {
	    // Only pay attention to encoding if it's a string. This
	    // prevents accidentally sending in a number that would
	    // be interpretted as a start offset.
	    return typeof encoding === 'string'
	      ? createBuffer(that, size).fill(fill, encoding)
	      : createBuffer(that, size).fill(fill)
	  }
	  return createBuffer(that, size)
	}

	/**
	 * Creates a new filled Buffer instance.
	 * alloc(size[, fill[, encoding]])
	 **/
	Buffer.alloc = function (size, fill, encoding) {
	  return alloc(null, size, fill, encoding)
	}

	function allocUnsafe (that, size) {
	  assertSize(size)
	  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) {
	    for (var i = 0; i < size; ++i) {
	      that[i] = 0
	    }
	  }
	  return that
	}

	/**
	 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
	 * */
	Buffer.allocUnsafe = function (size) {
	  return allocUnsafe(null, size)
	}
	/**
	 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
	 */
	Buffer.allocUnsafeSlow = function (size) {
	  return allocUnsafe(null, size)
	}

	function fromString (that, string, encoding) {
	  if (typeof encoding !== 'string' || encoding === '') {
	    encoding = 'utf8'
	  }

	  if (!Buffer.isEncoding(encoding)) {
	    throw new TypeError('"encoding" must be a valid string encoding')
	  }

	  var length = byteLength(string, encoding) | 0
	  that = createBuffer(that, length)

	  var actual = that.write(string, encoding)

	  if (actual !== length) {
	    // Writing a hex string, for example, that contains invalid characters will
	    // cause everything after the first invalid character to be ignored. (e.g.
	    // 'abxxcd' will be treated as 'ab')
	    that = that.slice(0, actual)
	  }

	  return that
	}

	function fromArrayLike (that, array) {
	  var length = array.length < 0 ? 0 : checked(array.length) | 0
	  that = createBuffer(that, length)
	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255
	  }
	  return that
	}

	function fromArrayBuffer (that, array, byteOffset, length) {
	  array.byteLength // this throws if `array` is not a valid ArrayBuffer

	  if (byteOffset < 0 || array.byteLength < byteOffset) {
	    throw new RangeError('\'offset\' is out of bounds')
	  }

	  if (array.byteLength < byteOffset + (length || 0)) {
	    throw new RangeError('\'length\' is out of bounds')
	  }

	  if (byteOffset === undefined && length === undefined) {
	    array = new Uint8Array(array)
	  } else if (length === undefined) {
	    array = new Uint8Array(array, byteOffset)
	  } else {
	    array = new Uint8Array(array, byteOffset, length)
	  }

	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    // Return an augmented `Uint8Array` instance, for best performance
	    that = array
	    that.__proto__ = Buffer.prototype
	  } else {
	    // Fallback: Return an object instance of the Buffer class
	    that = fromArrayLike(that, array)
	  }
	  return that
	}

	function fromObject (that, obj) {
	  if (Buffer.isBuffer(obj)) {
	    var len = checked(obj.length) | 0
	    that = createBuffer(that, len)

	    if (that.length === 0) {
	      return that
	    }

	    obj.copy(that, 0, 0, len)
	    return that
	  }

	  if (obj) {
	    if ((typeof ArrayBuffer !== 'undefined' &&
	        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
	      if (typeof obj.length !== 'number' || isnan(obj.length)) {
	        return createBuffer(that, 0)
	      }
	      return fromArrayLike(that, obj)
	    }

	    if (obj.type === 'Buffer' && isArray(obj.data)) {
	      return fromArrayLike(that, obj.data)
	    }
	  }

	  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
	}

	function checked (length) {
	  // Note: cannot use `length < kMaxLength()` here because that fails when
	  // length is NaN (which is otherwise coerced to zero.)
	  if (length >= kMaxLength()) {
	    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
	                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
	  }
	  return length | 0
	}

	function SlowBuffer (length) {
	  if (+length != length) { // eslint-disable-line eqeqeq
	    length = 0
	  }
	  return Buffer.alloc(+length)
	}

	Buffer.isBuffer = function isBuffer (b) {
	  return !!(b != null && b._isBuffer)
	}

	Buffer.compare = function compare (a, b) {
	  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
	    throw new TypeError('Arguments must be Buffers')
	  }

	  if (a === b) return 0

	  var x = a.length
	  var y = b.length

	  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
	    if (a[i] !== b[i]) {
	      x = a[i]
	      y = b[i]
	      break
	    }
	  }

	  if (x < y) return -1
	  if (y < x) return 1
	  return 0
	}

	Buffer.isEncoding = function isEncoding (encoding) {
	  switch (String(encoding).toLowerCase()) {
	    case 'hex':
	    case 'utf8':
	    case 'utf-8':
	    case 'ascii':
	    case 'latin1':
	    case 'binary':
	    case 'base64':
	    case 'ucs2':
	    case 'ucs-2':
	    case 'utf16le':
	    case 'utf-16le':
	      return true
	    default:
	      return false
	  }
	}

	Buffer.concat = function concat (list, length) {
	  if (!isArray(list)) {
	    throw new TypeError('"list" argument must be an Array of Buffers')
	  }

	  if (list.length === 0) {
	    return Buffer.alloc(0)
	  }

	  var i
	  if (length === undefined) {
	    length = 0
	    for (i = 0; i < list.length; ++i) {
	      length += list[i].length
	    }
	  }

	  var buffer = Buffer.allocUnsafe(length)
	  var pos = 0
	  for (i = 0; i < list.length; ++i) {
	    var buf = list[i]
	    if (!Buffer.isBuffer(buf)) {
	      throw new TypeError('"list" argument must be an Array of Buffers')
	    }
	    buf.copy(buffer, pos)
	    pos += buf.length
	  }
	  return buffer
	}

	function byteLength (string, encoding) {
	  if (Buffer.isBuffer(string)) {
	    return string.length
	  }
	  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
	      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
	    return string.byteLength
	  }
	  if (typeof string !== 'string') {
	    string = '' + string
	  }

	  var len = string.length
	  if (len === 0) return 0

	  // Use a for loop to avoid recursion
	  var loweredCase = false
	  for (;;) {
	    switch (encoding) {
	      case 'ascii':
	      case 'latin1':
	      case 'binary':
	        return len
	      case 'utf8':
	      case 'utf-8':
	      case undefined:
	        return utf8ToBytes(string).length
	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return len * 2
	      case 'hex':
	        return len >>> 1
	      case 'base64':
	        return base64ToBytes(string).length
	      default:
	        if (loweredCase) return utf8ToBytes(string).length // assume utf8
	        encoding = ('' + encoding).toLowerCase()
	        loweredCase = true
	    }
	  }
	}
	Buffer.byteLength = byteLength

	function slowToString (encoding, start, end) {
	  var loweredCase = false

	  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
	  // property of a typed array.

	  // This behaves neither like String nor Uint8Array in that we set start/end
	  // to their upper/lower bounds if the value passed is out of range.
	  // undefined is handled specially as per ECMA-262 6th Edition,
	  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
	  if (start === undefined || start < 0) {
	    start = 0
	  }
	  // Return early if start > this.length. Done here to prevent potential uint32
	  // coercion fail below.
	  if (start > this.length) {
	    return ''
	  }

	  if (end === undefined || end > this.length) {
	    end = this.length
	  }

	  if (end <= 0) {
	    return ''
	  }

	  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
	  end >>>= 0
	  start >>>= 0

	  if (end <= start) {
	    return ''
	  }

	  if (!encoding) encoding = 'utf8'

	  while (true) {
	    switch (encoding) {
	      case 'hex':
	        return hexSlice(this, start, end)

	      case 'utf8':
	      case 'utf-8':
	        return utf8Slice(this, start, end)

	      case 'ascii':
	        return asciiSlice(this, start, end)

	      case 'latin1':
	      case 'binary':
	        return latin1Slice(this, start, end)

	      case 'base64':
	        return base64Slice(this, start, end)

	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return utf16leSlice(this, start, end)

	      default:
	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
	        encoding = (encoding + '').toLowerCase()
	        loweredCase = true
	    }
	  }
	}

	// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
	// Buffer instances.
	Buffer.prototype._isBuffer = true

	function swap (b, n, m) {
	  var i = b[n]
	  b[n] = b[m]
	  b[m] = i
	}

	Buffer.prototype.swap16 = function swap16 () {
	  var len = this.length
	  if (len % 2 !== 0) {
	    throw new RangeError('Buffer size must be a multiple of 16-bits')
	  }
	  for (var i = 0; i < len; i += 2) {
	    swap(this, i, i + 1)
	  }
	  return this
	}

	Buffer.prototype.swap32 = function swap32 () {
	  var len = this.length
	  if (len % 4 !== 0) {
	    throw new RangeError('Buffer size must be a multiple of 32-bits')
	  }
	  for (var i = 0; i < len; i += 4) {
	    swap(this, i, i + 3)
	    swap(this, i + 1, i + 2)
	  }
	  return this
	}

	Buffer.prototype.swap64 = function swap64 () {
	  var len = this.length
	  if (len % 8 !== 0) {
	    throw new RangeError('Buffer size must be a multiple of 64-bits')
	  }
	  for (var i = 0; i < len; i += 8) {
	    swap(this, i, i + 7)
	    swap(this, i + 1, i + 6)
	    swap(this, i + 2, i + 5)
	    swap(this, i + 3, i + 4)
	  }
	  return this
	}

	Buffer.prototype.toString = function toString () {
	  var length = this.length | 0
	  if (length === 0) return ''
	  if (arguments.length === 0) return utf8Slice(this, 0, length)
	  return slowToString.apply(this, arguments)
	}

	Buffer.prototype.equals = function equals (b) {
	  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
	  if (this === b) return true
	  return Buffer.compare(this, b) === 0
	}

	Buffer.prototype.inspect = function inspect () {
	  var str = ''
	  var max = exports.INSPECT_MAX_BYTES
	  if (this.length > 0) {
	    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
	    if (this.length > max) str += ' ... '
	  }
	  return '<Buffer ' + str + '>'
	}

	Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
	  if (!Buffer.isBuffer(target)) {
	    throw new TypeError('Argument must be a Buffer')
	  }

	  if (start === undefined) {
	    start = 0
	  }
	  if (end === undefined) {
	    end = target ? target.length : 0
	  }
	  if (thisStart === undefined) {
	    thisStart = 0
	  }
	  if (thisEnd === undefined) {
	    thisEnd = this.length
	  }

	  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
	    throw new RangeError('out of range index')
	  }

	  if (thisStart >= thisEnd && start >= end) {
	    return 0
	  }
	  if (thisStart >= thisEnd) {
	    return -1
	  }
	  if (start >= end) {
	    return 1
	  }

	  start >>>= 0
	  end >>>= 0
	  thisStart >>>= 0
	  thisEnd >>>= 0

	  if (this === target) return 0

	  var x = thisEnd - thisStart
	  var y = end - start
	  var len = Math.min(x, y)

	  var thisCopy = this.slice(thisStart, thisEnd)
	  var targetCopy = target.slice(start, end)

	  for (var i = 0; i < len; ++i) {
	    if (thisCopy[i] !== targetCopy[i]) {
	      x = thisCopy[i]
	      y = targetCopy[i]
	      break
	    }
	  }

	  if (x < y) return -1
	  if (y < x) return 1
	  return 0
	}

	// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
	// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
	//
	// Arguments:
	// - buffer - a Buffer to search
	// - val - a string, Buffer, or number
	// - byteOffset - an index into `buffer`; will be clamped to an int32
	// - encoding - an optional encoding, relevant is val is a string
	// - dir - true for indexOf, false for lastIndexOf
	function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
	  // Empty buffer means no match
	  if (buffer.length === 0) return -1

	  // Normalize byteOffset
	  if (typeof byteOffset === 'string') {
	    encoding = byteOffset
	    byteOffset = 0
	  } else if (byteOffset > 0x7fffffff) {
	    byteOffset = 0x7fffffff
	  } else if (byteOffset < -0x80000000) {
	    byteOffset = -0x80000000
	  }
	  byteOffset = +byteOffset  // Coerce to Number.
	  if (isNaN(byteOffset)) {
	    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
	    byteOffset = dir ? 0 : (buffer.length - 1)
	  }

	  // Normalize byteOffset: negative offsets start from the end of the buffer
	  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
	  if (byteOffset >= buffer.length) {
	    if (dir) return -1
	    else byteOffset = buffer.length - 1
	  } else if (byteOffset < 0) {
	    if (dir) byteOffset = 0
	    else return -1
	  }

	  // Normalize val
	  if (typeof val === 'string') {
	    val = Buffer.from(val, encoding)
	  }

	  // Finally, search either indexOf (if dir is true) or lastIndexOf
	  if (Buffer.isBuffer(val)) {
	    // Special case: looking for empty string/buffer always fails
	    if (val.length === 0) {
	      return -1
	    }
	    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
	  } else if (typeof val === 'number') {
	    val = val & 0xFF // Search for a byte value [0-255]
	    if (Buffer.TYPED_ARRAY_SUPPORT &&
	        typeof Uint8Array.prototype.indexOf === 'function') {
	      if (dir) {
	        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
	      } else {
	        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
	      }
	    }
	    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
	  }

	  throw new TypeError('val must be string, number or Buffer')
	}

	function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
	  var indexSize = 1
	  var arrLength = arr.length
	  var valLength = val.length

	  if (encoding !== undefined) {
	    encoding = String(encoding).toLowerCase()
	    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
	        encoding === 'utf16le' || encoding === 'utf-16le') {
	      if (arr.length < 2 || val.length < 2) {
	        return -1
	      }
	      indexSize = 2
	      arrLength /= 2
	      valLength /= 2
	      byteOffset /= 2
	    }
	  }

	  function read (buf, i) {
	    if (indexSize === 1) {
	      return buf[i]
	    } else {
	      return buf.readUInt16BE(i * indexSize)
	    }
	  }

	  var i
	  if (dir) {
	    var foundIndex = -1
	    for (i = byteOffset; i < arrLength; i++) {
	      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
	        if (foundIndex === -1) foundIndex = i
	        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
	      } else {
	        if (foundIndex !== -1) i -= i - foundIndex
	        foundIndex = -1
	      }
	    }
	  } else {
	    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
	    for (i = byteOffset; i >= 0; i--) {
	      var found = true
	      for (var j = 0; j < valLength; j++) {
	        if (read(arr, i + j) !== read(val, j)) {
	          found = false
	          break
	        }
	      }
	      if (found) return i
	    }
	  }

	  return -1
	}

	Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
	  return this.indexOf(val, byteOffset, encoding) !== -1
	}

	Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
	  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
	}

	Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
	  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
	}

	function hexWrite (buf, string, offset, length) {
	  offset = Number(offset) || 0
	  var remaining = buf.length - offset
	  if (!length) {
	    length = remaining
	  } else {
	    length = Number(length)
	    if (length > remaining) {
	      length = remaining
	    }
	  }

	  // must be an even number of digits
	  var strLen = string.length
	  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

	  if (length > strLen / 2) {
	    length = strLen / 2
	  }
	  for (var i = 0; i < length; ++i) {
	    var parsed = parseInt(string.substr(i * 2, 2), 16)
	    if (isNaN(parsed)) return i
	    buf[offset + i] = parsed
	  }
	  return i
	}

	function utf8Write (buf, string, offset, length) {
	  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
	}

	function asciiWrite (buf, string, offset, length) {
	  return blitBuffer(asciiToBytes(string), buf, offset, length)
	}

	function latin1Write (buf, string, offset, length) {
	  return asciiWrite(buf, string, offset, length)
	}

	function base64Write (buf, string, offset, length) {
	  return blitBuffer(base64ToBytes(string), buf, offset, length)
	}

	function ucs2Write (buf, string, offset, length) {
	  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
	}

	Buffer.prototype.write = function write (string, offset, length, encoding) {
	  // Buffer#write(string)
	  if (offset === undefined) {
	    encoding = 'utf8'
	    length = this.length
	    offset = 0
	  // Buffer#write(string, encoding)
	  } else if (length === undefined && typeof offset === 'string') {
	    encoding = offset
	    length = this.length
	    offset = 0
	  // Buffer#write(string, offset[, length][, encoding])
	  } else if (isFinite(offset)) {
	    offset = offset | 0
	    if (isFinite(length)) {
	      length = length | 0
	      if (encoding === undefined) encoding = 'utf8'
	    } else {
	      encoding = length
	      length = undefined
	    }
	  // legacy write(string, encoding, offset, length) - remove in v0.13
	  } else {
	    throw new Error(
	      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
	    )
	  }

	  var remaining = this.length - offset
	  if (length === undefined || length > remaining) length = remaining

	  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
	    throw new RangeError('Attempt to write outside buffer bounds')
	  }

	  if (!encoding) encoding = 'utf8'

	  var loweredCase = false
	  for (;;) {
	    switch (encoding) {
	      case 'hex':
	        return hexWrite(this, string, offset, length)

	      case 'utf8':
	      case 'utf-8':
	        return utf8Write(this, string, offset, length)

	      case 'ascii':
	        return asciiWrite(this, string, offset, length)

	      case 'latin1':
	      case 'binary':
	        return latin1Write(this, string, offset, length)

	      case 'base64':
	        // Warning: maxLength not taken into account in base64Write
	        return base64Write(this, string, offset, length)

	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return ucs2Write(this, string, offset, length)

	      default:
	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
	        encoding = ('' + encoding).toLowerCase()
	        loweredCase = true
	    }
	  }
	}

	Buffer.prototype.toJSON = function toJSON () {
	  return {
	    type: 'Buffer',
	    data: Array.prototype.slice.call(this._arr || this, 0)
	  }
	}

	function base64Slice (buf, start, end) {
	  if (start === 0 && end === buf.length) {
	    return base64.fromByteArray(buf)
	  } else {
	    return base64.fromByteArray(buf.slice(start, end))
	  }
	}

	function utf8Slice (buf, start, end) {
	  end = Math.min(buf.length, end)
	  var res = []

	  var i = start
	  while (i < end) {
	    var firstByte = buf[i]
	    var codePoint = null
	    var bytesPerSequence = (firstByte > 0xEF) ? 4
	      : (firstByte > 0xDF) ? 3
	      : (firstByte > 0xBF) ? 2
	      : 1

	    if (i + bytesPerSequence <= end) {
	      var secondByte, thirdByte, fourthByte, tempCodePoint

	      switch (bytesPerSequence) {
	        case 1:
	          if (firstByte < 0x80) {
	            codePoint = firstByte
	          }
	          break
	        case 2:
	          secondByte = buf[i + 1]
	          if ((secondByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
	            if (tempCodePoint > 0x7F) {
	              codePoint = tempCodePoint
	            }
	          }
	          break
	        case 3:
	          secondByte = buf[i + 1]
	          thirdByte = buf[i + 2]
	          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
	            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
	              codePoint = tempCodePoint
	            }
	          }
	          break
	        case 4:
	          secondByte = buf[i + 1]
	          thirdByte = buf[i + 2]
	          fourthByte = buf[i + 3]
	          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
	            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
	              codePoint = tempCodePoint
	            }
	          }
	      }
	    }

	    if (codePoint === null) {
	      // we did not generate a valid codePoint so insert a
	      // replacement char (U+FFFD) and advance only 1 byte
	      codePoint = 0xFFFD
	      bytesPerSequence = 1
	    } else if (codePoint > 0xFFFF) {
	      // encode to utf16 (surrogate pair dance)
	      codePoint -= 0x10000
	      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
	      codePoint = 0xDC00 | codePoint & 0x3FF
	    }

	    res.push(codePoint)
	    i += bytesPerSequence
	  }

	  return decodeCodePointsArray(res)
	}

	// Based on http://stackoverflow.com/a/22747272/680742, the browser with
	// the lowest limit is Chrome, with 0x10000 args.
	// We go 1 magnitude less, for safety
	var MAX_ARGUMENTS_LENGTH = 0x1000

	function decodeCodePointsArray (codePoints) {
	  var len = codePoints.length
	  if (len <= MAX_ARGUMENTS_LENGTH) {
	    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
	  }

	  // Decode in chunks to avoid "call stack size exceeded".
	  var res = ''
	  var i = 0
	  while (i < len) {
	    res += String.fromCharCode.apply(
	      String,
	      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
	    )
	  }
	  return res
	}

	function asciiSlice (buf, start, end) {
	  var ret = ''
	  end = Math.min(buf.length, end)

	  for (var i = start; i < end; ++i) {
	    ret += String.fromCharCode(buf[i] & 0x7F)
	  }
	  return ret
	}

	function latin1Slice (buf, start, end) {
	  var ret = ''
	  end = Math.min(buf.length, end)

	  for (var i = start; i < end; ++i) {
	    ret += String.fromCharCode(buf[i])
	  }
	  return ret
	}

	function hexSlice (buf, start, end) {
	  var len = buf.length

	  if (!start || start < 0) start = 0
	  if (!end || end < 0 || end > len) end = len

	  var out = ''
	  for (var i = start; i < end; ++i) {
	    out += toHex(buf[i])
	  }
	  return out
	}

	function utf16leSlice (buf, start, end) {
	  var bytes = buf.slice(start, end)
	  var res = ''
	  for (var i = 0; i < bytes.length; i += 2) {
	    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
	  }
	  return res
	}

	Buffer.prototype.slice = function slice (start, end) {
	  var len = this.length
	  start = ~~start
	  end = end === undefined ? len : ~~end

	  if (start < 0) {
	    start += len
	    if (start < 0) start = 0
	  } else if (start > len) {
	    start = len
	  }

	  if (end < 0) {
	    end += len
	    if (end < 0) end = 0
	  } else if (end > len) {
	    end = len
	  }

	  if (end < start) end = start

	  var newBuf
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    newBuf = this.subarray(start, end)
	    newBuf.__proto__ = Buffer.prototype
	  } else {
	    var sliceLen = end - start
	    newBuf = new Buffer(sliceLen, undefined)
	    for (var i = 0; i < sliceLen; ++i) {
	      newBuf[i] = this[i + start]
	    }
	  }

	  return newBuf
	}

	/*
	 * Need to make sure that buffer isn't trying to write out of bounds.
	 */
	function checkOffset (offset, ext, length) {
	  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
	  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
	}

	Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)

	  var val = this[offset]
	  var mul = 1
	  var i = 0
	  while (++i < byteLength && (mul *= 0x100)) {
	    val += this[offset + i] * mul
	  }

	  return val
	}

	Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) {
	    checkOffset(offset, byteLength, this.length)
	  }

	  var val = this[offset + --byteLength]
	  var mul = 1
	  while (byteLength > 0 && (mul *= 0x100)) {
	    val += this[offset + --byteLength] * mul
	  }

	  return val
	}

	Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 1, this.length)
	  return this[offset]
	}

	Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  return this[offset] | (this[offset + 1] << 8)
	}

	Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  return (this[offset] << 8) | this[offset + 1]
	}

	Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)

	  return ((this[offset]) |
	      (this[offset + 1] << 8) |
	      (this[offset + 2] << 16)) +
	      (this[offset + 3] * 0x1000000)
	}

	Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)

	  return (this[offset] * 0x1000000) +
	    ((this[offset + 1] << 16) |
	    (this[offset + 2] << 8) |
	    this[offset + 3])
	}

	Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)

	  var val = this[offset]
	  var mul = 1
	  var i = 0
	  while (++i < byteLength && (mul *= 0x100)) {
	    val += this[offset + i] * mul
	  }
	  mul *= 0x80

	  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

	  return val
	}

	Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)

	  var i = byteLength
	  var mul = 1
	  var val = this[offset + --i]
	  while (i > 0 && (mul *= 0x100)) {
	    val += this[offset + --i] * mul
	  }
	  mul *= 0x80

	  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

	  return val
	}

	Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 1, this.length)
	  if (!(this[offset] & 0x80)) return (this[offset])
	  return ((0xff - this[offset] + 1) * -1)
	}

	Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  var val = this[offset] | (this[offset + 1] << 8)
	  return (val & 0x8000) ? val | 0xFFFF0000 : val
	}

	Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  var val = this[offset + 1] | (this[offset] << 8)
	  return (val & 0x8000) ? val | 0xFFFF0000 : val
	}

	Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)

	  return (this[offset]) |
	    (this[offset + 1] << 8) |
	    (this[offset + 2] << 16) |
	    (this[offset + 3] << 24)
	}

	Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)

	  return (this[offset] << 24) |
	    (this[offset + 1] << 16) |
	    (this[offset + 2] << 8) |
	    (this[offset + 3])
	}

	Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	  return ieee754.read(this, offset, true, 23, 4)
	}

	Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	  return ieee754.read(this, offset, false, 23, 4)
	}

	Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 8, this.length)
	  return ieee754.read(this, offset, true, 52, 8)
	}

	Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 8, this.length)
	  return ieee754.read(this, offset, false, 52, 8)
	}

	function checkInt (buf, value, offset, ext, max, min) {
	  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
	  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
	  if (offset + ext > buf.length) throw new RangeError('Index out of range')
	}

	Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) {
	    var maxBytes = Math.pow(2, 8 * byteLength) - 1
	    checkInt(this, value, offset, byteLength, maxBytes, 0)
	  }

	  var mul = 1
	  var i = 0
	  this[offset] = value & 0xFF
	  while (++i < byteLength && (mul *= 0x100)) {
	    this[offset + i] = (value / mul) & 0xFF
	  }

	  return offset + byteLength
	}

	Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) {
	    var maxBytes = Math.pow(2, 8 * byteLength) - 1
	    checkInt(this, value, offset, byteLength, maxBytes, 0)
	  }

	  var i = byteLength - 1
	  var mul = 1
	  this[offset + i] = value & 0xFF
	  while (--i >= 0 && (mul *= 0x100)) {
	    this[offset + i] = (value / mul) & 0xFF
	  }

	  return offset + byteLength
	}

	Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
	  this[offset] = (value & 0xff)
	  return offset + 1
	}

	function objectWriteUInt16 (buf, value, offset, littleEndian) {
	  if (value < 0) value = 0xffff + value + 1
	  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
	    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
	      (littleEndian ? i : 1 - i) * 8
	  }
	}

	Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff)
	    this[offset + 1] = (value >>> 8)
	  } else {
	    objectWriteUInt16(this, value, offset, true)
	  }
	  return offset + 2
	}

	Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 8)
	    this[offset + 1] = (value & 0xff)
	  } else {
	    objectWriteUInt16(this, value, offset, false)
	  }
	  return offset + 2
	}

	function objectWriteUInt32 (buf, value, offset, littleEndian) {
	  if (value < 0) value = 0xffffffff + value + 1
	  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
	    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
	  }
	}

	Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset + 3] = (value >>> 24)
	    this[offset + 2] = (value >>> 16)
	    this[offset + 1] = (value >>> 8)
	    this[offset] = (value & 0xff)
	  } else {
	    objectWriteUInt32(this, value, offset, true)
	  }
	  return offset + 4
	}

	Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 24)
	    this[offset + 1] = (value >>> 16)
	    this[offset + 2] = (value >>> 8)
	    this[offset + 3] = (value & 0xff)
	  } else {
	    objectWriteUInt32(this, value, offset, false)
	  }
	  return offset + 4
	}

	Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) {
	    var limit = Math.pow(2, 8 * byteLength - 1)

	    checkInt(this, value, offset, byteLength, limit - 1, -limit)
	  }

	  var i = 0
	  var mul = 1
	  var sub = 0
	  this[offset] = value & 0xFF
	  while (++i < byteLength && (mul *= 0x100)) {
	    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
	      sub = 1
	    }
	    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
	  }

	  return offset + byteLength
	}

	Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) {
	    var limit = Math.pow(2, 8 * byteLength - 1)

	    checkInt(this, value, offset, byteLength, limit - 1, -limit)
	  }

	  var i = byteLength - 1
	  var mul = 1
	  var sub = 0
	  this[offset + i] = value & 0xFF
	  while (--i >= 0 && (mul *= 0x100)) {
	    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
	      sub = 1
	    }
	    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
	  }

	  return offset + byteLength
	}

	Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
	  if (value < 0) value = 0xff + value + 1
	  this[offset] = (value & 0xff)
	  return offset + 1
	}

	Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff)
	    this[offset + 1] = (value >>> 8)
	  } else {
	    objectWriteUInt16(this, value, offset, true)
	  }
	  return offset + 2
	}

	Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 8)
	    this[offset + 1] = (value & 0xff)
	  } else {
	    objectWriteUInt16(this, value, offset, false)
	  }
	  return offset + 2
	}

	Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff)
	    this[offset + 1] = (value >>> 8)
	    this[offset + 2] = (value >>> 16)
	    this[offset + 3] = (value >>> 24)
	  } else {
	    objectWriteUInt32(this, value, offset, true)
	  }
	  return offset + 4
	}

	Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
	  if (value < 0) value = 0xffffffff + value + 1
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 24)
	    this[offset + 1] = (value >>> 16)
	    this[offset + 2] = (value >>> 8)
	    this[offset + 3] = (value & 0xff)
	  } else {
	    objectWriteUInt32(this, value, offset, false)
	  }
	  return offset + 4
	}

	function checkIEEE754 (buf, value, offset, ext, max, min) {
	  if (offset + ext > buf.length) throw new RangeError('Index out of range')
	  if (offset < 0) throw new RangeError('Index out of range')
	}

	function writeFloat (buf, value, offset, littleEndian, noAssert) {
	  if (!noAssert) {
	    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
	  }
	  ieee754.write(buf, value, offset, littleEndian, 23, 4)
	  return offset + 4
	}

	Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
	  return writeFloat(this, value, offset, true, noAssert)
	}

	Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
	  return writeFloat(this, value, offset, false, noAssert)
	}

	function writeDouble (buf, value, offset, littleEndian, noAssert) {
	  if (!noAssert) {
	    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
	  }
	  ieee754.write(buf, value, offset, littleEndian, 52, 8)
	  return offset + 8
	}

	Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
	  return writeDouble(this, value, offset, true, noAssert)
	}

	Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
	  return writeDouble(this, value, offset, false, noAssert)
	}

	// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
	Buffer.prototype.copy = function copy (target, targetStart, start, end) {
	  if (!start) start = 0
	  if (!end && end !== 0) end = this.length
	  if (targetStart >= target.length) targetStart = target.length
	  if (!targetStart) targetStart = 0
	  if (end > 0 && end < start) end = start

	  // Copy 0 bytes; we're done
	  if (end === start) return 0
	  if (target.length === 0 || this.length === 0) return 0

	  // Fatal error conditions
	  if (targetStart < 0) {
	    throw new RangeError('targetStart out of bounds')
	  }
	  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
	  if (end < 0) throw new RangeError('sourceEnd out of bounds')

	  // Are we oob?
	  if (end > this.length) end = this.length
	  if (target.length - targetStart < end - start) {
	    end = target.length - targetStart + start
	  }

	  var len = end - start
	  var i

	  if (this === target && start < targetStart && targetStart < end) {
	    // descending copy from end
	    for (i = len - 1; i >= 0; --i) {
	      target[i + targetStart] = this[i + start]
	    }
	  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
	    // ascending copy from start
	    for (i = 0; i < len; ++i) {
	      target[i + targetStart] = this[i + start]
	    }
	  } else {
	    Uint8Array.prototype.set.call(
	      target,
	      this.subarray(start, start + len),
	      targetStart
	    )
	  }

	  return len
	}

	// Usage:
	//    buffer.fill(number[, offset[, end]])
	//    buffer.fill(buffer[, offset[, end]])
	//    buffer.fill(string[, offset[, end]][, encoding])
	Buffer.prototype.fill = function fill (val, start, end, encoding) {
	  // Handle string cases:
	  if (typeof val === 'string') {
	    if (typeof start === 'string') {
	      encoding = start
	      start = 0
	      end = this.length
	    } else if (typeof end === 'string') {
	      encoding = end
	      end = this.length
	    }
	    if (val.length === 1) {
	      var code = val.charCodeAt(0)
	      if (code < 256) {
	        val = code
	      }
	    }
	    if (encoding !== undefined && typeof encoding !== 'string') {
	      throw new TypeError('encoding must be a string')
	    }
	    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
	      throw new TypeError('Unknown encoding: ' + encoding)
	    }
	  } else if (typeof val === 'number') {
	    val = val & 255
	  }

	  // Invalid ranges are not set to a default, so can range check early.
	  if (start < 0 || this.length < start || this.length < end) {
	    throw new RangeError('Out of range index')
	  }

	  if (end <= start) {
	    return this
	  }

	  start = start >>> 0
	  end = end === undefined ? this.length : end >>> 0

	  if (!val) val = 0

	  var i
	  if (typeof val === 'number') {
	    for (i = start; i < end; ++i) {
	      this[i] = val
	    }
	  } else {
	    var bytes = Buffer.isBuffer(val)
	      ? val
	      : utf8ToBytes(new Buffer(val, encoding).toString())
	    var len = bytes.length
	    for (i = 0; i < end - start; ++i) {
	      this[i + start] = bytes[i % len]
	    }
	  }

	  return this
	}

	// HELPER FUNCTIONS
	// ================

	var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

	function base64clean (str) {
	  // Node strips out invalid characters like \n and \t from the string, base64-js does not
	  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
	  // Node converts strings with length < 2 to ''
	  if (str.length < 2) return ''
	  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
	  while (str.length % 4 !== 0) {
	    str = str + '='
	  }
	  return str
	}

	function stringtrim (str) {
	  if (str.trim) return str.trim()
	  return str.replace(/^\s+|\s+$/g, '')
	}

	function toHex (n) {
	  if (n < 16) return '0' + n.toString(16)
	  return n.toString(16)
	}

	function utf8ToBytes (string, units) {
	  units = units || Infinity
	  var codePoint
	  var length = string.length
	  var leadSurrogate = null
	  var bytes = []

	  for (var i = 0; i < length; ++i) {
	    codePoint = string.charCodeAt(i)

	    // is surrogate component
	    if (codePoint > 0xD7FF && codePoint < 0xE000) {
	      // last char was a lead
	      if (!leadSurrogate) {
	        // no lead yet
	        if (codePoint > 0xDBFF) {
	          // unexpected trail
	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	          continue
	        } else if (i + 1 === length) {
	          // unpaired lead
	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	          continue
	        }

	        // valid lead
	        leadSurrogate = codePoint

	        continue
	      }

	      // 2 leads in a row
	      if (codePoint < 0xDC00) {
	        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	        leadSurrogate = codePoint
	        continue
	      }

	      // valid surrogate pair
	      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
	    } else if (leadSurrogate) {
	      // valid bmp char, but last char was a lead
	      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	    }

	    leadSurrogate = null

	    // encode utf8
	    if (codePoint < 0x80) {
	      if ((units -= 1) < 0) break
	      bytes.push(codePoint)
	    } else if (codePoint < 0x800) {
	      if ((units -= 2) < 0) break
	      bytes.push(
	        codePoint >> 0x6 | 0xC0,
	        codePoint & 0x3F | 0x80
	      )
	    } else if (codePoint < 0x10000) {
	      if ((units -= 3) < 0) break
	      bytes.push(
	        codePoint >> 0xC | 0xE0,
	        codePoint >> 0x6 & 0x3F | 0x80,
	        codePoint & 0x3F | 0x80
	      )
	    } else if (codePoint < 0x110000) {
	      if ((units -= 4) < 0) break
	      bytes.push(
	        codePoint >> 0x12 | 0xF0,
	        codePoint >> 0xC & 0x3F | 0x80,
	        codePoint >> 0x6 & 0x3F | 0x80,
	        codePoint & 0x3F | 0x80
	      )
	    } else {
	      throw new Error('Invalid code point')
	    }
	  }

	  return bytes
	}

	function asciiToBytes (str) {
	  var byteArray = []
	  for (var i = 0; i < str.length; ++i) {
	    // Node's code seems to be doing this and not & 0x7F..
	    byteArray.push(str.charCodeAt(i) & 0xFF)
	  }
	  return byteArray
	}

	function utf16leToBytes (str, units) {
	  var c, hi, lo
	  var byteArray = []
	  for (var i = 0; i < str.length; ++i) {
	    if ((units -= 2) < 0) break

	    c = str.charCodeAt(i)
	    hi = c >> 8
	    lo = c % 256
	    byteArray.push(lo)
	    byteArray.push(hi)
	  }

	  return byteArray
	}

	function base64ToBytes (str) {
	  return base64.toByteArray(base64clean(str))
	}

	function blitBuffer (src, dst, offset, length) {
	  for (var i = 0; i < length; ++i) {
	    if ((i + offset >= dst.length) || (i >= src.length)) break
	    dst[i + offset] = src[i]
	  }
	  return i
	}

	function isnan (val) {
	  return val !== val // eslint-disable-line no-self-compare
	}

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 4 */
/***/ function(module, exports) {

	'use strict'

	exports.byteLength = byteLength
	exports.toByteArray = toByteArray
	exports.fromByteArray = fromByteArray

	var lookup = []
	var revLookup = []
	var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

	var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
	for (var i = 0, len = code.length; i < len; ++i) {
	  lookup[i] = code[i]
	  revLookup[code.charCodeAt(i)] = i
	}

	revLookup['-'.charCodeAt(0)] = 62
	revLookup['_'.charCodeAt(0)] = 63

	function placeHoldersCount (b64) {
	  var len = b64.length
	  if (len % 4 > 0) {
	    throw new Error('Invalid string. Length must be a multiple of 4')
	  }

	  // the number of equal signs (place holders)
	  // if there are two placeholders, than the two characters before it
	  // represent one byte
	  // if there is only one, then the three characters before it represent 2 bytes
	  // this is just a cheap hack to not do indexOf twice
	  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0
	}

	function byteLength (b64) {
	  // base64 is 4/3 + up to two characters of the original data
	  return b64.length * 3 / 4 - placeHoldersCount(b64)
	}

	function toByteArray (b64) {
	  var i, j, l, tmp, placeHolders, arr
	  var len = b64.length
	  placeHolders = placeHoldersCount(b64)

	  arr = new Arr(len * 3 / 4 - placeHolders)

	  // if there are placeholders, only get up to the last complete 4 chars
	  l = placeHolders > 0 ? len - 4 : len

	  var L = 0

	  for (i = 0, j = 0; i < l; i += 4, j += 3) {
	    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]
	    arr[L++] = (tmp >> 16) & 0xFF
	    arr[L++] = (tmp >> 8) & 0xFF
	    arr[L++] = tmp & 0xFF
	  }

	  if (placeHolders === 2) {
	    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)
	    arr[L++] = tmp & 0xFF
	  } else if (placeHolders === 1) {
	    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)
	    arr[L++] = (tmp >> 8) & 0xFF
	    arr[L++] = tmp & 0xFF
	  }

	  return arr
	}

	function tripletToBase64 (num) {
	  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
	}

	function encodeChunk (uint8, start, end) {
	  var tmp
	  var output = []
	  for (var i = start; i < end; i += 3) {
	    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
	    output.push(tripletToBase64(tmp))
	  }
	  return output.join('')
	}

	function fromByteArray (uint8) {
	  var tmp
	  var len = uint8.length
	  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
	  var output = ''
	  var parts = []
	  var maxChunkLength = 16383 // must be multiple of 3

	  // go through the array every three bytes, we'll deal with trailing stuff later
	  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
	    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
	  }

	  // pad the end with zeros, but make sure to not forget the extra bytes
	  if (extraBytes === 1) {
	    tmp = uint8[len - 1]
	    output += lookup[tmp >> 2]
	    output += lookup[(tmp << 4) & 0x3F]
	    output += '=='
	  } else if (extraBytes === 2) {
	    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])
	    output += lookup[tmp >> 10]
	    output += lookup[(tmp >> 4) & 0x3F]
	    output += lookup[(tmp << 2) & 0x3F]
	    output += '='
	  }

	  parts.push(output)

	  return parts.join('')
	}


/***/ },
/* 5 */
/***/ function(module, exports) {

	exports.read = function (buffer, offset, isLE, mLen, nBytes) {
	  var e, m
	  var eLen = nBytes * 8 - mLen - 1
	  var eMax = (1 << eLen) - 1
	  var eBias = eMax >> 1
	  var nBits = -7
	  var i = isLE ? (nBytes - 1) : 0
	  var d = isLE ? -1 : 1
	  var s = buffer[offset + i]

	  i += d

	  e = s & ((1 << (-nBits)) - 1)
	  s >>= (-nBits)
	  nBits += eLen
	  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

	  m = e & ((1 << (-nBits)) - 1)
	  e >>= (-nBits)
	  nBits += mLen
	  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

	  if (e === 0) {
	    e = 1 - eBias
	  } else if (e === eMax) {
	    return m ? NaN : ((s ? -1 : 1) * Infinity)
	  } else {
	    m = m + Math.pow(2, mLen)
	    e = e - eBias
	  }
	  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
	}

	exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
	  var e, m, c
	  var eLen = nBytes * 8 - mLen - 1
	  var eMax = (1 << eLen) - 1
	  var eBias = eMax >> 1
	  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
	  var i = isLE ? 0 : (nBytes - 1)
	  var d = isLE ? 1 : -1
	  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

	  value = Math.abs(value)

	  if (isNaN(value) || value === Infinity) {
	    m = isNaN(value) ? 1 : 0
	    e = eMax
	  } else {
	    e = Math.floor(Math.log(value) / Math.LN2)
	    if (value * (c = Math.pow(2, -e)) < 1) {
	      e--
	      c *= 2
	    }
	    if (e + eBias >= 1) {
	      value += rt / c
	    } else {
	      value += rt * Math.pow(2, 1 - eBias)
	    }
	    if (value * c >= 2) {
	      e++
	      c /= 2
	    }

	    if (e + eBias >= eMax) {
	      m = 0
	      e = eMax
	    } else if (e + eBias >= 1) {
	      m = (value * c - 1) * Math.pow(2, mLen)
	      e = e + eBias
	    } else {
	      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
	      e = 0
	    }
	  }

	  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

	  e = (e << mLen) | m
	  eLen += mLen
	  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

	  buffer[offset + i - d] |= s * 128
	}


/***/ },
/* 6 */
/***/ function(module, exports) {

	var toString = {}.toString;

	module.exports = Array.isArray || function (arr) {
	  return toString.call(arr) == '[object Array]';
	};


/***/ },
/* 7 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * A structure that contains a point in a two-dimensional coordinate system.
	 * @access public
	 * @see https://developer.apple.com/reference/coregraphics/cgpoint
	 */

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var CGPoint = function () {
	  // Creating Point Values

	  /**
	   * Creates a point with coordinates specified as integer values.   
	   * @access public
	   * @constructor
	   * @param {number} x - 
	   * @param {number} y - 
	   * @see https://developer.apple.com/reference/coregraphics/cgpoint/1455965-init
	   */
	  function CGPoint(x, y) {
	    _classCallCheck(this, CGPoint);

	    // Geometric Properties
	    this.x = x;
	    this.y = y;
	  }

	  // Special Values

	  /**
	   * The point with location (0,0).
	   * @type {CGPoint}
	   * @desc 
	   * @see https://developer.apple.com/reference/coregraphics/cgpoint/1454433-zero
	   */


	  _createClass(CGPoint, [{
	    key: 'applying',


	    // Geometric Properties

	    // Transforming Points

	    /**
	     * Returns the point resulting from an affine transformation of an existing point.
	     * @access public
	     * @param {CGAffineTransform} t - The affine transform to apply. 
	     * @returns {CGPoint} - 
	     * @see https://developer.apple.com/reference/coregraphics/cgpoint/1454251-applying
	     */
	    value: function applying(t) {
	      return null;
	    }

	    // Alternate Representations

	    /**
	     * Creates a point from a canonical dictionary representation.
	     * @access public
	     * @param {Map} dict - A dictionary containing x and y values for the point to create, in the format used by the dictionaryRepresentation property.
	     * @returns {void}
	     * @see https://developer.apple.com/reference/coregraphics/cgpoint/2427118-init
	     */

	  }, {
	    key: 'equalTo',


	    // Comparing Points

	    /**
	     * Returns whether two points are equal. 
	     * @access public
	     * @param {CGPoint} point2 - 
	     * @returns {boolean} - 
	     * @see https://developer.apple.com/reference/coregraphics/cgpoint/1456179-equalto
	     */
	    value: function equalTo(point2) {
	      var epsilon = 0.00001;
	      return Math.abs(this.x - point2.x) < epsilon && Math.abs(this.y - point2.y) < epsilon;
	    }

	    /**
	     * @access public
	     * @returns {CGPoint} -
	     */

	  }, {
	    key: 'copy',
	    value: function copy() {
	      return new CGPoint(this.x, this.y);
	    }
	  }, {
	    key: 'zero',
	    value: function zero() {
	      return new CGPoint(0, 0);
	    }

	    /**
	     * @access public
	     * @param {CGPoint} p -
	     * @returns {CGPoint} -
	     */

	  }, {
	    key: 'add',
	    value: function add(p) {
	      var r = new CGPoint();
	      r.x = this.x + p.x;
	      r.y = this.y + p.y;
	      return r;
	    }

	    /**
	     * @access public
	     * @param {CGPoint} p -
	     * @returns {CGPoint} -
	     */

	  }, {
	    key: 'sub',
	    value: function sub(p) {
	      var r = new CGPoint();
	      r.x = this.x - p.x;
	      r.y = this.y - p.y;
	      return r;
	    }

	    /**
	     * @access public
	     * @param {number} n -
	     * @returns {CGPoint} -
	     */

	  }, {
	    key: 'mul',
	    value: function mul(n) {
	      var r = new CGPoint();
	      r.x = this.x * n;
	      r.y = this.y * n;
	      return r;
	    }

	    /**
	     * @access public
	     * @param {CGPoint} p -
	     * @returns {number} -
	     */

	  }, {
	    key: 'dot',
	    value: function dot(p) {
	      return this.x * p.x + this.y * p.y;
	    }

	    /**
	     * @access public
	     * @param {CGPoint} p -
	     * @param {number} rate -
	     * @returns {CGPoint} -
	     */

	  }, {
	    key: 'lerp',
	    value: function lerp(p, rate) {
	      var r = new CGPoint();
	      r.x = this.x + rate * (p.x - this.x);
	      r.y = this.y + rate * (p.y - this.y);
	      return r;
	    }

	    /**
	     * @access public
	     * @returns {CGPoint} -
	     */

	  }, {
	    key: 'normalize',
	    value: function normalize() {
	      var len = this.length();
	      var r = new CGPoint();
	      if (len === 0) {
	        return r;
	      }
	      var sqr = 1.0 / len;
	      r.x = this.x * sqr;
	      r.y = this.y * sqr;
	      return r;
	    }

	    /**
	     * @access public
	     * @returns {number} -
	     */

	  }, {
	    key: 'length',
	    value: function length() {
	      return Math.sqrt(this.x * this.x + this.y * this.y);
	    }

	    /**
	     * @access public
	     * @returns {number[]} -
	     */

	  }, {
	    key: 'floatArray',
	    value: function floatArray() {
	      return [this.x, this.y];
	    }

	    /**
	     * @access public
	     * @returns {Float32Array} -
	     */

	  }, {
	    key: 'float32Array',
	    value: function float32Array() {
	      return new Float32Array([this.x, this.y]);
	    }
	  }, {
	    key: 'dictionaryRepresentation',


	    /**
	     * Returns a dictionary representation of the specified point.
	     * @type {Map}
	     * @desc 
	     * @see https://developer.apple.com/reference/coregraphics/cgpoint/1455382-dictionaryrepresentation
	     */
	    get: function get() {
	      var map = new Map();
	      map.set('x', this.x);
	      map.set('y', this.y);
	      return map;
	    }

	    /**
	     * A textual representation of the point's coordinate values. 
	     * @type {string}
	     * @desc 
	     * @see https://developer.apple.com/reference/coregraphics/cgpoint/1645825-debugdescription
	     */

	  }, {
	    key: 'debugDescription',
	    get: function get() {
	      return '{x: ' + this.x + ', y: ' + this.y + '}';
	    }

	    /**
	     * A representation of the point's structure and display style for use in debugging.
	     * @type {Mirror}
	     * @desc Mirrors are used by playgrounds and the debugger.
	     * @see https://developer.apple.com/reference/coregraphics/cgpoint/1645834-custommirror
	     */

	  }, {
	    key: 'customMirror',
	    get: function get() {
	      return null;
	    }

	    /**
	     * A representation of the point for use in Playgrounds.
	     * @type {PlaygroundQuickLook}
	     * @desc 
	     * @see https://developer.apple.com/reference/coregraphics/cgpoint/1645835-customplaygroundquicklook
	     */

	  }, {
	    key: 'customPlaygroundQuickLook',
	    get: function get() {
	      return null;
	    }
	  }], [{
	    key: 'pointWithDictionaryRepresentation',
	    value: function pointWithDictionaryRepresentation(dict) {
	      return new CGPoint(dict.get('x'), dict.get('y'));
	    }
	  }, {
	    key: 'zero',
	    get: function get() {
	      return new CGPoint(0, 0);
	    }
	  }]);

	  return CGPoint;
	}();

	exports.default = CGPoint;

/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _CGPoint = __webpack_require__(7);

	var _CGPoint2 = _interopRequireDefault(_CGPoint);

	var _CGSize = __webpack_require__(9);

	var _CGSize2 = _interopRequireDefault(_CGSize);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	/**
	 * A structure that contains the location and dimensions of a rectangle.
	 * @access public
	 * @see https://developer.apple.com/reference/coregraphics/cgrect
	 */
	var CGRect = function () {
	  // Creating Rectangle Values

	  /**
	   * Creates a rectangle with the specified origin and size.
	   * @access public
	   * @constructor
	   * @param {CGPoint} origin - 
	   * @param {CGSize} size - 
	   * @see https://developer.apple.com/reference/coregraphics/cgrect/1454856-init
	   */
	  function CGRect(origin, size) {
	    _classCallCheck(this, CGRect);

	    // Basic Geometric Properties
	    this.origin = origin.copy();
	    this.size = size.copy();
	  }

	  // Special Values

	  /**
	   * The rectangle whose origin and size are both zero.
	   * @type {CGRect}
	   * @desc The zero rectangle is equivalent to one created by calling CGRect(x: 0, y: 0, width: 0, height: 0).
	   * @see https://developer.apple.com/reference/coregraphics/cgrect/1455437-zero
	   */


	  _createClass(CGRect, [{
	    key: 'applying',


	    // Creating Derived Rectangles

	    /**
	     * Applies an affine transform to a rectangle.
	     * @access public
	     * @param {CGAffineTransform} t - The affine transform to apply to the rect parameter.
	     * @returns {CGRect} - 
	     * @desc Because affine transforms do not preserve rectangles in general, this function returns the smallest rectangle that contains the transformed corner points of the rect parameter. If the affine transform t consists solely of scaling and translation operations, then the returned rectangle coincides with the rectangle constructed from the four transformed corners.
	     * @see https://developer.apple.com/reference/coregraphics/cgrect/1455875-applying
	     */
	    value: function applying(t) {
	      return null;
	    }

	    /**
	     * Returns a rectangle that is smaller or larger than the source rectangle, with the same center point.
	     * @access public
	     * @param {number} dx - The x-coordinate value to use for adjusting the source rectangle. To create an inset rectangle, specify a positive value. To create a larger, encompassing rectangle, specify a negative value.
	     * @param {number} dy - The y-coordinate value to use for adjusting the source rectangle. To create an inset rectangle, specify a positive value. To create a larger, encompassing rectangle, specify a negative value.
	     * @returns {CGRect} - 
	     * @desc The rectangle is standardized and then the inset parameters are applied. If the resulting rectangle would have a negative height or width, a null rectangle is returned.
	     * @see https://developer.apple.com/reference/coregraphics/cgrect/1454218-insetby
	     */

	  }, {
	    key: 'insetBy',
	    value: function insetBy(dx, dy) {
	      var newX = this.minX + dx;
	      var newY = this.minY + dy;
	      var newWidth = this.size.width - dx * 2;
	      var newHeight = this.size.height - dy * 2;
	      return new CGRect(new _CGPoint2.default(newX, newY), new _CGSize2.default(newWidth, newHeight));
	    }

	    /**
	     * Returns a rectangle with an origin that is offset from that of the source rectangle.
	     * @access public
	     * @param {number} dx - The offset value for the x-coordinate.
	     * @param {number} dy - The offset value for the  y-coordinate.
	     * @returns {CGRect} - 
	     * @see https://developer.apple.com/reference/coregraphics/cgrect/1454841-offsetby
	     */

	  }, {
	    key: 'offsetBy',
	    value: function offsetBy(dx, dy) {
	      return new CGRect(new _CGPoint2.default(this.origin.x + dx, this.origin.y + dy), this.size);
	    }

	    /**
	     * Returns the smallest rectangle that contains the two source rectangles.
	     * @access public
	     * @param {CGRect} r2 - Another rectangle to be combined with this rectangle.
	     * @returns {CGRect} - 
	     * @desc Both rectangles are standardized prior to calculating the union. If either of the rectangles is a null rectangle, a copy of the other rectangle is returned (resulting in a null rectangle if both rectangles are null). Otherwise a rectangle that completely contains the source rectangles is returned.
	     * @see https://developer.apple.com/reference/coregraphics/cgrect/1455837-union
	     */

	  }, {
	    key: 'union',
	    value: function union(r2) {
	      if (this.isNull && r2.isNull) {
	        return new CGRect(new _CGPoint2.default(0, 0), null);
	      } else if (this.isNull) {
	        return r2.copy();
	      } else if (r2.isNull) {
	        return this.copy();
	      }

	      var minX = this.minX < r2.minX ? this.minX : r2.minX;
	      var maxX = this.maxX > r2.maxX ? this.maxX : r2.maxX;
	      var minY = this.minY < r2.minY ? this.minY : r2.minY;
	      var maxY = this.maxY > r2.maxY ? this.maxY : r2.maxY;
	      var width = maxX - minX;
	      var height = maxY - minY;
	      return new CGRect(new _CGPoint2.default(minX, minY), new _CGSize2.default(width, height));
	    }

	    /**
	     * Returns the intersection of two rectangles.
	     * @access public
	     * @param {CGRect} r2 - Another rectangle to intersect with this rectangle.
	     * @returns {CGRect} - 
	     * @desc Both rectangles are standardized prior to calculating the intersection.
	     * @see https://developer.apple.com/reference/coregraphics/cgrect/1455346-intersection
	     */

	  }, {
	    key: 'intersection',
	    value: function intersection(r2) {
	      if (this.isNull || r2.isNull) {
	        return new CGRect(new _CGPoint2.default(0, 0), null);
	      }
	      var minX = this.minX > r2.minX ? this.minX : r2.minX;
	      var maxX = this.maxX < r2.maxX ? this.maxX : r2.maxX;
	      var minY = this.minY > r2.minY ? this.minY : r2.minY;
	      var maxY = this.maxY < r2.maxY ? this.maxY : r2.maxY;
	      var width = maxX - minX;
	      var height = maxY - minY;
	      if (width < 0 || height < 0) {
	        return new CGRect(new _CGPoint2.default(0, 0), null);
	      }
	      return new CGRect(new _CGPoint2.default(minX, minY), new _CGSize2.default(width, height));
	    }

	    /**
	     * Creates two rectangles by dividing the original rectangle. 
	     * @access public
	     * @param {number} atDistance - A distance from the rectangle side specified in the fromEdge parameter, defining the line along which to divide the rectangle.
	     * @param {CGRectEdge} fromEdge - The side of the rectangle from which to measure the atDistance parameter, defining the line along which to divide the rectangle.
	     * @returns {{slice: CGRect, remainder: CGRect}} - 
	     * @desc Together the fromEdge and atDistance parameters define a line (parallel to the specified edge of the rectangle and at the specified distance from that edge) that divides the rectangle into two component rectangles.
	     * @see https://developer.apple.com/reference/coregraphics/cgrect/2299988-divided
	     */

	  }, {
	    key: 'dividedFrom',
	    value: function dividedFrom(atDistance, fromEdge) {
	      return null;
	    }
	    /**
	     * Returns a rectangle with a positive width and height.
	     * @type {CGRect}
	     * @desc 
	     * @see https://developer.apple.com/reference/coregraphics/cgrect/1456432-standardized
	     */

	  }, {
	    key: 'intersects',


	    // Checking Characteristics

	    /**
	     * Returns whether two rectangles intersect.
	     * @access public
	     * @param {CGRect} rect2 - The rectangle to test for intersection with this rectangle.
	     * @returns {boolean} - 
	     * @see https://developer.apple.com/reference/coregraphics/cgrect/1454747-intersects
	     */
	    value: function intersects(rect2) {
	      var r = this.intersection(rect2);
	      return this.width > 0 && this.height > 0;
	    }

	    /**
	     * Returns whether a rectangle contains a specified point.
	     * @access public
	     * @param {CGPoint} point - The point to examine. 
	     * @returns {boolean} - 
	     * @desc A point is considered inside the rectangle if its coordinates lie inside the rectangle or on the minimum X or minimum Y edge.
	     * @see https://developer.apple.com/reference/coregraphics/cgrect/1456316-contains
	     */

	  }, {
	    key: 'contains',
	    value: function contains(point) {
	      return point.x >= this.minX && point.x <= this.maxX && point.y >= this.minY && point.y <= this.maxY;
	    }

	    /**
	     * Returns whether a rectangle has zero width or height, or is a null rectangle.
	     * @type {boolean}
	     * @desc An empty rectangle is either a null rectangle or a valid rectangle with zero height or width.
	     * @see https://developer.apple.com/reference/coregraphics/cgrect/1454917-isempty
	     */

	  }, {
	    key: 'initDictionaryRepresentation',


	    // Alternate Representations

	    /**
	     * Creates a rectangle from a canonical dictionary representation. 
	     * @access public
	     * @param {Map} dict - A dictionary containing x, y, width, and height values for the rectangle to create, in the format used by the dictionaryRepresentation property.
	     * @returns {void}
	     * @see https://developer.apple.com/reference/coregraphics/cgrect/2427139-init
	     */
	    value: function initDictionaryRepresentation(dict) {
	      // Basic Geometric Properties
	      this.origin = dict.get('origin');
	      this.size = dict.get('size');
	    }

	    /**
	     * Returns a dictionary representation of the provided rectangle.
	     * @type {Map}
	     * @desc 
	     * @see https://developer.apple.com/reference/coregraphics/cgrect/1455760-dictionaryrepresentation
	     */

	  }, {
	    key: 'equalTo',


	    // Comparing Rectangles

	    /**
	     * Returns whether two rectangles are equal in size and position.
	     * @access public
	     * @param {CGRect} rect2 - The rectangle to compare this rectangle with.
	     * @returns {boolean} - 
	     * @see https://developer.apple.com/reference/coregraphics/cgrect/1456516-equalto
	     */
	    value: function equalTo(rect2) {
	      if (this.origin === null || rect2.origin === null) {
	        return false;
	      }
	      if (this.size === null || rect2.size === null) {
	        return false;
	      }

	      return this.origin.equalTo(rect2.origin) && this.size.equalTo(rect2.size);
	    }
	  }, {
	    key: 'zero',
	    value: function zero() {
	      return new CGRect(new _CGPoint2.default(0, 0), new CGRect(0, 0));
	    }
	  }, {
	    key: 'add',
	    value: function add(rect2) {
	      return new CGRect(this.origin.add(rect2.origin), this.size.add(rect2.size));
	    }
	  }, {
	    key: 'sub',
	    value: function sub(rect2) {
	      return new CGRect(this.origin.sub(rect2.origin), this.size.sub(rect2.size));
	    }

	    /**
	     * @access public
	     * @param {CGRect} r -
	     * @param {number} rate -
	     * @returns {CGRect} -
	     */

	  }, {
	    key: 'lerp',
	    value: function lerp(r, rate) {
	      var origin = this.origin.lerp(r.origin, rate);
	      var size = this.size.lerp(r.size, rate);
	      return new CGRect(origin, size);
	    }
	  }, {
	    key: 'copy',
	    value: function copy() {
	      return new CGRect(this.origin, this.size);
	    }

	    /**
	     * @access public
	     * @param {number} x -
	     * @param {number} y -
	     * @param {number} width -
	     * @param {number} height -
	     * @returns {CGRect} -
	     */

	  }, {
	    key: 'height',


	    // Basic Geometric Properties

	    // Calculated Geometric Properties
	    /**
	     * Returns the height of a rectangle.
	     * @type {number}
	     * @desc Regardless of whether the height is stored in the CGRect data structure as a positive or negative number, this function returns the height as if the rectangle were standardized. That is, the result is never a negative number.
	     * @see https://developer.apple.com/reference/coregraphics/cgrect/1455645-height
	     */
	    get: function get() {
	      if (this.isNull) {
	        return 0;
	      }
	      return Math.abs(this.size.height);
	    }
	    /**
	     * Returns the width of a rectangle.
	     * @type {number}
	     * @desc Regardless of whether the width is stored in the CGRect data structure as a positive or negative number, this function returns the width as if the rectangle were standardized.  That is, the result is never a negative number.
	     * @see https://developer.apple.com/reference/coregraphics/cgrect/1454758-width
	     */

	  }, {
	    key: 'width',
	    get: function get() {
	      if (this.isNull) {
	        return 0;
	      }
	      return Math.abs(this.size.width);
	    }

	    /**
	     * Returns the smallest value for the x-coordinate of the rectangle.
	     * @type {number}
	     * @desc 
	     * @see https://developer.apple.com/reference/coregraphics/cgrect/1455948-minx
	     */

	  }, {
	    key: 'minX',
	    get: function get() {
	      if (this.size.width < 0) {
	        return this.origin.x + this.size.width;
	      }
	      return this.origin.x;
	    }

	    /**
	     * Returns the x- coordinate that establishes the center of a rectangle.
	     * @type {number}
	     * @desc 
	     * @see https://developer.apple.com/reference/coregraphics/cgrect/1456175-midx
	     */

	  }, {
	    key: 'midX',
	    get: function get() {
	      return this.origin.x + this.size.width * 0.5;
	    }

	    /**
	     * Returns the largest value of the x-coordinate for the rectangle.
	     * @type {number}
	     * @desc 
	     * @see https://developer.apple.com/reference/coregraphics/cgrect/1454334-maxx
	     */

	  }, {
	    key: 'maxX',
	    get: function get() {
	      if (this.size.width > 0) {
	        return this.origin.x + this.size.width;
	      }
	      return this.origin.x;
	    }

	    /**
	     * Returns the smallest value for the y-coordinate of the rectangle.
	     * @type {number}
	     * @desc 
	     * @see https://developer.apple.com/reference/coregraphics/cgrect/1454832-miny
	     */

	  }, {
	    key: 'minY',
	    get: function get() {
	      if (this.size.height < 0) {
	        return this.origin.y + this.size.height;
	      }
	      return this.origin.y;
	    }

	    /**
	     * Returns the y-coordinate that establishes the center of the rectangle.
	     * @type {number}
	     * @desc 
	     * @see https://developer.apple.com/reference/coregraphics/cgrect/1456550-midy
	     */

	  }, {
	    key: 'midY',
	    get: function get() {
	      return this.origin.y + this.size.height * 0.5;
	    }

	    /**
	     * Returns the largest value for the y-coordinate of the rectangle.
	     * @type {number}
	     * @desc 
	     * @see https://developer.apple.com/reference/coregraphics/cgrect/1454060-maxy
	     */

	  }, {
	    key: 'maxY',
	    get: function get() {
	      if (this.size.height > 0) {
	        return this.origin.y + this.size.height;
	      }
	      return this.origin.y;
	    }
	  }, {
	    key: 'standardized',
	    get: function get() {
	      var r = this.copy();
	      if (this.isNull) {
	        return CGRect.zero;
	      }
	      if (this.width < 0) {
	        r.origin.x = this.origin.x + this.width;
	        r.size.width = -this.width;
	      }
	      if (this.height < 0) {
	        r.origin.y = this.origin.y + this.height;
	        r.size.height = -this.height;
	      }
	      return r;
	    }

	    /**
	     * Returns the smallest rectangle that results from converting the source rectangle values to integers.
	     * @type {CGRect}
	     * @desc 
	     * @see https://developer.apple.com/reference/coregraphics/cgrect/1456348-integral
	     */

	  }, {
	    key: 'integral',
	    get: function get() {
	      return null;
	    }
	  }, {
	    key: 'isEmpty',
	    get: function get() {
	      return this.isNull || this.size.height === 0 || this.size.width === 0;
	    }

	    /**
	     * Returns whether a rectangle is infinite.
	     * @type {boolean}
	     * @desc An infinite rectangle is one that has no defined bounds. Infinite rectangles can be created as output from a tiling filter. For example, the Core Image framework perspective tile filter creates an image whose extent is described by an infinite rectangle.
	     * @see https://developer.apple.com/reference/coregraphics/cgrect/1455008-isinfinite
	     */

	  }, {
	    key: 'isInfinite',
	    get: function get() {
	      return this.size.width === Infinity && this.size.height === Infinity;
	    }

	    /**
	     * Returns whether the rectangle is equal to the null rectangle.
	     * @type {boolean}
	     * @desc A null rectangle is the equivalent of an empty set. For example, the result of intersecting two disjoint rectangles is a null rectangle. A null rectangle cannot be drawn and interacts with other rectangles in special ways.
	     * @see https://developer.apple.com/reference/coregraphics/cgrect/1455471-isnull
	     */

	  }, {
	    key: 'isNull',
	    get: function get() {
	      return this.size === null;
	    }
	  }, {
	    key: 'dictionaryRepresentation',
	    get: function get() {
	      var map = new Map();
	      map.set('origin', this.origin);
	      map.set('size', this.size);
	      return map;
	    }

	    /**
	     * 
	     * @type {string}
	     * @desc A textual representation of the rectangle's origin and size values. 
	     * @see https://developer.apple.com/reference/coregraphics/cgrect/1645823-debugdescription
	     */

	  }, {
	    key: 'debugDescription',
	    get: function get() {
	      if (this.size === null) {
	        return '{null}';
	      }
	      var origin = this.origin ? this.origin.debugDescription() : '{null}';
	      var size = this.size ? this.size.debugDescription() : '{null}';

	      return '{origin:' + origin + ', size:' + size + '}';
	    }

	    /**
	     * A representation of the rectangle's structure and display style for use in debugging. 
	     * @type {Mirror}
	     * @desc 
	     * @see https://developer.apple.com/reference/coregraphics/cgrect/1645833-custommirror
	     */

	  }, {
	    key: 'customMirror',
	    get: function get() {
	      return null;
	    }

	    /**
	     * A representation of the rectangle for use in Playgrounds. 
	     * @type {PlaygroundQuickLook}
	     * @desc 
	     * @see https://developer.apple.com/reference/coregraphics/cgrect/1645827-customplaygroundquicklook
	     */

	  }, {
	    key: 'customPlaygroundQuickLook',
	    get: function get() {
	      return null;
	    }
	  }], [{
	    key: 'rectWithXYWidthHeight',
	    value: function rectWithXYWidthHeight(x, y, width, height) {
	      var point = new _CGPoint2.default(x, y);
	      var size = new _CGSize2.default(width, height);
	      return new CGRect(point, size);
	    }
	  }, {
	    key: 'zero',
	    get: function get() {
	      return new CGRect(new _CGPoint2.default(0, 0), new _CGSize2.default(0, 0));
	    }
	  }]);

	  return CGRect;
	}();

	exports.default = CGRect;

/***/ },
/* 9 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * A structure that contains width and height values.
	 * @access public
	 * @see https://developer.apple.com/reference/coregraphics/cgsize
	 */

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var CGSize = function () {
	  _createClass(CGSize, null, [{
	    key: '_initWithData',

	    /**
	     * @access private
	     * @param {Buffer} data -
	     * @param {number} [offset = 0] -
	     * @param {boolean} [bigEndian = false] -
	     * @returns {CGSize}
	     */
	    value: function _initWithData(data) {
	      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
	      var bigEndian = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

	      throw new Error('not implemented');
	    }

	    // Initializers

	    /**
	     * Creates a size with dimensions specified as floating-point values.    
	     * @access public
	     * @constructor
	     * @param {number} width - 
	     * @param {number} height - 
	     * @see https://developer.apple.com/reference/coregraphics/cgsize/1454915-init
	     */

	  }]);

	  function CGSize(width, height) {
	    _classCallCheck(this, CGSize);

	    // Geometric Properties
	    this.width = width;
	    this.height = height;
	  }

	  // Geometric Properties

	  // Special Values
	  /**
	   * The size whose width and height are both zero.
	   * @type {CGSize}
	   * @desc 
	   * @see https://developer.apple.com/reference/coregraphics/cgsize/1455512-zero
	   */


	  _createClass(CGSize, [{
	    key: 'applying',


	    // Transforming Sizes

	    /**
	     * Returns the height and width resulting from a transformation of an existing height and width.
	     * @access public
	     * @param {CGAffineTransform} t - The affine transform to apply. 
	     * @returns {CGSize} - 
	     * @see https://developer.apple.com/reference/coregraphics/cgsize/1454806-applying
	     */
	    value: function applying(t) {
	      return null;
	    }

	    // Alternate Representations

	    /**
	     * Creates a size from a canonical dictionary representation. 
	     * @access public
	     * @param {Map} dict - A dictionary containing width and height values for the size to create, in the format used by the dictionaryRepresentation property.
	     * @returns {void}
	     * @see https://developer.apple.com/reference/coregraphics/cgsize/2427155-init
	     */

	  }, {
	    key: 'equalTo',


	    // Comparing Sizes

	    /**
	     * Returns whether two sizes are equal. 
	     * @access public
	     * @param {CGSize} size2 - 
	     * @returns {boolean} - 
	     * @see https://developer.apple.com/reference/coregraphics/cgsize/1455176-equalto
	     */
	    value: function equalTo(size2) {
	      var epsilon = 0.00001;
	      return Math.abs(this.width - size2.width) < epsilon && Math.abs(this.height - size2.height) < epsilon;
	    }
	  }, {
	    key: 'zero',
	    value: function zero() {
	      return new CGSize(0, 0);
	    }
	  }, {
	    key: 'add',
	    value: function add(size2) {
	      return new CGSize(this.width + size2.width, this.height + size2.height);
	    }
	  }, {
	    key: 'sub',
	    value: function sub(size2) {
	      return new CGSize(this.width - size2.width, this.height - size2.height);
	    }

	    /**
	     * @access public
	     * @param {CGSize} s -
	     * @param {number} rate -
	     * @returns {CGSize} -
	     */

	  }, {
	    key: 'lerp',
	    value: function lerp(s, rate) {
	      var w = this.width + rate * (s.width - this.width);
	      var h = this.height + rate * (s.height - this.height);
	      return new CGSize(w, h);
	    }
	  }, {
	    key: 'copy',
	    value: function copy() {
	      return new CGSize(this.width, this.height);
	    }
	  }, {
	    key: 'dictionaryRepresentation',


	    /**
	     * Returns a dictionary representation of the specified size.
	     * @type {Map}
	     * @desc 
	     * @see https://developer.apple.com/reference/coregraphics/cgsize/1455274-dictionaryrepresentation
	     */
	    get: function get() {
	      var map = new Map();
	      map.set('width', this.width);
	      map.set('height', this.height);
	      return map;
	    }

	    /**
	     * A textual representation of the size's dimensions.  
	     * @type {string}
	     * @desc 
	     * @see https://developer.apple.com/reference/coregraphics/cgsize/1645822-debugdescription
	     */

	  }, {
	    key: 'debugDescription',
	    get: function get() {
	      return '{width: ' + this.width + ', height: ' + this.height + '}';
	    }

	    /**
	     * A representation of the size's structure and display style for use in debugging. 
	     * @type {Mirror}
	     * @desc 
	     * @see https://developer.apple.com/reference/coregraphics/cgsize/1645828-custommirror
	     */

	  }, {
	    key: 'customMirror',
	    get: function get() {
	      return null;
	    }
	    /**
	     * A representation of the size for use in Playgrounds. 
	     * @type {PlaygroundQuickLook}
	     * @desc 
	     * @see https://developer.apple.com/reference/coregraphics/cgsize/1645830-customplaygroundquicklook
	     */

	  }, {
	    key: 'customPlaygroundQuickLook',
	    get: function get() {
	      return null;
	    }
	  }], [{
	    key: 'sizeWithDictionaryRepresentation',
	    value: function sizeWithDictionaryRepresentation(dict) {
	      return new CGSize(dict.get('width'), dict.get('height'));
	    }
	  }, {
	    key: 'zero',
	    get: function get() {
	      return new CGSize(0, 0);
	    }
	  }]);

	  return CGSize;
	}();

	exports.default = CGSize;

/***/ },
/* 10 */
/***/ function(module, exports) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var _ClassList = new Map();

	_ClassList.registerClass = function (classObj) {
	  var className = classObj.className;
	  var structInitializer = classObj._initWithData;
	  if (typeof className === 'undefined') {
	    if (typeof structInitializer === 'undefined') {
	      // doesn't seem to be an instance of NSObject
	      return;
	    }
	    className = classObj.prototype.constructor.name;
	  }
	  _ClassList.set(className, classObj);
	};

	exports.default = _ClassList;

/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _NSObject2 = __webpack_require__(2);

	var _NSObject3 = _interopRequireDefault(_NSObject2);

	var _NSColorSpaceModel = __webpack_require__(12);

	var _NSColorSpaceModel2 = _interopRequireDefault(_NSColorSpaceModel);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * An object that stores color data and sometimes opacity (that is, alpha value). 
	 * @access public
	 * @extends {NSObject}
	 * @see https://developer.apple.com/reference/uikit/uicolor
	 */
	var SKColor = function (_NSObject) {
	  _inherits(SKColor, _NSObject);

	  _createClass(SKColor, null, [{
	    key: '_initWithData',


	    /**
	     * @access private
	     * @param {Buffer} data -
	     * @param {number} [offset = 0] -
	     * @param {boolean} [bigEndian = false] -
	     * @returns {SKColor}
	     */
	    value: function _initWithData(data) {
	      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
	      var bigEndian = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

	      var instance = new SKColor();
	      if (bigEndian) {
	        instance.red = data.readFloatBE(offset + 0);
	        instance.blue = data.readFloatBE(offset + 4);
	        instance.green = data.readFloatBE(offset + 8);
	        instance.alpha = data.readFloatBE(offset + 12);
	      } else {
	        instance.red = data.readFloatLE(offset + 0);
	        instance.blue = data.readFloatLE(offset + 4);
	        instance.green = data.readFloatLE(offset + 8);
	        instance.alpha = data.readFloatLE(offset + 12);
	      }
	      return instance;
	    }

	    // Initializers

	    /**
	     * 
	     * @access public
	     * @constructor
	     * @param {number} red - 
	     * @param {number} green - 
	     * @param {number} blue - 
	     * @param {number} alpha - 
	     * @see https://developer.apple.com/reference/uikit/uicolor/1625015-init
	     */

	  }, {
	    key: '_propTypes',
	    get: function get() {
	      return {
	        $constructor: function $constructor(propNames, propValues) {
	          if (typeof propValues.NSColorSpace !== 'undefined') {
	            // initialize for NSColor
	            /*
	            const buf = propValues.NSRGB || propValues.NSWhite
	            const ascii = buf.toString('ascii')
	            const values = ascii.split(' ')
	            const space = propValues.NSColorSpace - 1
	            switch(space){
	              case NSColorSpaceModel.gray:
	                break
	              case NSColorSpaceModel.RGB: {
	                const r = parseFloat(values[0])
	                const g = parseFloat(values[1])
	                const b = parseFloat(values[2])
	                const a = 1.0
	                console.log(`NSColor -> SKColor: r:${r} g:${g} b:${b} a:${a}`)
	                return new SKColor(r, g, b, a)
	              }
	              case NSColorSpaceModel.CMYK:
	                if(propValues.NSWhite){
	                  const w = parseFloat(values[0])
	                  return new SKColor(w, w, w, 1.0)
	                }
	                break
	              case NSColorSpaceModel.LAB:
	                break
	              case NSColorSpaceModel.deviceN:
	                break
	              case NSColorSpaceModel.indexed:
	                break
	              case NSColorSpaceModel.patterned:
	                break
	            }
	            console.error(`unknown color space: ${propValues.NSColorSpace}`)
	            throw new Error(`unknown color space: ${propValues.NSColorSpace}`)
	            */
	            if (typeof propValues.NSRGB !== 'undefined') {
	              var ascii = propValues.NSRGB.toString('ascii');
	              var values = ascii.split(' ');
	              var r = parseFloat(values[0]);
	              var g = parseFloat(values[1]);
	              var b = parseFloat(values[2]);
	              var a = 1.0;
	              //console.log(`NSColor -> SKColor NSRGB: r:${r} g:${g} b:${b} a:${a}`)
	              return new SKColor(r, g, b, a);
	            } else if (typeof propValues.NSWhite !== 'undefined') {
	              var _ascii = propValues.NSWhite.toString('ascii');
	              var _values = _ascii.split(' ');
	              var w = parseFloat(_values[0]);
	              var _a = 1.0;
	              //console.log(`NSColor -> SKColor NSWhite: r:${w} g:${w} b:${w} a:${a}`)
	              return new SKColor(w, w, w, _a);
	            } else {
	              console.error('unknown color space');
	              throw new Error('unknown color space');
	            }
	          } else {
	            // TODO: implement
	            return new SKColor();
	          }
	        },
	        // for NSColor
	        NSRGB: ['bytes', null],
	        NSWhite: ['bytes', null],
	        NSComponents: ['bytes', null],
	        NSColorSpace: ['integer', null],
	        NSCustomColorSpace: ['NSColorSpace', null]
	      };
	    }
	  }]);

	  function SKColor(red, green, blue, alpha) {
	    _classCallCheck(this, SKColor);

	    /**
	     * @type {number}
	     */
	    var _this = _possibleConstructorReturn(this, (SKColor.__proto__ || Object.getPrototypeOf(SKColor)).call(this));

	    _this.red = red;

	    /**
	     * @type {number}
	     */
	    _this.green = green;

	    /**
	     * @type {number}
	     */
	    _this.blue = blue;

	    /**
	     * @type {number}
	     */
	    _this.alpha = alpha;
	    return _this;
	  }

	  // Creating a Color Object with a Predefined Color

	  /**
	   * A color object in the sRGB color space whose grayscale value is 0.0 and whose alpha value is 1.0.
	   * @type {SKColor}
	   * @desc 
	   * @see https://developer.apple.com/reference/uikit/uicolor/1621929-black
	   */


	  _createClass(SKColor, [{
	    key: 'withAlphaComponent',


	    // Creating a Custom UIColor Object in a Specific Color Space

	    /**
	     * Initializes and returns a color object using the specified opacity and grayscale values. 
	     * @access public
	     * @param {number} white - The grayscale value of the color object. On applications linked for iOS 10 or later, the color is specified in an extended color space, and the input value  is never clamped. On earlier versions of iOS, white values below 0.0 are interpreted as 0.0, and values above 1.0 are interpreted as 1.0.
	     * @param {number} alpha - The opacity value of the color object, specified as a value from 0.0 to 1.0. Alpha values below 0.0 are interpreted as 0.0, and values above 1.0 are interpreted as 1.0
	     * @returns {void}
	     * @desc On applications linked on iOS 10 or later, the input parameters are not clamped. On earlier versions of iOS, values below 0.0 are interpreted as 0.0, and values above 1.0 are interpreted as 1.0.
	     * @see https://developer.apple.com/reference/uikit/uicolor/1621944-init
	     */
	    //init(white, alpha) {
	    //}

	    // Creating a UIColor Object from another Representation of Color

	    /**
	     * Creates and returns a color object that has the same color space and component values as the receiver, but has the specified alpha component. 
	     * @access public
	     * @param {number} alpha - The opacity value of the new color object, specified as a value from 0.0 to 1.0. Alpha values below 0.0 are interpreted as 0.0, and values above 1.0 are interpreted as 1.0
	     * @returns {SKColor} - 
	     * @desc A subclass with explicit opacity components should override this method to return a color with the specified alpha.
	     * @see https://developer.apple.com/reference/uikit/uicolor/1621922-withalphacomponent
	     */
	    value: function withAlphaComponent(alpha) {
	      return new SKColor(this.red, this.green, this.blue, alpha);
	    }

	    // Creating a UIColor Object that Draws Using a Pattern

	    /**
	     * Initializes and returns a color object using the specified Quartz color reference. 
	     * @access public
	     * @param {Image} image - The image to use when creating the pattern color. 
	     * @returns {void}
	     * @desc You can use pattern colors to set the fill or stroke color just as you would a solid color. During drawing, the image in the pattern color is tiled as necessary to cover the given area. By default, the phase of the returned color is 0, which causes the top-left corner of the image to be aligned with the drawing origin. To change the phase, make the color the current color and then use the setPatternPhase(_:) function to change the phase.
	     * @see https://developer.apple.com/reference/uikit/uicolor/1621933-init
	     */

	  }, {
	    key: 'initPatternImage',
	    value: function initPatternImage(image) {}

	    // Setting the Graphics Contexts Drawing Color

	    /**
	     * Sets the color of subsequent stroke and fill operations to the color that the receiver represents. 
	     * @access public
	     * @returns {void}
	     * @desc If you subclass UIColor, you must implement this method in your subclass. Your custom implementation should modify both the stroke and fill color in the current graphics context by setting them both to the color represented by the receiver.
	     * @see https://developer.apple.com/reference/uikit/uicolor/1621928-set
	     */

	  }, {
	    key: 'set',
	    value: function set() {}

	    /**
	     * Sets the color of subsequent fill operations to the color that the receiver represents.
	     * @access public
	     * @returns {void}
	     * @desc If you subclass UIColor, you must implement this method in your subclass. Your custom implementation should modify the fill color in the current graphics context by setting it to the color represented by the receiver.
	     * @see https://developer.apple.com/reference/uikit/uicolor/1621926-setfill
	     */

	  }, {
	    key: 'setFill',
	    value: function setFill() {}

	    /**
	     * Sets the color of subsequent stroke operations to the color that the receiver represents.
	     * @access public
	     * @returns {void}
	     * @desc If you subclass UIColor, you must implement this method in your subclass. Your custom implementation should modify the stroke color in the current graphics context by setting it to the color represented by the receiver.
	     * @see https://developer.apple.com/reference/uikit/uicolor/1621948-setstroke
	     */

	  }, {
	    key: 'setStroke',
	    value: function setStroke() {}

	    // Retrieving Color Information

	    /**
	     * Returns the components that make up the color in the HSB color space.
	     * @access public
	     * @returns {Object} -
	     * @property {number} color.hue - On return, the hue component of the color object. On applications linked for iOS 10 or later, the hue component is specified in an extended range color space and can have any value. Values between 0.0 and 1.0 are inside the sRGB color gamut. On earlier versions of iOS, the specified value is always between 0.0 and 1.0.
	     * @property {number} color.saturation - On return, the saturation component of the color object. On applications linked for iOS 10 or later, the saturation component is specified in an extended range color space and can have any value. Values between 0.0 and 1.0 are inside the sRGB color gamut. On earlier versions of iOS, the specified value is always between 0.0 and 1.0.
	     * @property {number} color.brightness - On return, the brightness component of the color object. On applications linked for iOS 10 or later, the brightness component is specified in an extended range color space and can have any value. Values between 0.0 and 1.0 are inside the sRGB color gamut. On earlier versions of iOS, the specified value is always between 0.0 and 1.0.
	     * @property {number} color.alpha - On return, the opacity component of the color object, specified as a value between 0.0 and 1.0.
	     * @desc If the color is in a compatible color space, the color is converted into the HSB color space and its components are returned to your application. If the color is not in a compatible color space, the parameters are unchanged.
	     * @see https://developer.apple.com/reference/uikit/uicolor/1621949-gethue
	     */

	  }, {
	    key: 'getHSBA',
	    value: function getHSBA() {
	      // TODO: implement
	      var color = {
	        hue: 0,
	        saturation: 0,
	        brightness: 0,
	        alpha: 0
	      };
	      return color;
	    }

	    /**
	     * Returns the components that make up the color in the RGB color space.
	     * @access public
	     * @param {number} red -
	     * @param {number} green -
	     * @param {number} blue -
	     * @param {number} alpha -
	     * @returns {Object} -
	     * @property {number} color.red - On return, the red component of the color object. On applications linked for iOS 10 or later, the red component is specified in an extended range sRGB color space and can have any value. Values between 0.0 and 1.0 are inside the sRGB color gamut. On earlier versions of iOS, the specified value is always between 0.0 and 1.0.
	     * @property {number} color.green - On return, the green component of the color object. On applications linked for iOS 10 or later, the green component is specified in an extended range sRGB color space and can have any value. Values between 0.0 and 1.0 are inside the sRGB color gamut. On earlier versions of iOS, the specified value is always between 0.0 and 1.0.
	     * @property {number} color.blue - On return, the blue component of the color object. On applications linked for iOS 10 or later, the blue component is specified in an extended range sRGB color space and can have any value. Values between 0.0 and 1.0 are inside the sRGB color gamut. On earlier versions of iOS, the specified value is always between 0.0 and 1.0.
	     * @property {number} color.alpha - On return, the opacity component of the color object, specified as a value between 0.0 and 1.0.
	     * @desc If the color is in a compatible color space, the color is converted into RGB format and its components are returned to your application. If the color is not in a compatible color space, the parameters are unchanged.
	     * @see https://developer.apple.com/reference/uikit/uicolor/1621919-getred
	     */

	  }, {
	    key: 'getRGBA',
	    value: function getRGBA(red, green, blue, alpha) {
	      var color = {
	        red: this.red,
	        green: this.green,
	        blue: this.blue,
	        alpha: this.alpha
	      };
	      return color;
	    }

	    /**
	     * Returns the grayscale components of the color.
	     * @access public
	     * @param {?UnsafeMutablePointer<CGFloat>} white - On return, the grayscale component of the color object. On applications linked for iOS 10 or later, the grayscale component is specified in an extended range gray color space and can have any value. Values between 0.0 and 1.0 are inside the sRGB color gamut. On earlier versions of iOS, the specified value is always between 0.0 and 1.0.
	     * @param {?UnsafeMutablePointer<CGFloat>} alpha - On return, the opacity component of the color object, specified as a value between 0.0 and 1.0.
	     * @returns {boolean} - 
	     * @desc If the color is in a compatible color space, the color is converted into grayscale format and returned to your application. If the color is not in a compatible color space, the parameters are unchanged.
	     * @see https://developer.apple.com/reference/uikit/uicolor/1621927-getwhite
	     */
	    //getWhite(white, alpha) {
	    //  return false
	    //}

	    /**
	     * HTML color representation
	     * @access public
	     * @type {string}
	     */

	  }, {
	    key: '_copy',


	    /**
	     * @access private
	     * @returns {SKColor} -
	     */
	    value: function _copy() {
	      return new SKColor(this.red, this.green, this.blue, this.alpha);
	    }

	    /**
	     * @access private
	     * @param {SKColor} c -
	     * @param {number} rate -
	     * @returns {SKColor} -
	     */

	  }, {
	    key: '_lerp',
	    value: function _lerp(c, rate) {
	      var r = new SKColor();
	      r.red = this.red + rate * (c.red - this.red);
	      r.green = this.green + rate * (c.green - this.green);
	      r.blue = this.blue + rate * (c.blue - this.blue);
	      r.alpha = this.alpha + rate * (c.alpha - this.alpha);
	      return r;
	    }
	  }, {
	    key: 'zero',
	    value: function zero() {
	      return new SKColor(0, 0, 0, 0);
	    }

	    /**
	     * @access private
	     * @param {SKColor} c -
	     * @returns {SKColor} -
	     */

	  }, {
	    key: 'add',
	    value: function add(c) {
	      var r = new SKColor();
	      r.red = this.red + c.red;
	      r.green = this.green + c.green;
	      r.blue = this.blue + c.blue;
	      r.alpha = this.alpha + c.alpha;
	      return r;
	    }

	    /**
	     * @access private
	     * @param {SKColor} c -
	     * @returns {SKColor} -
	     */

	  }, {
	    key: 'sub',
	    value: function sub(c) {
	      var r = new SKColor();
	      r.red = this.red - c.red;
	      r.green = this.green - c.green;
	      r.blue = this.blue - c.blue;
	      r.alpha = this.alpha - c.alpha;
	      return r;
	    }

	    /**
	     * @access public
	     * @returns {number[]} -
	     */

	  }, {
	    key: 'floatArray',
	    value: function floatArray() {
	      return [this.red, this.green, this.blue, this.alpha];
	    }

	    /**
	     * @access public
	     * @returns {Float32Array} -
	     */

	  }, {
	    key: 'float32Array',
	    value: function float32Array() {
	      return new Float32Array([this.red, this.green, this.blue, this.alpha]);
	    }
	  }, {
	    key: 'htmlColor',
	    get: function get() {
	      var r = Math.round(this.red * 255);
	      var g = Math.round(this.green * 255);
	      var b = Math.round(this.blue * 255);
	      return 'rgba(' + r + ', ' + g + ', ' + b + ', ' + this.alpha + ')';
	    }

	    /**
	     * HTML color representation
	     * @access public
	     * @type {string}
	     */

	  }, {
	    key: 'hexColor',
	    get: function get() {
	      var r = Math.round(this.red * 255).toString(16);
	      var g = Math.round(this.green * 255).toString(16);
	      var b = Math.round(this.blue * 255).toString(16);
	      return '#' + r + g + b;
	    }
	  }], [{
	    key: 'black',
	    get: function get() {
	      return new SKColor(0.0, 0.0, 0.0, 1.0);
	    }

	    /**
	     * A color object whose RGB values are 0.0, 0.0, and 1.0 and whose alpha value is 1.0.
	     * @type {SKColor}
	     * @desc 
	     * @see https://developer.apple.com/reference/uikit/uicolor/1621947-blue
	     */

	  }, {
	    key: 'blue',
	    get: function get() {
	      return new SKColor(0.0, 0.0, 1.0, 1.0);
	    }

	    /**
	     * A color object whose RGB values are 0.6, 0.4, and 0.2 and whose alpha value is 1.0.
	     * @type {SKColor}
	     * @desc 
	     * @see https://developer.apple.com/reference/uikit/uicolor/1621950-brown
	     */

	  }, {
	    key: 'brown',
	    get: function get() {
	      return new SKColor(0.6, 0.4, 0.2, 1.0);
	    }

	    /**
	     * A color object whose grayscale and alpha values are both 0.0.
	     * @type {SKColor}
	     * @desc 
	     * @see https://developer.apple.com/reference/uikit/uicolor/1621945-clear
	     */

	  }, {
	    key: 'clear',
	    get: function get() {
	      return new SKColor(0.0, 0.0, 0.0, 0.0);
	    }

	    /**
	     * A color object whose RGB values are 0.0, 1.0, and 1.0 and whose alpha value is 1.0.
	     * @type {SKColor}
	     * @desc 
	     * @see https://developer.apple.com/reference/uikit/uicolor/1621942-cyan
	     */

	  }, {
	    key: 'cyan',
	    get: function get() {
	      return new SKColor(0.0, 1.0, 1.0, 1.0);
	    }

	    /**
	     * A color object whose grayscale value is 1/3 and whose alpha value is 1.0.
	     * @type {SKColor}
	     * @desc 
	     * @see https://developer.apple.com/reference/uikit/uicolor/1621952-darkgray
	     */

	  }, {
	    key: 'darkGray',
	    get: function get() {
	      var third = 1.0 / 3.0;
	      return new SKColor(third, third, third, 1.0);
	    }

	    /**
	     * A color object whose grayscale value is 0.5 and whose alpha value is 1.0.
	     * @type {SKColor}
	     * @desc 
	     * @see https://developer.apple.com/reference/uikit/uicolor/1621941-gray
	     */

	  }, {
	    key: 'gray',
	    get: function get() {
	      return new SKColor(0.5, 0.5, 0.5, 1.0);
	    }

	    /**
	     * A color object whose RGB values are 0.0, 1.0, and 0.0 and whose alpha value is 1.0.
	     * @type {SKColor}
	     * @desc 
	     * @see https://developer.apple.com/reference/uikit/uicolor/1621946-green
	     */

	  }, {
	    key: 'green',
	    get: function get() {
	      return new SKColor(0.0, 1.0, 0.0, 1.0);
	    }

	    /**
	     * A color object whose grayscale value is 2/3 and whose alpha value is 1.0.
	     * @type {SKColor}
	     * @desc 
	     * @see https://developer.apple.com/reference/uikit/uicolor/1621932-lightgray
	     */

	  }, {
	    key: 'lightGray',
	    get: function get() {
	      var twoThirds = 2.0 / 3.0;
	      return new SKColor(twoThirds, twoThirds, twoThirds, 1.0);
	    }

	    /**
	     * A color object whose RGB values are 1.0, 0.0, and 1.0 and whose alpha value is 1.0.
	     * @type {SKColor}
	     * @desc 
	     * @see https://developer.apple.com/reference/uikit/uicolor/1621934-magenta
	     */

	  }, {
	    key: 'magenta',
	    get: function get() {
	      return new SKColor(1.0, 0.0, 1.0, 1.0);
	    }

	    /**
	     * A color object whose RGB values are 1.0, 0.5, and 0.0 and whose alpha value is 1.0.
	     * @type {SKColor}
	     * @desc 
	     * @see https://developer.apple.com/reference/uikit/uicolor/1621956-orange
	     */

	  }, {
	    key: 'orange',
	    get: function get() {
	      return new SKColor(1.0, 0.5, 0.0, 1.0);
	    }

	    /**
	     * A color object whose RGB values are 0.5, 0.0, and 0.5 and whose alpha value is 1.0.
	     * @type {SKColor}
	     * @desc 
	     * @see https://developer.apple.com/reference/uikit/uicolor/1621923-purple
	     */

	  }, {
	    key: 'purple',
	    get: function get() {
	      return new SKColor(0.5, 0.0, 0.5, 1.0);
	    }

	    /**
	     * A color object whose RGB values are 1.0, 0.0, and 0.0 and whose alpha value is 1.0.
	     * @type {SKColor}
	     * @desc 
	     * @see https://developer.apple.com/reference/uikit/uicolor/1621924-red
	     */

	  }, {
	    key: 'red',
	    get: function get() {
	      return new SKColor(1.0, 0.0, 0.0, 1.0);
	    }

	    /**
	     * A color object whose grayscale value is 1.0 and whose alpha value is 1.0.
	     * @type {SKColor}
	     * @desc 
	     * @see https://developer.apple.com/reference/uikit/uicolor/1621920-white
	     */

	  }, {
	    key: 'white',
	    get: function get() {
	      return new SKColor(1.0, 0.0, 0.0, 1.0);
	    }

	    /**
	     * A color object whose RGB values are 1.0, 1.0, and 0.0 and whose alpha value is 1.0.
	     * @type {SKColor}
	     * @desc 
	     * @see https://developer.apple.com/reference/uikit/uicolor/1621953-yellow
	     */

	  }, {
	    key: 'yellow',
	    get: function get() {
	      return new SKColor(1.0, 1.0, 0.0, 1.0);
	    }
	  }]);

	  return SKColor;
	}(_NSObject3.default);

	exports.default = SKColor;

/***/ },
/* 12 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * The type of the color-space mode constants listed in Color Space Models.
	 * @typedef {Object} NSColorSpaceModel
	 * @property {number} CMYK - 
	 * @property {number} LAB - 
	 * @property {number} RGB - 
	 * @property {number} deviceN - 
	 * @property {number} gray - 
	 * @property {number} indexed - 
	 * @property {number} patterned - 
	 * @property {number} unknown - 
	 * @see https://developer.apple.com/reference/appkit/nscolorspacemodel
	 */

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var NSColorSpaceModel = {
	  gray: 0,
	  RGB: 1,
	  CMYK: 2,
	  LAB: 3,
	  deviceN: 4,
	  indexed: 5,
	  patterned: 6,
	  unknown: -1
	};

	exports.default = NSColorSpaceModel;

/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _AVAudioNode2 = __webpack_require__(14);

	var _AVAudioNode3 = _interopRequireDefault(_AVAudioNode2);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var AVAudioMixerNode = function (_AVAudioNode) {
	  _inherits(AVAudioMixerNode, _AVAudioNode);

	  function AVAudioMixerNode() {
	    _classCallCheck(this, AVAudioMixerNode);

	    var _this = _possibleConstructorReturn(this, (AVAudioMixerNode.__proto__ || Object.getPrototypeOf(AVAudioMixerNode)).call(this));

	    _this._gainNode = null;
	    return _this;
	  }

	  _createClass(AVAudioMixerNode, [{
	    key: 'volume',
	    get: function get() {
	      return this._gainNode.gain.value;
	    },
	    set: function set(newValue) {
	      this._gainNode.gain.value = newValue;
	    }
	  }]);

	  return AVAudioMixerNode;
	}(_AVAudioNode3.default);

	exports.default = AVAudioMixerNode;

/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _NSObject2 = __webpack_require__(2);

	var _NSObject3 = _interopRequireDefault(_NSObject2);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var AVAudioNode = function (_NSObject) {
	  _inherits(AVAudioNode, _NSObject);

	  function AVAudioNode() {
	    _classCallCheck(this, AVAudioNode);

	    return _possibleConstructorReturn(this, (AVAudioNode.__proto__ || Object.getPrototypeOf(AVAudioNode)).call(this));
	  }

	  return AVAudioNode;
	}(_NSObject3.default);

	exports.default = AVAudioNode;

/***/ },
/* 15 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * Compositing operations for images.
	 * @typedef {Object} CGBlendMode
	 * @property {number} normal - Paints the source image samples over the background image samples.
	 * @property {number} multiply - Multiplies the source image samples with the background image samples. This results in colors that are at least as dark as either of the two contributing sample colors.
	 * @property {number} screen - Multiplies  the inverse of the source image samples with the inverse of the background image samples. This results in colors that are at least as light as either of the two contributing sample colors.
	 * @property {number} overlay - 
	 * @property {number} darken - 
	 * @property {number} lighten - 
	 * @property {number} colorDodge - Brightens the background image samples to reflect the source image samples. Source image sample values that specify black do not produce a change.
	 * @property {number} colorBurn - Darkens the background image samples to reflect the source image samples. Source image sample values that specify white do not produce a change.
	 * @property {number} softLight - 
	 * @property {number} hardLight - 
	 * @property {number} difference - 
	 * @property {number} exclusion - Produces an effect similar to that produced by difference, but with lower contrast. Source image sample values that are black dont produce a change; white inverts the background color values.
	 * @property {number} hue - Uses the luminance and saturation values of the background with the hue of the source image.
	 * @property {number} saturation - Uses the luminance and hue values of the background with the saturation of the source image. Areas of the background that have no saturation (that is, pure gray areas) dont produce a change.
	 * @property {number} color - Uses the luminance values of the background with the hue and saturation values of the source image. This mode preserves the gray levels in the image. You can use this mode to color monochrome images or to tint color images.
	 * @property {number} luminosity - Uses the hue and saturation of the background with the luminance of the source image. This mode creates an effect that is inverse to the effect created by color.
	 * @property {number} clear - R = 0
	 * @property {number} copy - R = S
	 * @property {number} sourceIn - R = S*Da
	 * @property {number} sourceOut - R = S*(1 - Da)
	 * @property {number} sourceAtop - R = S*Da + D*(1 - Sa)
	 * @property {number} destinationOver - R = S*(1 - Da) + D
	 * @property {number} destinationIn - R = D*Sa
	 * @property {number} destinationOut - R = D*(1 - Sa)
	 * @property {number} destinationAtop - R = S*(1 - Da) + D*Sa
	 * @property {number} xor - R = S*(1 - Da) + D*(1 - Sa). This XOR mode is only nominally related to the classical bitmap XOR operation, which is not supported by Core Graphics
	 * @property {number} plusDarker - R = MAX(0, 1 - ((1 - D) + (1 - S)))
	 * @property {number} plusLighter - R = MIN(1, S + D)
	 * @see https://developer.apple.com/reference/coregraphics/cgblendmode
	 */

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var CGBlendMode = {
	  normal: 0,
	  multiply: 1,
	  screen: 2,
	  overlay: 3,
	  darken: 4,
	  lighten: 5,
	  colorDodge: 6,
	  colorBurn: 7,
	  softLight: 8,
	  hardLight: 9,
	  difference: 10,
	  exclusion: 11,
	  hue: 12,
	  saturation: 13,
	  color: 14,
	  luminosity: 15,
	  clear: 16,
	  copy: 17,
	  sourceIn: 18,
	  sourceOut: 19,
	  sourceAtop: 20,
	  destinationOver: 21,
	  destinationIn: 22,
	  destinationOut: 23,
	  destinationAtop: 24,
	  xor: 25,
	  plusDarker: 26,
	  plusLighter: 27
	};

	exports.default = CGBlendMode;

/***/ },
/* 16 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * Styles for rendering the endpoint of a stroked line.
	 * @typedef {Object} CGLineCap
	 * @property {number} butt - A line with a squared-off end. Core Graphics draws the line to extend only to the exact endpoint of the path. This is the default.
	 * @property {number} round - A line with a rounded end. Core Graphics draws the line to extend beyond the endpoint of the path. The line ends with a semicircular arc with a radius of 1/2 the lines width, centered on the endpoint.
	 * @property {number} square - A line with a squared-off end. Core Graphics extends the line beyond the endpoint of the path for a distance equal to half the line width.
	 * @see https://developer.apple.com/reference/coregraphics/cglinecap
	 */

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var CGLineCap = {
	  butt: 0,
	  round: 1,
	  square: 2
	};

	exports.default = CGLineCap;

/***/ },
/* 17 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * Junction types for stroked lines.
	 * @typedef {Object} CGLineJoin
	 * @property {number} miter - 
	 * @property {number} round - A join with a rounded end. Core Graphics draws the line to extend beyond the endpoint of the path. The line ends with a semicircular arc with a radius of 1/2 the lines width, centered on the endpoint.
	 * @property {number} bevel - A join with a squared-off end. Core Graphics draws the line to extend beyond the endpoint of the path, for a distance of 1/2 the lines width.
	 * @see https://developer.apple.com/reference/coregraphics/cglinejoin
	 */

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var CGLineJoin = {
	  miter: 0,
	  round: 1,
	  bevel: 2
	};

	exports.default = CGLineJoin;

/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _CGPoint = __webpack_require__(7);

	var _CGPoint2 = _interopRequireDefault(_CGPoint);

	var _CGRect = __webpack_require__(8);

	var _CGRect2 = _interopRequireDefault(_CGRect);

	var _CGPath = __webpack_require__(19);

	var _CGPath2 = _interopRequireDefault(_CGPath);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	/**
	 * A mutable graphics path: a mathematical description of shapes or lines to be drawn in a graphics context.
	 * @access public
	 * @see https://developer.apple.com/reference/coregraphics/cgmutablepath
	 */
	var CGMutablePath = function () {
	  function CGMutablePath() {
	    _classCallCheck(this, CGMutablePath);
	  }

	  _createClass(CGMutablePath, [{
	    key: 'init',


	    // Creating Graphics Paths

	    /**
	     * Creates a mutable graphics path.
	     * @access public
	     * @returns {void}
	     * @see https://developer.apple.com/reference/coregraphics/cgmutablepath/1411209-init
	     */
	    value: function init() {}

	    // Copying a Graphics Path

	    /**
	     * Creates a mutable copy of an existing graphics path.
	     * @access public
	     * @returns {?CGMutablePath} - 
	     * @desc You can modify a mutable graphics path by calling the various path geometry functions, such as addArc(_:x:y:radius:startAngle:endAngle:clockwise:), addLineTo(_:x:y:), and moveTo(_:x:y:).
	     * @see https://developer.apple.com/reference/coregraphics/cgpath/1411196-mutablecopy
	     */

	  }, {
	    key: 'mutableCopy',
	    value: function mutableCopy() {
	      return null;
	    }

	    /**
	     * Creates a mutable copy of a graphics path transformed by a transformation matrix.
	     * @access public
	     * @param {?UnsafePointer<CGAffineTransform>} transform - A pointer to an affine transformation matrix, or NULL if no transformation is needed. If specified, Core Graphics applies the transformation to all elements of the new path.
	     * @returns {?CGMutablePath} - 
	     * @see https://developer.apple.com/reference/coregraphics/cgpath/1411150-mutablecopy
	     */

	  }, {
	    key: 'mutableCopyUsing',
	    value: function mutableCopyUsing(transform) {
	      return null;
	    }

	    // Constructing a Graphics Path

	    /**
	     * Begins a new subpath at the specified point.  
	     * @access public
	     * @param {CGPoint} point - The point, in user space coordinates, at which to start a new subpath.
	     * @param {CGAffineTransform} transform - An affine transform to apply to the point before adding to the path. Defaults to the identity transform if not specified.
	     * @returns {void}
	     * @desc The specified point becomes the start point of a new subpath. The current point is set to this start point.
	     * @see https://developer.apple.com/reference/coregraphics/cgmutablepath/2427143-move
	     */

	  }, {
	    key: 'moveTo',
	    value: function moveTo(point, transform) {}

	    /**
	     * Appends a straight line segment from the current point to the specified point. 
	     * @access public
	     * @param {CGPoint} point - The location, in user space coordinates, for the end of the new line segment.
	     * @param {CGAffineTransform} transform - An affine transform to apply to the point before adding to the path. Defaults to the identity transform if not specified.
	     * @returns {void}
	     * @desc After adding the line segment, the current point is set to the endpoint of the line segment.
	     * @see https://developer.apple.com/reference/coregraphics/cgmutablepath/2427121-addline
	     */

	  }, {
	    key: 'addLineTo',
	    value: function addLineTo(point, transform) {}

	    /**
	     * Adds a sequence of connected straight-line segments to the path. 
	     * @access public
	     * @param {CGPoint[]} points - An array of values that specify the start and end points of the line segments to draw. Each point in the array specifies a position in user space. The first point in the array specifies the initial starting point.
	     * @param {CGAffineTransform} transform - An affine transform to apply to the points before adding to the path. Defaults to the identity transform if not specified.
	     * @returns {void}
	     * @desc Calling this convenience method is equivalent to calling the move(to:transform:) method with the first value in the points array, then calling the addLine(to:transform:) method for each subsequent point until the array is exhausted. After calling this method, the path's current point is the last point in the array.
	     * @see https://developer.apple.com/reference/coregraphics/cgmutablepath/2427154-addlines
	     */

	  }, {
	    key: 'addLinesBetween',
	    value: function addLinesBetween(points, transform) {}

	    /**
	     * Adds a rectangular subpath to the path. 
	     * @access public
	     * @param {CGRect} rect - A rectangle, specified in user space coordinates.
	     * @param {CGAffineTransform} transform - An affine transform to apply to the rectangle before adding to the path. Defaults to the identity transform if not specified.
	     * @returns {void}
	     * @desc This is a convenience function that adds a rectangle to a path, starting by moving to the bottom left corner and then adding lines counter-clockwise to create a rectangle, closing the subpath.
	     * @see https://developer.apple.com/reference/coregraphics/cgmutablepath/2427119-addrect
	     */

	  }, {
	    key: 'addRect',
	    value: function addRect(rect, transform) {}

	    /**
	     * Adds a set of rectangular subpaths to the path. 
	     * @access public
	     * @param {CGRect[]} rects - An array of rectangles, specified in user space coordinates.
	     * @param {CGAffineTransform} transform - An affine transform to apply to the rectangles before adding to the path. Defaults to the identity transform if not specified.
	     * @returns {void}
	     * @desc Calling this convenience method is equivalent to repeatedly calling the addRect(_:transform:) method for each rectangle in the array.
	     * @see https://developer.apple.com/reference/coregraphics/cgmutablepath/2427131-addrects
	     */

	  }, {
	    key: 'addRects',
	    value: function addRects(rects, transform) {}

	    /**
	     * Adds an ellipse that fits inside the specified rectangle. 
	     * @access public
	     * @param {CGRect} rect - A rectangle that defines the area for the ellipse to fit in.
	     * @param {CGAffineTransform} transform - An affine transform to apply to the ellipse before adding to the path. Defaults to the identity transform if not specified.
	     * @returns {void}
	     * @desc The ellipse is approximated by a sequence of Bzier curves. Its center is the midpoint of the rectangle defined by the rect parameter. If the rectangle is square, then the ellipse is circular with a radius equal to one-half the width (or height) of the rectangle. If the rect parameter specifies a rectangular shape, then the major and minor axes of the ellipse are defined by the width and height of the rectangle.The ellipse forms a complete subpath of the paththat is, the ellipse drawing starts with a move-to operation and ends with a close-subpath operation, with all moves oriented in the clockwise direction.
	     * @see https://developer.apple.com/reference/coregraphics/cgmutablepath/2427120-addellipse
	     */

	  }, {
	    key: 'addEllipseIn',
	    value: function addEllipseIn(rect, transform) {}

	    /**
	     *  Adds a subpath to the path, in the shape of a rectangle with rounded corners.
	     * @access public
	     * @param {CGRect} rect - The rectangle to add, specified in user space coordinates.
	     * @param {number} cornerWidth - The horizontal size, in user space coordinates, for rounded corner sections.
	     * @param {number} cornerHeight - The vertical size, in user space coordinates, for rounded corner sections.
	     * @param {CGAffineTransform} transform - An affine transform to apply to the rectangle before adding to the path. Defaults to the identity transform if not specified.
	     * @returns {void}
	     * @desc This convenience method is equivalent to a move operation to start the subpath followed by a series of arc and line operations that construct the rounded rectangle. Each corner of the rounded rectangle is one-quarter of an ellipse with axes equal to the cornerWidth and cornerHeight parameters. The rounded rectangle forms a closed subpath oriented in the clockwise direction.
	     * @see https://developer.apple.com/reference/coregraphics/cgmutablepath/2427144-addroundedrect
	     */

	  }, {
	    key: 'addRoundedRectIn',
	    value: function addRoundedRectIn(rect, cornerWidth, cornerHeight, transform) {}

	    /**
	     * Adds an arc of a circle to the path, specified with a radius and angles. 
	     * @access public
	     * @param {CGPoint} center - The center of the arc, in user space coordinates.
	     * @param {number} radius - The radius of the arc, in user space coordinates.
	     * @param {number} startAngle - The angle to the starting point of the arc, measured in radians from the positive x-axis.
	     * @param {number} endAngle - The angle to the end point of the arc, measured in radians from the positive x-axis.
	     * @param {boolean} clockwise - true to make a clockwise arc; false to make a counterclockwise arc.
	     * @param {CGAffineTransform} transform - An affine transform to apply to the arc before adding to the path. Defaults to the identity transform if not specified.
	     * @returns {void}
	     * @desc This method calculates starting and ending points using the radius and angles you specify, uses a sequence of cubic Bzier curves to approximate a segment of a circle between those points, and then appends those curves to the path.The clockwise parameter determines the direction in which the arc is created; the actual direction of the final path is dependent on the transform parameter and the current transform of a context where the path is drawn. In a flipped coordinate system (the default for UIView drawing methods in iOS), specifying a clockwise arc results in a counterclockwise arc after the transformation is applied.If the path already contains a subpath, this method adds a line connecting the current point to the starting point of the arc. If the current path is empty, his method creates a new subpath whose starting point is the starting point of the arc. The ending point of the arc becomes the new current point of the path.
	     * @see https://developer.apple.com/reference/coregraphics/cgmutablepath/2427140-addarc
	     */

	  }, {
	    key: 'addArc',
	    value: function addArc(center, radius, startAngle, endAngle, clockwise, transform) {}

	    /**
	     * Adds an arc of a circle to the path, specified with a radius and a difference in angle.  
	     * @access public
	     * @param {CGPoint} center - The center of the arc, in user space coordinates.
	     * @param {number} radius - The radius of the arc, in user space coordinates.
	     * @param {number} startAngle - The angle to the starting point of the arc, measured in radians from the positive x-axis.
	     * @param {number} delta - The difference, measured in radians, between the starting angle and ending angle of the arc. A positive value creates a counter-clockwise arc (in user space coordinates), and vice versa.
	     * @param {CGAffineTransform} transform - An affine transform to apply to the arc before adding to the path. Defaults to the identity transform if not specified.
	     * @returns {void}
	     * @desc This method calculates starting and ending points using the radius and angles you specify, uses a sequence of cubic Bzier curves to approximate a segment of a circle between those points, and then appends those curves to the path.The delta parameter determines both the length of the arc the direction in which the arc is created; the actual direction of the final path is dependent on the transform parameter and the current transform of a context where the path is drawn. In a flipped coordinate system (the default for UIView drawing methods in iOS), specifying a clockwise arc results in a counterclockwise arc after the transformation is applied.If the path already contains a subpath, this method adds a line connecting the current point to the starting point of the arc. If the current path is empty, his method creates a new subpath whose starting point is the starting point of the arc. The ending point of the arc becomes the new current point of the path.
	     * @see https://developer.apple.com/reference/coregraphics/cgmutablepath/2427147-addrelativearc
	     */

	  }, {
	    key: 'addRelativeArc',
	    value: function addRelativeArc(center, radius, startAngle, delta, transform) {}

	    /**
	     * Adds a cubic Bzier curve to the path, with the specified end point and control points. 
	     * @access public
	     * @param {CGPoint} end - The point, in user space coordinates, at which to end the curve.
	     * @param {CGPoint} control1 - The first control point of the curve, in user space coordinates.
	     * @param {CGPoint} control2 - The second control point of the curve, in user space coordinates.
	     * @param {CGAffineTransform} transform - An affine transform to apply to the curve before adding to the path. Defaults to the identity transform if not specified.
	     * @returns {void}
	     * @desc This method constructs a curve starting from the path's current point and ending at the specified end point, with curvature defined by the two control points. After this method appends that curve to the current path, the end point of the curve becomes the path's current point.
	     * @see https://developer.apple.com/reference/coregraphics/cgmutablepath/2427158-addcurve
	     */

	  }, {
	    key: 'addCurveTo',
	    value: function addCurveTo(end, control1, control2, transform) {}

	    /**
	     * Adds a quadratic Bzier curve to the path, with the specified end point and control point. 
	     * @access public
	     * @param {CGPoint} end - The point, in user space coordinates, at which to end the curve.
	     * @param {CGPoint} control - The control point of the curve, in user space coordinates.
	     * @param {CGAffineTransform} transform - An affine transform to apply to the curve before adding to the path. Defaults to the identity transform if not specified.
	     * @returns {void}
	     * @desc This method constructs a curve starting from the path's current point and ending at the specified end point, with curvature defined by the control point. After this method appends that curve to the current path, the end point of the curve becomes the path's current point.
	     * @see https://developer.apple.com/reference/coregraphics/cgmutablepath/2427128-addquadcurve
	     */

	  }, {
	    key: 'addQuadCurveTo',
	    value: function addQuadCurveTo(end, control, transform) {}

	    /**
	     * Appends another path object to the path. 
	     * @access public
	     * @param {CGPath} path - The path to add.
	     * @param {CGAffineTransform} transform - An affine transform to apply to the path parameter before adding to this path. Defaults to the identity transform if not specified.
	     * @returns {void}
	     * @desc If the path parameter is a non-empty empty path, its path elements are appended in order to this path. Afterward, the start point and current point of this path are those of the last subpath in the path parameter.
	     * @see https://developer.apple.com/reference/coregraphics/cgmutablepath/2427150-addpath
	     */

	  }, {
	    key: 'addPath',
	    value: function addPath(path, transform) {}

	    /**
	     * Closes and completes a subpath in a mutable graphics path.
	     * @access public
	     * @returns {void}
	     * @desc Appends a line from the current point to the starting point of the current subpath and ends the subpath. After closing the subpath, your application can begin a new subpath without first calling moveTo(_:x:y:). In this case, a new subpath is implicitly created with a starting and current point equal to the previous subpaths starting point.
	     * @see https://developer.apple.com/reference/coregraphics/cgmutablepath/1411188-closesubpath
	     */

	  }, {
	    key: 'closeSubpath',
	    value: function closeSubpath() {}
	  }]);

	  return CGMutablePath;
	}();

	exports.default = CGMutablePath;

/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _CGRect = __webpack_require__(8);

	var _CGRect2 = _interopRequireDefault(_CGRect);

	var _CGLineCap = __webpack_require__(16);

	var _CGLineCap2 = _interopRequireDefault(_CGLineCap);

	var _CGLineJoin = __webpack_require__(17);

	var _CGLineJoin2 = _interopRequireDefault(_CGLineJoin);

	var _CGMutablePath = __webpack_require__(18);

	var _CGMutablePath2 = _interopRequireDefault(_CGMutablePath);

	var _CGPoint = __webpack_require__(7);

	var _CGPoint2 = _interopRequireDefault(_CGPoint);

	var _CGPathFillRule = __webpack_require__(20);

	var _CGPathFillRule2 = _interopRequireDefault(_CGPathFillRule);

	var _CGPathApplierFunction = __webpack_require__(21);

	var _CGPathApplierFunction2 = _interopRequireDefault(_CGPathApplierFunction);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var _typeID = null;

	/**
	 * An immutable graphics path: a mathematical description of shapes or lines to be drawn in a graphics context.
	 * @access public
	 * @see https://developer.apple.com/reference/coregraphics/cgpath
	 */

	var CGPath = function () {
	  function CGPath() {
	    _classCallCheck(this, CGPath);
	  }

	  _createClass(CGPath, [{
	    key: 'init',


	    // Creating Graphics Paths

	    /**
	     * Create an immutable path of a rectangle.
	     * @access public
	     * @param {CGRect} rect - The rectangle to add.
	     * @param {?UnsafePointer<CGAffineTransform>} transform - A pointer to an affine transformation matrix, or NULL if no transformation is needed. If specified, Core Graphics applies the transformation to the rectangle before it is added to the path.
	     * @returns {void}
	     * @desc This is a convenience function that creates a path of an rectangle. Using this convenience function is more efficient than creating a mutable path and adding an rectangle to it.Calling this function is equivalent to using minX and related functions to find the corners of the rectangle, then using the moveTo(_:x:y:), addLineTo(_:x:y:), and closeSubpath() functions to draw the rectangle. 
	     * @see https://developer.apple.com/reference/coregraphics/cgpath/1411155-init
	     */
	    value: function init(rect, transform) {

	      // Examining a Graphics Path

	      this._boundingBox = null;
	      this._boundingBoxOfPath = null;
	      this._currentPoint = null;
	      this._isEmpty = false;
	    }

	    /**
	     * Create an immutable path of an ellipse.
	     * @access public
	     * @param {CGRect} rect - The rectangle that bounds the ellipse.
	     * @param {?UnsafePointer<CGAffineTransform>} transform - A pointer to an affine transformation matrix, or NULL if no transformation is needed. If specified, Core Graphics applies the transformation to the ellipse before it is added to the path.
	     * @returns {void}
	     * @desc This is a convenience function that creates a path of an ellipse. Using this convenience function is more efficient than creating a mutable path and adding an ellipse to it.The ellipse is approximated by a sequence of Bzier curves. Its center is the midpoint of the rectangle defined by the rect parameter. If the rectangle is square, then the ellipse is circular with a radius equal to one-half the width (or height) of the rectangle. If the rect parameter specifies a rectangular shape, then the major and minor axes of the ellipse are defined by the width and height of the rectangle. The ellipse forms a complete subpath of the paththat is, the ellipse drawing starts with a move-to operation and ends with a close-subpath operation, with all moves oriented in the clockwise direction. If you supply an affine transform, then the constructed Bzier curves that define the ellipse are transformed before they are added to the path.
	     * @see https://developer.apple.com/reference/coregraphics/cgpath/1411177-init
	     */

	  }, {
	    key: 'initEllipseIn',
	    value: function initEllipseIn(rect, transform) {

	      // Examining a Graphics Path

	      this._boundingBox = null;
	      this._boundingBoxOfPath = null;
	      this._currentPoint = null;
	      this._isEmpty = false;
	    }

	    /**
	     * Create an immutable path of a rounded rectangle.
	     * @access public
	     * @param {CGRect} rect - The rectangle to add.
	     * @param {number} cornerWidth - The width of the rounded corner sections.
	     * @param {number} cornerHeight - The height of the rounded corner sections.
	     * @param {?UnsafePointer<CGAffineTransform>} transform - A pointer to an affine transformation matrix, or NULL if no transformation is needed. If specified, Core Graphics applies the transformation to the rectangle before it is added to the path.
	     * @returns {void}
	     * @desc This is a convenience function that creates a path of an rounded rectangle. Using this convenience function is more efficient than creating a mutable path and adding an rectangle to it.Each corner of the rounded rectangle is one-quarter of an ellipse with axes equal to the cornerWidth and cornerHeight parameters. The rounded rectangle forms a complete subpath and is oriented in the clockwise direction.
	     * @see https://developer.apple.com/reference/coregraphics/cgpath/1411218-init
	     */

	  }, {
	    key: 'initRoundedRect',
	    value: function initRoundedRect(rect, cornerWidth, cornerHeight, transform) {

	      // Examining a Graphics Path

	      this._boundingBox = null;
	      this._boundingBoxOfPath = null;
	      this._currentPoint = null;
	      this._isEmpty = false;
	    }

	    // Copying a Graphics Path

	    /**
	     * Creates an immutable copy of a graphics path.
	     * @access public
	     * @returns {?CGPath} - 
	     * @see https://developer.apple.com/reference/coregraphics/cgpath/1411211-copy
	     */

	  }, {
	    key: 'copy',
	    value: function copy() {
	      return null;
	    }

	    /**
	     * Creates an immutable copy of a graphics path transformed by a transformation matrix.
	     * @access public
	     * @param {?UnsafePointer<CGAffineTransform>} transform - A pointer to an affine transformation matrix, or NULL if no transformation is needed. If specified, Core Graphics applies the transformation to all elements of the new path.
	     * @returns {?CGPath} - 
	     * @see https://developer.apple.com/reference/coregraphics/cgpath/1411161-copy
	     */

	  }, {
	    key: 'copyUsing',
	    value: function copyUsing(transform) {
	      return null;
	    }

	    /**
	     * Returns a new path equivalent to the results of drawing the path with a dashed stroke.
	     * @access public
	     * @param {number} phase - A value that specifies how far into the dash pattern the line starts, in units of the user space. For example, a value of 0 draws a line starting with the beginning of a dash pattern, and a value of 3 means the line is drawn with the dash pattern starting at three units from its beginning. 
	     * @param {number[]} lengths - An array of values that specify the lengths, in user space coordinates, of the painted and unpainted segments  of the dash pattern.For example, the array [2,3] sets a dash pattern that alternates between a 2-unit-long painted segment and a 3-unit-long unpainted segment. The array [1,3,4,2] sets the pattern to a 1-unit painted segment, a 3-unit unpainted segment, a 4-unit painted segment, and a 2-unit unpainted segment.Pass an empty array to clear the dash pattern so that all stroke drawing in the context uses solid lines.
	     * @param {CGAffineTransform} transform - An affine transform to apply to the path before dashing. Defaults to the identity transform if not specified.
	     * @returns {CGPath} - 
	     * @desc The new path is created so that filling the new path draws the same pixels as stroking the original path with the specified dash parameters.
	     * @see https://developer.apple.com/reference/coregraphics/cgpath/2427137-copy
	     */

	  }, {
	    key: 'copyDashingWithPhase',
	    value: function copyDashingWithPhase(phase, lengths, transform) {
	      return null;
	    }

	    /**
	     * Returns a new path equivalent to the results of drawing the path with a solid stroke. 
	     * @access public
	     * @param {number} lineWidth - The line width to use, in user space units. The value must be greater than 0.
	     * @param {CGLineCap} lineCap - The line cap style to render. (For equivalent CGContext drawing methods, the default style is butt.) 
	     * @param {CGLineJoin} lineJoin - The line join style to render. (For equivalent CGContext drawing methods, the default style is miter.) 
	     * @param {number} miterLimit - A value that limits how sharp individual corners in the path can be when using the miter line join style. When the ratio of a the length required for a mitered corner to the line width exceeds this value, that corner uses the bevel style instead.
	     * @param {CGAffineTransform} transform - An affine transform to apply to the path before dashing. Defaults to the identity transform if not specified.
	     * @returns {CGPath} - 
	     * @desc The new path is created so that filling the new path draws the same pixels as stroking the original path with the specified line style.
	     * @see https://developer.apple.com/reference/coregraphics/cgpath/2427133-copy
	     */

	  }, {
	    key: 'copyStrokingWithWidth',
	    value: function copyStrokingWithWidth(lineWidth, lineCap, lineJoin, miterLimit, transform) {
	      return null;
	    }

	    /**
	     * Creates a mutable copy of an existing graphics path.
	     * @access public
	     * @returns {?CGMutablePath} - 
	     * @desc You can modify a mutable graphics path by calling the various path geometry functions, such as addArc(_:x:y:radius:startAngle:endAngle:clockwise:), addLineTo(_:x:y:), and moveTo(_:x:y:).
	     * @see https://developer.apple.com/reference/coregraphics/cgpath/1411196-mutablecopy
	     */

	  }, {
	    key: 'mutableCopy',
	    value: function mutableCopy() {
	      return null;
	    }

	    /**
	     * Creates a mutable copy of a graphics path transformed by a transformation matrix.
	     * @access public
	     * @param {?UnsafePointer<CGAffineTransform>} transform - A pointer to an affine transformation matrix, or NULL if no transformation is needed. If specified, Core Graphics applies the transformation to all elements of the new path.
	     * @returns {?CGMutablePath} - 
	     * @see https://developer.apple.com/reference/coregraphics/cgpath/1411150-mutablecopy
	     */

	  }, {
	    key: 'mutableCopyUsing',
	    value: function mutableCopyUsing(transform) {
	      return null;
	    }

	    // Examining a Graphics Path

	    /**
	     * Returns whether the specified point is interior to the path.
	     * @access public
	     * @param {CGPoint} point - The point to check.
	     * @param {CGPathFillRule} rule - The rule for determining which areas to treat as the interior of the path. Defaults to the winding rule if not specified.
	     * @param {CGAffineTransform} transform - An affine transform to apply to the point before checking for containment in the path. Defaults to the identity transform if not specified.
	     * @returns {boolean} - 
	     * @desc A point is contained in a path if it would be inside the painted region when the path is filled.
	     * @see https://developer.apple.com/reference/coregraphics/cgpath/2427117-contains
	     */

	  }, {
	    key: 'containsUsing',
	    value: function containsUsing(point, rule, transform) {
	      return false;
	    }

	    /**
	     * Indicates whether or not a graphics path represents a rectangle.
	     * @access public
	     * @param {?UnsafeMutablePointer<CGRect>} rect - On input, a pointer to an uninitialized rectangle. If the specified path represents a rectangle, on return contains a copy of the rectangle. 
	     * @returns {boolean} - 
	     * @see https://developer.apple.com/reference/coregraphics/cgpath/1411163-isrect
	     */

	  }, {
	    key: 'isRect',
	    value: function isRect(rect) {
	      return false;
	    }
	    /**
	     * Returns the bounding box containing all points in a graphics path.
	     * @type {CGRect}
	     * @desc The bounding box is the smallest rectangle completely enclosing all points in the path, including control points for Bzier and quadratic curves. 
	     * @see https://developer.apple.com/reference/coregraphics/cgpath/1411165-boundingbox
	     */

	  }, {
	    key: 'apply',


	    // Applying a Function to the Elements of a Path

	    /**
	     * For each element in a graphics path, calls a custom applier function.
	     * @access public
	     * @param {?Object} info - A pointer to the user data that Core Graphics will pass to the function being applied, or NULL.
	     * @param {CGPathApplierFunction} _function - 
	     * @returns {void}
	     * @desc For each element in the specified path, Core Graphics calls the applier function, which can examine (but not modify) the element.
	     * @see https://developer.apple.com/reference/coregraphics/cgpath/1411203-apply
	     */
	    value: function apply(info, _function) {}

	    // Working with Core Foundation Types
	    /**
	     * Returns the Core Foundation type identifier for Core Graphics graphics paths.
	     * @type {CFTypeID}
	     * @desc 
	     * @see https://developer.apple.com/reference/coregraphics/cgpath/1411192-typeid
	     */

	  }, {
	    key: 'init__byDashing',


	    // Initializers

	    /**
	     * Creates a dashed copy of another path.
	     * @access public
	     * @param {CGPath} path - The path to copy.
	     * @param {?UnsafePointer<CGAffineTransform>} transform - A pointer to an affine transformation matrix, or NULL if no transformation is needed. If specified, Core Graphics applies the transformation to elements of the converted path before adding them to the new path.
	     * @param {number} phase - A value that specifies how far into the dash pattern the line starts, in units of the user space. For example, passing a value of 3 means the line is drawn with the dash pattern starting at three units from its beginning. Passing a value of 0 draws a line starting with the beginning of a dash pattern.
	     * @param {?UnsafePointer<CGFloat>} lengths - An array of values that specify the lengths of the painted segments and unpainted segments, respectively, of the dash patternor NULL for no dash pattern.For example, passing an array with the values [2,3] sets a dash pattern that alternates between a 2-user-space-unit-long painted segment and a 3-user-space-unit-long unpainted segment. Passing the values [1,3,4,2] sets the pattern to a 1-unit painted segment, a 3-unit unpainted segment, a 4-unit painted segment, and a 2-unit unpainted segment.
	     * @param {number} count - If the lengths parameter specifies an array, pass the number of elements in the array. Otherwise, pass 0.
	     * @returns {void}
	     * @desc The new path is created so that filling the new path draws the same pixels as stroking the original path with the specified dash parameters.
	     * @see https://developer.apple.com/reference/coregraphics/cgpath/1411134-init
	     */
	    value: function init__byDashing(path, transform, phase, lengths, count) {

	      // Examining a Graphics Path

	      this._boundingBox = null;
	      this._boundingBoxOfPath = null;
	      this._currentPoint = null;
	      this._isEmpty = false;
	    }

	    /**
	     * Creates a stroked copy of another path.
	     * @access public
	     * @param {CGPath} path - The path to copy.
	     * @param {?UnsafePointer<CGAffineTransform>} transform - A pointer to an affine transformation matrix, or NULL if no transformation is needed. If specified, Core Graphics applies the transformation to elements of the converted path before adding them to the new path.
	     * @param {number} lineWidth - The line width to use, in user space units. The value must be greater than 0.
	     * @param {CGLineCap} lineCap - A line cap style constantbutt (the default), round, or square. 
	     * @param {CGLineJoin} lineJoin - A line join valuemiter (the default), round, or bevel. 
	     * @param {number} miterLimit - The miter limit to use.
	     * @returns {void}
	     * @desc The new path is created so that filling the new path draws the same pixels as stroking the original path.If the line join style is set to kCGLineJoinMiter, Core Graphics uses the miter limit to determine whether the lines should be joined with a bevel instead of a miter. Core Graphics divides the length of the miter by the line width. If the result is greater than the miter limit, Core Graphics converts the style to a bevel. 
	     * @see https://developer.apple.com/reference/coregraphics/cgpath/1411128-init
	     */

	  }, {
	    key: 'init__byStroking',
	    value: function init__byStroking(path, transform, lineWidth, lineCap, lineJoin, miterLimit) {

	      // Examining a Graphics Path

	      this._boundingBox = null;
	      this._boundingBoxOfPath = null;
	      this._currentPoint = null;
	      this._isEmpty = false;
	    }
	  }, {
	    key: 'boundingBox',
	    get: function get() {
	      return this._boundingBox;
	    }
	    /**
	     * Returns the bounding box of a graphics path.
	     * @type {CGRect}
	     * @desc The path bounding box is the smallest rectangle completely enclosing all points in the path but not including control points for Bzier and quadratic curves. 
	     * @see https://developer.apple.com/reference/coregraphics/cgpath/1411200-boundingboxofpath
	     */

	  }, {
	    key: 'boundingBoxOfPath',
	    get: function get() {
	      return this._boundingBoxOfPath;
	    }
	    /**
	     * Returns the current point in a graphics path.
	     * @type {CGPoint}
	     * @desc If the path is emptythat is, if it has no elementsthis function returns CGPointZero (see CGGeometry). To determine whether a path is empty, use isEmpty.
	     * @see https://developer.apple.com/reference/coregraphics/cgpath/1411132-currentpoint
	     */

	  }, {
	    key: 'currentPoint',
	    get: function get() {
	      return this._currentPoint;
	    }
	    /**
	     * Indicates whether or not a graphics path is empty.
	     * @type {boolean}
	     * @desc An empty path contains no elements.
	     * @see https://developer.apple.com/reference/coregraphics/cgpath/1411149-isempty
	     */

	  }, {
	    key: 'isEmpty',
	    get: function get() {
	      return this._isEmpty;
	    }
	  }], [{
	    key: 'typeID',
	    get: function get() {
	      return _typeID;
	    }
	  }]);

	  return CGPath;
	}();

	exports.default = CGPath;

/***/ },
/* 20 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * Rules for determining which regions are interior to a path, used by the fillPath(using:) and clip(using:) methods.
	 * @typedef {Object} CGPathFillRule
	 * @property {number} evenOdd - A rule that considers a region to be interior to a path based on the number of times it is enclosed by path elements.
	 * @property {number} winding - A rule that considers a region to be interior to a path if the winding number for that region is nonzero.
	 * @see https://developer.apple.com/reference/coregraphics/cgpathfillrule
	 */

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var CGPathFillRule = {
	  evenOdd: 1,
	  winding: 0
	};

	exports.default = CGPathFillRule;

/***/ },
/* 21 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * Defines a callback function that can view an element in a graphics path.
	 * @type {function(): void}
	 * @returns {void}
	 * @see https://developer.apple.com/reference/coregraphics/cgpathapplierfunction
	 */

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var CGPathApplierFunction = function CGPathApplierFunction() {};

	exports.default = CGPathApplierFunction;

/***/ },
/* 22 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * A structure that contains a two-dimensional vector.
	 * @access public
	 * @see https://developer.apple.com/reference/coregraphics/cgvector
	 */

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var CGVector = function () {
	  function CGVector() {
	    _classCallCheck(this, CGVector);
	  }

	  _createClass(CGVector, [{
	    key: 'init',


	    // Initializers

	    /**
	     * Creates a vector with components specified as integer values.
	     * @access public
	     * @param {number} dx - 
	     * @param {number} dy - 
	     * @returns {void}
	     * @see https://developer.apple.com/reference/coregraphics/cgvector/1456249-init
	     */
	    value: function init(dx, dy) {

	      // Special Values

	      this._zero = null;

	      // Geometric Properties

	      this._dx = 0;
	      this._dy = 0;
	    }

	    // Special Values
	    /**
	     * The vector whose components are both zero.
	     * @type {CGVector}
	     * @desc 
	     * @see https://developer.apple.com/reference/coregraphics/cgvector/1454067-zero
	     */

	  }, {
	    key: 'zero',
	    get: function get() {
	      return this._zero;
	    }

	    // Geometric Properties

	  }]);

	  return CGVector;
	}();

	exports.default = CGVector;

/***/ },
/* 23 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * DispatchObject is the base class for many dispatch types, including DispatchQueue, DispatchGroup, and DispatchSource. 
	 * @access public
	 * @see https://developer.apple.com/reference/dispatch/dispatchobject
	 */

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var DispatchObject = function () {

	  /**
	   * constructor
	   * @access public
	   * @constructor
	   */
	  function DispatchObject() {
	    _classCallCheck(this, DispatchObject);
	  }
	  // nothing to do


	  // Instance Methods

	  /**
	   * Activates the dispatch object.
	   * @access public
	   * @returns {void}
	   * @desc Once a dispatch object has been activated, it cannot change its target queue.
	   * @see https://developer.apple.com/reference/dispatch/dispatchobject/1641002-activate
	   */


	  _createClass(DispatchObject, [{
	    key: 'activate',
	    value: function activate() {}

	    /**
	     * Resume the invocation of block objects on a dispatch object.
	     * @access public
	     * @returns {void}
	     * @desc Calling this function decrements the suspension count of a suspended dispatch queue or dispatch event source object. While the count is greater than zero, the object remains suspended. When the suspension count returns to zero, any blocks submitted to the dispatch queue or any events observed by the dispatch source while suspended are delivered.With one exception, each call to resume() must balance a call to suspend(). New dispatch event source objects returned by dispatch_source_create(_:_:_:_:) have a suspension count of 1 and must be resumed before any events are delivered. This approach allows your application to fully configure the dispatch event source object prior to delivery of the first event. In all other cases, it is undefined to call resume() more times than suspend(), which would result in a negative suspension count.
	     * @see https://developer.apple.com/reference/dispatch/dispatchobject/1452929-resume
	     */

	  }, {
	    key: 'resume',
	    value: function resume() {}

	    /**
	     * Sets the target queue for the given object.
	     * @access public
	     * @param {?DispatchQueue} queue - The new target queue for the object. The queue is retained, and the previous one, if any, is released. This parameter cannot be NULL.
	     * @returns {void}
	     * @desc An object's target queue is responsible for processing the object. The target queue determines the queue on which the object's finalizer is invoked. In addition, modifying the target queue of some objects changes their behavior:Dispatch queues:A dispatch queue's priority is inherited from its target queue. Use the dispatch_get_global_queue(_:_:) function to obtain a suitable target queue of the desired priority.If you submit a block to a serial queue, and the serial queues target queue is a different serial queue, that block is not invoked concurrently with blocks submitted to the target queue or to any other queue with that same target queue.ImportantIf you modify the target queue for a queue, you must be careful to avoid creating cycles in the queue hierarchy.Dispatch sources:A dispatch source's target queue specifies where its event handler and cancellation handler blocks are submitted.Dispatch I/O channels:A dispatch I/O channel's target queue specifies where its I/O operations are executed. This may affect the priority of the resulting I/O operations. For example, if the channel's target queue's priority is set to DISPATCH_QUEUE_PRIORITY_BACKGROUND, then any I/O operations performed by read(offset:length:queue:ioHandler:) or write(offset:data:queue:ioHandler:) on that queue are throttled when there is I/O contention.
	     * @see https://developer.apple.com/reference/dispatch/dispatchobject/1452989-settarget
	     */

	  }, {
	    key: 'setTarget',
	    value: function setTarget(queue) {}

	    /**
	     * Suspends the invocation of block objects on a dispatch object.
	     * @access public
	     * @returns {void}
	     * @desc By suspending a dispatch object, your application can temporarily prevent the execution of any blocks associated with that object. The suspension occurs after completion of any blocks running at the time of the call. Calling this function increments the suspension count of the object, and calling resume() decrements it. While the count is greater than zero, the object remains suspended, so you must balance each suspend() call with a matching resume() call.Any blocks submitted to a dispatch queue or events observed by a dispatch source are delivered once the object is resumed. 
	     * @see https://developer.apple.com/reference/dispatch/dispatchobject/1452801-suspend
	     */

	  }, {
	    key: 'suspend',
	    value: function suspend() {}
	  }]);

	  return DispatchObject;
	}();

	exports.default = DispatchObject;

/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _DispatchObject2 = __webpack_require__(23);

	var _DispatchObject3 = _interopRequireDefault(_DispatchObject2);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	//import __OS_dispatch_queue_attr from './__OS_dispatch_queue_attr'
	//import DispatchQoS from '.i/DispatchQoS'
	//import DispatchWorkItem from './DispatchWorkItem'
	//import DispatchGroup from './DispatchGroup'
	//import DispatchWorkItemFlags from './DispatchWorkItemFlags'
	//import DispatchTime from './DispatchTime'
	//import DispatchWallTime from './DispatchWallTime'
	//import DispatchSpecificKey from './DispatchSpecificKey'

	var _AutoreleaseFrequency = {
	  inherit: 0,
	  never: 2,
	  workItem: 1
	};

	/**
	 * @deprecated
	 */
	var _GlobalQueuePriority = {
	  background: 3,
	  default: 1,
	  high: 0,
	  low: 2
	};

	var _main = null;

	/**
	 * DispatchQueue manages the execution of work items. Each work item submitted to a queue is processed on a pool of threads managed by the system.
	 * @access public
	 * @extends {DispatchObject}
	 * @see https://developer.apple.com/reference/dispatch/dispatchqueue
	 */

	var DispatchQueue = function (_DispatchObject) {
	  _inherits(DispatchQueue, _DispatchObject);

	  // Initializers

	  /**
	   * 
	   * @access public
	   * @param {string} label - 
	   * @param {DispatchQoS} qos - 
	   * @param {DispatchQueue.Attributes} attributes - 
	   * @param {DispatchQueue.AutoreleaseFrequency} autoreleaseFrequency - 
	   * @param {?DispatchQueue} target - 
	   * @constructor
	   * @see https://developer.apple.com/reference/dispatch/dispatchqueue/2300059-init
	   */
	  function DispatchQueue(label, qos, attributes, autoreleaseFrequency, target) {
	    _classCallCheck(this, DispatchQueue);

	    /**
	     * @access private
	     * @type {string}
	     */
	    var _this = _possibleConstructorReturn(this, (DispatchQueue.__proto__ || Object.getPrototypeOf(DispatchQueue)).call(this));

	    _this._label = label;

	    /**
	     * @access private
	     * @type {DispatchQoS}
	     */
	    _this._qos = qos;

	    /**
	     * @access private
	     * @type {DispatchQueue.Attributes}
	     */
	    _this._attributes = attributes;

	    /**
	     * @access private
	     * @type {DispatchQueue.AutoreleaseFrequency}
	     */
	    _this._target = target;
	    return _this;
	  }

	  /**
	   * Creates a new dispatch queue to which blocks can be submitted.
	   * @access public
	   * @param {?UnsafePointer<Int8>} label - A string label to attach to the queue to uniquely identify it in debugging tools such as Instruments, sample, stackshots, and crash reports.  Because applications, libraries, and frameworks can all create their own dispatch queues, a reverse-DNS naming style (com.example.myqueue) is recommended.  This parameter is optional and can be NULL.
	   * @param {?__OS_dispatch_queue_attr} attr - In macOS 10.7 and later or iOS 4.3 and later, specify DISPATCH_QUEUE_SERIAL (or NULL) to create a serial queue or specify DISPATCH_QUEUE_CONCURRENT to create a concurrent queue. In earlier versions, you must specify NULL for this parameter.
	   * @returns {void}
	   * @desc Blocks submitted to a serial queue are executed one at a time in FIFO order. Note, however, that blocks submitted to independent queues may be executed concurrently with respect to each other. Blocks submitted to a concurrent queue are dequeued in FIFO order but may run concurrently if resources are available to do so.If your app isnt using ARC, you should call dispatch_release on a dispatch queue when its no longer needed. Any pending blocks submitted to a queue hold a reference to that queue, so the queue is not deallocated until all pending blocks have completed.
	   * @see https://developer.apple.com/reference/dispatch/dispatchqueue/1453030-init
	   */


	  _createClass(DispatchQueue, [{
	    key: 'init__label',
	    value: function init__label(label, attr) {

	      // Instance Properties

	      this._label = '';
	      this._qos = null;
	    }

	    /**
	     * 
	     * @access public
	     * @param {?UnsafePointer<Int8>} label - 
	     * @param {?__OS_dispatch_queue_attr} attr - 
	     * @param {?DispatchQueue} target - 
	     * @returns {void}
	     * @see https://developer.apple.com/reference/dispatch/dispatchqueue/1642205-init
	     */

	  }, {
	    key: 'init__labelQueue',
	    value: function init__labelQueue(label, attr, target) {

	      // Instance Properties

	      this._label = '';
	      this._qos = null;
	    }

	    // Instance Methods

	    /**
	     * 
	     * @access public
	     * @param {DispatchWorkItem} workItem - 
	     * @returns {void}
	     * @see https://developer.apple.com/reference/dispatch/dispatchqueue/1452870-sync
	     */

	  }, {
	    key: 'syncExecute',
	    value: function syncExecute(workItem) {}

	    /**
	     * 
	     * @access public
	     * @param {DispatchWorkItem} workItem - 
	     * @returns {void}
	     * @see https://developer.apple.com/reference/dispatch/dispatchqueue/2016103-async
	     */

	  }, {
	    key: 'asyncExecute',
	    value: function asyncExecute(workItem) {}

	    /**
	     * 
	     * @access public
	     * @param {DispatchTime} deadline - 
	     * @param {DispatchWorkItem} execute - 
	     * @returns {void}
	     * @see https://developer.apple.com/reference/dispatch/dispatchqueue/2300020-asyncafter
	     */

	  }, {
	    key: 'asyncAfter',
	    value: function asyncAfter(deadline, execute) {
	      var delay = deadline - Date.now();
	      window.setTimeout(function () {
	        execute();
	      }, delay);
	    }

	    /**
	     * 
	     * @access public
	     * @param {DispatchTime} deadline - 
	     * @param {DispatchQoS} qos - 
	     * @param {DispatchWorkItemFlags} flags - 
	     * @param {function(): void} work - 
	     * @returns {void}
	     * @see https://developer.apple.com/reference/dispatch/dispatchqueue/2300100-asyncafter
	     */

	  }, {
	    key: 'asyncAfterExecute',
	    value: function asyncAfterExecute(deadline, qos, flags, work) {}

	    /**
	     * 
	     * @access public
	     * @param {DispatchSpecificKey<T>} key - 
	     * @returns {?T} - 
	     * @see https://developer.apple.com/reference/dispatch/dispatchqueue/1780751-getspecific
	     */

	  }, {
	    key: 'getSpecific',
	    value: function getSpecific(key) {
	      return null;
	    }

	    /**
	     * 
	     * @access public
	     * @param {DispatchSpecificKey<T>} key - 
	     * @param {T} value - 
	     * @returns {void}
	     * @see https://developer.apple.com/reference/dispatch/dispatchqueue/1780629-setspecific
	     */

	  }, {
	    key: 'setSpecific',
	    value: function setSpecific(key, value) {}

	    /**
	     * 
	     * @access public
	     * @param {DispatchWorkItemFlags} flags - 
	     * @returns {void}
	     * @throws {Error}
	     * @see https://developer.apple.com/reference/dispatch/dispatchqueue/2016077-sync
	     */

	  }, {
	    key: 'sync',
	    value: function sync(flags) {}

	    // Instance Properties
	    /**
	     * 
	     * @type {string}
	     * @desc 
	     * @see https://developer.apple.com/reference/dispatch/dispatchqueue/1780825-label
	     */

	  }, {
	    key: 'label',
	    get: function get() {
	      return this._label;
	    }
	    /**
	     * 
	     * @type {DispatchQoS}
	     * @desc 
	     * @see https://developer.apple.com/reference/dispatch/dispatchqueue/1781008-qos
	     */

	  }, {
	    key: 'qos',
	    get: function get() {
	      return this._qos;
	    }

	    // Type Properties
	    /**
	     * 
	     * @type {DispatchQueue}
	     * @desc 
	     * @see https://developer.apple.com/reference/dispatch/dispatchqueue/1781006-main
	     */

	  }], [{
	    key: 'concurrentPerformExecute',


	    // Type Methods

	    /**
	     * 
	     * @access public
	     * @param {number} iterations - 
	     * @param {function(arg1: number): void} work - 
	     * @returns {void}
	     * @see https://developer.apple.com/reference/dispatch/dispatchqueue/2016088-concurrentperform
	     */
	    value: function concurrentPerformExecute(iterations, work) {}

	    /**
	     * 
	     * @deprecated
	     * @access public
	     * @param {DispatchQueue.GlobalQueuePriority} priority - 
	     * @returns {DispatchQueue} - 
	     * @see https://developer.apple.com/reference/dispatch/dispatchqueue/2300070-global
	     */

	  }, {
	    key: 'global',
	    value: function global(priority) {
	      return null;
	    }
	  }, {
	    key: 'main',
	    get: function get() {
	      return _main;
	    }
	  }]);

	  return DispatchQueue;
	}(_DispatchObject3.default);

	//_main = new DispatchQueue("com.apple.main-thread", new DispatchQoS(DispatchQoS.userInteractive, 0))


	exports.default = DispatchQueue;
	_main = new DispatchQueue("com.apple.main-thread", null);

/***/ },
/* 25 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * DispatchTime represents a point in time relative to the default clock with nanosecond precision. On Apple platforms, the default clock is based on the Mach absolute time unit.
	 * @access public
	 * @see https://developer.apple.com/reference/dispatch/dispatchtime
	 */

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var DispatchTime = function () {

	  // Initializers

	  /**
	   * Creates a time relative to the system clock that ticks since boot.
	   * @access public
	   * @param {UInt64} uptimeNanoseconds - The number of nanoseconds since boot, excluding any time the system spent asleep.
	   * @returns {void}
	   * @desc On Apple platforms, this clock is the same as the value returned by mach_absolute_time when converted into nanoseconds.
	   * @see https://developer.apple.com/reference/dispatch/dispatchtime/2300057-init
	   */
	  function DispatchTime(uptimeNanoseconds) {
	    _classCallCheck(this, DispatchTime);

	    // Instance Properties

	    this._uptimeNanoseconds = uptimeNanoseconds;
	  }

	  // Instance Properties
	  /**
	   * Returns the number of nanoseconds since boot, excluding any time the system spent asleep.
	   * @type {UInt64}
	   * @desc 
	   * @see https://developer.apple.com/reference/dispatch/dispatchtime/2300047-uptimenanoseconds
	   */


	  _createClass(DispatchTime, [{
	    key: 'uptimeNanoseconds',
	    get: function get() {
	      throw new Error('uptimeNanoseconds: not implemented');
	    }

	    // Type Properties

	    /**
	     * Returns a time in the distant future.
	     * @access public
	     * @returns {DispatchTime} -
	     * @desc You can pass this value to methods that schedule work to have the system wait indefinitely for a particular event to occur or condition to be met.
	     * @see https://developer.apple.com/reference/dispatch/dispatchtime/1780795-distantfuture
	     */

	  }], [{
	    key: 'now',


	    // Type Methods

	    /**
	     * Returns the current time.
	     * @access public
	     * @returns {DispatchTime} - 
	     * @see https://developer.apple.com/reference/dispatch/dispatchtime/1780853-now
	     */
	    value: function now() {
	      return Date.now();
	    }
	  }, {
	    key: 'distantFuture',
	    get: function get() {}
	  }]);

	  return DispatchTime;
	}();

	exports.default = DispatchTime;

/***/ },
/* 26 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * DispatchTimeInterval represents a number of seconds, millisconds, microseconds, or nanoseconds. You use DispatchTimeInterval values to specify the interval at which a DispatchSourceTimer fires or I/O handlers are invoked for a DispatchIO channel, as well as to increment and decrement DispatchTime values.
	 * @typedef {Object} DispatchTimeInterval
	 * @property {function} seconds - A number of seconds.
	 * @property {function} milliseconds - A number of milliseconds.
	 * @property {function} microseconds - A number of microseconds.
	 * @property {function} nanoseconds - A number of nanoseconds.
	 * @see https://developer.apple.com/reference/dispatch/dispatchtimeinterval
	 */

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var DispatchTimeInterval = {
	  seconds: function seconds(value) {
	    return value * 1000.0;
	  },
	  milliseconds: function milliseconds(value) {
	    return value;
	  },
	  microseconds: function microseconds(value) {
	    return value * 0.001;
	  },
	  nanoseconds: function nanoseconds(value) {
	    return value * 0.000001;
	  }
	};

	exports.default = DispatchTimeInterval;

/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _NSObject2 = __webpack_require__(2);

	var _NSObject3 = _interopRequireDefault(_NSObject2);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * dummy class for NSKeyedArchiver/Unarchiver
	 * @access public
	 * @extends {NSObject}
	 */
	var NSArray = function (_NSObject) {
	  _inherits(NSArray, _NSObject);

	  function NSArray() {
	    _classCallCheck(this, NSArray);

	    return _possibleConstructorReturn(this, (NSArray.__proto__ || Object.getPrototypeOf(NSArray)).apply(this, arguments));
	  }

	  _createClass(NSArray, null, [{
	    key: 'initWithCoder',

	    /**
	     * @access public
	     * @param {NSCoder} coder -
	     * @returns {Object[]} -
	     */
	    value: function initWithCoder(coder) {
	      var arr = [];
	      if (typeof coder._refObj['NS.objects'] !== 'undefined') {
	        var objects = coder._refObj['NS.objects'];
	        if (!Array.isArray(objects)) {
	          throw new Error('NS.objects must be Array');
	        }

	        var objCoder = coder.copy();
	        objCoder._refObj = objects;

	        for (var i = 0; i < objects.length; i++) {
	          var obj = objCoder.decodeObjectForKey(i);
	          arr.push(obj);
	        }
	      } else {
	        for (var _i = 0;; _i++) {
	          var key = 'NS.object.' + _i;
	          if (typeof coder._refObj[key] === 'undefined') {
	            break;
	          }
	          var _obj = coder.decodeObjectForKey(key);
	          arr.push(_obj);
	        }
	      }

	      return arr;
	    }
	  }]);

	  return NSArray;
	}(_NSObject3.default);

	exports.default = NSArray;

/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _NSObject2 = __webpack_require__(2);

	var _NSObject3 = _interopRequireDefault(_NSObject2);

	var _CGPoint = __webpack_require__(7);

	var _CGPoint2 = _interopRequireDefault(_CGPoint);

	var _CGRect = __webpack_require__(8);

	var _CGRect2 = _interopRequireDefault(_CGRect);

	var _CGSize = __webpack_require__(9);

	var _CGSize2 = _interopRequireDefault(_CGSize);

	var _CGVector = __webpack_require__(22);

	var _CGVector2 = _interopRequireDefault(_CGVector);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var _DecodingFailurePolicy = {
	  raiseException: Symbol('raiseException'),
	  setErrorAndReturn: Symbol('setErrorAndReturn')
	};

	/**
	 * The NSCoder abstract class declares the interface used by concrete subclasses to transfer objects and other values between memory and some other format. This capability provides the basis for archiving (where objects and data items are stored on disk) and distribution (where objects and data items are copied between different processes or threads). The concrete subclasses provided by Foundation for these purposes are NSArchiver, NSUnarchiver, NSKeyedArchiver, NSKeyedUnarchiver, and NSPortCoder. Concrete subclasses of NSCoder are referred to in general as coder classes, and instances of these classes as coder objects (or simply coders). A coder object that can only encode values is referred to as an encoder object, and one that can only decode values as a decoder object.
	 * @access public
	 * @extends {NSObject}
	 * @see https://developer.apple.com/reference/foundation/nscoder
	 */

	var NSCoder = function (_NSObject) {
	  _inherits(NSCoder, _NSObject);

	  /**
	   * constructor
	   * @access public
	   * @constructor
	   */
	  function NSCoder() {
	    _classCallCheck(this, NSCoder);

	    // Inspecting a Coder

	    var _this = _possibleConstructorReturn(this, (NSCoder.__proto__ || Object.getPrototypeOf(NSCoder)).call(this));

	    _this._allowsKeyedCoding = false;

	    // Secure Coding

	    _this._requiresSecureCoding = false;
	    _this._allowedClasses = null;

	    // Getting Version Information

	    _this._systemVersion = 0;

	    // Instance Properties

	    _this._decodingFailurePolicy = null;
	    _this._error = null;
	    return _this;
	  }

	  _createClass(NSCoder, [{
	    key: 'containsValueForKey',


	    // Inspecting a Coder

	    /**
	     * Returns a Boolean value that indicates whether an encoded value is available for a string.
	     * @access public
	     * @param {string} key - 
	     * @returns {boolean} - 
	     * @desc Subclasses must override this method if they perform keyed coding. The string is passed as key.
	     * @see https://developer.apple.com/reference/foundation/nscoder/1416125-containsvalue
	     */
	    value: function containsValueForKey(key) {
	      return false;
	    }
	    /**
	     * A Boolean value that indicates whether the receiver supports keyed coding of objects.
	     * @type {boolean}
	     * @desc false by default. Concrete subclasses that support keyed coding, such as NSKeyedArchiver, need to override this property to return true.
	     * @see https://developer.apple.com/reference/foundation/nscoder/1417541-allowskeyedcoding
	     */

	  }, {
	    key: 'encodeArrayOfObjCTypeAt',


	    // Encoding General Data

	    /**
	     * Encodes an array of count items, whose Objective-C type is given by itemType.
	     * @access public
	     * @param {UnsafePointer<Int8>} type - 
	     * @param {number} count - 
	     * @param {UnsafeRawPointer} array - 
	     * @returns {void}
	     * @desc The values are encoded from the buffer beginning at address. itemType must contain exactly one type code. NSCoders implementation invokes encodeValue(ofObjCType:at:) to encode the entire array of items. Subclasses that implement the encodeValue(ofObjCType:at:) method do not need to override this method.This method must be matched by a subsequent decodeArray(ofObjCType:count:at:) message.For information on creating an Objective-C type code suitable for itemType, see Type Encodings.Special ConsiderationsYou should not use this method to encode C arrays of Objective-C objects. See decodeArray(ofObjCType:count:at:) for more details.
	     * @see https://developer.apple.com/reference/foundation/nscoder/1417865-encodearray
	     */
	    value: function encodeArrayOfObjCTypeAt(type, count, array) {}

	    /**
	     * Encodes the object objv and associates it with the string key.
	     * @access public
	     * @param {?Object} objv - 
	     * @param {string} key - 
	     * @returns {void}
	     * @desc Subclasses must override this method to identify multiple encodings of objv and encode a reference to objv instead. For example, NSKeyedArchiver detects duplicate objects and encodes a reference to the original object rather than encode the same object twice.
	     * @see https://developer.apple.com/reference/foundation/nscoder/1411568-encode
	     */

	  }, {
	    key: 'encodeForKey',
	    value: function encodeForKey(objv, key) {}

	    /**
	     * Can be overridden by subclasses to encode object so that a copy, rather than a proxy, is created upon decoding.
	     * @access public
	     * @param {?Object} anObject - 
	     * @returns {void}
	     * @desc NSCoders implementation simply invokes encode(_:).This method must be matched by a corresponding decodeObject() message.
	     * @see https://developer.apple.com/reference/foundation/nscoder/1418225-encodebycopyobject
	     */

	  }, {
	    key: 'encodeBycopyObject',
	    value: function encodeBycopyObject(anObject) {}

	    /**
	     * Can be overridden by subclasses to encode object so that a proxy, rather than a copy, is created upon decoding.
	     * @access public
	     * @param {?Object} anObject - 
	     * @returns {void}
	     * @desc NSCoders implementation simply invokes encode(_:).This method must be matched by a corresponding decodeObject() message.
	     * @see https://developer.apple.com/reference/foundation/nscoder/1416279-encodebyrefobject
	     */

	  }, {
	    key: 'encodeByrefObject',
	    value: function encodeByrefObject(anObject) {}

	    /**
	     * Encodes a buffer of data whose types are unspecified.
	     * @access public
	     * @param {?UnsafeRawPointer} byteaddr - 
	     * @param {number} length - 
	     * @returns {void}
	     * @desc The buffer to be encoded begins at address, and its length in bytes is given by numBytes.This method must be matched by a corresponding decodeBytes(withReturnedLength:) message.
	     * @see https://developer.apple.com/reference/foundation/nscoder/1411664-encodebytes
	     */

	  }, {
	    key: 'encodeBytes',
	    value: function encodeBytes(byteaddr, length) {}

	    /**
	     * Encodes a buffer of data, bytesp, whose length is specified by lenv, and associates it with the string key.
	     * @access public
	     * @param {?UnsafePointer<UInt8>} bytesp - 
	     * @param {number} lenv - 
	     * @param {string} key - 
	     * @returns {void}
	     * @desc Subclasses must override this method if they perform keyed coding.
	     * @see https://developer.apple.com/reference/foundation/nscoder/1413078-encodebytes
	     */

	  }, {
	    key: 'encodeBytesLengthForKey',
	    value: function encodeBytesLengthForKey(bytesp, lenv, key) {}

	    /**
	     * Can be overridden by subclasses to conditionally encode object, preserving common references to that object.
	     * @access public
	     * @param {?Object} object - 
	     * @returns {void}
	     * @desc In the overriding method, object should be encoded only if its unconditionally encoded elsewhere (with any other encode...Object: method).This method must be matched by a subsequent decodeObject() message. Upon decoding, if object was never encoded unconditionally, decodeObject returns nil in place of object. However, if object was encoded unconditionally, all references to object must be resolved.NSCoders implementation simply invokes encode(_:). 
	     * @see https://developer.apple.com/reference/foundation/nscoder/1415196-encodeconditionalobject
	     */

	  }, {
	    key: 'encodeConditionalObject',
	    value: function encodeConditionalObject(object) {}

	    /**
	     * Conditionally encodes a reference to objv and associates it with the string key only if objv has been unconditionally encoded with encode(_:forKey:).
	     * @access public
	     * @param {?Object} objv - 
	     * @param {string} key - 
	     * @returns {void}
	     * @desc Subclasses must override this method if they support keyed coding.The encoded object is decoded with the decodeObject(forKey:) method. If objv was never encoded unconditionally, decodeObject(forKey:) returns nil in place of objv.
	     * @see https://developer.apple.com/reference/foundation/nscoder/1413918-encodeconditionalobject
	     */

	  }, {
	    key: 'encodeConditionalObjectForKey',
	    value: function encodeConditionalObjectForKey(objv, key) {}

	    /**
	     * Encodes size.
	     * @access public
	     * @param {CGSize} size - 
	     * @returns {void}
	     * @desc NSCoders implementation invokes encodeValue(ofObjCType:at:) to encode size.This method must be matched by a subsequent decodeSize() message.
	     * @see https://developer.apple.com/reference/foundation/nscoder/1391291-encode
	     */

	  }, {
	    key: 'encode',
	    value: function encode(size) {}

	    /**
	     * Encodes intv and associates it with the string key.
	     * @access public
	     * @param {number} intv - 
	     * @param {string} key - 
	     * @returns {void}
	     * @desc Subclasses must override this method if they perform keyed coding.
	     * @see https://developer.apple.com/reference/foundation/nscoder/1413906-encodecint
	     */

	  }, {
	    key: 'encodeCIntForKey',
	    value: function encodeCIntForKey(intv, key) {}

	    /**
	     * Encodes the property list aPropertyList.
	     * @access public
	     * @param {Object} aPropertyList - 
	     * @returns {void}
	     * @desc NSCoders implementation invokes encodeValue(ofObjCType:at:) to encode aPropertyList.This method must be matched by a subsequent decodePropertyList() message.
	     * @see https://developer.apple.com/reference/foundation/nscoder/1410643-encodepropertylist
	     */

	  }, {
	    key: 'encodePropertyList',
	    value: function encodePropertyList(aPropertyList) {}

	    /**
	     * Can be overridden by subclasses to encode an interconnected group of Objective-C objects, starting with rootObject.
	     * @access public
	     * @param {Object} rootObject - 
	     * @returns {void}
	     * @desc NSCoders implementation simply invokes encode(_:).This method must be matched by a subsequent decodeObject() message.
	     * @see https://developer.apple.com/reference/foundation/nscoder/1409439-encoderootobject
	     */

	  }, {
	    key: 'encodeRootObject',
	    value: function encodeRootObject(rootObject) {}

	    /**
	     * Must be overridden by subclasses to encode a single value residing at address, whose Objective-C type is given by valueType.
	     * @access public
	     * @param {UnsafePointer<Int8>} type - 
	     * @param {UnsafeRawPointer} addr - 
	     * @returns {void}
	     * @desc  valueType must contain exactly one type code.This method must be matched by a subsequent decodeValue(ofObjCType:at:) message.For information on creating an Objective-C type code suitable for valueType, see Type Encodings.Special ConsiderationsYou should not use this method to encode of Objective-C objects. See decodeArray(ofObjCType:count:at:) for more details.
	     * @see https://developer.apple.com/reference/foundation/nscoder/1414648-encodevalue
	     */

	  }, {
	    key: 'encodeValueOfObjCTypeAt',
	    value: function encodeValueOfObjCTypeAt(type, addr) {}

	    // Decoding General Data

	    /**
	     * Decodes an array of count items, whose Objective-C type is given by itemType.
	     * @access public
	     * @param {UnsafePointer<Int8>} itemType - 
	     * @param {number} count - 
	     * @param {Object} array - 
	     * @returns {void}
	     * @desc The items are decoded into the buffer beginning at address, which must be large enough to contain them all. itemType must contain exactly one type code. NSCoders implementation invokes decodeValue(ofObjCType:at:) to decode the entire array of items.This method matches an encodeArray(ofObjCType:count:at:) message used during encoding.For information on creating an Objective-C type code suitable for itemType, see Type Encodings.Special ConsiderationsYou should not use this method to decode C arrays of Objective-C objects. For historical reasons, returned objects will have an additional ownership reference which you can only relinquish using CFRelease.
	     * @see https://developer.apple.com/reference/foundation/nscoder/1408354-decodearray
	     */

	  }, {
	    key: 'decodeArrayOfObjCTypeAt',
	    value: function decodeArrayOfObjCTypeAt(itemType, count, array) {}

	    /**
	     * Decodes and returns a boolean value that was previously encoded with encode(_:forKey:) and associated with the string key.
	     * @access public
	     * @param {string} key - 
	     * @returns {boolean} - 
	     * @desc Subclasses must override this method if they perform keyed coding.
	     * @see https://developer.apple.com/reference/foundation/nscoder/1409293-decodebool
	     */

	  }, {
	    key: 'decodeBoolForKey',
	    value: function decodeBoolForKey(key) {
	      return false;
	    }

	    /**
	     * Decodes a buffer of data that was previously encoded with encodeBytes(_:length:forKey:) and associated with the string key.
	     * @access public
	     * @param {string} key - 
	     * @param {?UnsafeMutablePointer<Int>} lengthp - 
	     * @returns {?UnsafePointer<UInt8>} - 
	     * @desc  The buffers length is returned by reference in lengthp. The returned bytes are immutable. Subclasses must override this method if they perform keyed coding.
	     * @see https://developer.apple.com/reference/foundation/nscoder/1411987-decodebytes
	     */

	  }, {
	    key: 'decodeBytesForKeyReturnedLength',
	    value: function decodeBytesForKeyReturnedLength(key, lengthp) {
	      return null;
	    }

	    /**
	     * Decodes a buffer of data whose types are unspecified.
	     * @access public
	     * @param {UnsafeMutablePointer<Int>} lengthp - 
	     * @returns {?Object} - 
	     * @desc NSCoders implementation invokes decodeValue(ofObjCType:at:) to decode the data as a series of bytes, which this method then places into a buffer and returns. The buffers length is returned by reference in numBytes. If you need the bytes beyond the scope of the current @autoreleasepool block, you must copy them.This method matches an encodeBytes(_:length:) message used during encoding.
	     * @see https://developer.apple.com/reference/foundation/nscoder/1415441-decodebytes
	     */

	  }, {
	    key: 'decodeBytesWithReturnedLength',
	    value: function decodeBytesWithReturnedLength(lengthp) {
	      return null;
	    }

	    /**
	     * Decodes and returns an NSData object that was previously encoded with encode(_:). Subclasses must override this method.
	     * @access public
	     * @returns {?Data} - 
	     * @desc The implementation of your overriding method must match the implementation of your encode(_:) method. For example, a typical encode(_:) method encodes the number of bytes of data followed by the bytes themselves. Your override of this method must read the number of bytes, create an NSData object of the appropriate size, and decode the bytes into the new NSData object. 
	     * @see https://developer.apple.com/reference/foundation/nscoder/1409876-decodedata
	     */

	  }, {
	    key: 'decodeData',
	    value: function decodeData() {
	      return null;
	    }

	    /**
	     * Decodes and returns a double value that was previously encoded with either encode(_:forKey:) or encode(_:forKey:) and associated with the string key.
	     * @access public
	     * @param {string} key - 
	     * @returns {number} - 
	     * @desc Subclasses must override this method if they perform keyed coding.
	     * @see https://developer.apple.com/reference/foundation/nscoder/1409374-decodedouble
	     */

	  }, {
	    key: 'decodeDoubleForKey',
	    value: function decodeDoubleForKey(key) {
	      return 0;
	    }

	    /**
	     * Decodes and returns a float value that was previously encoded with encode(_:forKey:) or encode(_:forKey:) and associated with the string key.
	     * @access public
	     * @param {string} key - 
	     * @returns {number} - 
	     * @desc If the value was encoded as a double, the extra precision is lost. If the encoded real value does not fit into a float, the method raises an NSRangeException. Subclasses must override this method if they perform keyed coding.
	     * @see https://developer.apple.com/reference/foundation/nscoder/1408104-decodefloat
	     */

	  }, {
	    key: 'decodeFloatForKey',
	    value: function decodeFloatForKey(key) {
	      return 0;
	    }

	    /**
	     * Decodes and returns an int value that was previously encoded with encodeCInt(_:forKey:), encode(_:forKey:), encode(_:forKey:), or encode(_:forKey:) and associated with the string key.
	     * @access public
	     * @param {string} key - 
	     * @returns {number} - 
	     * @desc If the encoded integer does not fit into the default integer size, the method raises an NSRangeException. Subclasses must override this method if they perform keyed coding.
	     * @see https://developer.apple.com/reference/foundation/nscoder/1411168-decodecint
	     */

	  }, {
	    key: 'decodeCIntForKey',
	    value: function decodeCIntForKey(key) {
	      return 0;
	    }

	    /**
	     * Decodes and returns an NSInteger value that was previously encoded with encodeCInt(_:forKey:), encode(_:forKey:), encode(_:forKey:), or encode(_:forKey:) and associated with the string key.
	     * @access public
	     * @param {string} key - 
	     * @returns {number} - 
	     * @desc If the encoded integer does not fit into the NSInteger size, the method raises an NSRangeException. Subclasses must override this method if they perform keyed coding.
	     * @see https://developer.apple.com/reference/foundation/nscoder/1409246-decodeinteger
	     */

	  }, {
	    key: 'decodeIntegerForKey',
	    value: function decodeIntegerForKey(key) {
	      return 0;
	    }

	    /**
	     * Decodes and returns a 32-bit integer value that was previously encoded with encodeCInt(_:forKey:), encode(_:forKey:), encode(_:forKey:), or encode(_:forKey:) and associated with the string key.
	     * @access public
	     * @param {string} key - 
	     * @returns {number} - 
	     * @desc If the encoded integer does not fit into a 32-bit integer, the method raises an NSRangeException. Subclasses must override this method if they perform keyed coding.
	     * @see https://developer.apple.com/reference/foundation/nscoder/1408918-decodeint32
	     */

	  }, {
	    key: 'decodeInt32ForKey',
	    value: function decodeInt32ForKey(key) {
	      return 0;
	    }

	    /**
	     * Decodes and returns a 64-bit integer value that was previously encoded with encodeCInt(_:forKey:), encode(_:forKey:), encode(_:forKey:), or encode(_:forKey:) and associated with the string key.
	     * @access public
	     * @param {string} key - 
	     * @returns {Int64} - 
	     * @desc Subclasses must override this method if they perform keyed coding.
	     * @see https://developer.apple.com/reference/foundation/nscoder/1407878-decodeint64
	     */

	  }, {
	    key: 'decodeInt64ForKey',
	    value: function decodeInt64ForKey(key) {
	      return null;
	    }

	    /**
	     * Decodes an Objective-C object that was previously encoded with any of the encode...Object: methods.
	     * @access public
	     * @returns {?Object} - 
	     * @desc NSCoders implementation invokes decodeValue(ofObjCType:at:) to decode the object data.Subclasses may need to override this method if they override any of the corresponding encode...Object: methods. For example, if an object was encoded conditionally using the encodeConditionalObject(_:) method, this method needs to check whether the object had actually been encoded.
	     * @see https://developer.apple.com/reference/foundation/nscoder/1414478-decodeobject
	     */

	  }, {
	    key: 'decodeObject',
	    value: function decodeObject() {
	      return null;
	    }

	    /**
	     * Decodes and returns an Objective-C object that was previously encoded with encode(_:forKey:) or encodeConditionalObject(_:forKey:) and associated with the string key.
	     * @access public
	     * @param {string} key - 
	     * @returns {?Object} - 
	     * @desc Subclasses must override this method if they perform keyed coding.
	     * @see https://developer.apple.com/reference/foundation/nscoder/1418185-decodeobject
	     */

	  }, {
	    key: 'decodeObjectForKey',
	    value: function decodeObjectForKey(key) {
	      return null;
	    }

	    /**
	     * Decodes and returns an NSPoint structure that was previously encoded with encode(_:).
	     * @access public
	     * @returns {CGPoint} - 
	     * @see https://developer.apple.com/reference/foundation/nscoder/1391189-decodepoint
	     */

	  }, {
	    key: 'decodePoint',
	    value: function decodePoint() {
	      return null;
	    }

	    /**
	     * Decodes and returns an NSPoint structure that was previously encoded with encode(_:forKey:).
	     * @access public
	     * @param {string} key - 
	     * @returns {CGPoint} - 
	     * @see https://developer.apple.com/reference/foundation/nscoder/1391214-decodepoint
	     */

	  }, {
	    key: 'decodePointForKey',
	    value: function decodePointForKey(key) {
	      return null;
	    }

	    /**
	     * Decodes a property list that was previously encoded with encodePropertyList(_:).
	     * @access public
	     * @returns {?Object} - 
	     * @see https://developer.apple.com/reference/foundation/nscoder/1411916-decodepropertylist
	     */

	  }, {
	    key: 'decodePropertyList',
	    value: function decodePropertyList() {
	      return null;
	    }

	    /**
	     * Decodes and returns an NSRect structure that was previously encoded with encode(_:).
	     * @access public
	     * @returns {CGRect} - 
	     * @see https://developer.apple.com/reference/foundation/nscoder/1391269-decoderect
	     */

	  }, {
	    key: 'decodeRect',
	    value: function decodeRect() {
	      return null;
	    }

	    /**
	     * Decodes and returns an NSRect structure that was previously encoded with encode(_:forKey:).
	     * @access public
	     * @param {string} key - 
	     * @returns {CGRect} - 
	     * @see https://developer.apple.com/reference/foundation/nscoder/1391116-decoderect
	     */

	  }, {
	    key: 'decodeRectForKey',
	    value: function decodeRectForKey(key) {
	      return null;
	    }

	    /**
	     * Decodes and returns an NSSize structure that was previously encoded with encode(_:).
	     * @access public
	     * @returns {CGSize} - 
	     * @see https://developer.apple.com/reference/foundation/nscoder/1391144-decodesize
	     */

	  }, {
	    key: 'decodeSize',
	    value: function decodeSize() {
	      return null;
	    }

	    /**
	     * Decodes and returns an NSSize structure that was previously encoded with encode(_:forKey:).
	     * @access public
	     * @param {string} key - 
	     * @returns {CGSize} - 
	     * @see https://developer.apple.com/reference/foundation/nscoder/1391253-decodesize
	     */

	  }, {
	    key: 'decodeSizeForKey',
	    value: function decodeSizeForKey(key) {
	      return null;
	    }

	    /**
	     * Decodes a single value, whose Objective-C type is given by valueType.
	     * @access public
	     * @param {UnsafePointer<Int8>} type - 
	     * @param {Object} data - 
	     * @returns {void}
	     * @desc  valueType must contain exactly one type code, and the buffer specified by data must be large enough to hold the value corresponding to that type code. For information on creating an Objective-C type code suitable for valueType, see Type Encodings.Subclasses must override this method and provide an implementation to decode the value. In your overriding implementation, decode the value into the buffer beginning at data.This method matches an encodeValue(ofObjCType:at:) message used during encoding.
	     * @see https://developer.apple.com/reference/foundation/nscoder/1417159-decodevalue
	     */

	  }, {
	    key: 'decodeValueOfObjCTypeAt',
	    value: function decodeValueOfObjCTypeAt(type, data) {}

	    /**
	     * Returns a decoded property list for the specified key.
	     * @access public
	     * @param {string} key - The coder key.
	     * @returns {?Object} - 
	     * @desc This method calls decodeObjectOfClasses:forKey: with a set allowing only property list types.
	     * @see https://developer.apple.com/reference/foundation/nscoder/1416284-decodepropertylist
	     */

	  }, {
	    key: 'decodePropertyListForKey',
	    value: function decodePropertyListForKey(key) {
	      return null;
	    }

	    // Decoding Geometry-Based Data

	    /**
	     * Decodes and returns the CGPoint structure associated with the specified key in the receivers archive. 
	     * @access public
	     * @param {string} key - The key that identifies the point.
	     * @returns {CGPoint} - 
	     * @desc Use this method to decode a point that was previously encoded using the encode(_:forKey:) method.
	     * @see https://developer.apple.com/reference/foundation/nscoder/1624523-decodecgpoint
	     */

	  }, {
	    key: 'decodeCGPointForKey',
	    value: function decodeCGPointForKey(key) {
	      return null;
	    }

	    /**
	     * Decodes and returns the CGRect structure associated with the specified key in the receivers archive. 
	     * @access public
	     * @param {string} key - The key that identifies the rectangle.
	     * @returns {CGRect} - 
	     * @desc Use this method to decode a rectangle that was previously encoded using the encode(_:forKey:) method.
	     * @see https://developer.apple.com/reference/foundation/nscoder/1624522-decodecgrect
	     */

	  }, {
	    key: 'decodeCGRectForKey',
	    value: function decodeCGRectForKey(key) {
	      return null;
	    }

	    /**
	     * Decodes and returns the CGSize structure associated with the specified key in the receivers archive. 
	     * @access public
	     * @param {string} key - The key that identifies the size information.
	     * @returns {CGSize} - 
	     * @desc Use this method to decode size information that was previously encoded using the encode(_:forKey:) method.
	     * @see https://developer.apple.com/reference/foundation/nscoder/1624519-decodecgsize
	     */

	  }, {
	    key: 'decodeCGSizeForKey',
	    value: function decodeCGSizeForKey(key) {
	      return null;
	    }

	    /**
	     * Decodes and returns the CGAffineTransform structure associated with the specified key in the receivers archive. 
	     * @access public
	     * @param {string} key - The key that identifies the affine transform.
	     * @returns {CGAffineTransform} - 
	     * @desc Use this method to decode size information that was previously encoded using the encode(_:forKey:) method.
	     * @see https://developer.apple.com/reference/foundation/nscoder/1624478-decodecgaffinetransform
	     */

	  }, {
	    key: 'decodeCGAffineTransformForKey',
	    value: function decodeCGAffineTransformForKey(key) {
	      return null;
	    }

	    /**
	     * Decodes and returns the UIEdgeInsets structure associated with the specified key in the receivers archive. 
	     * @access public
	     * @param {string} key - The key that identifies the edge insets.
	     * @returns {UIEdgeInsets} - 
	     * @desc Use this method to decode size information that was previously encoded using the encode(_:forKey:) method.
	     * @see https://developer.apple.com/reference/foundation/nscoder/1624492-decodeuiedgeinsets
	     */

	  }, {
	    key: 'decodeUIEdgeInsetsForKey',
	    value: function decodeUIEdgeInsetsForKey(key) {
	      return null;
	    }

	    /**
	     * Decodes and returns the UIOffset structure associated with the specified key in the receivers archive. 
	     * @access public
	     * @param {string} key - The key that identifies the offset.
	     * @returns {UIOffset} - 
	     * @desc Use this method to decode offset information that was previously encoded using the encode(_:forKey:) method.
	     * @see https://developer.apple.com/reference/foundation/nscoder/1624507-decodeuioffset
	     */

	  }, {
	    key: 'decodeUIOffsetForKey',
	    value: function decodeUIOffsetForKey(key) {
	      return null;
	    }

	    /**
	     * Decodes and returns the CGVector data associated with the specified key in the coders archive.
	     * @access public
	     * @param {string} key - The key that identifies the vector.
	     * @returns {CGVector} - 
	     * @desc Use this method to decode vector information that was previously encoded using the encode(_:forKey:) method.
	     * @see https://developer.apple.com/reference/foundation/nscoder/1624488-decodecgvector
	     */

	  }, {
	    key: 'decodeCGVectorForKey',
	    value: function decodeCGVectorForKey(key) {
	      return null;
	    }

	    // Decoding Core Media Time Structures

	    /**
	     * Returns the CMTime structure associated with a given key.
	     * @access public
	     * @param {string} key - The key for a CMTime structure encoded in the receiver.
	     * @returns {CMTime} - 
	     * @see https://developer.apple.com/reference/foundation/nscoder/1389544-decodetime
	     */

	  }, {
	    key: 'decodeTimeForKey',
	    value: function decodeTimeForKey(key) {
	      return null;
	    }

	    /**
	     * Returns the CMTimeRange structure associated with a given key.
	     * @access public
	     * @param {string} key - The key for a CMTimeRange structure encoded in the receiver.
	     * @returns {CMTimeRange} - 
	     * @see https://developer.apple.com/reference/foundation/nscoder/1385718-decodetimerange
	     */

	  }, {
	    key: 'decodeTimeRangeForKey',
	    value: function decodeTimeRangeForKey(key) {
	      return null;
	    }

	    /**
	     * Returns the CMTimeMapping structure associated with a given key.
	     * @access public
	     * @param {string} key - The key for a CMTimeMapping structure encoded in the receiver.
	     * @returns {CMTimeMapping} - 
	     * @see https://developer.apple.com/reference/foundation/nscoder/1389860-decodetimemapping
	     */

	  }, {
	    key: 'decodeTimeMappingForKey',
	    value: function decodeTimeMappingForKey(key) {
	      return null;
	    }

	    // Secure Coding
	    /**
	     * Boolean value that indicates whether the coder requires secure coding.
	     * @type {boolean}
	     * @desc true if this coder requires secure coding; false otherwise.Secure coders check a set of allowed classes before decoding objects, and all objects must implement the NSSecureCoding protocol.
	     * @see https://developer.apple.com/reference/foundation/nscoder/1409845-requiressecurecoding
	     */

	  }, {
	    key: 'versionForClassName',


	    // Getting Version Information

	    /**
	     * This method is present for historical reasons and is not used with keyed archivers.
	     * @access public
	     * @param {string} className - 
	     * @returns {number} - 
	     * @desc The version number does apply not to NSKeyedArchiver/NSKeyedUnarchiver.  A keyed archiver does not encode class version numbers.
	     * @see https://developer.apple.com/reference/foundation/nscoder/1417703-version
	     */
	    value: function versionForClassName(className) {
	      return 0;
	    }
	    /**
	     * The system version in effect for the archive.
	     * @type {number}
	     * @desc During encoding, the current version. During decoding, the version that was in effect when the data was encoded.Subclasses that implement decoding must override this property to return the system version of the data being decoded.
	     * @see https://developer.apple.com/reference/foundation/nscoder/1413205-systemversion
	     */

	  }, {
	    key: 'decodeObjectOfClassForKey',


	    // Instance Methods

	    /**
	     * 
	     * @access public
	     * @param {DecodedObjectType.Type} cls - 
	     * @param {string} key - 
	     * @returns {NSCoding} - 
	     * @see https://developer.apple.com/reference/foundation/nscoder/2292924-decodeobject
	     */
	    value: function decodeObjectOfClassForKey(cls, key) {
	      return null;
	    }

	    /**
	     * 
	     * @access public
	     * @returns {void}
	     * @throws {Error}
	     * @see https://developer.apple.com/reference/foundation/nscoder/1407699-decodetoplevelobject
	     */

	  }, {
	    key: 'decodeTopLevelObject',
	    value: function decodeTopLevelObject() {}

	    /**
	     * 
	     * @access public
	     * @param {string} key - 
	     * @returns {void}
	     * @throws {Error}
	     * @see https://developer.apple.com/reference/foundation/nscoder/2293311-decodetoplevelobject
	     */

	  }, {
	    key: 'decodeTopLevelObjectForKey',
	    value: function decodeTopLevelObjectForKey(key) {}

	    /**
	     * 
	     * @access public
	     * @param {?Object[]} classes - 
	     * @param {string} key - 
	     * @returns {void}
	     * @throws {Error}
	     * @see https://developer.apple.com/reference/foundation/nscoder/2293221-decodetoplevelobject
	     */

	  }, {
	    key: 'decodeTopLevelObjectOfForKey',
	    value: function decodeTopLevelObjectOfForKey(classes, key) {}

	    /**
	     * 
	     * @access public
	     * @param {Error} error - 
	     * @returns {void}
	     * @see https://developer.apple.com/reference/foundation/nscoder/1411455-failwitherror
	     */

	  }, {
	    key: 'failWithError',
	    value: function failWithError(error) {}
	  }, {
	    key: 'allowsKeyedCoding',
	    get: function get() {
	      return this._allowsKeyedCoding;
	    }
	  }, {
	    key: 'requiresSecureCoding',
	    get: function get() {
	      return this._requiresSecureCoding;
	    }
	    /**
	     * The set of coded classes allowed for secure coding.
	     * @type {?Set<AnyHashable>}
	     * @desc Secure coders check this set of allowed classes before decoding objects, and all objects must implement the NSSecureCoding protocol.
	     * @see https://developer.apple.com/reference/foundation/nscoder/1412486-allowedclasses
	     */

	  }, {
	    key: 'allowedClasses',
	    get: function get() {
	      return this._allowedClasses;
	    }
	  }, {
	    key: 'systemVersion',
	    get: function get() {
	      return this._systemVersion;
	    }

	    // Instance Properties
	    /**
	     * 
	     * @type {NSCoder.DecodingFailurePolicy}
	     * @desc 
	     * @see https://developer.apple.com/reference/foundation/nscoder/1642984-decodingfailurepolicy
	     */

	  }, {
	    key: 'decodingFailurePolicy',
	    get: function get() {
	      return this._decodingFailurePolicy;
	    }

	    /**
	     * 
	     * @type {?Error}
	     * @desc 
	     * @see https://developer.apple.com/reference/foundation/nscoder/1643263-error
	     */

	  }, {
	    key: 'error',
	    get: function get() {
	      return this._error;
	    }
	  }], [{
	    key: 'DecodingFailurePolicy',
	    get: function get() {
	      return _DecodingFailurePolicy;
	    }
	  }]);

	  return NSCoder;
	}(_NSObject3.default);

	exports.default = NSCoder;

/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _NSObject2 = __webpack_require__(2);

	var _NSObject3 = _interopRequireDefault(_NSObject2);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * dummy class for NSColorSpace
	 * @access public
	 * @extends {NSObject}
	 */
	var NSColorSpace = function (_NSObject) {
	  _inherits(NSColorSpace, _NSObject);

	  _createClass(NSColorSpace, null, [{
	    key: '_propTypes',
	    get: function get() {
	      return {
	        NSICC: ['NSMutableData', '_icc'],
	        NSSpaceID: ['integer', '_spaceID'],
	        NSID: ['integer', '_id']
	      };
	    }
	  }]);

	  function NSColorSpace() {
	    _classCallCheck(this, NSColorSpace);

	    var _this = _possibleConstructorReturn(this, (NSColorSpace.__proto__ || Object.getPrototypeOf(NSColorSpace)).call(this));

	    _this._icc = null;
	    _this._spaceID = null;
	    _this._id = null;
	    return _this;
	  }

	  return NSColorSpace;
	}(_NSObject3.default);

	exports.default = NSColorSpace;

/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _NSObject2 = __webpack_require__(2);

	var _NSObject3 = _interopRequireDefault(_NSObject2);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * dummy class for NSKeyedArchiver/Unarchiver
	 * @access public
	 * @extends {NSObject}
	 */
	var NSData = function (_NSObject) {
	  _inherits(NSData, _NSObject);

	  function NSData() {
	    _classCallCheck(this, NSData);

	    return _possibleConstructorReturn(this, (NSData.__proto__ || Object.getPrototypeOf(NSData)).apply(this, arguments));
	  }

	  _createClass(NSData, null, [{
	    key: 'initWithCoder',

	    /**
	     * @access public
	     * @param {NSCoder} coder -
	     * @returns {_Buffer} -
	     */
	    value: function initWithCoder(coder) {
	      var data = coder.decodeBytesForKeyReturnedLength('NS.data', null);
	      if (typeof data !== 'undefined') {
	        return data;
	      }
	      var bytes = coder.decodeBytesForKeyReturnedLength('NS.bytes', null);
	      if (typeof bytes !== 'undefined') {
	        return bytes;
	      }
	      return null;
	    }
	  }]);

	  return NSData;
	}(_NSObject3.default);

	exports.default = NSData;

/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _NSObject2 = __webpack_require__(2);

	var _NSObject3 = _interopRequireDefault(_NSObject2);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * dummy class for NSKeyedArchiver/Unarchiver
	 * @access public
	 * @extends {NSObject}
	 */
	var NSDictionary = function (_NSObject) {
	  _inherits(NSDictionary, _NSObject);

	  function NSDictionary() {
	    _classCallCheck(this, NSDictionary);

	    return _possibleConstructorReturn(this, (NSDictionary.__proto__ || Object.getPrototypeOf(NSDictionary)).apply(this, arguments));
	  }

	  _createClass(NSDictionary, null, [{
	    key: 'initWithCoder',

	    /**
	     * @access public
	     * @param {NSCoder} coder -
	     * @returns {Object} -
	     */
	    value: function initWithCoder(coder) {
	      var dict = {};
	      if (typeof coder._refObj['NS.objects'] !== 'undefined') {
	        var keys = coder._refObj['NS.keys'];
	        var objects = coder._refObj['NS.objects'];
	        if (!Array.isArray(keys)) {
	          throw new Error('NS.keys must be Array');
	        }
	        if (!Array.isArray(objects)) {
	          throw new Error('NS.objects must be Array');
	        }
	        if (keys.length !== objects.length) {
	          throw new Error('NS.keys.length !== NS.objects.length');
	        }

	        var keyCoder = coder.copy();
	        keyCoder._refObj = keys;

	        var objCoder = coder.copy();
	        objCoder._refObj = objects;

	        for (var i = 0; i < keys.length; i++) {
	          var key = keyCoder.decodeObjectForKey(i);
	          var obj = objCoder.decodeObjectForKey(i);
	          dict[key] = obj;
	        }
	      } else {
	        for (var _i = 0;; _i++) {
	          var objKey = 'NS.object.' + _i;
	          var keyKey = 'NS.key.' + _i;
	          if (typeof coder._refObj[objKey] === 'undefined') {
	            break;
	          }
	          var _key = coder.decodeObjectForKey(keyKey);
	          var _obj = coder.decodeObjectForKey(objKey);
	          dict[_key] = _obj;
	        }
	      }

	      return dict;
	    }
	  }]);

	  return NSDictionary;
	}(_NSObject3.default);

	exports.default = NSDictionary;

/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _NSCoder2 = __webpack_require__(28);

	var _NSCoder3 = _interopRequireDefault(_NSCoder2);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	//import NSMutableData from './NSMutableData'
	//import NSKeyedArchiverDelegate from '../undefined/NSKeyedArchiverDelegate'


	/**
	 * NSKeyedArchiver, a concrete subclass of NSCoder, provides a way to encode objects (and scalar values) into an architecture-independent format that can be stored in a file. When you archive a set of objects, the class information and instance variables for each object are written to the archive. NSKeyedArchivers companion class, NSKeyedUnarchiver, decodes the data in an archive and creates a set of objects equivalent to the original set.
	 * @access public
	 * @extends {NSCoder}
	 * @see https://developer.apple.com/reference/foundation/nskeyedarchiver
	 */
	var NSKeyedArchiver = function (_NSCoder) {
	  _inherits(NSKeyedArchiver, _NSCoder);

	  // Initializers

	  /**
	   * 
	   * @access public
	   * @constructor
	   * @see https://developer.apple.com/reference/foundation/nskeyedarchiver/1642790-init
	   */
	  function NSKeyedArchiver() {
	    _classCallCheck(this, NSKeyedArchiver);

	    // Archiving Data

	    /**
	     * The format in which the receiver encodes its data.
	     * @type {PropertyListSerialization.PropertyListFormat}
	     * @see https://developer.apple.com/reference/foundation/nskeyedarchiver/1417520-outputformat
	     */
	    var _this = _possibleConstructorReturn(this, (NSKeyedArchiver.__proto__ || Object.getPrototypeOf(NSKeyedArchiver)).call(this));

	    _this.outputFormat = null;

	    /**
	     * Indicates whether the receiver requires all archived classes to conform to NSSecureCoding.
	     * @type {boolean}
	     * @see https://developer.apple.com/reference/foundation/nskeyedarchiver/1417084-requiressecurecoding
	     */
	    _this.requiresSecureCoding = false;

	    // Managing the Delegate

	    /**
	     * The archivers delegate.
	     * @type {?NSKeyedArchiverDelegate}
	     * @see https://developer.apple.com/reference/foundation/nskeyedarchiver/1412809-delegate
	     */
	    _this.delegate = null;

	    // Instance Properties

	    _this._encodedData = null;
	    return _this;
	  }

	  // Initializing an NSKeyedArchiver Object

	  /**
	   * Returns the receiver, initialized for encoding an archive into a given a mutable-data object.
	   * @access public
	   * @param {NSMutableData} data - The mutable-data object into which the archive is written.
	   * @returns {NSKeyedArchiver}
	   * @desc When you finish encoding data, you must invoke finishEncoding() at which point data is filled. The format of the receiver is NSPropertyListBinaryFormat_v1_0.
	   * @see https://developer.apple.com/reference/foundation/nskeyedarchiver/1409579-init
	   */
	  //initForWritingWith(data) {


	  _createClass(NSKeyedArchiver, [{
	    key: 'finishEncoding',


	    /**
	     * Instructs the receiver to construct the final data stream.
	     * @access public
	     * @returns {void}
	     * @desc No more values can be encoded after this method is called. You must call this method when finished.
	     * @see https://developer.apple.com/reference/foundation/nskeyedarchiver/1413904-finishencoding
	     */
	    value: function finishEncoding() {}

	    // Encoding Data and Objects

	    /**
	     * Encodes a given float value and associates it with a given key.
	     * @access public
	     * @param {number} realv - The value to encode.
	     * @param {string} key - The key with which to associate realv. This value must not be nil.
	     * @returns {void}
	     * @see https://developer.apple.com/reference/foundation/nskeyedarchiver/1416972-encode
	     */

	  }, {
	    key: 'encodeForKey',
	    value: function encodeForKey(realv, key) {}

	    /**
	     * Encodes a given number of bytes from a given C array of bytes and associates them with the a given key.
	     * @access public
	     * @param {?UnsafePointer<UInt8>} bytesp - A C array of bytes to encode.
	     * @param {number} lenv - The number of bytes from bytesp to encode.
	     * @param {string} key - The key with which to associate the encoded value. This value must not be nil.
	     * @returns {void}
	     * @see https://developer.apple.com/reference/foundation/nskeyedarchiver/1417696-encodebytes
	     */

	  }, {
	    key: 'encodeBytesLengthForKey',
	    value: function encodeBytesLengthForKey(bytesp, lenv, key) {}

	    /**
	     * Encodes a reference to a given object and associates it with a given key only if it has been unconditionally encoded elsewhere in the archive with encode(_:forKey:).
	     * @access public
	     * @param {?Object} objv - The object to encode. 
	     * @param {string} key - The key with which to associate the encoded value. This value must not be nil.
	     * @returns {void}
	     * @see https://developer.apple.com/reference/foundation/nskeyedarchiver/1413677-encodeconditionalobject
	     */

	  }, {
	    key: 'encodeConditionalObjectForKey',
	    value: function encodeConditionalObjectForKey(objv, key) {}

	    // Managing Classes and Class Names

	    /**
	     * Adds a class translation mapping to the receiver whereby instances of of a given class are encoded with a given class name instead of their real class names.
	     * @access public
	     * @param {?string} codedName - 
	     * @param {Object} cls - The class for which to set up a translation mapping.
	     * @returns {void}
	     * @desc When encoding, the receivers translation map overrides any translation that may also be present in the classs map.
	     * @see https://developer.apple.com/reference/foundation/nskeyedarchiver/1414746-setclassname
	     */

	  }, {
	    key: 'encodedData',


	    // Instance Properties
	    /**
	     * Returns the encoded data for the archiver.
	     * @type {Data}
	     * @desc If encoding has not yet finished, invoking this property calls finishEncoding() and returns the data. If you initialized the keyed archiver with a specific mutable data instance, then that data is returned by the property after finishEncoding() is called.
	     * @see https://developer.apple.com/reference/foundation/nskeyedarchiver/1643042-encodeddata
	     */
	    get: function get() {
	      return this._encodedData;
	    }
	  }], [{
	    key: 'archiverForWritingWithData',
	    value: function archiverForWritingWithData(data) {
	      var instance = new NSKeyedArchiver();

	      // TODO: implement

	      return instance;
	    }

	    // Archiving Data

	    /**
	     * Returns an NSData object containing the encoded form of the object graph whose root object is given.
	     * @access public
	     * @param {Object} rootObject - 
	     * @returns {Data} - 
	     * @see https://developer.apple.com/reference/foundation/nskeyedarchiver/1413189-archiveddata
	     */

	  }, {
	    key: 'archivedDataWithRootObject',
	    value: function archivedDataWithRootObject(rootObject) {
	      return null;
	    }

	    /**
	     * Archives an object graph rooted at a given object by encoding it into a data object then atomically writes the resulting data object to a file at a given path, and returns a Boolean value that indicates whether the operation was successful.
	     * @access public
	     * @param {Object} rootObject - 
	     * @param {string} path - The path of the file in which to write the archive.
	     * @returns {boolean} - 
	     * @desc The format of the archive is NSPropertyListBinaryFormat_v1_0.
	     * @see https://developer.apple.com/reference/foundation/nskeyedarchiver/1410621-archiverootobject
	     */

	  }, {
	    key: 'archiveRootObjectToFile',
	    value: function archiveRootObjectToFile(rootObject, path) {
	      return false;
	    }
	  }, {
	    key: 'setClassNameFor',
	    value: function setClassNameFor(codedName, cls) {}

	    /**
	     * Returns the class name with which the receiver encodes instances of a given class.
	     * @access public
	     * @param {Object} cls - The class for which to determine the translation mapping.
	     * @returns {?string} - 
	     * @see https://developer.apple.com/reference/foundation/nskeyedarchiver/1407245-classname
	     */

	  }, {
	    key: 'classNameFor',
	    value: function classNameFor(cls) {
	      return null;
	    }
	  }]);

	  return NSKeyedArchiver;
	}(_NSCoder3.default);

	exports.default = NSKeyedArchiver;

/***/ },
/* 33 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _NSCoder2 = __webpack_require__(28);

	var _NSCoder3 = _interopRequireDefault(_NSCoder2);

	var _NSData = __webpack_require__(30);

	var _NSData2 = _interopRequireDefault(_NSData);

	var _File2 = __webpack_require__(34);

	var _File3 = _interopRequireDefault(_File2);

	var _FileReader2 = __webpack_require__(35);

	var _FileReader3 = _interopRequireDefault(_FileReader2);

	var _BinaryReader2 = __webpack_require__(36);

	var _BinaryReader3 = _interopRequireDefault(_BinaryReader2);

	var _ClassList2 = __webpack_require__(10);

	var _ClassList3 = _interopRequireDefault(_ClassList2);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	/*global Buffer*/

	var _classForKey = new Map();
	var _loadingSymbol = Symbol('loading');

	var _UID = function () {
	  function _UID(unarchiver, value) {
	    _classCallCheck(this, _UID);

	    this._unarchiver = unarchiver;
	    this._value = value;
	  }

	  _createClass(_UID, [{
	    key: 'value',
	    get: function get() {
	      return this._value;
	    }
	  }, {
	    key: 'obj',
	    get: function get() {
	      return this._unarchiver._parsedObj.$objects[this._value];
	    }
	  }]);

	  return _UID;
	}();

	/**
	 * NSKeyedUnarchiver, a concrete subclass of NSCoder, defines methods for decoding a set of named objects (and scalar values) from a keyed archive. Such archives are produced by instances of the NSKeyedArchiver class.
	 * @access public
	 * @extends {NSCoder}
	 * @see https://developer.apple.com/reference/foundation/nskeyedunarchiver
	 */


	var NSKeyedUnarchiver = function (_NSCoder) {
	  _inherits(NSKeyedUnarchiver, _NSCoder);

	  // Initializing a Keyed Unarchiver

	  /**
	   * Initializes the receiver for decoding an archive previously encoded by NSKeyedArchiver.
	   * @access public
	   * @constructor
	   * @param {Data} data - An archive previously encoded by NSKeyedArchiver.
	   * @desc When you finish decoding data, you should invoke finishDecoding(). This method throws an exception if data is not a valid archive.
	   * @see https://developer.apple.com/reference/foundation/nskeyedunarchiver/1410862-init
	   */
	  function NSKeyedUnarchiver() {
	    var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

	    _classCallCheck(this, NSKeyedUnarchiver);

	    // Unarchiving Data

	    /**
	     * Indicates whether the receiver requires all unarchived classes to conform to NSSecureCoding.
	     * @type {boolean}
	     * @see https://developer.apple.com/reference/foundation/nskeyedunarchiver/1410824-requiressecurecoding
	     */
	    var _this = _possibleConstructorReturn(this, (NSKeyedUnarchiver.__proto__ || Object.getPrototypeOf(NSKeyedUnarchiver)).call(this));

	    _this._requiresSecureCoding = false;

	    // Managing the Delegate

	    /**
	     * The receivers delegate.
	     * @type {?NSKeyedUnarchiverDelegate}
	     * @see https://developer.apple.com/reference/foundation/nskeyedunarchiver/1415688-delegate
	     */
	    _this.delegate = null;

	    // Instance Properties

	    /**
	     * 
	     * @type {NSCoder.DecodingFailurePolicy}
	     * @see https://developer.apple.com/reference/foundation/nskeyedunarchiver/1643164-decodingfailurepolicy
	     */
	    _this._decodingFailurePolicy = null;

	    /**
	     * @access private
	     * @type {?_BinaryReader}
	     */
	    _this._reader = null;

	    /**
	     * @access private
	     * @type {number}
	     */
	    _this._offsetSize = 0;

	    /**
	     * @access private
	     * @type {number}
	     */
	    _this._objCount = 0;

	    /**
	     * @access private
	     * @type {Object[]}
	     */
	    _this._offsetArray = [];

	    /**
	     * @access private
	     * @type {Object}
	     */
	    _this._parsedObj = {};

	    /**
	     * @access private
	     * @type {Object[]}
	     */
	    _this._dataObj = [];

	    _this._resolveFunctions = [];

	    /**
	     * @access private
	     * @type {string}
	     */
	    _this._filePath = null;

	    /**
	     * @access private
	     * @type {?Object}
	     */
	    _this._refObj = null;

	    /**
	     * @access private
	     * @type {boolean}
	     */
	    _this._decodingFinished = false;

	    if (data !== null) {
	      _this._reader = new _BinaryReader3.default(data, true, 'utf8');
	      _this._checkHeader();
	      _this._parsedObj = _this._parseBPlist();
	    }
	    return _this;
	  }

	  _createClass(NSKeyedUnarchiver, [{
	    key: 'copy',
	    value: function copy() {
	      var coder = new NSKeyedUnarchiver();
	      coder._requiresSecureCoding = this._requiresSecureCoding;
	      coder.delegate = this.delegate;
	      coder._decodingFailurePolicy = this._decodingFailurePolicy;
	      coder._reader = this._reader;
	      coder._offsetSize = this._offsetSize;
	      coder._objCount = this._objCount;
	      coder._offsetArray = this._offsetArray;
	      coder._parsedObj = this._parsedObj;
	      coder._dataObj = this._dataObj;
	      coder._resolveFunctions = this._resolveFunctions;
	      coder._filePath = this._filePath;
	      coder._refObj = this._refObj;
	      coder._decodingFinished = this._decodingFinished;
	      return coder;
	    }

	    // Unarchiving Data

	    /**
	     * Decodes and returns the object graph previously encoded by NSKeyedArchiver and stored in a given NSData object.
	     * @access public
	     * @param {Buffer} data - An object graph previously encoded by NSKeyedArchiver.
	     * @param {?string} path - 
	     * @returns {?Object} - 
	     * @desc This method raises an invalidArchiveOperationException if data is not a valid archive.
	     * @see https://developer.apple.com/reference/foundation/nskeyedunarchiver/1413894-unarchiveobject
	     */

	  }, {
	    key: '_checkHeader',
	    value: function _checkHeader() {
	      this._reader.seek(0);
	      var header = this._reader.readString(8);
	      if (header !== 'bplist00') {
	        throw new Error('unsupported file format: ' + header);
	      }
	    }
	  }, {
	    key: '_parseBPlist',
	    value: function _parseBPlist() {
	      var reader = this._reader;

	      // read basic info
	      reader.seek(-26);
	      var dataLen = reader.length;
	      var intSize = reader.readUnsignedByte();
	      this._offsetSize = reader.readUnsignedByte();
	      this._objCount = reader.readUnsignedLongLong();
	      var topIndex = reader.readUnsignedLongLong();
	      var tablePos = reader.readUnsignedLongLong();

	      //console.log(`dataLen: ${dataLen}`)
	      //console.log(`intSize: ${intSize}`)
	      //console.log(`offsetSize: ${this._offsetSize}`)
	      //console.log(`objCount: ${this._objCount}`)
	      //console.log(`topIndex: ${topIndex}`)
	      //console.log(`tablePos: ${tablePos}`)

	      this._offsetArray = [];
	      var pos = tablePos;
	      reader.seek(pos);
	      var objCount = this._objCount;
	      for (var i = 0; i < objCount; i++) {
	        var offset = reader.readInteger(intSize);
	        this._offsetArray.push(offset);
	      }

	      return this._parseObjAtIndex(topIndex);
	    }
	  }, {
	    key: '_parseObjAtIndex',
	    value: function _parseObjAtIndex(index) {
	      return this._parseObj(this._offsetArray[index]);
	    }
	  }, {
	    key: '_parseObj',
	    value: function _parseObj() {
	      var _this2 = this;

	      var offset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
	      var signed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

	      var reader = this._reader;
	      if (offset !== null) {
	        reader.seek(offset);
	      }
	      var type = reader.readUnsignedByte();
	      var type1 = type & 0xF0;
	      var type2 = type & 0x0F;
	      //console.log(`parseObj: type: ${type1} ${type2}`)
	      if (type1 === 0x00) {
	        // null, boolean
	        if (type2 === 0) {
	          //console.log('   type: null')
	          return null;
	        } else if (type2 === 8) {
	          //console.log('   type: boolean')
	          return false;
	        } else if (type2 === 9) {
	          //console.log('   type: boolean')
	          return true;
	        }
	      } else if (type1 === 0x10) {
	        // Int
	        var len = Math.pow(2, type2);
	        //console.log('   type: integer ' + len)
	        return reader.readInteger(len, signed);
	      } else if (type1 === 0x20) {
	        // Float
	        var _len = Math.pow(2, type2);
	        if (_len === 4) {
	          //console.log('   type: float')
	          return reader.readFloat();
	        } else if (_len === 8) {
	          //console.log('   type: double')
	          return reader.readDouble();
	        }
	        throw new Error('unsupported float size: ' + _len);
	      } else if (type1 === 0x30) {
	        // Date
	        //console.log('   type: Date')
	      } else if (type1 === 0x40) {
	        // Data
	        var count = this._getDataSize(type2);
	        //console.log(`   type: Data: length: ${count}`)
	        return reader.readData(count);
	      } else if (type1 === 0x50) {
	        // ASCII
	        var _count = this._getDataSize(type2);
	        //console.log('   type: ascii ' + count)
	        return reader.readString(_count, 'ascii');
	      } else if (type1 === 0x60) {
	        // UTF-16
	        var _count2 = this._getDataSize(type2);
	        //console.log('   type: UTF-16 ' + count)
	        return reader.readString(_count2, 'utf16be'); // Big Endian might not be supported...
	      } else if (type1 === 0x80) {
	        // UID
	        var uid = reader.readInteger(type2 + 1, false);
	        //console.log('   type: UID: ' + uid)
	        return new _UID(this, uid);
	      } else if (type1 === 0xA0) {
	        // Array
	        var _count3 = this._getDataSize(type2);
	        //console.log('   type: array: ' + count)
	        var arrIndex = [];
	        for (var i = 0; i < _count3; i++) {
	          arrIndex.push(reader.readInteger(this._offsetSize, false));
	        }
	        var arr = arrIndex.map(function (index) {
	          return _this2._parseObjAtIndex(index);
	        });
	        //console.log(`***arr.length: ${arr.length}`)
	        return arr;
	      } else if (type1 === 0xC0) {
	        // Set
	        var _count4 = this._getDataSize(type2);
	        var setIndex = [];
	        for (var _i = 0; _i < _count4; _i++) {
	          setIndex.push(reader.readInteger(this._offsetSize, false));
	        }
	        var _arr = setIndex.map(function (index) {
	          return _this2._parseObjAtIndex(index);
	        });
	        return new Set(_arr);
	      } else if (type1 === 0xD0) {
	        // Dictionary
	        //console.log('   type: dictionary')
	        var _count5 = this._getDataSize(type2);
	        var keyIndex = [];
	        var valueIndex = [];
	        for (var _i2 = 0; _i2 < _count5; _i2++) {
	          keyIndex.push(reader.readInteger(this._offsetSize, false));
	        }
	        for (var _i3 = 0; _i3 < _count5; _i3++) {
	          valueIndex.push(reader.readInteger(this._offsetSize, false));
	        }
	        var result = {};
	        for (var _i4 = 0; _i4 < _count5; _i4++) {
	          var key = this._parseObjAtIndex(keyIndex[_i4]);
	          //console.log('key: ' + key)
	          var val = this._parseObjAtIndex(valueIndex[_i4]);
	          //console.log('val: ' + val)
	          result[key] = val;
	        }
	        return result;
	      }

	      throw new Error('unknown data type: ' + type);
	    }
	  }, {
	    key: '_getDataSize',
	    value: function _getDataSize(type2) {
	      var count = 0;
	      if (type2 !== 0x0F) {
	        count = type2;
	      } else {
	        count = this._parseObj(null, false);
	        if (typeof count !== 'number') {
	          throw new Error('data size must be int type');
	        }
	      }
	      return count;
	    }
	  }, {
	    key: '_parseClassAt',
	    value: function _parseClassAt(index) {
	      var _this3 = this;

	      var obj = this._parsedObj.$objects[index];
	      if (this._dataObj[index] === _loadingSymbol) {
	        // it seems to be a reference loop; return Promise
	        return new Promise(function (resolve, reject) {
	          if (typeof _this3._resolveFunctions[index] === 'undefined') {
	            _this3._resolveFunctions[index] = [];
	          }
	          _this3._resolveFunctions[index].push(resolve);
	        });
	      } else if (typeof this._dataObj[index] !== 'undefined') {
	        return this._dataObj[index];
	      }
	      this._dataObj[index] = _loadingSymbol;
	      var data = this._parseClass(obj);
	      this._dataObj[index] = data;
	      if (Array.isArray(this._resolveFunctions[index])) {
	        this._resolveFunctions[index].forEach(function (resolve) {
	          resolve(data);
	        });
	        delete this._resolveFunctions[index];
	      }
	      return data;
	    }
	  }, {
	    key: '_parseClass',
	    value: function _parseClass(obj) {
	      var className = obj.$class.obj.$classname;
	      //console.log(`parseClass ${className}`)
	      var classObj = NSKeyedUnarchiver.classForClassName(className);
	      if (classObj) {
	        var unarchiver = this.copy();
	        unarchiver._refObj = obj;
	        return classObj.initWithCoder(unarchiver);
	      }
	      return null;
	    }

	    /**
	     * @access private
	     * @param {Object} obj -
	     * @param {Object} classObj -
	     * @returns {Object} -
	     */

	  }, {
	    key: '_parseStruct',
	    value: function _parseStruct(obj, classObj) {
	      if (typeof classObj._initWithData !== 'function') {
	        throw new Error(classObj.prototype.constructor.name + ' class doesn\'t have _initWithData function');
	      }
	      return classObj._initWithData(obj);
	    }

	    /**
	     * Decodes and returns the object graph previously encoded by NSKeyedArchiver written to the file at a given path.
	     * @access public
	     * @param {string} path - A path to a file that contains an object graph previously encoded by NSKeyedArchiver.
	     * @returns {Promise} - 
	     * @desc This method raises an invalidArgumentException if the file at path does not contain a valid archive.
	     * @see https://developer.apple.com/reference/foundation/nskeyedunarchiver/1417153-unarchiveobject
	     */

	  }, {
	    key: 'containsValueForKey',


	    // Decoding Data

	    /**
	     * Returns a Boolean value that indicates whether the archive contains a value for a given key within the current decoding scope.
	     * @access public
	     * @param {string} key - A key in the archive within the current decoding scope. key must not be nil.
	     * @returns {boolean} - 
	     * @see https://developer.apple.com/reference/foundation/nskeyedunarchiver/1413564-containsvalue
	     */
	    value: function containsValueForKey(key) {
	      return typeof this._refObj[key] !== 'undefined';
	    }

	    /**
	     * Decodes a Boolean value associated with a given key.
	     * @access public
	     * @param {string} key - A key in the archive within the current decoding scope. key must not be nil.
	     * @returns {boolean} - 
	     * @see https://developer.apple.com/reference/foundation/nskeyedunarchiver/1413260-decodebool
	     */

	  }, {
	    key: 'decodeBoolForKey',
	    value: function decodeBoolForKey(key) {
	      if (this._decodingFinished) {
	        throw new Error('can\'t decode \'' + key + '\' after finishDecoding() is called');
	      }
	      var value = this._getValueForKey(key);
	      return !!value;
	    }

	    /**
	     * Decodes a stream of bytes associated with a given key.
	     * @access public
	     * @param {string} key - A key in the archive within the current decoding scope. key must not be nil.
	     * @param {?UnsafeMutablePointer<Int>} lengthp - Upon return, contains the number of bytes returned.
	     * @returns {?UnsafePointer<UInt8>} - 
	     * @desc The returned value is a pointer to a temporary buffer owned by the receiver. The buffer goes away with the unarchiver, not the containing autorelease pool block. You must copy the bytes into your own buffer if you need the data to persist beyond the life of the receiver.
	     * @see https://developer.apple.com/reference/foundation/nskeyedunarchiver/1418091-decodebytes
	     */

	  }, {
	    key: 'decodeBytesForKeyReturnedLength',
	    value: function decodeBytesForKeyReturnedLength(key, lengthp) {
	      if (this._decodingFinished) {
	        throw new Error('can\'t decode \'' + key + '\' after finishDecoding() is called');
	      }
	      return this._getValueForKey(key);
	    }

	    /**
	     * Decodes a double-precision floating-point value associated with a given key.
	     * @access public
	     * @param {string} key - A key in the archive within the current decoding scope. key must not be nil.
	     * @returns {number} - 
	     * @desc If the archived value was encoded as single-precision, the type is coerced. 
	     * @see https://developer.apple.com/reference/foundation/nskeyedunarchiver/1414963-decodedouble
	     */

	  }, {
	    key: 'decodeDoubleForKey',
	    value: function decodeDoubleForKey(key) {
	      if (this._decodingFinished) {
	        throw new Error('can\'t decode \'' + key + '\' after finishDecoding() is called');
	      }
	      return this._getValueForKey(key);
	    }

	    /**
	     * Decodes a single-precision floating-point value associated with a given key.
	     * @access public
	     * @param {string} key - A key in the archive within the current decoding scope. key must not be nil.
	     * @returns {number} - 
	     * @desc If the archived value was encoded as double precision, the type is coerced, loosing precision. If the archived value is too large for single precision, the method raises an NSRangeException. 
	     * @see https://developer.apple.com/reference/foundation/nskeyedunarchiver/1412252-decodefloat
	     */

	  }, {
	    key: 'decodeFloatForKey',
	    value: function decodeFloatForKey(key) {
	      if (this._decodingFinished) {
	        throw new Error('can\'t decode \'' + key + '\' after finishDecoding() is called');
	      }
	      return this._getValueForKey(key);
	    }

	    /**
	     * Decodes and returns an int value that was previously encoded with encodeCInt(_:forKey:), encode(_:forKey:), encode(_:forKey:), or encode(_:forKey:) and associated with the string key.
	     * @access public
	     * @param {string} key - 
	     * @returns {number} - 
	     * @desc If the encoded integer does not fit into the default integer size, the method raises an NSRangeException. Subclasses must override this method if they perform keyed coding.
	     * @see https://developer.apple.com/reference/foundation/nscoder/1411168-decodecint
	     */

	  }, {
	    key: 'decodeCIntForKey',
	    value: function decodeCIntForKey(key) {
	      if (this._decodingFinished) {
	        throw new Error('can\'t decode \'' + key + '\' after finishDecoding() is called');
	      }
	      return this._getValueForKey(key);
	    }

	    /**
	     * Decodes a 32-bit integer value associated with a given key.
	     * @access public
	     * @param {string} key - A key in the archive within the current decoding scope. key must not be nil.
	     * @returns {number} - 
	     * @desc If the archived value was encoded with a different size but is still an integer, the type is coerced. If the archived value is too large to fit into a 32-bit integer, the method raises an NSRangeException. 
	     * @see https://developer.apple.com/reference/foundation/nskeyedunarchiver/1416327-decodeint32
	     */

	  }, {
	    key: 'decodeInt32ForKey',
	    value: function decodeInt32ForKey(key) {
	      if (this._decodingFinished) {
	        throw new Error('can\'t decode \'' + key + '\' after finishDecoding() is called');
	      }
	      return this._getValueForKey(key);
	    }

	    /**
	     * Decodes a 64-bit integer value associated with a given key.
	     * @access public
	     * @param {string} key - A key in the archive within the current decoding scope. key must not be nil.
	     * @returns {Int64} - 
	     * @desc If the archived value was encoded with a different size but is still an integer, the type is coerced. 
	     * @see https://developer.apple.com/reference/foundation/nskeyedunarchiver/1413288-decodeint64
	     */

	  }, {
	    key: 'decodeInt64ForKey',
	    value: function decodeInt64ForKey(key) {
	      if (this._decodingFinished) {
	        throw new Error('can\'t decode \'' + key + '\' after finishDecoding() is called');
	      }
	      return this._getValueForKey(key);
	    }

	    /**
	     * Decodes and returns an object associated with a given key.
	     * @access public
	     * @param {string} key - A key in the archive within the current decoding scope. key must not be nil.
	     * @returns {?Object} - 
	     * @see https://developer.apple.com/reference/foundation/nskeyedunarchiver/1409082-decodeobject
	     */

	  }, {
	    key: 'decodeObjectForKey',
	    value: function decodeObjectForKey(key) {
	      if (this._decodingFinished) {
	        throw new Error('can\'t decode \'' + key + '\' after finishDecoding() is called');
	      }
	      var parsedObj = this._refObj[key];
	      if (typeof parsedObj === 'string') {
	        return parsedObj;
	      } else if (parsedObj instanceof _UID) {
	        var obj = parsedObj.obj;
	        if (typeof obj.$class !== 'undefined') {
	          return this._parseClassAt(parsedObj.value);
	        }
	        return obj;
	      }
	      throw new Error('unknown data type for key ' + key + ': ' + parsedObj);
	    }

	    /**
	     * Returns a decoded property list for the specified key.
	     * @access public
	     * @param {string} key - The coder key.
	     * @returns {?Object} - 
	     * @desc This method calls decodeObjectOfClasses:forKey: with a set allowing only property list types.
	     * @see https://developer.apple.com/reference/foundation/nscoder/1416284-decodepropertylist
	     */

	  }, {
	    key: 'decodePropertyListForKey',
	    value: function decodePropertyListForKey(key) {
	      if (this._decodingFinished) {
	        throw new Error('can\'t decode \'' + key + '\' after finishDecoding() is called');
	      }
	      var parsedObj = this.decodeObjectForKey(key);
	      //console.log(`${key}: ${parsedObj.constructor.name}`)
	      if (!(parsedObj instanceof Buffer)) {
	        throw new Error('propertylist of key ' + key + ' is not Buffer data');
	      }
	      //console.log(`***header: ${parsedObj.toString('ascii', 0, 8)}`)
	      //console.log(`length: ${parsedObj.length}`)
	      //for(let i=0; i<8; i++){
	      //  console.log(`${i}: ${parsedObj.readUIntBE(i, 1)}`)
	      //}
	      return NSKeyedUnarchiver.unarchiveObjectWithData(parsedObj, this._filePath);
	    }
	  }, {
	    key: 'decodeObjectOfTypeForKey',
	    value: function decodeObjectOfTypeForKey(type, key) {
	      if (this._decodingFinished) {
	        throw new Error('can\'t decode \'' + key + '\' after finishDecoding() is called');
	      }
	      var parsedObj = this._refObj[key];
	      if (!(parsedObj instanceof Buffer)) {
	        throw new Error('value is not Buffer data for key: ' + key);
	      }
	      return this._parseStruct(parsedObj, type);
	    }
	  }, {
	    key: 'finishDecoding',


	    /**
	     * Tells the receiver that you are finished decoding objects.
	     * @access public
	     * @returns {void}
	     * @desc Invoking this method allows the receiver to notify its delegate and to perform any final operations on the archive. Once this method is invoked, the receiver cannot decode any further values.
	     * @see https://developer.apple.com/reference/foundation/nskeyedunarchiver/1418233-finishdecoding
	     */
	    value: function finishDecoding() {
	      this._decodingFinished = true;
	    }

	    // Managing Class Names

	    /**
	     * Adds a class translation mapping to the receiver whereby objects encoded with a given class name are decoded as instances of a given class instead.
	     * @access public
	     * @param {?Object} cls - The class with which to replace instances of the class named codedName.
	     * @param {string} codedName - 
	     * @returns {void}
	     * @desc When decoding, the receivers translation map overrides any translation that may also be present in the classs map (see setClass(_:forClassName:)).
	     * @see https://developer.apple.com/reference/foundation/nskeyedunarchiver/1414659-setclass
	     */

	  }, {
	    key: '_getValueForKey',
	    value: function _getValueForKey(key) {
	      var value = this._refObj[key];
	      if (value instanceof _UID) {
	        return value.obj;
	      }
	      return value;
	    }
	  }, {
	    key: '_fileName',
	    get: function get() {
	      if (this._filePath === null) {
	        return null;
	      }
	      var paths = this._filePath.split('/');
	      var fileName = paths.pop();
	      return fileName;
	    }
	  }, {
	    key: '_directoryPath',
	    get: function get() {
	      if (this._filePath === null) {
	        return null;
	      }
	      var paths = this._filePath.split('/');
	      var fileName = paths.pop();
	      var directoryPath = paths.join('/') + '/';
	      return directoryPath;
	    }
	  }], [{
	    key: 'unarchiveObjectWithData',
	    value: function unarchiveObjectWithData(data) {
	      var path = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

	      var unarchiver = new NSKeyedUnarchiver(data);
	      unarchiver._filePath = path;
	      var topObjIndex = unarchiver._parsedObj.$top.root.value;
	      return unarchiver._parseClassAt(topObjIndex);
	    }
	  }, {
	    key: '_getBufferOfFile',
	    value: function _getBufferOfFile(path) {
	      // TODO: use 'await' to return Buffer instead of Promise
	      var promise = new Promise(function (resolve, reject) {
	        var file = new _File3.default([], path);
	        var reader = new _FileReader3.default();
	        reader.onload = function () {
	          var data = reader.result;
	          resolve(data);
	        };
	        reader.onerror = function () {
	          reject(reader.error);
	        };
	        reader.readAsBinaryString(file);
	      });
	      return promise;
	    }
	  }, {
	    key: 'unarchiveObjectWithFile',
	    value: function unarchiveObjectWithFile(path) {
	      var promise = NSKeyedUnarchiver._getBufferOfFile(path).then(function (data) {
	        return NSKeyedUnarchiver.unarchiveObjectWithData(data, path);
	      });

	      return promise;
	    }
	  }, {
	    key: 'setClassForClassName',
	    value: function setClassForClassName(cls, codedName) {
	      _classForKey.set(codedName, cls);
	    }

	    /**
	     * Returns the class from which the receiver instantiates an encoded object with a given class name.
	     * @access public
	     * @param {string} codedName - 
	     * @returns {?Object} - 
	     * @desc The classs separate translation map is not searched.
	     * @see https://developer.apple.com/reference/foundation/nskeyedunarchiver/1412476-class
	     */

	  }, {
	    key: 'classForClassName',
	    value: function classForClassName(codedName) {
	      var classObj = _classForKey.get(codedName);
	      if (classObj) {
	        return classObj;
	      }
	      return _ClassList3.default.get(codedName);
	    }

	    // Type Methods

	    /**
	     * 
	     * @access public
	     * @param {NSData} data - 
	     * @param {string} path -
	     * @returns {void}
	     * @throws {Error}
	     * @see https://developer.apple.com/reference/foundation/nskeyedunarchiver/1413622-unarchivetoplevelobjectwithdata
	     */

	  }, {
	    key: 'unarchiveTopLevelObjectWithData',
	    value: function unarchiveTopLevelObjectWithData(data) {
	      var path = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

	      // what's different from unarchiveObjectWithData???
	      return NSKeyedUnarchiver.unarchiveObjectWithData(data, path);
	    }
	  }]);

	  return NSKeyedUnarchiver;
	}(_NSCoder3.default);

	exports.default = NSKeyedUnarchiver;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3).Buffer))

/***/ },
/* 34 */
/***/ function(module, exports) {

	'use strict';

	/*global File*/

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = File;

/***/ },
/* 35 */
/***/ function(module, exports) {

	'use strict';

	/*global FileReader*/

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.default = FileReader;

/***/ },
/* 36 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {'use strict';

	//import _Buffer from './_Buffer'

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _ecl = __webpack_require__(37);

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	/*global Buffer*/

	/**
	 * BinaryReader class
	 * @access public
	 */
	var _BinaryReader = function () {
	  /**
	   * constructor
	   * @param {Buffer|ArrayBuffer} data - 
	   * @param {boolean} bigEndian -
	   * @param {string} encoding -
	   * @constructor
	   */
	  function _BinaryReader(data) {
	    var bigEndian = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
	    var encoding = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';

	    _classCallCheck(this, _BinaryReader);

	    /**
	     * @access private
	     * @type {number}
	     */
	    this._pos = 0;

	    /**
	     * @access private
	     * @type {boolean}
	     */
	    this._eof = true;

	    /**
	     *
	     * @access public
	     * @type {Buffer}
	     */
	    this.buffer = null;

	    if (data instanceof Buffer) {
	      this.buffer = data;
	    } else if (typeof data === 'string') {
	      this.buffer = Buffer.from(data, 'binary');
	    } else {
	      this.buffer = Buffer.from(data);
	    }

	    /**
	     *
	     * @access public
	     * @type {boolean}
	     */
	    this.bigEndian = bigEndian;

	    /**
	     *
	     * @access public
	     * @type {string}
	     */
	    this.encoding = encoding;
	  }

	  /**
	   * @access public
	   * @param {number} length - length of data to skip
	   * @param {boolean} noAssert -
	   * @returns {void}
	   */


	  _createClass(_BinaryReader, [{
	    key: 'skip',
	    value: function skip(length) {
	      var noAssert = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

	      this._pos += length;
	      if (!noAssert) {
	        this._check();
	      }
	    }

	    /**
	     * @access public
	     * @param {number} pos -
	     * @returns {void}
	     */

	  }, {
	    key: 'seek',
	    value: function seek(pos) {
	      if (pos < 0) {
	        this._pos = this.buffer.length + pos;
	      } else {
	        this._pos = pos;
	      }

	      if (this._pos < 0) {
	        this._pos = 0;
	      } else if (this._pos > this.buffer.length) {
	        this._pos = this.buffer.length;
	      }
	    }

	    /**
	     *
	     * @access public
	     * @param {number} length - length of data to read
	     * @param {?string} [encoding = null] -
	     * @returns {string} -
	     */

	  }, {
	    key: 'readString',
	    value: function readString(length) {
	      var encoding = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

	      var start = this._pos;
	      this._pos += length;
	      var _encoding = encoding || this.encoding || 'sjis';
	      //if(_Buffer.isEncoding(_encoding)){
	      if (Buffer.isEncoding(_encoding)) {
	        return this.buffer.toString(_encoding, start, this._pos);
	      }

	      var data = this.buffer.toString('binary', start, this._pos);
	      return this._convert(data, _encoding);
	    }

	    /**
	     *
	     * @access public
	     * @param {number} length - 
	     * @param {boolean} signed -
	     * @returns {number} -
	     */

	  }, {
	    key: 'readInteger',
	    value: function readInteger(length, signed) {
	      var start = this._pos;
	      this._pos += length;

	      // big endian
	      if (this.bigEndian) {
	        if (signed) {
	          return this.buffer.readIntBE(start, length);
	        }
	        return this.buffer.readUIntBE(start, length);
	      }

	      // little endian
	      if (signed) {
	        return this.buffer.readIntLE(start, length);
	      }
	      return this.buffer.readUIntLE(start, length);
	    }

	    /**
	     *
	     * @access public
	     * @returns {number} -
	     */

	  }, {
	    key: 'readUnsignedByte',
	    value: function readUnsignedByte() {
	      return this.readInteger(1, false);
	    }

	    /**
	     *
	     * @access public
	     * @returns {number} -
	     */

	  }, {
	    key: 'readUnsignedShort',
	    value: function readUnsignedShort() {
	      return this.readInteger(2, false);
	    }

	    /**
	     *
	     * @access public
	     * @returns {number} -
	     */

	  }, {
	    key: 'readUnsignedInt',
	    value: function readUnsignedInt() {
	      return this.readInteger(4, false);
	    }

	    /**
	     *
	     * @access public
	     * @returns {number} -
	     */

	  }, {
	    key: 'readUnsignedLongLong',
	    value: function readUnsignedLongLong() {
	      return this.readInteger(8, false);
	    }

	    /**
	     *
	     * @access public
	     * @returns {number} -
	     */

	  }, {
	    key: 'readByte',
	    value: function readByte() {
	      return this.readInteger(1, true);
	    }

	    /**
	     *
	     * @access public
	     * @returns {number} -
	     */

	  }, {
	    key: 'readShort',
	    value: function readShort() {
	      return this.readInteger(2, true);
	    }

	    /**
	     *
	     * @access public
	     * @returns {number} -
	     */

	  }, {
	    key: 'readInt',
	    value: function readInt() {
	      return this.readInteger(4, true);
	    }

	    /**
	     *
	     * @access public
	     * @returns {number} -
	     */

	  }, {
	    key: 'readLongLong',
	    value: function readLongLong() {
	      return this.readInteger(8, true);
	    }

	    /**
	     *
	     * @access public
	     * @returns {number} -
	     */

	  }, {
	    key: 'readFloat',
	    value: function readFloat() {
	      var start = this._pos;
	      this._pos += 4;
	      if (this.bigEndian) {
	        return this.buffer.readFloatBE(start);
	      }

	      return this.buffer.readFloatLE(start);
	    }

	    /**
	     *
	     * @access public
	     * @returns {number} -
	     */

	  }, {
	    key: 'readDouble',
	    value: function readDouble() {
	      var start = this._pos;
	      this._pos += 8;
	      if (this.bigEndian) {
	        return this.buffer.readDoubleBE(start);
	      }

	      return this.buffer.readDoubleLE(start);
	    }

	    /**
	     *
	     * @access public
	     * @param {number} length -
	     * @returns {Buffer} -
	     */

	  }, {
	    key: 'readData',
	    value: function readData(length) {
	      var start = this._pos;
	      this._pos += length;
	      return this.buffer.slice(start, this._pos);
	    }

	    /**
	     *
	     * @access private
	     * @returns {void}
	     */

	  }, {
	    key: '_check',
	    value: function _check() {
	      if (this._pos >= this.buffer.length) {
	        throw new Error('_BinaryReader: buffer out of range (' + this._pos + ' >= ' + this.buffer.length + ')');
	      }
	    }

	    /**
	     *
	     * @access private
	     * @param {number[]} data - length of data to convert
	     * @param {?string} [encoding = null] -
	     * @returns {string} -
	     */

	  }, {
	    key: '_convert',
	    value: function _convert(data, encoding) {
	      var length = data.length;
	      var escapeString = '';
	      for (var i = 0; i < length; i++) {
	        var charCode = data.charCodeAt(i);
	        if (charCode === 0) {
	          break;
	        } else if (charCode < 16) {
	          escapeString += '%0' + charCode.toString(16);
	        } else {
	          escapeString += '%' + charCode.toString(16);
	        }
	      }

	      if (encoding === 'sjis') {
	        return (0, _ecl.UnescapeSJIS)(escapeString);
	      } else if (encoding === 'euc-jp') {
	        return (0, _ecl.UnescapeEUCJP)(escapeString);
	      } else if (encoding === 'jis-7') {
	        return (0, _ecl.UnescapeJIS7)(escapeString);
	      } else if (encoding === 'jis-8') {
	        return (0, _ecl.UnescapeJIS8)(escapeString);
	      } else if (encoding === 'unicode') {
	        return (0, _ecl.UnescapeUnicode)(escapeString);
	      } else if (encoding === 'utf7') {
	        return (0, _ecl.UnescapeUTF7)(escapeString);
	      } else if (encoding === 'utf-8') {
	        return (0, _ecl.UnescapeUTF8)(escapeString);
	      } else if (encoding === 'utf-16') {
	        return (0, _ecl.UnescapeUTF16LE)(escapeString);
	      }

	      throw new Error('unsupported encoding: ' + encoding);
	    }
	  }, {
	    key: 'getAvailableDataLength',
	    value: function getAvailableDataLength() {
	      return this.buffer.length - this._pos;
	    }
	  }, {
	    key: 'length',
	    get: function get() {
	      return this.buffer.length;
	    }
	  }]);

	  return _BinaryReader;
	}();

	exports.default = _BinaryReader;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3).Buffer))

/***/ },
/* 37 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	//
	// Escape Codec Library: ecl.js (Ver.041208)
	//
	// Copyright (C) http://nurucom-archives.hp.infoseek.co.jp/digital/
	//

	var EscapeSJIS = function EscapeSJIS(str) {
		return str.replace(/[^*+.-9A-Z_a-z-]/g, function (s) {
			var c = s.charCodeAt(0),
			    m;
			return c < 128 ? (c < 16 ? "%0" : "%") + c.toString(16).toUpperCase() : 65376 < c && c < 65440 ? "%" + (c - 65216).toString(16).toUpperCase() : (c = JCT11280.indexOf(s)) < 0 ? "%81E" : "%" + ((m = ((c < 8272 ? c : c = JCT11280.lastIndexOf(s)) - (c %= 188)) / 188) < 31 ? m + 129 : m + 193).toString(16).toUpperCase() + (64 < (c += c < 63 ? 64 : 65) && c < 91 || 95 == c || 96 < c && c < 123 ? String.fromCharCode(c) : "%" + c.toString(16).toUpperCase());
		});
	};

	var UnescapeSJIS = function UnescapeSJIS(str) {
		return str.replace(/%(8[1-9A-F]|[9E][0-9A-F]|F[0-9A-C])(%[4-689A-F][0-9A-F]|%7[0-9A-E]|[@-~])|%([0-7][0-9A-F]|A[1-9A-F]|[B-D][0-9A-F])/ig, function (s) {
			var c = parseInt(s.substring(1, 3), 16),
			    l = s.length;
			return 3 == l ? String.fromCharCode(c < 160 ? c : c + 65216) : JCT11280.charAt((c < 160 ? c - 129 : c - 193) * 188 + (4 == l ? s.charCodeAt(3) - 64 : (c = parseInt(s.substring(4), 16)) < 127 ? c - 64 : c - 65));
		});
	};

	var EscapeEUCJP = function EscapeEUCJP(str) {
		return str.replace(/[^*+.-9A-Z_a-z-]/g, function (s) {
			var c = s.charCodeAt(0);
			return (c < 128 ? (c < 16 ? "%0" : "%") + c.toString(16) : 65376 < c && c < 65440 ? "%8E%" + (c - 65216).toString(16) : (c = JCT8836.indexOf(s)) < 0 ? "%A1%A6" : "%" + ((c - (c %= 94)) / 94 + 161).toString(16) + "%" + (c + 161).toString(16)).toUpperCase();
		});
	};

	var UnescapeEUCJP = function UnescapeEUCJP(str) {
		return str.replace(/(%A[1-9A-F]|%[B-E][0-9A-F]|%F[0-9A-E]){2}|%8E%(A[1-9A-F]|[B-D][0-9A-F])|%[0-7][0-9A-F]/ig, function (s) {
			var c = parseInt(s.substring(1), 16);
			return c < 161 ? String.fromCharCode(c < 128 ? c : parseInt(s.substring(4), 16) + 65216) : JCT8836.charAt((c - 161) * 94 + parseInt(s.substring(4), 16) - 161);
		});
	};

	var EscapeJIS7 = function EscapeJIS7(str) {
		var u = String.fromCharCode,
		    ri = u(92, 120, 48, 48, 45, 92, 120, 55, 70),
		    rj = u(65377, 45, 65439, 93, 43),
		    H = function H(c) {
			return 41 < c && c < 58 && 44 != c || 64 < c && c < 91 || 95 == c || 96 < c && c < 123 ? u(c) : "%" + c.toString(16).toUpperCase();
		},
		    I = function I(s) {
			var c = s.charCodeAt(0);
			return (c < 16 ? "%0" : "%") + c.toString(16).toUpperCase();
		},
		    rI = new RegExp();rI.compile("[^*+.-9A-Z_a-z-]", "g");
		return ("g" + str + "g").replace(RegExp("[" + ri + "]+", "g"), function (s) {
			return "%1B%28B" + s.replace(rI, I);
		}).replace(RegExp("[" + rj, "g"), function (s) {
			var c,
			    i = 0,
			    t = "%1B%28I";while (c = s.charCodeAt(i++)) {
				t += H(c - 65344);
			}return t;
		}).replace(RegExp("[^" + ri + rj, "g"), function (s) {
			var a,
			    c,
			    i = 0,
			    t = "%1B%24B";while (a = s.charAt(i++)) {
				t += (c = JCT8836.indexOf(a)) < 0 ? "%21%26" : H((c - (c %= 94)) / 94 + 33) + H(c + 33);
			}return t;
		}).slice(8, -1);
	};

	var UnescapeJIS7 = function UnescapeJIS7(str) {
		var i = 0,
		    p,
		    q,
		    s = "",
		    u = String.fromCharCode,
		    P = ("%28B" + str.replace(/%49/g, "I").replace(/%1B%24%4[02]|%1B%24@/ig, "%1B%24B")).split(/%1B/i),
		    I = function I(s) {
			return u(parseInt(s.substring(1), 16));
		},
		    J = function J(s) {
			return u((3 == s.length ? parseInt(s.substring(1), 16) : s.charCodeAt(0)) + 65344);
		},
		    K = function K(s) {
			var l = s.length;
			return JCT8836.charAt(4 < l ? (parseInt(s.substring(1), 16) - 33) * 94 + parseInt(s.substring(4), 16) - 33 : 2 < l ? (37 == (l = s.charCodeAt(0)) ? (parseInt(s.substring(1, 3), 16) - 33) * 94 + s.charCodeAt(3) : (l - 33) * 94 + parseInt(s.substring(2), 16)) - 33 : (s.charCodeAt(0) - 33) * 94 + s.charCodeAt(1) - 33);
		},
		    rI = new RegExp(),
		    rJ = new RegExp(),
		    rK = new RegExp();
		rI.compile("%[0-7][0-9A-F]", "ig");rJ.compile("(%2[1-9A-F]|%[3-5][0-9A-F])|[!-_]", "ig");
		rK.compile("(%2[1-9A-F]|%[3-6][0-9A-F]|%7[0-9A-E]){2}|(%2[1-9A-F]|%[3-6][0-9A-F]|%7[0-9A-E])[!-~]|[!-~](%2[1-9A-F]|%[3-6][0-9A-F]|%7[0-9A-E])|[!-~]{2}", "ig");
		while (p = P[i++]) {
			s += "%24B" == (q = p.substring(0, 4)) ? p.substring(4).replace(rK, K) : "%28I" == q ? p.substring(4).replace(rJ, J) : p.replace(rI, I).substring(2);
		}return s;
	};

	var EscapeJIS8 = function EscapeJIS8(str) {
		var u = String.fromCharCode,
		    r = u(92, 120, 48, 48, 45, 92, 120, 55, 70, 65377, 45, 65439, 93, 43),
		    H = function H(c) {
			return 41 < c && c < 58 && 44 != c || 64 < c && c < 91 || 95 == c || 96 < c && c < 123 ? u(c) : "%" + c.toString(16).toUpperCase();
		},
		    I = function I(s) {
			var c = s.charCodeAt(0);
			return (c < 16 ? "%0" : "%") + (c < 128 ? c : c - 65216).toString(16).toUpperCase();
		},
		    rI = new RegExp();rI.compile("[^*+.-9A-Z_a-z-]", "g");
		return ("g" + str + "g").replace(RegExp("[" + r, "g"), function (s) {
			return "%1B%28B" + s.replace(rI, I);
		}).replace(RegExp("[^" + r, "g"), function (s) {
			var a,
			    c,
			    i = 0,
			    t = "%1B%24B";while (a = s.charAt(i++)) {
				t += (c = JCT8836.indexOf(a)) < 0 ? "%21%26" : H((c - (c %= 94)) / 94 + 33) + H(c + 33);
			}return t;
		}).slice(8, -1);
	};

	var UnescapeJIS8 = function UnescapeJIS8(str) {
		var i = 0,
		    p,
		    s = "",
		    P = ("%28B" + str.replace(/%1B%24%4[02]|%1B%24@/ig, "%1B%24B")).split(/%1B/i),
		    I = function I(s) {
			var c = parseInt(s.substring(1), 16);
			return String.fromCharCode(c < 128 ? c : c + 65216);
		},
		    K = function K(s) {
			var l = s.length;
			return JCT8836.charAt(4 < l ? (parseInt(s.substring(1), 16) - 33) * 94 + parseInt(s.substring(4), 16) - 33 : 2 < l ? (37 == (l = s.charCodeAt(0)) ? (parseInt(s.substring(1, 3), 16) - 33) * 94 + s.charCodeAt(3) : (l - 33) * 94 + parseInt(s.substring(2), 16)) - 33 : (s.charCodeAt(0) - 33) * 94 + s.charCodeAt(1) - 33);
		},
		    rI = new RegExp(),
		    rK = new RegExp();
		rI.compile("%([0-7][0-9A-F]|A[1-9A-F]|[B-D][0-9A-F])", "ig");
		rK.compile("(%2[1-9A-F]|%[3-6][0-9A-F]|%7[0-9A-E]){2}|(%2[1-9A-F]|%[3-6][0-9A-F]|%7[0-9A-E])[!-~]|[!-~](%2[1-9A-F]|%[3-6][0-9A-F]|%7[0-9A-E])|[!-~]{2}", "ig");
		while (p = P[i++]) {
			s += "%24B" == p.substring(0, 4) ? p.substring(4).replace(rK, K) : p.replace(rI, I).substring(2);
		}return s;
	};

	var EscapeUnicode = function EscapeUnicode(str) {
		return str.replace(/[^*+.-9A-Z_a-z-]/g, function (s) {
			var c = s.charCodeAt(0);
			return (c < 16 ? "%0" : c < 256 ? "%" : c < 4096 ? "%u0" : "%u") + c.toString(16).toUpperCase();
		});
	};

	var UnescapeUnicode = function UnescapeUnicode(str) {
		return str.replace(/%u[0-9A-F]{4}|%[0-9A-F]{2}/ig, function (s) {
			return String.fromCharCode("0x" + s.substring(s.length / 3));
		});
	};

	var EscapeUTF7 = function EscapeUTF7(str) {
		var B = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split(""),
		    E = function E(s) {
			var c = s.charCodeAt(0);
			return B[c >> 10] + B[c >> 4 & 63] + B[(c & 15) << 2 | (c = s.charCodeAt(1)) >> 14] + (0 <= c ? B[c >> 8 & 63] + B[c >> 2 & 63] + B[(c & 3) << 4 | (c = s.charCodeAt(2)) >> 12] + (0 <= c ? B[c >> 6 & 63] + B[c & 63] : "") : "");
		},
		    re = new RegExp();re.compile("[^+]{1,3}", "g");
		return (str + "g").replace(/[^*+.-9A-Z_a-z-]+[*+.-9A-Z_a-z-]|[+]/g, function (s) {
			if ("+" == s) return "+-";
			var l = s.length - 1,
			    w = s.charAt(l);
			return "+" + s.substring(0, l).replace(re, E) + ("+" == w ? "-+-" : "*" == w || "." == w || "_" == w ? w : "-" + w);
		}).slice(0, -1);
	};

	var UnescapeUTF7 = function UnescapeUTF7(str) {
		var i = 0,
		    B = {};
		while (i < 64) {
			B["ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charAt(i)] = i++;
		}return str.replace(RegExp("[+][+/-9A-Za-z]*-?", "g"), function (s) {
			if ("+-" == s) return "+";
			var b = B[s.charAt(1)],
			    c,
			    i = 1,
			    t = "";
			while (0 <= b) {
				if ((c = i & 7) < 6) c = c < 3 ? b << 10 | B[s.charAt(++i)] << 4 | (b = B[s.charAt(++i)]) >> 2 : (b & 3) << 14 | B[s.charAt(++i)] << 8 | B[s.charAt(++i)] << 2 | (b = B[s.charAt(++i)]) >> 4;else {
					c = (b & 15) << 12 | B[s.charAt(++i)] << 6 | B[s.charAt(++i)];b = B[s.charAt(++i)];
				}
				if (c) t += String.fromCharCode(c);
			}
			return t;
		});
	};

	var EscapeUTF8 = function EscapeUTF8(str) {
		return str.replace(/[^*+.-9A-Z_a-z-]/g, function (s) {
			var c = s.charCodeAt(0);
			return (c < 16 ? "%0" + c.toString(16) : c < 128 ? "%" + c.toString(16) : c < 2048 ? "%" + (c >> 6 | 192).toString(16) + "%" + (c & 63 | 128).toString(16) : "%" + (c >> 12 | 224).toString(16) + "%" + (c >> 6 & 63 | 128).toString(16) + "%" + (c & 63 | 128).toString(16)).toUpperCase();
		});
	};

	var UnescapeUTF8 = function UnescapeUTF8(str) {
		return str.replace(/%(E(0%[AB]|[1-CEF]%[89AB]|D%[89])[0-9A-F]|C[2-9A-F]|D[0-9A-F])%[89AB][0-9A-F]|%[0-7][0-9A-F]/ig, function (s) {
			var c = parseInt(s.substring(1), 16);
			return String.fromCharCode(c < 128 ? c : c < 224 ? (c & 31) << 6 | parseInt(s.substring(4), 16) & 63 : ((c & 15) << 6 | parseInt(s.substring(4), 16) & 63) << 6 | parseInt(s.substring(7), 16) & 63);
		});
	};

	var EscapeUTF16LE = function EscapeUTF16LE(str) {
		var H = function H(c) {
			return 41 < c && c < 58 && 44 != c || 64 < c && c < 91 || 95 == c || 96 < c && c < 123 ? String.fromCharCode(c) : (c < 16 ? "%0" : "%") + c.toString(16).toUpperCase();
		};
		return str.replace(/[^ ]| /g, function (s) {
			var c = s.charCodeAt(0);return H(c & 255) + H(c >> 8);
		});
	};

	var UnescapeUTF16LE = function UnescapeUTF16LE(str) {
		var u = String.fromCharCode,
		    b = u(92, 120, 48, 48, 45, 92, 120, 70, 70);
		return str.replace(/^%FF%FE/i, "").replace(RegExp("%[0-9A-F]{2}%[0-9A-F]{2}|%[0-9A-F]{2}[" + b + "]|[" + b + "]%[0-9A-F]{2}|[" + b + "]{2}", "ig"), function (s) {
			var l = s.length;
			return u(4 < l ? "0x" + s.substring(4, 6) + s.substring(1, 3) : 2 < l ? 37 == (l = s.charCodeAt(0)) ? parseInt(s.substring(1, 3), 16) | s.charCodeAt(3) << 8 : l | parseInt(s.substring(2), 16) << 8 : s.charCodeAt(0) | s.charCodeAt(1) << 8);
		});
	};

	var GetEscapeCodeType = function GetEscapeCodeType(str) {
		if (/%u[0-9A-F]{4}/i.test(str)) return "Unicode";
		if (/%([0-9A-DF][0-9A-F]%[8A]0%|E0%80|[0-7][0-9A-F]|C[01])%[8A]0|%00|%[7F]F/i.test(str)) return "UTF16LE";
		if (/%E[0-9A-F]%[8A]0%[8A]0|%[CD][0-9A-F]%[8A]0/i.test(str)) return "UTF8";
		if (/%F[DE]/i.test(str)) return (/%8[0-9A-D]|%9[0-9A-F]|%A0/i.test(str) ? "UTF16LE" : "EUCJP"
		);
		if (/%1B/i.test(str)) return (/%[A-D][0-9A-F]/i.test(str) ? "JIS8" : "JIS7"
		);
		var S = str.substring(0, 6143).replace(/%[0-9A-F]{2}|[^ ]| /ig, function (s) {
			return s.length < 3 ? "40" : s.substring(1);
		}),
		    c,
		    C,
		    i = 0,
		    T;
		while (0 <= (c = parseInt(S.substring(i, i += 2), 16)) && i < 4092) {
			if (128 <= c) {
				if ((C = parseInt(S.substring(i, i + 2), 16)) < 128) i += 2;else if (194 <= c && c < 240 && C < 192) {
					if (c < 224) {
						T = "UTF8";i += 2;continue;
					}
					if (2 == parseInt(S.charAt(i + 2), 16) >> 2) {
						T = "UTF8";i += 4;continue;
					}
				}
				if (142 == c && 161 <= C && C < 224) {
					if (!T) T = "EUCJP";if ("EUCJP" == T) continue;
				}
				if (c < 161) return "SJIS";
				if (c < 224 && !T) {
					if ((164 == c && C < 244 || 165 == c && C < 247) && 161 <= C) i += 2;else T = 224 <= C ? "EUCJP" : "SJIS";
				} else T = "EUCJP";
			}
		}return T ? T : "EUCJP";
	};

	var JCT11280 = Function('var a="zKV33~jZ4zN=~ji36XazM93y!{~k2y!o~k0ZlW6zN?3Wz3W?{EKzK[33[`y|;-~j^YOTz$!~kNy|L1$353~jV3zKk3~k-4P4zK_2+~jY4y!xYHR~jlz$_~jk4z$e3X5He<0y!wy|X3[:~l|VU[F3VZ056Hy!nz/m1XD61+1XY1E1=1y|bzKiz!H034zKj~mEz#c5ZA3-3X$1~mBz$$3~lyz#,4YN5~mEz#{ZKZ3V%7Y}!J3X-YEX_J(3~mAz =V;kE0/y|F3y!}~m>z/U~mI~j_2+~mA~jp2;~m@~k32;~m>V}2u~mEX#2x~mBy+x2242(~mBy,;2242(~may->2&XkG2;~mIy-_2&NXd2;~mGz,{4<6:.:B*B:XC4>6:.>B*BBXSA+A:X]E&E<~r#z+625z s2+zN=`HXI@YMXIAXZYUM8X4K/:Q!Z&33 3YWX[~mB`{zKt4z (zV/z 3zRw2%Wd39]S11z$PAXH5Xb;ZQWU1ZgWP%3~o@{Dgl#gd}T){Uo{y5_d{e@}C(} WU9|cB{w}bzvV|)[} H|zT}d||0~{]Q|(l{|x{iv{dw}(5}[Z|kuZ }cq{{y|ij}.I{idbof%cu^d}Rj^y|-M{ESYGYfYsZslS`?ZdYO__gLYRZ&fvb4oKfhSf^d<Yeasc1f&a=hnYG{QY{D`Bsa|u,}Dl|_Q{C%xK|Aq}C>|c#ryW=}eY{L+`)][YF_Ub^h4}[X|?r|u_ex}TL@YR]j{SrXgo*|Gv|rK}B#mu{R1}hs|dP{C7|^Qt3|@P{YVV |8&}#D}ef{e/{Rl|>Hni}R1{Z#{D[}CQlQ||E}[s{SG_+i8eplY[=[|ec[$YXn#`hcm}YR|{Ci(_[ql|?8p3]-}^t{wy}4la&pc|3e{Rp{LqiJ],] `kc(]@chYnrM`O^,ZLYhZB]ywyfGY~aex!_Qww{a!|)*lHrM{N+n&YYj~Z b c#e_[hZSon|rOt`}hBXa^i{lh|<0||r{KJ{kni)|x,|0auY{D!^Sce{w;|@S|cA}Xn{C1h${E]Z-XgZ*XPbp]^_qbH^e[`YM|a||+=]!Lc}]vdBc=j-YSZD]YmyYLYKZ9Z>Xcczc2{Yh}9Fc#Z.l{}(D{G{{mRhC|L3b#|xK[Bepj#ut`H[,{E9Yr}1b{[e]{ZFk7[ZYbZ0XL]}Ye[(`d}c!|*y`Dg=b;gR]Hm=hJho}R-[n}9;{N![7k_{UbmN]rf#pTe[x8}!Qcs_rs[m`|>N}^V})7{^r|/E}),}HH{OYe2{Skx)e<_.cj.cjoMhc^d}0uYZd!^J_@g,[[[?{i@][|3S}Yl3|!1|eZ|5IYw|1D}e7|Cv{OHbnx-`wvb[6[4} =g+k:{C:}ed{S]|2M]-}WZ|/q{LF|dYu^}Gs^c{Z=}h>|/i|{W]:|ip{N:|zt|S<{DH[p_tvD{N<[8Axo{X4a.^o^X>Yfa59`#ZBYgY~_t^9`jZHZn`>G[oajZ;X,i)Z.^~YJe ZiZF^{][[#Zt^|]Fjx]&_5dddW]P0C[-]}]d|y {C_jUql] |OpaA[Z{lp|rz}:Mu#]_Yf6{Ep?f5`$[6^D][^u[$[6^.Z8]]ePc2U/=]K^_+^M{q*|9tYuZ,s(dS{i=|bNbB{uG}0jZOa:[-]dYtu3]:]<{DJ_SZIqr_`l=Yt`gkTnXb3d@kiq0a`Z{|!B|}e}Ww{Sp,^Z|0>_Z}36|]A|-t}lt{R6pi|v8hPu#{C>YOZHYmg/Z4nicK[}hF_Bg|YRZ7c|crkzYZY}_iXcZ.|)U|L5{R~qi^Uga@Y[xb}&qdbd6h5|Btw[}c<{Ds53[Y7]?Z<|e0{L[ZK]mXKZ#Z2^tavf0`PE[OSOaP`4gi`qjdYMgys/?[nc,}EEb,eL]g[n{E_b/vcvgb.{kcwi`~v%|0:|iK{Jh_vf5lb}KL|(oi=LrzhhY_^@`zgf[~g)[J_0fk_V{T)}I_{D&_/d9W/|MU[)f$xW}?$xr4<{Lb{y4}&u{XJ|cm{Iu{jQ}CMkD{CX|7A}G~{kt)nB|d5|<-}WJ}@||d@|Iy}Ts|iL|/^|no|0;}L6{Pm]7}$zf:|r2}?C_k{R(}-w|`G{Gy[g]bVje=_0|PT{^Y^yjtT[[[l!Ye_`ZN]@[n_)j3nEgMa]YtYpZy].d-Y_cjb~Y~[nc~sCi3|zg}B0}do{O^{|$`_|D{}U&|0+{J3|8*]iayx{a{xJ_9|,c{Ee]QXlYb]$[%YMc*]w[aafe]aVYi[fZEii[xq2YQZHg]Y~h#|Y:thre^@^|_F^CbTbG_1^qf7{L-`VFx Zr|@EZ;gkZ@slgko`[e}T:{Cu^pddZ_`yav^Ea+[#ZBbSbO`elQfLui}.F|txYcbQ`XehcGe~fc^RlV{D_0ZAej[l&jShxG[ipB_=u:eU}3e8[=j|{D(}dO{Do[BYUZ0/]AYE]ALYhZcYlYP/^-^{Yt_1_-;YT`P4BZG=IOZ&]H[e]YYd[9^F[1YdZxZ?Z{Z<]Ba2[5Yb[0Z4l?]d_;_)a?YGEYiYv`_XmZs4ZjY^Zb]6gqGaX^9Y}dXZr[g|]Y}K aFZp^k^F]M`^{O1Ys]ZCgCv4|E>}8eb7}l`{L5[Z_faQ|c2}Fj}hw^#|Ng|B||w2|Sh{v+[G}aB|MY}A{|8o}X~{E8paZ:]i^Njq]new)`-Z>haounWhN}c#{DfZ|fK]KqGZ=:u|fqoqcv}2ssm}.r{]{nIfV{JW)[K|,Z{Uxc|]l_KdCb%]cfobya3`p}G^|LZiSC]U|(X|kBlVg[kNo({O:g:|-N|qT}9?{MBiL}Sq{`P|3a|u.{Uaq:{_o|^S}jX{Fob0`;|#y_@[V[K|cw[<_ }KU|0F}d3|et{Q7{LuZttsmf^kYZ`Af`}$x}U`|Ww}d]| >}K,r&|XI|*e{C/a-bmr1fId4[;b>tQ_:]hk{b-pMge]gfpo.|(w[jgV{EC1Z,YhaY^q,_G[c_g[J0YX]`[h^hYK^_Yib,` {i6vf@YM^hdOKZZn(jgZ>bzSDc^Z%[[o9[2=/YHZ(_/Gu_`*|8z{DUZxYt^vuvZjhi^lc&gUd4|<UiA`z]$b/Z?l}YI^jaHxe|;F}l${sQ}5g}hA|e4}?o{ih}Uz{C)jPe4]H^J[Eg[|AMZMlc}:,{iz}#*|gc{Iq|/:|zK{l&}#u|myd{{M&v~nV};L|(g|I]ogddb0xsd7^V})$uQ{HzazsgxtsO^l}F>ZB]r|{7{j@cU^{{CbiYoHlng]f+nQ[bkTn/}<-d9q {KXadZYo+n|l[|lc}V2{[a{S4Zam~Za^`{HH{xx_SvF|ak=c^[v^7_rYT`ld@]:_ub%[$[m](Shu}G2{E.ZU_L_R{tz`vj(f?^}hswz}GdZ}{S:h`aD|?W|`dgG|if{a8|J1{N,}-Ao3{H#{mfsP|[ bzn+}_Q{MT{u4kHcj_q`eZj[8o0jy{p7}C|[}l){MuYY{|Ff!Ykn3{rT|m,^R|,R}$~Ykgx{P!]>iXh6[l[/}Jgcg{JYZ.^qYfYIZl[gZ#Xj[Pc7YyZD^+Yt;4;`e8YyZVbQ7YzZxXja.7SYl[s]2^/Ha$[6ZGYrb%XiYdf2]H]kZkZ*ZQ[ZYS^HZXcCc%Z|[(bVZ]]:OJQ_DZCg<[,]%Zaa [g{C00HY[c%[ChyZ,Z_`PbXa+eh`^&jPi0a[ggvhlekL]w{Yp^v}[e{~;k%a&k^|nR_z_Qng}[E}*Wq:{k^{FJZpXRhmh3^p>de^=_7`|ZbaAZtdhZ?n4ZL]u`9ZNc3g%[6b=e.ZVfC[ZZ^^^hD{E(9c(kyZ=bb|Sq{k`|vmr>izlH[u|e`}49}Y%}FT{[z{Rk}Bz{TCc/lMiAqkf(m$hDc;qooi[}^o:c^|Qm}a_{mrZ(pA`,}<2sY| adf_%|}`}Y5U;}/4|D>|$X{jw{C<|F.hK|*A{MRZ8Zsm?imZm_?brYWZrYx`yVZc3a@f?aK^ojEd {bN}/3ZH]/$YZhm^&j 9|(S|b]mF}UI{q&aM]LcrZ5^.|[j`T_V_Gak}9J[ ZCZD|^h{N9{~&[6Zd{}B}2O|cv]K}3s}Uy|l,fihW{EG`j_QOp~Z$F^zexS`dcISfhZBXP|.vn|_HYQ|)9|cr]<`&Z6]m_(ZhPcSg>`Z]5`~1`0Xcb4k1{O!bz|CN_T{LR|a/gFcD|j<{Z._[f)mPc:1`WtIaT1cgYkZOaVZOYFrEe[}T$}Ch}mk{K-^@]fH{Hdi`c*Z&|Kt{if[C{Q;{xYB`dYIX:ZB[}]*[{{p9|4GYRh2ao{DS|V+[zd$`F[ZXKadb*A] Ys]Maif~a/Z2bmclb8{Jro_rz|x9cHojbZ{GzZx_)]:{wAayeDlx}<=`g{H1{l#}9i|)=|lP{Qq}.({La|!Y{i2EZfp=c*}Cc{EDvVB|;g}2t{W4av^Bn=]ri,|y?|3+}T*ckZ*{Ffr5e%|sB{lx^0]eZb]9[SgAjS_D|uHZx]dive[c.YPkcq/}db{EQh&hQ|eg}G!ljil|BO]X{Qr_GkGl~YiYWu=c3eb}29v3|D|}4i||.{Mv})V{SP1{FX}CZW6{cm|vO{pS|e#}A~|1i}81|Mw}es|5[}3w{C`h9aL]o{}p[G`>i%a1Z@`Ln2bD[$_h`}ZOjhdTrH{[j_:k~kv[Sdu]CtL}41{I |[[{]Zp$]XjxjHt_eThoa#h>sSt8|gK|TVi[Y{t=}Bs|b7Zpr%{gt|Yo{CS[/{iteva|cf^hgn}($_c^wmb^Wm+|55jrbF|{9^ q6{C&c+ZKdJkq_xOYqZYSYXYl`8]-cxZAq/b%b*_Vsa[/Ybjac/OaGZ4fza|a)gY{P?| I|Y |,pi1n7}9bm9ad|=d{aV|2@[(}B`d&|Uz}B}{`q|/H|!JkM{FU|CB|.{}Az}#P|lk}K{|2rk7{^8^?`/|k>|Ka{Sq}Gz}io{DxZh[yK_#}9<{TRdgc]`~Z>JYmYJ]|`!ZKZ]gUcx|^E[rZCd`f9oQ[NcD_$ZlZ;Zr}mX|=!|$6ZPZYtIo%fj}CpcN|B,{VDw~gb}@hZg`Q{LcmA[(bo`<|@$|o1|Ss}9Z_}tC|G`{F/|9nd}i=}V-{L8aaeST]daRbujh^xlpq8|}zs4bj[S`J|]?G{P#{rD{]I`OlH{Hm]VYuSYUbRc*6[j`8]pZ[bt_/^Jc*[<Z?YE|Xb|?_Z^Vcas]h{t9|Uwd)_(=0^6Zb{Nc} E[qZAeX[a]P^|_J>e8`W^j_Y}R{{Jp__]Ee#e:iWb9q_wKbujrbR}CY`,{mJ}gz{Q^{t~N|? gSga`V_||:#mi}3t|/I`X{N*|ct|2g{km}gi|{={jC}F;|E}{ZZjYf*frmu}8Tdroi{T[|+~}HG{cJ}DM{Lp{Ctd&}$hi3|FZ| m}Kr|38}^c|m_|Tr{Qv|36}?Up>|;S{DV{k_as}BK{P}}9p|t`jR{sAm4{D=b4pWa[}Xi{EjwEkI}3S|E?u=X0{jf} S|NM|JC{qo^3cm]-|JUx/{Cj{s>{Crt[UXuv|D~|j|d{YXZR}Aq}0r}(_{pJfi_z}0b|-vi)Z mFe,{f4|q`b{}^Z{HM{rbeHZ|^x_o|XM|L%|uFXm}@C_{{Hhp%a7|0p[Xp+^K}9U{bP}: tT}B|}+$|b2|[^|~h{FAby[`{}xgygrt~h1[li`c4vz|,7p~b(|mviN}^pg[{N/|g3|^0c,gE|f%|7N{q[|tc|TKA{LU}I@|AZp(}G-sz{F |qZ{}F|f-}RGn6{Z]_5})B}UJ{FFb2]4ZI@v=k,]t_Dg5Bj]Z-]L]vrpdvdGlk|gF}G]|IW}Y0[G| /bo|Te^,_B}#n^^{QHYI[?hxg{[`]D^IYRYTb&kJ[cri[g_9]Ud~^_]<p@_e_XdNm-^/|5)|h_{J;{kacVopf!q;asqd}n)|.m|bf{QW|U)}b+{tL|w``N|to{t ZO|T]jF}CB|0Q{e5Zw|k |We}5:{HO{tPwf_uajjBfX}-V_C_{{r~gg|Ude;s+}KNXH}! `K}eW{Upwbk%ogaW}9EYN}YY|&v|SL{C3[5s.]Y]I]u{M6{pYZ`^,`ZbCYR[1mNg>rsk0Ym[jrE]RYiZTr*YJ{Ge|%-lf|y(`=[t}E6{k!|3)}Zk} ][G{E~cF{u3U.rJ|a9p#o#ZE|?|{sYc#vv{E=|LC}cu{N8`/`3`9rt[4|He{cq|iSYxY`}V |(Q|t4{C?]k_Vlvk)BZ^r<{CL}#h}R+[<|i=}X|{KAo]|W<`K{NW|Zx}#;|fe{IMr<|K~tJ_x}AyLZ?{GvbLnRgN}X&{H7|x~}Jm{]-| GpNu0}.ok>|c4{PYisrDZ|fwh9|hfo@{H~XSbO]Odv]%`N]b1Y]]|eIZ}_-ZA]aj,>eFn+j[aQ_+]h[J_m_g]%_wf.`%k1e#Z?{CvYu_B^|gk`Xfh^M3`afGZ-Z|[m{L}|k3cp[it ^>YUi~d>{T*}YJ{Q5{Jxa$hg|%4`}|LAgvb }G}{P=|<;Ux{_skR{cV|-*|s-{Mp|XP|$G|_J}c6cM{_=_D|*9^$ec{V;|4S{qO|w_|.7}d0|/D}e}|0G{Dq]Kdp{}dfDi>}B%{Gd|nl}lf{C-{y}|ANZr}#={T~|-(}c&{pI|ft{lsVP}){|@u}!W|bcmB{d?|iW|:dxj{PSkO|Hl]Li:}VYk@|2={fnWt{M3`cZ6|)}|Xj}BYa?vo{e4|L7|B7{L7|1W|lvYO}W8nJ|$Vih|{T{d*_1|:-n2dblk``fT{Ky|-%}m!|Xy|-a{Pz}[l{kFjz|iH}9N{WE{x,|jz}R {P|{D)c=nX|Kq|si}Ge{sh|[X{RF{t`|jsr*fYf,rK|/9}$}}Nf{y!1|<Std}4Wez{W${Fd_/^O[ooqaw_z[L`Nbv[;l7V[ii3_PeM}.h^viqYjZ*j1}+3{bt{DR[;UG}3Og,rS{JO{qw{d<_zbAh<R[1_r`iZTbv^^a}c{iEgQZ<exZFg.^Rb+`Uj{a+{z<[~r!]`[[|rZYR|?F|qppp]L|-d|}K}YZUM|=Y|ktm*}F]{D;g{uI|7kg^}%?Z%ca{N[_<q4xC]i|PqZC]n}.bDrnh0Wq{tr|OMn6tM|!6|T`{O`|>!]ji+]_bTeU}Tq|ds}n|{Gm{z,f)}&s{DPYJ`%{CGd5v4tvb*hUh~bf]z`jajiFqAii]bfy^U{Or|m+{I)cS|.9k:e3`^|xN}@Dnlis`B|Qo{`W|>||kA}Y}{ERYuYx`%[exd`]|OyiHtb}HofUYbFo![5|+]gD{NIZR|Go}.T{rh^4]S|C9_}xO^i`vfQ}C)bK{TL}cQ|79iu}9a];sj{P.o!f[Y]pM``Jda^Wc9ZarteBZClxtM{LW}l9|a.mU}KX}4@{I+f1}37|8u}9c|v${xGlz}jP{Dd1}e:}31}%3X$|22i<v+r@~mf{sN{C67G97855F4YL5}8f{DT|xy{sO{DXB334@55J1)4.G9A#JDYtXTYM4, YQD9;XbXm9SX]IB^4UN=Xn<5(;(F3YW@XkH-X_VM[DYM:5XP!T&Y`6|,^{IS-*D.H>:LXjYQ0I3XhAF:9:(==.F*3F1189K/7163D,:@|e2{LS36D4hq{Lw/84443@4.933:0307::6D7}&l{Mx657;89;,K5678H&93D(H<&<>0B90X^I;}Ag1{P%3A+>><975}[S{PZE453?4|T2{Q+5187;>447:81{C=hL6{Me^:=7ii{R=.=F<81;48?|h8}Uh{SE|,VxL{ST,7?9Y_5Xk3A#:$%YSYdXeKXOD8+TXh7(@>(YdXYHXl9J6X_5IXaL0N?3YK7Xh!1?XgYz9YEXhXaYPXhC3X`-YLY_XfVf[EGXZ5L8BXL9YHX]SYTXjLXdJ: YcXbQXg1PX]Yx4|Jr{Ys4.8YU+XIY`0N,<H%-H;:0@,74/:8546I=9177154870UC]d<C3HXl7ALYzXFXWP<<?E!88E5@03YYXJ?YJ@6YxX-YdXhYG|9o{`iXjY_>YVXe>AYFX[/(I@0841?):-B=14337:8=|14{c&93788|di{cW-0>0<097/A;N{FqYpugAFT%X/Yo3Yn,#=XlCYHYNX[Xk3YN:YRT4?)-YH%A5XlYF3C1=NWyY}>:74-C673<69545v {iT85YED=64=.F4..9878/D4378?48B3:7:7/1VX[f4{D,{l<5E75{dAbRB-8-@+;DBF/$ZfW8S<4YhXA.(5@*11YV8./S95C/0R-A4AXQYI7?68167B95HA1*<M3?1/@;/=54XbYP36}lc{qzSS38:19?,/39193574/66878Yw1X-87E6=;964X`T734:>86>1/=0;(I-1::7ALYGXhF+Xk[@W%TYbX7)KXdYEXi,H-XhYMRXfYK?XgXj.9HX_SX]YL1XmYJ>Y}WwIXiI-3-GXcYyXUYJ$X`Vs[7;XnYEZ;XF! 3;%8;PXX(N3Y[)Xi1YE&/ :;74YQ6X`33C;-(>Xm0(TYF/!YGXg8 9L5P01YPXO-5%C|qd{{/K/E6,=0144:361:955;6443@?B7*7:F89&F35YaX-CYf,XiFYRXE_e{}sF 0*7XRYPYfXa5YXXY8Xf8Y~XmA[9VjYj*#YMXIYOXk,HHX40YxYMXU8OXe;YFXLYuPXP?EB[QV0CXfY{:9XV[FWE0D6X^YVP*$4%OXiYQ(|xp|%c3{}V`1>Y`XH00:8/M6XhQ1:;3414|TE|&o@1*=81G8<3}6<|(f6>>>5-5:8;093B^3U*+*^*UT30XgYU&7*O1953)5@E78--F7YF*B&0:%P68W9Zn5974J9::3}Vk|-,C)=)1AJ4+<3YGXfY[XQXmT1M-XcYTYZXCYZXEYXXMYN,17>XIG*SaS|/eYJXbI?XdNZ+WRYP<F:R PXf;0Xg`$|1GX9YdXjLYxWX!ZIXGYaXNYm6X9YMX?9EXmZ&XZ#XQ>YeXRXfAY[4 ;0X!Zz0XdN$XhYL XIY^XGNXUYS/1YFXhYk.TXn4DXjB{jg|4DEX]:XcZMW=A.+QYL<LKXc[vV$+&PX*Z3XMYIXUQ:ZvW< YSXFZ,XBYeXMM)?Xa XiZ4/EXcP3%}&-|6~:1(-+YT$@XIYRBC<}&,|7aJ6}bp|8)K1|Xg|8C}[T|8Q.89;-964I38361<=/;883651467<7:>?1:.}le|:Z=39;1Y^)?:J=?XfLXbXi=Q0YVYOXaXiLXmJXO5?.SFXiCYW}-;|=u&D-X`N0X^,YzYRXO(QX_YW9`I|>hZ:N&X)DQXP@YH#XmNXi$YWX^=!G6YbYdX>XjY|XlX^XdYkX>YnXUXPYF)FXT[EVTMYmYJXmYSXmNXi#GXmT3X8HOX[ZiXN]IU2>8YdX1YbX<YfWuZ8XSXcZU%0;1XnXkZ_WTG,XZYX5YSX Yp 05G?XcYW(IXg6K/XlYP4XnI @XnO1W4Zp-9C@%QDYX+OYeX9>--YSXkD.YR%Q/Yo YUX].Xi<HYEZ2WdCE6YMXa7F)=,D>-@9/8@5=?7164;35387?N<618=6>7D+C50<6B03J0{Hj|N9$D,9I-,.KB3}m |NzE0::/81YqXjMXl7YG; [.W=Z0X4XQY]:MXiR,XgM?9$9>:?E;YE77VS[Y564760391?14941:0=:8B:;/1DXjFA-564=0B3XlH1+D85:0Q!B#:-6&N/:9<-R3/7Xn<*3J4.H:+334B.=>30H.;3833/76464665755:/83H6633:=;.>5645}&E|Y)?1/YG-,93&N3AE@5 <L1-G/8A0D858/30>8<549=@B8] V0[uVQYlXeD(P#ID&7T&7;Xi0;7T-$YE)E=1:E1GR):--0YI7=E<}n9|aT6783A>D7&4YG7=391W;Zx<5+>F#J39}o/|cc;6=A050EQXg8A1-}D-|d^5548083563695D?-.YOXd37I$@LYLWeYlX<Yd+YR A$;3-4YQ-9XmA0!9/XLY_YT(=5XdDI>YJ5XP1ZAW{9>X_6R(XhYO65&J%DA)C-!B:97#A9;@?F;&;(9=11/=657/H,<8}bz|j^5446>.L+&Y^8Xb6?(CYOXb*YF(8X`FYR(XPYVXmPQ%&DD(XmZXW??YOXZXfCYJ79,O)XnYF7K0!QXmXi4IYFRXS,6<%-:YO(+:-3Q!1E1:W,Zo}Am|n~;3580534*?3Zc4=9334361693:30C<6/717:<1/;>59&:4}6!|rS36=1?75<8}[B|s809983579I.A.>84758=108564741H*9E{L{|u%YQ<%6XfH.YUXe4YL@,>N}Tv|ve*G0X)Z;/)3@A74(4P&A1X:YVH97;,754*A66:1 D739E3553545558E4?-?K17/770843XAYf838A7K%N!YW4.$T19Z`WJ*0XdYJXTYOXNZ 1XaN1A+I&Xi.Xk3Z3GB&5%WhZ1+5#Y[X<4YMXhQYoQXVXbYQ8XSYUX4YXBXWDMG0WxZA[8V+Z8X;D],Va$%YeX?FXfX[XeYf<X:Z[WsYz8X_Y]%XmQ(!7BXIZFX]&YE3F$(1XgYgYE& +[+W!<YMYFXc;+PXCYI9YrWxGXY9DY[!GXiI7::)OC;*$.>N*HA@{C|}&k=:<TB83X`3YL+G4XiK]i}(fYK<=5$.FYE%4*5*H*6XkCYL=*6Xi6!Yi1KXR4YHXbC8Xj,B9ZbWx/XbYON#5B}Ue}+QKXnF1&YV5XmYQ0!*3IXBYb71?1B75XmF;0B976;H/RXU:YZX;BG-NXj;XjI>A#D3B636N;,*%<D:0;YRXY973H5)-4FXOYf0:0;/7759774;7;:/855:543L43<?6=E,.A4:C=L)%4YV!1(YE/4YF+ F3%;S;&JC:%/?YEXJ4GXf/YS-EXEYW,9;E}X$}547EXiK=51-?71C%?57;5>463553Zg90;6447?<>4:9.7538XgN{|!}9K/E&3-:D+YE1)YE/3;37/:05}n<}:UX8Yj4Yt864@JYK..G=.(A Q3%6K>3(P3#AYE$-6H/456*C=.XHY[#S.<780191;057C)=6HXj?955B:K1 E>-B/9,;5.!L?:0>/.@//:;7833YZ56<4:YE=/:7Z_WGC%3I6>XkC*&NA16X=Yz2$X:Y^&J48<99k8}CyB-61<18K946YO4{|N}E)YIB9K0L>4=46<1K0+R;6-=1883:478;4,S+3YJX`GJXh.Yp+Xm6MXcYpX(>7Yo,/:X=Z;Xi0YTYHXjYmXiXj;*;I-8S6N#XgY}.3XfYGO3C/$XjL$*NYX,1 6;YH&<XkK9C#I74.>}Hd`A748X[T450[n75<4439:18A107>|ET}Rf<1;14876/Yb983E<5.YNXd4149>,S=/4E/<306443G/06}0&}UkYSXFYF=44=-5095=88;63844,9E6644{PL}WA8:>)7+>763>>0/B3A545CCnT}Xm|dv}Xq1L/YNXk/H8;;.R63351YY747@15YE4J8;46;.38.>4A369.=-83,;Ye3?:3@YE.4-+N353;/;@(X[YYD>@/05-I*@.:551741Yf5>6A443<3535;.58/86=D4753442$635D1>0359NQ @73:3:>><Xn?;43C14 ?Y|X611YG1&<+,4<*,YLXl<1/AIXjF*N89A4Z576K1XbJ5YF.ZOWN.YGXO/YQ01:4G38Xl1;KI0YFXB=R<7;D/,/4>;$I,YGXm94@O35Yz66695385.>:6A#5}W7n^4336:4157597434433<3|XA}m`>=D>:4A.337370?-6Q96{`E|4A}C`|Qs{Mk|J+~r>|o,wHv>Vw}!c{H!|Gb|*Ca5}J||,U{t+{CN[!M65YXOY_*B,Y[Z9XaX[QYJYLXPYuZ%XcZ8LY[SYPYKZM<LMYG9OYqSQYM~[e{UJXmQYyZM_)>YjN1~[f3{aXFY|Yk:48YdH^NZ0|T){jVFYTZNFY^YTYN~[h{nPYMYn3I]`EYUYsYIZEYJ7Yw)YnXPQYH+Z.ZAZY]^Z1Y`YSZFZyGYHXLYG 8Yd#4~[i|+)YH9D?Y^F~Y7|-eYxZ^WHYdYfZQ~[j|3>~[k|3oYmYqY^XYYO=Z*4[]Z/OYLXhZ1YLZIXgYIHYEYK,<Y`YEXIGZI[3YOYcB4SZ!YHZ*&Y{Xi3~[l|JSY`Zz?Z,~[m|O=Yi>??XnYWXmYS617YVYIHZ(Z4[~L4/=~[n|Yu{P)|];YOHHZ}~[o33|a>~[r|aE]DH~[s|e$Zz~[t|kZFY~XhYXZB[`Y}~[u|{SZ&OYkYQYuZ2Zf8D~[v}% ~[w3},Q[X]+YGYeYPIS~[y}4aZ!YN^!6PZ*~[z}?E~[{3}CnZ=~[}}EdDZz/9A3(3S<,YR8.D=*XgYPYcXN3Z5 4)~[~}JW=$Yu.XX~] }KDX`PXdZ4XfYpTJLY[F5]X~[2Yp}U+DZJ::<446[m@~]#3}]1~]%}^LZwZQ5Z`/OT<Yh^ -~]&}jx[ ~m<z!%2+~ly4VY-~o>}p62yz!%2+Xf2+~ly4VY-zQ`z (=] 2z~o2",C={" ":0,"!":1},c=34,i=2,p,s="",u=String.fromCharCode,t=u(12539);while(++c<127)C[u(c)]=c^39&&c^92?i++:0;i=0;while(0<=(c=C[a.charAt(i++)]))if(16==c)if((c=C[a.charAt(i++)])<87){if(86==c)c=1879;while(c--)s+=u(++p)}else s+=s.substr(8272,360);else if(c<86)s+=u(p+=c<51?c-16:(c-55)*92+C[a.charAt(i++)]);else if((c=((c-86)*92+C[a.charAt(i++)])*92+C[a.charAt(i++)])<49152)s+=u(p=c<40960?c:c|57344);else{c&=511;while(c--)s+=t;p=12539}return s')();

	var JCT8836 = JCT11280.substring(0, 8836);

	exports.EscapeSJIS = EscapeSJIS;
	exports.UnescapeSJIS = UnescapeSJIS;
	exports.EscapeEUCJP = EscapeEUCJP;
	exports.UnescapeEUCJP = UnescapeEUCJP;
	exports.EscapeJIS7 = EscapeJIS7;
	exports.UnescapeJIS7 = UnescapeJIS7;
	exports.EscapeJIS8 = EscapeJIS8;
	exports.UnescapeJIS8 = UnescapeJIS8;
	exports.EscapeUnicode = EscapeUnicode;
	exports.UnescapeUnicode = UnescapeUnicode;
	exports.EscapeUTF7 = EscapeUTF7;
	exports.UnescapeUTF7 = UnescapeUTF7;
	exports.EscapeUTF8 = EscapeUTF8;
	exports.UnescapeUTF8 = UnescapeUTF8;
	exports.EscapeUTF16LE = EscapeUTF16LE;
	exports.UnescapeUTF16LE = UnescapeUTF16LE;
	exports.GetEscapeCodeType = GetEscapeCodeType;
	exports.JCT11280 = JCT11280;
	exports.JCT8836 = JCT8836;

/***/ },
/* 38 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _NSArray2 = __webpack_require__(27);

	var _NSArray3 = _interopRequireDefault(_NSArray2);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * dummy class for NSKeyedArchiver/Unarchiver
	 * @access public
	 * @extends {NSArray}
	 */
	var NSMutableArray = function (_NSArray) {
	  _inherits(NSMutableArray, _NSArray);

	  function NSMutableArray() {
	    _classCallCheck(this, NSMutableArray);

	    return _possibleConstructorReturn(this, (NSMutableArray.__proto__ || Object.getPrototypeOf(NSMutableArray)).apply(this, arguments));
	  }

	  return NSMutableArray;
	}(_NSArray3.default);

	exports.default = NSMutableArray;

/***/ },
/* 39 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _NSData2 = __webpack_require__(30);

	var _NSData3 = _interopRequireDefault(_NSData2);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * dummy class for NSKeyedArchiver/Unarchiver
	 * @access public
	 * @extends {NSData}
	 */
	var NSMutableData = function (_NSData) {
	  _inherits(NSMutableData, _NSData);

	  function NSMutableData() {
	    _classCallCheck(this, NSMutableData);

	    return _possibleConstructorReturn(this, (NSMutableData.__proto__ || Object.getPrototypeOf(NSMutableData)).apply(this, arguments));
	  }

	  return NSMutableData;
	}(_NSData3.default);

	exports.default = NSMutableData;

/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _NSDictionary2 = __webpack_require__(31);

	var _NSDictionary3 = _interopRequireDefault(_NSDictionary2);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * dummy class for NSKeyedArchiver/Unarchiver
	 * @access public
	 * @extends {NSDictionary}
	 */
	var NSMutableDictionary = function (_NSDictionary) {
	  _inherits(NSMutableDictionary, _NSDictionary);

	  function NSMutableDictionary() {
	    _classCallCheck(this, NSMutableDictionary);

	    return _possibleConstructorReturn(this, (NSMutableDictionary.__proto__ || Object.getPrototypeOf(NSMutableDictionary)).apply(this, arguments));
	  }

	  return NSMutableDictionary;
	}(_NSDictionary3.default);

	exports.default = NSMutableDictionary;

/***/ },
/* 41 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _NSObject2 = __webpack_require__(2);

	var _NSObject3 = _interopRequireDefault(_NSObject2);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * dummy class for NSURL
	 * @access public
	 * @extends {NSObject}
	 */
	var NSURL = function (_NSObject) {
	  _inherits(NSURL, _NSObject);

	  function NSURL() {
	    _classCallCheck(this, NSURL);

	    return _possibleConstructorReturn(this, (NSURL.__proto__ || Object.getPrototypeOf(NSURL)).apply(this, arguments));
	  }

	  _createClass(NSURL, null, [{
	    key: 'initWithCoder',

	    /**
	     * @access public
	     * @param {NSCoder} coder -
	     * @returns {string} -
	     */
	    value: function initWithCoder(coder) {
	      var base = coder._refObj['NS.base'].obj;
	      var relative = coder._refObj['NS.relative'].obj;
	      var url = relative; // Should I add the base url?

	      if (url.indexOf(':') < 0) {
	        url = coder._directoryPath + url;
	      }
	      console.error('NSURL: ' + url);

	      return url;
	    }
	  }]);

	  return NSURL;
	}(_NSObject3.default);

	exports.default = NSURL;

/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _NSObject2 = __webpack_require__(2);

	var _NSObject3 = _interopRequireDefault(_NSObject2);

	var _CGPoint = __webpack_require__(7);

	var _CGPoint2 = _interopRequireDefault(_CGPoint);

	var _CGVector = __webpack_require__(22);

	var _CGVector2 = _interopRequireDefault(_CGVector);

	var _CGSize = __webpack_require__(9);

	var _CGSize2 = _interopRequireDefault(_CGSize);

	var _CGRect = __webpack_require__(8);

	var _CGRect2 = _interopRequireDefault(_CGRect);

	var _CATransform3D = __webpack_require__(43);

	var _CATransform3D2 = _interopRequireDefault(_CATransform3D);

	var _SCNVector = __webpack_require__(44);

	var _SCNVector2 = _interopRequireDefault(_SCNVector);

	var _SCNVector3 = __webpack_require__(45);

	var _SCNVector4 = _interopRequireDefault(_SCNVector3);

	var _SCNMatrix = __webpack_require__(46);

	var _SCNMatrix2 = _interopRequireDefault(_SCNMatrix);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * An NSValue object is a simple container for a single C or Objective-C data item. It can hold any of the scalar types such as int, float, and char, as well as pointers, structures, and object id references. Use this class to work with such data types in collections (such as NSArray and NSSet), Key-value coding, and other APIs that require Objective-C objects. NSValue objects are always immutable.
	 * @access public
	 * @extends {NSObject}
	 * @see https://developer.apple.com/reference/foundation/nsvalue
	 */
	var NSValue = function (_NSObject) {
	  _inherits(NSValue, _NSObject);

	  _createClass(NSValue, [{
	    key: 'initBytesObjCType',


	    // Working with Raw Values

	    /**
	     * Initializes a value object to contain the specified value, interpreted with the specified Objective-C type.
	     * @access public
	     * @param {UnsafeRawPointer} value - A pointer to data to be stored in the new value object.
	     * @param {UnsafePointer<Int8>} type - The Objective-C type of value, as provided by the @encode() compiler directive. Do not hard-code this parameter as a C string. 
	     * @returns {void}
	     * @desc See Number and Value Programming Topics for other considerations in creating a value object.This is the designated initializer for the NSValue class.
	     * @see https://developer.apple.com/reference/foundation/nsvalue/1411621-init
	     */
	    value: function initBytesObjCType(value, type) {}

	    /**
	     * Creates a value object containing the specified value, interpreted with the specified Objective-C type.
	     * @access public
	     * @param {UnsafeRawPointer} value - A pointer to data to be stored in the new value object.
	     * @param {UnsafePointer<Int8>} type - The Objective-C type of value, as provided by the @encode() compiler directive. Do not hard-code this parameter as a C string. 
	     * @returns {void}
	     * @desc This method has the same effect as valueWithBytes:objCType: and may be deprecated in a future release. You should use valueWithBytes:objCType: instead.
	     * @see https://developer.apple.com/reference/foundation/nsvalue/1417400-init
	     */

	  }, {
	    key: 'initWithObjCType',
	    value: function initWithObjCType(value, type) {}

	    /**
	     * Copies the value into the specified buffer.
	     * @access public
	     * @param {Object} value - 
	     * @returns {void}
	     * @see https://developer.apple.com/reference/foundation/nsvalue/1415141-getvalue
	     */

	  }, {
	    key: 'getValue',
	    value: function getValue(value) {}

	    /**
	     * A C string containing the Objective-C type of the data contained in the value object.
	     * @type {UnsafePointer<Int8>}
	     * @desc This property provides the same string produced by the @encode() compiler directive.
	     * @see https://developer.apple.com/reference/foundation/nsvalue/1412365-objctype
	     */

	  }, {
	    key: 'objCType',
	    get: function get() {
	      return this._objCType;
	    }

	    // Working with Pointer and Object Values

	    /**
	     * Creates a value object containing the specified pointer.
	     * @access public
	     * @constructor
	     * @param {?UnsafeRawPointer} pointer - 
	     * @desc This method is equivalent to invoking init(_:withObjCType:) in this manner:NSValue *theValue = [NSValue value:&aPointer withObjCType:@encode(void *)];
	    This method does not copy the contents of aPointer, so you must not to free the memory at the pointer destination while the NSValue object exists. NSData objects may be more suited for arbitrary pointers than NSValue objects.NSValue *theValue = [NSValue value:&aPointer withObjCType:@encode(void *)];
	      * @see https://developer.apple.com/reference/foundation/nsvalue/1415975-init
	     */

	  }], [{
	    key: 'initWithCoder',

	    /**
	     * @access public
	     * @param {NSCoder} coder -
	     * @returns {Object} -
	     */
	    value: function initWithCoder(coder) {
	      var special = coder._refObj['NS.special'];

	      var size = coder._refObj['NS.sizeval'].obj;
	      if (size) {
	        if (size.charAt(0) !== '{' || size.charAt(size.length - 1) !== '}') {
	          throw new Error('unknown NSValue size format: ' + size);
	        }
	        var values = size.slice(1, -1).split(',').map(parseFloat);
	        console.error('size width: ' + values[0] + ', height: ' + values[1]);
	        return new _CGSize2.default(values[0], values[1]);
	      }
	      throw new Error('unknown NSValue type');
	    }
	  }]);

	  function NSValue(pointer) {
	    _classCallCheck(this, NSValue);

	    // Working with Raw Values

	    var _this = _possibleConstructorReturn(this, (NSValue.__proto__ || Object.getPrototypeOf(NSValue)).call(this));

	    _this._objCType = null;

	    // Working with Pointer and Object Values

	    _this._pointerValue = null;
	    _this._nonretainedObjectValue = null;

	    // Working with Range Values

	    _this._rangeValue = null;

	    // Working with Foundation Geometry Values

	    _this._pointValue = null;
	    _this._sizeValue = null;
	    _this._rectValue = null;

	    // Working with CoreGraphics Geometry Values

	    _this._cgPointValue = null;
	    _this._cgVectorValue = null;
	    _this._cgSizeValue = null;
	    _this._cgRectValue = null;
	    _this._cgAffineTransformValue = null;

	    // Working with UIKit Geometry Values

	    _this._uiEdgeInsetsValue = null;
	    _this._uiOffsetValue = null;

	    // Working with CoreAnimation Transform Values

	    _this._caTransform3DValue = null;

	    // Working with Media Time Values

	    _this._timeValue = null;
	    _this._timeRangeValue = null;
	    _this._timeMappingValue = null;

	    // Working with Geographic Coordinate Values

	    _this._mkCoordinateValue = null;
	    _this._mkCoordinateSpanValue = null;

	    // Working with SceneKit Vector and Matrix Values

	    _this._scnVector3Value = null;
	    _this._scnVector4Value = null;
	    _this._scnMatrix4Value = null;

	    // Instance Properties

	    _this._edgeInsetsValue = null;
	    return _this;
	  }

	  /**
	   * Creates a value object containing the specified object.
	   * @access public
	   * @param {?Object} anObject - The value for the new object.
	   * @returns {void}
	   * @desc  This method is equivalent to invoking init(_:withObjCType:) in this manner:NSValue *theValue = [NSValue value:&anObject withObjCType:@encode(void *)];
	  This method is useful if you want to add an object to a Collection but dont want the collection to create a strong reference to it.NSValue *theValue = [NSValue value:&anObject withObjCType:@encode(void *)];
	    * @see https://developer.apple.com/reference/foundation/nsvalue/1408098-init
	   */


	  _createClass(NSValue, [{
	    key: 'initNonretainedObject',
	    value: function initNonretainedObject(anObject) {}

	    /**
	     * Returns the value as an untyped pointer.
	     * @type {?Object}
	     * @desc 
	     * @see https://developer.apple.com/reference/foundation/nsvalue/1410668-pointervalue
	     */

	  }, {
	    key: 'initCgPoint',


	    // Working with CoreGraphics Geometry Values

	    /**
	     * Creates a new value object containing the specified CoreGraphics point structure.
	     * @access public
	     * @param {CGPoint} point - The value for the new object.
	     * @returns {void}
	     * @see https://developer.apple.com/reference/foundation/nsvalue/1624531-init
	     */
	    value: function initCgPoint(point) {}

	    /**
	     * Creates a new value object containing the specified CoreGraphics vector structure.
	     * @access public
	     * @param {CGVector} vector - The value for the new object.
	     * @returns {void}
	     * @see https://developer.apple.com/reference/foundation/nsvalue/1624493-init
	     */

	  }, {
	    key: 'initCgVector',
	    value: function initCgVector(vector) {}

	    /**
	     * Creates a new value object containing the specified CoreGraphics size structure.
	     * @access public
	     * @param {CGSize} size - The value for the new object.
	     * @returns {void}
	     * @see https://developer.apple.com/reference/foundation/nsvalue/1624511-init
	     */

	  }, {
	    key: 'initCgSize',
	    value: function initCgSize(size) {}

	    /**
	     * Creates a new value object containing the specified CoreGraphics rectangle structure.
	     * @access public
	     * @param {CGRect} rect - The value for the new object.
	     * @returns {void}
	     * @see https://developer.apple.com/reference/foundation/nsvalue/1624529-init
	     */

	  }, {
	    key: 'initCgRect',
	    value: function initCgRect(rect) {}

	    /**
	     * Creates a new value object containing the specified CoreGraphics affine transform structure.
	     * @access public
	     * @param {CGAffineTransform} transform - The value for the new object.
	     * @returns {void}
	     * @see https://developer.apple.com/reference/foundation/nsvalue/1624503-init
	     */

	  }, {
	    key: 'initCgAffineTransform',
	    value: function initCgAffineTransform(transform) {}

	    /**
	     * Returns the CoreGraphics point structure representation of the value.
	     * @type {CGPoint}
	     * @desc 
	     * @see https://developer.apple.com/reference/foundation/nsvalue/1624534-cgpointvalue
	     */

	  }, {
	    key: 'initUiEdgeInsets',


	    // Working with UIKit Geometry Values

	    /**
	     * Creates a new value object containing the specified UIKit edge insets structure.
	     * @access public
	     * @param {UIEdgeInsets} insets - The value for the new object.
	     * @returns {void}
	     * @see https://developer.apple.com/reference/foundation/nsvalue/1624485-init
	     */
	    value: function initUiEdgeInsets(insets) {}

	    /**
	     * Creates a new value object containing the specified UIKit offset structure.
	     * @access public
	     * @param {UIOffset} insets - The value for the new object.
	     * @returns {void}
	     * @see https://developer.apple.com/reference/foundation/nsvalue/1624530-init
	     */

	  }, {
	    key: 'initUiOffset',
	    value: function initUiOffset(insets) {}

	    /**
	     * Returns the UIKit edge insets structure representation of the value.
	     * @type {UIEdgeInsets}
	     * @desc 
	     * @see https://developer.apple.com/reference/foundation/nsvalue/1624517-uiedgeinsetsvalue
	     */

	  }, {
	    key: 'initCaTransform3D',


	    // Working with CoreAnimation Transform Values

	    /**
	     * Creates a new value object containing the specified CoreAnimation transform structure.
	     * @access public
	     * @param {CATransform3D} t - 
	     * @returns {void}
	     * @see https://developer.apple.com/reference/foundation/nsvalue/1436556-init
	     */
	    value: function initCaTransform3D(t) {}

	    /**
	     * The CoreAnimation transform structure representation of the value.
	     * @type {CATransform3D}
	     * @desc 
	     * @see https://developer.apple.com/reference/foundation/nsvalue/1436572-catransform3dvalue
	     */

	  }, {
	    key: 'initMkCoordinate',


	    // Working with Geographic Coordinate Values

	    /**
	     * Creates a new value object containing the specified CoreLocation geographic coordinate structure.
	     * @access public
	     * @param {CLLocationCoordinate2D} coordinate - The value for the new object.
	     * @returns {void}
	     * @see https://developer.apple.com/reference/foundation/nsvalue/1452193-init
	     */
	    value: function initMkCoordinate(coordinate) {}

	    /**
	     * Creates a new value object containing the specified MapKit coordinate span structure.
	     * @access public
	     * @param {MKCoordinateSpan} span - The value for the new object.
	     * @returns {void}
	     * @see https://developer.apple.com/reference/foundation/nsvalue/1452333-init
	     */

	  }, {
	    key: 'initMkCoordinateSpan',
	    value: function initMkCoordinateSpan(span) {}

	    /**
	     * The CoreLocation geographic coordinate structure representation of the value.
	     * @type {CLLocationCoordinate2D}
	     * @desc 
	     * @see https://developer.apple.com/reference/foundation/nsvalue/1452495-mkcoordinatevalue
	     */

	  }, {
	    key: 'initScnVector3',


	    // Working with SceneKit Vector and Matrix Values

	    /**
	     * Creates a value object that contains the specified three-element SceneKit vector.
	     * @access public
	     * @param {SCNVector3} v - 
	     * @returns {void}
	     * @see https://developer.apple.com/reference/foundation/nsvalue/1409671-init
	     */
	    value: function initScnVector3(v) {}

	    /**
	     * Creates a value object that contains the specified four-element SceneKit vector.
	     * @access public
	     * @param {SCNVector4} v - 
	     * @returns {void}
	     * @see https://developer.apple.com/reference/foundation/nsvalue/1409688-init
	     */

	  }, {
	    key: 'initScnVector4',
	    value: function initScnVector4(v) {}

	    /**
	     * Creates a value object that contains the specified SceneKit 4 x 4 matrix.
	     * @access public
	     * @param {SCNMatrix4} v - The value for the new object.
	     * @returns {void}
	     * @see https://developer.apple.com/reference/foundation/nsvalue/1409680-init
	     */

	  }, {
	    key: 'initScnMatrix4',
	    value: function initScnMatrix4(v) {}

	    /**
	     * The three-element Scene Kit vector representation of the value.
	     * @type {SCNVector3}
	     * @desc 
	     * @see https://developer.apple.com/reference/foundation/nsvalue/1409669-scnvector3value
	     */

	  }, {
	    key: 'isEqualTo',


	    // Comparing Value Objects

	    /**
	     * Returns a Boolean value that indicates whether the value object and another value object are equal.
	     * @access public
	     * @param {NSValue} value - 
	     * @returns {boolean} - 
	     * @desc The NSValue class compares the type and contents of each value object to determine equality.
	     * @see https://developer.apple.com/reference/foundation/nsvalue/1409038-isequal
	     */
	    value: function isEqualTo(value) {
	      return false;
	    }

	    // Initializers

	    /**
	     * 
	     * @access public
	     * @param {NSCoder} aDecoder - 
	     * @returns {void}
	     * @see https://developer.apple.com/reference/foundation/nsvalue/1417896-init
	     */

	  }, {
	    key: 'initCoder',
	    value: function initCoder(aDecoder) {}

	    /**
	     * 
	     * @access public
	     * @param {EdgeInsets} insets - 
	     * @returns {void}
	     * @see https://developer.apple.com/reference/foundation/nsvalue/1391181-init
	     */

	  }, {
	    key: 'initEdgeInsets',
	    value: function initEdgeInsets(insets) {}

	    // Instance Properties
	    /**
	     * 
	     * @type {EdgeInsets}
	     * @desc 
	     * @see https://developer.apple.com/reference/foundation/nsvalue/1391123-edgeinsetsvalue
	     */

	  }, {
	    key: 'pointerValue',
	    get: function get() {
	      return this._pointerValue;
	    }

	    /**
	     * The value as a non-retained pointer to an object.
	     * @type {?Object}
	     * @desc If the value was not created to hold a pointer-sized data item, the result is undefined.
	     * @see https://developer.apple.com/reference/foundation/nsvalue/1412287-nonretainedobjectvalue
	     */

	  }, {
	    key: 'nonretainedObjectValue',
	    get: function get() {
	      return this._nonretainedObjectValue;
	    }

	    // Working with Range Values
	    /**
	     * The Foundation range structure representation of the value.
	     * @type {NSRange}
	     * @desc 
	     * @see https://developer.apple.com/reference/foundation/nsvalue/1413902-rangevalue
	     */

	  }, {
	    key: 'rangeValue',
	    get: function get() {
	      return this._rangeValue;
	    }

	    // Working with Foundation Geometry Values
	    /**
	     * The Foundation point structure representation of the value.
	     * @type {CGPoint}
	     * @desc 
	     * @see https://developer.apple.com/reference/foundation/nsvalue/1391255-pointvalue
	     */

	  }, {
	    key: 'pointValue',
	    get: function get() {
	      return this._pointValue;
	    }

	    /**
	     * The Foundation size structure representation of the value.
	     * @type {CGSize}
	     * @desc 
	     * @see https://developer.apple.com/reference/foundation/nsvalue/1391301-sizevalue
	     */

	  }, {
	    key: 'sizeValue',
	    get: function get() {
	      return this._sizeValue;
	    }

	    /**
	     * The Foundation rectangle structure representation of the value.
	     * @type {CGRect}
	     * @desc 
	     * @see https://developer.apple.com/reference/foundation/nsvalue/1391171-rectvalue
	     */

	  }, {
	    key: 'rectValue',
	    get: function get() {
	      return this._rectValue;
	    }
	  }, {
	    key: 'cgPointValue',
	    get: function get() {
	      return this._cgPointValue;
	    }

	    /**
	     * Returns the CoreGraphics vector structure representation of the value.
	     * @type {CGVector}
	     * @desc 
	     * @see https://developer.apple.com/reference/foundation/nsvalue/1624486-cgvectorvalue
	     */

	  }, {
	    key: 'cgVectorValue',
	    get: function get() {
	      return this._cgVectorValue;
	    }

	    /**
	     * Returns the CoreGraphics size structure representation of the value.
	     * @type {CGSize}
	     * @desc 
	     * @see https://developer.apple.com/reference/foundation/nsvalue/1624489-cgsizevalue
	     */

	  }, {
	    key: 'cgSizeValue',
	    get: function get() {
	      return this._cgSizeValue;
	    }
	    /**
	     * Returns the CoreGraphics rectangle structure representation of the value.
	     * @type {CGRect}
	     * @desc 
	     * @see https://developer.apple.com/reference/foundation/nsvalue/1624506-cgrectvalue
	     */

	  }, {
	    key: 'cgRectValue',
	    get: function get() {
	      return this._cgRectValue;
	    }

	    /**
	     * Returns the CoreGraphics affine transform representation of the value.
	     * @type {CGAffineTransform}
	     * @desc 
	     * @see https://developer.apple.com/reference/foundation/nsvalue/1624512-cgaffinetransformvalue
	     */

	  }, {
	    key: 'cgAffineTransformValue',
	    get: function get() {
	      return this._cgAffineTransformValue;
	    }
	  }, {
	    key: 'uiEdgeInsetsValue',
	    get: function get() {
	      return this._uiEdgeInsetsValue;
	    }

	    /**
	     * Returns the UIKit offset structure representation of the value.
	     * @type {UIOffset}
	     * @desc 
	     * @see https://developer.apple.com/reference/foundation/nsvalue/1624526-uioffsetvalue
	     */

	  }, {
	    key: 'uiOffsetValue',
	    get: function get() {
	      return this._uiOffsetValue;
	    }
	  }, {
	    key: 'caTransform3DValue',
	    get: function get() {
	      return this._caTransform3DValue;
	    }

	    // Working with Media Time Values
	    /**
	     * The CoreMedia time structure representation of the value.
	     * @type {CMTime}
	     * @desc 
	     * @see https://developer.apple.com/reference/foundation/nsvalue/1388151-timevalue
	     */

	  }, {
	    key: 'timeValue',
	    get: function get() {
	      return this._timeValue;
	    }
	    /**
	     * The CoreMedia time range structure representation of the value.
	     * @type {CMTimeRange}
	     * @desc 
	     * @see https://developer.apple.com/reference/foundation/nsvalue/1385930-timerangevalue
	     */

	  }, {
	    key: 'timeRangeValue',
	    get: function get() {
	      return this._timeRangeValue;
	    }
	    /**
	     * The CoreMedia time mapping structure representation of the value.
	     * @type {CMTimeMapping}
	     * @desc 
	     * @see https://developer.apple.com/reference/foundation/nsvalue/1387277-timemappingvalue
	     */

	  }, {
	    key: 'timeMappingValue',
	    get: function get() {
	      return this._timeMappingValue;
	    }
	  }, {
	    key: 'mkCoordinateValue',
	    get: function get() {
	      return this._mkCoordinateValue;
	    }
	    /**
	     * The MapKit coordinate span structure representation of the value.
	     * @type {MKCoordinateSpan}
	     * @desc 
	     * @see https://developer.apple.com/reference/foundation/nsvalue/1452516-mkcoordinatespanvalue
	     */

	  }, {
	    key: 'mkCoordinateSpanValue',
	    get: function get() {
	      return this._mkCoordinateSpanValue;
	    }
	  }, {
	    key: 'scnVector3Value',
	    get: function get() {
	      return this._scnVector3Value;
	    }
	    /**
	     * The four-element Scene Kit vector representation of the value.
	     * @type {SCNVector4}
	     * @desc 
	     * @see https://developer.apple.com/reference/foundation/nsvalue/1409725-scnvector4value
	     */

	  }, {
	    key: 'scnVector4Value',
	    get: function get() {
	      return this._scnVector4Value;
	    }
	    /**
	     * The Scene Kit 4 x 4 matrix representation of the value.
	     * @type {SCNMatrix4}
	     * @desc 
	     * @see https://developer.apple.com/reference/foundation/nsvalue/1409684-scnmatrix4value
	     */

	  }, {
	    key: 'scnMatrix4Value',
	    get: function get() {
	      return this._scnMatrix4Value;
	    }
	  }, {
	    key: 'edgeInsetsValue',
	    get: function get() {
	      return this._edgeInsetsValue;
	    }
	  }]);

	  return NSValue;
	}(_NSObject3.default);

	exports.default = NSValue;

/***/ },
/* 43 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * Defines the standard transform matrix used throughout Core Animation.
	 * @access public
	 * @see https://developer.apple.com/reference/quartzcore/catransform3d
	 */

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var CATransform3D =

	// Initializers

	/**
	 * 
	 * @access public
	 * @param {number[][]} m - 
	 * @returns {void}
	 * @see https://developer.apple.com/reference/quartzcore/catransform3d/1523734-init
	 */
	function CATransform3D(m) {
	  _classCallCheck(this, CATransform3D);

	  // Instance Properties

	  this._m11 = 1;
	  this._m12 = 0;
	  this._m13 = 0;
	  this._m14 = 0;
	  this._m21 = 0;
	  this._m22 = 1;
	  this._m23 = 0;
	  this._m24 = 0;
	  this._m31 = 0;
	  this._m32 = 0;
	  this._m33 = 1;
	  this._m34 = 0;
	  this._m41 = 0;
	  this._m42 = 0;
	  this._m43 = 0;
	  this._m44 = 1;
	}

	// Instance Properties
	;

	exports.default = CATransform3D;

/***/ },
/* 44 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _SCNVector = __webpack_require__(45);

	var _SCNVector2 = _interopRequireDefault(_SCNVector);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	//import _Ammo from '../third_party/ammo'
	/*global Ammo*/

	/**
	 * A representation of a three-component vector.
	 * @access public
	 * @see https://developer.apple.com/reference/scenekit/scnvector3
	 */
	var SCNVector3 = function () {

	  // Initializers

	  /**
	   * 
	   * @access public
	   * @constructor
	   * @param {number} x - 
	   * @param {number} y - 
	   * @param {number} z - 
	   * @returns {void}
	   * @see https://developer.apple.com/reference/scenekit/scnvector3/1522904-init
	   */
	  function SCNVector3() {
	    var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
	    var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
	    var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

	    _classCallCheck(this, SCNVector3);

	    // Instance Properties
	    /** @type {number} */
	    this.x = x;
	    /** @type {number} */
	    this.y = y;
	    /** @type {number} */
	    this.z = z;

	    //if(x instanceof Ammo.btVector3){
	    //  this.x = x.x()
	    //  this.y = x.y()
	    //  this.z = x.z()
	    //}
	  }

	  /**
	   * @access private
	   * @param {Buffer} data -
	   * @param {number} [offset = 0] -
	   * @param {boolean} [bigEndian = false] -
	   * @returns {SCNVector3}
	   */


	  _createClass(SCNVector3, [{
	    key: '_copy',
	    value: function _copy() {
	      return new SCNVector3(this.x, this.y, this.z);
	    }
	  }, {
	    key: '_copyFrom',
	    value: function _copyFrom(v) {
	      this.x = v.x;
	      this.y = v.y;
	      this.z = v.z;
	    }

	    // extensions

	  }, {
	    key: 'zero',
	    value: function zero() {
	      return new SCNVector3();
	    }

	    /**
	     * @access public
	     * @param {SCNVector3} v -
	     * @returns {SCNVector3} -
	     */

	  }, {
	    key: 'add',
	    value: function add(v) {
	      var r = new SCNVector3();
	      r.x = this.x + v.x;
	      r.y = this.y + v.y;
	      r.z = this.z + v.z;
	      return r;
	    }

	    /**
	     * @access public
	     * @param {SCNVector3} v -
	     * @returns {SCNVector3} -
	     */

	  }, {
	    key: 'sub',
	    value: function sub(v) {
	      var r = new SCNVector3();
	      r.x = this.x - v.x;
	      r.y = this.y - v.y;
	      r.z = this.z - v.z;
	      return r;
	    }

	    /**
	     * @access public
	     * @param {number} n -
	     * @returns {SCNVector3} -
	     */

	  }, {
	    key: 'mul',
	    value: function mul(n) {
	      var r = new SCNVector3();
	      r.x = this.x * n;
	      r.y = this.y * n;
	      r.z = this.z * n;
	      return r;
	    }

	    /**
	     * @access public
	     * @param {SCNVector3} v -
	     * @returns {number} -
	     */

	  }, {
	    key: 'dot',
	    value: function dot(v) {
	      return this.x * v.x + this.y * v.y + this.z * v.z;
	    }

	    /**
	     * @access public
	     * @param {SCNVecor3} v -
	     * @returns {SCNVector3} -
	     */

	  }, {
	    key: 'cross',
	    value: function cross(v) {
	      var r = new SCNVector3();
	      r.x = this.y * v.z - this.z * v.y;
	      r.y = this.z * v.x - this.x * v.z;
	      r.z = this.x * v.y - this.y * v.x;
	      return r;
	    }

	    /**
	     * @access public
	     * @param {SCNVector3} v -
	     * @param {number} rate -
	     * @returns {SCNVector3} -
	     */

	  }, {
	    key: 'lerp',
	    value: function lerp(v, rate) {
	      var r = new SCNVector3();
	      r.x = this.x + rate * (v.x - this.x);
	      r.y = this.y + rate * (v.y - this.y);
	      r.z = this.z + rate * (v.z - this.z);
	      return r;
	    }

	    /**
	     * @access public
	     * @returns {SCNVector3} -
	     */

	  }, {
	    key: 'normalize',
	    value: function normalize() {
	      var len = this.length();
	      var r = new SCNVector3();
	      if (len === 0) {
	        return r;
	      }
	      var sqr = 1.0 / len;
	      r.x = this.x * sqr;
	      r.y = this.y * sqr;
	      r.z = this.z * sqr;

	      return r;
	    }

	    /**
	     * @access public
	     * @returns {number} -
	     */

	  }, {
	    key: 'length',
	    value: function length() {
	      return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
	    }

	    /**
	     * @access public
	     * @param {SCNMatrix4} m -
	     * @returns {SCNVector3} -
	     */

	  }, {
	    key: 'transform',
	    value: function transform(m) {
	      var r = new SCNVector3();
	      var w = this.x * m.m14 + this.y * m.m24 + this.z * m.m34 + m.m44;
	      if (w === 0) {
	        return r;
	      }
	      var iw = 1.0 / w;
	      r.x = (this.x * m.m11 + this.y * m.m21 + this.z * m.m31 + m.m41) * iw;
	      r.y = (this.x * m.m12 + this.y * m.m22 + this.z * m.m32 + m.m42) * iw;
	      r.z = (this.x * m.m13 + this.y * m.m23 + this.z * m.m33 + m.m43) * iw;
	      return r;
	    }

	    /**
	     * @access public
	     * @param {SCNMatrix4} m -
	     * @returns {SCNVector3} -
	     */

	  }, {
	    key: 'rotate',
	    value: function rotate(m) {
	      var r = new SCNVector3();
	      r.x = this.x * m.m11 + this.y * m.m21 + this.z * m.m31;
	      r.y = this.x * m.m12 + this.y * m.m22 + this.z * m.m32;
	      r.z = this.x * m.m13 + this.y * m.m23 + this.z * m.m33;
	      return r;
	    }

	    /**
	     * @access public
	     * @param {SCNVector4} q -
	     * @returns {SCNVector3} -
	     */

	  }, {
	    key: 'rotateWithQuaternion',
	    value: function rotateWithQuaternion(q) {
	      return this.rotate(q.rotMatrix());
	    }

	    /**
	     * @access public
	     * @returns {SCNVector4} -
	     */

	  }, {
	    key: 'eulerAnglesToRotation',
	    value: function eulerAnglesToRotation() {
	      var rot = new _SCNVector2.default();
	      var halfX = this.x * 0.5;
	      var halfY = this.y * 0.5;
	      var halfZ = this.z * 0.5;
	      var cosX = Math.cos(halfX);
	      var sinX = Math.sin(halfX);
	      var cosY = Math.cos(halfY);
	      var sinY = Math.sin(halfY);
	      var cosZ = Math.cos(halfZ);
	      var sinZ = Math.sin(halfZ);

	      var q = new _SCNVector2.default();
	      var x = sinX * cosY * cosZ - cosX * sinY * sinZ;
	      var y = cosX * sinY * cosZ + sinX * cosY * sinZ;
	      var z = cosX * cosY * sinZ - sinX * sinY * cosZ;
	      var d = x * x + y * y + z * z;
	      if (d === 0) {
	        rot.x = 0;
	        rot.y = 0;
	        rot.z = 0;
	        rot.w = 0;
	      } else {
	        var r = 1.0 / Math.sqrt(d);
	        rot.x = x * r;
	        rot.y = y * r;
	        rot.z = z * r;
	        rot.w = 2 * Math.acos(cosX * cosY * cosZ + sinX * sinY * sinZ);
	      }

	      return rot;
	    }

	    /**
	     * @access public
	     * @returns {SCNVector4} -
	     */

	  }, {
	    key: 'eulerAnglesToQuat',
	    value: function eulerAnglesToQuat() {
	      return this.eulerAnglesToRotation().rotationToQuat();
	    }

	    /**
	     * @access public
	     * @returns {number[]} -
	     */

	  }, {
	    key: 'floatArray',
	    value: function floatArray() {
	      return [this.x, this.y, this.z];
	    }

	    /**
	     * @access public
	     * @returns {Float32Array} -
	     */

	  }, {
	    key: 'float32Array',
	    value: function float32Array() {
	      return new Float32Array([this.x, this.y, this.z]);
	    }

	    /**
	     * @access private
	     * @returns {Ammo.btVector3}
	     * @desc call Ammo.destroy(vec) after using it.
	     */

	  }, {
	    key: '_createBtVector3',
	    value: function _createBtVector3() {
	      //return new Ammo.btVector3(this.x, this.y, this.z)
	    }
	  }], [{
	    key: '_initWithData',
	    value: function _initWithData(data) {
	      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
	      var bigEndian = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

	      var instance = new SCNVector3();
	      if (bigEndian) {
	        instance.x = data.readFloatBE(offset + 0);
	        instance.y = data.readFloatBE(offset + 4);
	        instance.z = data.readFloatBE(offset + 8);
	      } else {
	        instance.x = data.readFloatLE(offset + 0);
	        instance.y = data.readFloatLE(offset + 4);
	        instance.z = data.readFloatLE(offset + 8);
	      }
	      return instance;
	    }
	  }]);

	  return SCNVector3;
	}();

	exports.default = SCNVector3;

/***/ },
/* 45 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _SCNMatrix = __webpack_require__(46);

	var _SCNMatrix2 = _interopRequireDefault(_SCNMatrix);

	var _SCNVector = __webpack_require__(44);

	var _SCNVector2 = _interopRequireDefault(_SCNVector);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	/*global Ammo*/

	/**
	 * A representation of a four-component vector.
	 * @access public
	 * @see https://developer.apple.com/reference/scenekit/scnvector4
	 */
	var SCNVector4 = function () {
	  // Initializers

	  /**
	   * 
	   * @access public
	   * @constructor
	   * @param {number} x - 
	   * @param {number} y - 
	   * @param {number} z - 
	   * @param {number} w - 
	   * @see https://developer.apple.com/reference/scenekit/scnvector4/1523931-init
	   */
	  function SCNVector4() {
	    var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
	    var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
	    var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
	    var w = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;

	    _classCallCheck(this, SCNVector4);

	    // Instance Properties
	    /** @type {number} */
	    this.x = x;
	    /** @type {number} */
	    this.y = y;
	    /** @type {number} */
	    this.z = z;
	    /** @type {number} */
	    this.w = w;

	    //if(x instanceof Ammo.btVector4){
	    //  this.x = x.x()
	    //  this.y = x.y()
	    //  this.z = x.z()
	    //  this.w = x.w()
	    //}
	  }

	  /**
	   * @access private
	   * @param {Buffer} data -
	   * @param {number} [offset = 0] -
	   * @param {boolean} [bigEndian = false] -
	   * @returns {SCNVector4}
	   */


	  _createClass(SCNVector4, [{
	    key: '_copy',
	    value: function _copy() {
	      return new SCNVector4(this.x, this.y, this.z, this.w);
	    }
	  }, {
	    key: '_copyFrom',
	    value: function _copyFrom(v) {
	      this.x = v.x;
	      this.y = v.y;
	      this.z = v.z;
	      this.w = v.z;
	    }

	    // extensions

	  }, {
	    key: 'zero',
	    value: function zero() {
	      return new SCNVector4();
	    }

	    /**
	     * @access public
	     * @param {SCNVector4} v -
	     * @returns {SCNVector4} -
	     */

	  }, {
	    key: 'add',
	    value: function add(v) {
	      var r = new SCNVector4();
	      r.x = this.x + v.x;
	      r.y = this.y + v.y;
	      r.z = this.z + v.z;
	      r.w = this.w + v.w;
	      return r;
	    }

	    /**
	     * @access public
	     * @param {SCNVector4} v -
	     * @returns {SCNVector4} -
	     */

	  }, {
	    key: 'sub',
	    value: function sub(v) {
	      var r = new SCNVector4();
	      r.x = this.x - v.x;
	      r.y = this.y - v.y;
	      r.z = this.z - v.z;
	      r.w = this.w - v.w;
	      return r;
	    }

	    /**
	     * @access public
	     * @param {number} n -
	     * @returns {SCNVector4} -
	     */

	  }, {
	    key: 'mul',
	    value: function mul(n) {
	      var r = new SCNVector4();
	      r.x = this.x * n;
	      r.y = this.y * n;
	      r.z = this.z * n;
	      r.w = this.w * n;
	      return r;
	    }

	    /**
	     * @access public
	     * @param {SCNVector4} v -
	     * @returns {number} -
	     */

	  }, {
	    key: 'dot',
	    value: function dot(v) {
	      return this.x * v.x + this.y * v.y + this.z * v.z + this.z * v.z;
	    }

	    /**
	     * @access public
	     * @param {SCNVecor4} v -
	     * @returns {SCNVector4} -
	     */

	  }, {
	    key: 'cross',
	    value: function cross(v) {
	      var r = new SCNVector4();
	      r.x = this.w * v.x + this.x * v.w + this.y * v.z - this.z * v.y;
	      r.y = this.w * v.y - this.x * v.z + this.y * v.w + this.z * v.x;
	      r.z = this.w * v.z + this.x * v.y - this.y * v.x + this.z * v.w;
	      r.w = this.w * v.w - this.x * v.x - this.y * v.y - this.z * v.z;
	      return r;
	    }

	    /**
	     * @access public
	     * @param {SCNVector4} v -
	     * @param {number} rate -
	     * @returns {SCNVector4} -
	     */

	  }, {
	    key: 'lerp',
	    value: function lerp(v, rate) {
	      var r = new SCNVector4();
	      r.x = this.x + rate * (v.x - this.x);
	      r.y = this.y + rate * (v.y - this.y);
	      r.z = this.z + rate * (v.z - this.z);
	      r.w = this.w + rate * (v.w - this.w);
	      return r;
	    }

	    /**
	     * @access public
	     * @param {SCNVector4} v -
	     * @param {number} rate -
	     * @returns {SCNVector4} -
	     */

	  }, {
	    key: 'slerp',
	    value: function slerp(v, rate) {
	      var r = new SCNVector4();
	      var qr = this.dot(v);

	      if (qr < 0) {
	        r.x = this.x - (this.x + v.x) * rate;
	        r.y = this.y - (this.y + v.y) * rate;
	        r.z = this.z - (this.z + v.z) * rate;
	        r.w = this.w - (this.w + v.w) * rate;
	      } else {
	        r.x = this.x + (v.x - this.x) * rate;
	        r.y = this.y + (v.y - this.y) * rate;
	        r.z = this.z + (v.z - this.z) * rate;
	        r.w = this.w + (v.w - this.w) * rate;
	      }
	      return r.normalize();
	    }

	    /**
	     * @access public
	     * @returns {SCNVector4} -
	     */

	  }, {
	    key: 'normalize',
	    value: function normalize() {
	      var r = new SCNVector4();
	      var sqr = 1.0 / this.length();
	      r.x = this.x * sqr;
	      r.y = this.y * sqr;
	      r.z = this.z * sqr;
	      r.w = this.w * sqr;
	      return r;
	    }

	    /**
	     * @access public
	     * @returns {number} -
	     */

	  }, {
	    key: 'length',
	    value: function length() {
	      return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
	    }
	  }, {
	    key: 'transform',
	    value: function transform(m) {
	      var r = new SCNVector4();
	      r.x = this.x * m.m11 + this.y * m.m21 + this.z * m.m31 + this.w * m.m41;
	      r.y = this.x * m.m12 + this.y * m.m22 + this.z * m.m32 + this.w * m.m42;
	      r.z = this.x * m.m13 + this.y * m.m23 + this.z * m.m33 + this.w * m.m43;
	      r.w = this.x * m.m14 + this.y * m.m24 + this.z * m.m34 + this.w * m.m44;
	      return r;
	    }

	    /**
	     * @access public
	     * @returns {SCNVector4} -
	     */

	  }, {
	    key: 'ln',
	    value: function ln() {
	      var r = new SCNVector4();
	      var v = this.normalize();

	      var n = Math.sqrt(v.x * v.x + v.y * v.y + v.z * v.z);
	      if (n === 0) {
	        r.x = 0;
	        r.y = 0;
	        r.z = 0;
	        r.w = 0;
	        return r;
	      }
	      var theta = Math.atan2(n, v.w) / n;

	      r.x = theta * v.x;
	      r.y = theta * v.y;
	      r.z = theta * v.z;
	      r.w = 0;
	      return r;
	    }

	    /**
	     * @access public
	     * @returns {SCNVector4} -
	     */

	  }, {
	    key: 'exp',
	    value: function exp() {
	      var r = new SCNVector4();
	      var n = Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);

	      if (n > 0.0) {
	        var sinn = Math.sin(n);
	        r.x = sinn * this.x / n;
	        r.y = sinn * this.y / n;
	        r.z = sinn * this.z / n;
	        r.w = Math.cos(n);
	      } else {
	        r.x = 0.0;
	        r.y = 0.0;
	        r.z = 0.0;
	        r.w = 1.0;
	      }
	      return r;
	    }

	    /**
	     * @access public
	     * @returns {SCNMatrix4} -
	     */

	  }, {
	    key: 'rotMatrix',
	    value: function rotMatrix() {
	      var r = new _SCNMatrix2.default();
	      var x2 = this.x * this.x * 2.0;
	      var y2 = this.y * this.y * 2.0;
	      var z2 = this.z * this.z * 2.0;
	      var xy = this.x * this.y * 2.0;
	      var yz = this.y * this.z * 2.0;
	      var zx = this.z * this.x * 2.0;
	      var xw = this.x * this.w * 2.0;
	      var yw = this.y * this.w * 2.0;
	      var zw = this.z * this.w * 2.0;

	      r.m11 = 1.0 - y2 - z2;
	      r.m12 = xy + zw;
	      r.m13 = zx - yw;
	      r.m14 = 0.0;
	      r.m21 = xy - zw;
	      r.m22 = 1.0 - z2 - x2;
	      r.m23 = yz + xw;
	      r.m24 = 0.0;
	      r.m31 = zx + yw;
	      r.m32 = yz - xw;
	      r.m33 = 1.0 - x2 - y2;
	      r.m34 = 0.0;
	      r.m41 = 0.0;
	      r.m42 = 0.0;
	      r.m43 = 0.0;
	      r.m44 = 1.0;
	      return r;
	    }

	    /**
	     * @access public
	     * @returns {SCNVector4} -
	     */

	  }, {
	    key: 'rotationToQuat',
	    value: function rotationToQuat() {
	      var quat = new SCNVector4();
	      if (this.x === 0 && this.y === 0 && this.z === 0) {
	        quat.x = 0;
	        quat.y = 0;
	        quat.z = 0;
	        quat.w = 1.0;
	      } else {
	        var r = 1.0 / Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
	        var cosW = Math.cos(this.w * 0.5);
	        var sinW = Math.sin(this.w * 0.5) * r;
	        quat.x = this.x * sinW;
	        quat.y = this.y * sinW;
	        quat.z = this.z * sinW;
	        quat.w = cosW;
	      }

	      return quat;
	    }

	    /**
	     * @access public
	     * @returns {SCNVector4} -
	     */

	  }, {
	    key: 'quatToRotation',
	    value: function quatToRotation() {
	      var rot = new SCNVector4();
	      if (this.x === 0 && this.y === 0 && this.z === 0) {
	        rot.x = 0;
	        rot.y = 0;
	        rot.z = 0;
	        if (Math.abs(this.w) > 1) {
	          // actually, if this.w < -1, rotation will be NaN...
	          rot.w = 0;
	        } else {
	          // I don't know why it needs to be double but I make it the same as SceneKit
	          rot.w = Math.acos(this.w) * 2.0;
	        }
	      } else {
	        var quat = this.normalize();
	        var r = 1.0 / Math.sqrt(quat.x * quat.x + quat.y * quat.y + quat.z * quat.z);
	        rot.x = quat.x * r;
	        rot.y = quat.y * r;
	        rot.z = quat.z * r;

	        var w = Math.acos(quat.w);
	        if (isNaN(w)) {
	          rot.w = 0;
	        } else {
	          // I don't know why it needs to be double but I make it the same as SceneKit
	          rot.w = w * 2.0;
	        }
	      }
	      return rot;
	    }

	    /**
	     * @access public
	     * @returns {SCNVector3} -
	     */

	  }, {
	    key: 'rotationToEulerAngles',
	    value: function rotationToEulerAngles() {
	      var euler = new _SCNVector2.default();
	      var sinW = Math.sin(this.w);
	      var cosWR = 1.0 - Math.cos(this.w);
	      var len2 = this.x * this.x + this.y * this.y + this.z * this.z;
	      if (len2 === 0) {
	        return euler;
	      }
	      var r = 1.0 / Math.sqrt(len2);
	      var x = this.x * r;
	      var y = this.y * r;
	      var z = this.z * r;
	      var s = y * sinW - x * z * cosWR;

	      //console.log(`s: ${s}`)
	      //const threshold = 0.998
	      var threshold = 0.999999;
	      if (s > threshold) {
	        // TODO: check SceneKit implementation
	        euler.x = 0;
	        euler.y = -Math.PI * 0.5;
	        euler.z = -2.0 * Math.atan2(z * Math.sin(this.w * 0.5), Math.cos(this.w * 0.5));
	      } else if (s < -threshold) {
	        // TODO: check SceneKit implementation
	        euler.x = 0;
	        euler.y = Math.PI * 0.5;
	        euler.z = 2.0 * Math.atan2(z * Math.sin(this.w * 0.5), Math.cos(this.w * 0.5));
	      } else {
	        euler.x = Math.atan2(x * sinW + y * z * cosWR, 1 - (y * y + x * x) * cosWR);
	        euler.y = Math.asin(s);
	        euler.z = Math.atan2(z * sinW + x * y * cosWR, 1 - (z * z + y * y) * cosWR);
	      }

	      return euler;
	    }

	    /**
	     * @access public
	     * @retruns {SCNVector3} -
	     */

	  }, {
	    key: 'quatToEulerAngles',
	    value: function quatToEulerAngles() {
	      return this.quatToRotation().rotationToEulerAngles();
	    }

	    /**
	     * @access public
	     * @returns {number[]} -
	     */

	  }, {
	    key: 'floatArray',
	    value: function floatArray() {
	      return [this.x, this.y, this.z, this.w];
	    }

	    /**
	     * @access public
	     * @returns {Float32Array} -
	     */

	  }, {
	    key: 'float32Array',
	    value: function float32Array() {
	      return new Float32Array([this.x, this.y, this.z, this.w]);
	    }

	    /**
	     * @access private
	     * @returns {Ammo.btVector4}
	     * @desc call Ammo.destroy(vec) after using it.
	     */

	  }, {
	    key: '_createBtVector4',
	    value: function _createBtVector4() {}
	    //return new Ammo.btVector4(this.x, this.y, this.z, this.w)


	    /**
	     * @access private
	     * @returns {Ammo.btQuaternion}
	     * @desc call Ammo.destroy(quat) after using it.
	     */

	  }, {
	    key: '_createBtQuaternion',
	    value: function _createBtQuaternion() {
	      //return new Ammo.btQuaternion(this.x, this.y, this.z, this.w)
	    }
	  }], [{
	    key: '_initWithData',
	    value: function _initWithData(data) {
	      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
	      var bigEndian = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

	      var instance = new SCNVector4();
	      if (bigEndian) {
	        instance.x = data.readFloatBE(offset + 0);
	        instance.y = data.readFloatBE(offset + 4);
	        instance.z = data.readFloatBE(offset + 8);
	        instance.w = data.readFloatBE(offset + 12);
	      } else {
	        instance.x = data.readFloatLE(offset + 0);
	        instance.y = data.readFloatLE(offset + 4);
	        instance.z = data.readFloatLE(offset + 8);
	        instance.w = data.readFloatLE(offset + 12);
	      }
	      return instance;
	    }
	  }]);

	  return SCNVector4;
	}();

	exports.default = SCNVector4;

/***/ },
/* 46 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _SCNVector = __webpack_require__(44);

	var _SCNVector2 = _interopRequireDefault(_SCNVector);

	var _SCNVector3 = __webpack_require__(45);

	var _SCNVector4 = _interopRequireDefault(_SCNVector3);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var _epsilon = 0.0000001;

	/**
	 * A representation of a 4 x 4 matrix.
	 * @access public
	 * @see https://developer.apple.com/reference/scenekit/scnmatrix4
	 */

	var SCNMatrix4 = function () {

	  // Initializers

	  /**
	   * 
	   * @access public
	   * @construtor
	   * @param {number[][]} [m = null] - 
	   * @see https://developer.apple.com/reference/quartzcore/catransform3d/1524036-init
	   */
	  function SCNMatrix4() {
	    var m = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

	    _classCallCheck(this, SCNMatrix4);

	    // Instance Properties

	    /** @type {number} */
	    this.m11 = 0;
	    /** @type {number} */
	    this.m12 = 0;
	    /** @type {number} */
	    this.m13 = 0;
	    /** @type {number} */
	    this.m14 = 0;
	    /** @type {number} */
	    this.m21 = 0;
	    /** @type {number} */
	    this.m22 = 0;
	    /** @type {number} */
	    this.m23 = 0;
	    /** @type {number} */
	    this.m24 = 0;
	    /** @type {number} */
	    this.m31 = 0;
	    /** @type {number} */
	    this.m32 = 0;
	    /** @type {number} */
	    this.m33 = 0;
	    /** @type {number} */
	    this.m34 = 0;
	    /** @type {number} */
	    this.m41 = 0;
	    /** @type {number} */
	    this.m42 = 0;
	    /** @type {number} */
	    this.m43 = 0;
	    /** @type {number} */
	    this.m44 = 0;

	    if (m instanceof SCNMatrix4) {
	      this.m11 = m.m11;
	      this.m12 = m.m12;
	      this.m13 = m.m13;
	      this.m14 = m.m14;
	      this.m21 = m.m21;
	      this.m22 = m.m22;
	      this.m23 = m.m23;
	      this.m24 = m.m24;
	      this.m31 = m.m31;
	      this.m32 = m.m32;
	      this.m33 = m.m33;
	      this.m34 = m.m34;
	      this.m41 = m.m41;
	      this.m42 = m.m42;
	      this.m43 = m.m43;
	      this.m44 = m.m44;
	    } else if (arguments.length >= 16) {
	      this.m11 = arguments[0];
	      this.m12 = arguments[1];
	      this.m13 = arguments[2];
	      this.m14 = arguments[3];
	      this.m21 = arguments[4];
	      this.m22 = arguments[5];
	      this.m23 = arguments[6];
	      this.m24 = arguments[7];
	      this.m31 = arguments[8];
	      this.m32 = arguments[9];
	      this.m33 = arguments[10];
	      this.m34 = arguments[11];
	      this.m41 = arguments[12];
	      this.m42 = arguments[13];
	      this.m43 = arguments[14];
	      this.m44 = arguments[15];
	    } else if (m !== null) {
	      // TODO: type check
	      this.m11 = m[0][0];
	      this.m12 = m[0][1];
	      this.m13 = m[0][2];
	      this.m14 = m[0][3];
	      this.m21 = m[1][0];
	      this.m22 = m[1][1];
	      this.m23 = m[1][2];
	      this.m24 = m[1][3];
	      this.m31 = m[2][0];
	      this.m32 = m[2][1];
	      this.m33 = m[2][2];
	      this.m34 = m[2][3];
	      this.m41 = m[3][0];
	      this.m42 = m[3][1];
	      this.m43 = m[3][2];
	      this.m44 = m[3][3];
	    }
	  }

	  /**
	   * @access private
	   * @param {Buffer} data -
	   * @param {number} [offset = 0] -
	   * @returns {SCNMatrix4}
	   */


	  _createClass(SCNMatrix4, [{
	    key: '_copy',
	    value: function _copy() {
	      return new SCNMatrix4(this);
	    }

	    // extensions

	    /**
	     * @access public
	     * @param {SCNMatrix4} m -
	     * @returns {SCNMatrix4} - 
	     */

	  }, {
	    key: 'add',
	    value: function add(m) {
	      var r = new SCNMatrix4();
	      r.m11 = this.m11 + m.m11;
	      r.m12 = this.m12 + m.m12;
	      r.m13 = this.m13 + m.m13;
	      r.m14 = this.m14 + m.m14;
	      r.m21 = this.m21 + m.m21;
	      r.m22 = this.m22 + m.m22;
	      r.m23 = this.m23 + m.m23;
	      r.m24 = this.m24 + m.m24;
	      r.m31 = this.m31 + m.m31;
	      r.m32 = this.m32 + m.m32;
	      r.m33 = this.m33 + m.m33;
	      r.m34 = this.m34 + m.m34;
	      r.m41 = this.m41 + m.m41;
	      r.m42 = this.m42 + m.m42;
	      r.m43 = this.m43 + m.m43;
	      r.m44 = this.m44 + m.m44;
	      return r;
	    }

	    /**
	     * @access public
	     * @param {number} t -
	     * @returns {SCNMatrix4} - 
	     */

	  }, {
	    key: 'mul',
	    value: function mul(t) {
	      var r = new SCNMatrix4();
	      r.m11 = this.m11 * t;
	      r.m12 = this.mj2 * t;
	      r.m13 = this.m13 * t;
	      r.m14 = this.m14 * t;
	      r.m21 = this.m21 * t;
	      r.m22 = this.m22 * t;
	      r.m23 = this.m23 * t;
	      r.m24 = this.m24 * t;
	      r.m31 = this.m31 * t;
	      r.m32 = this.m32 * t;
	      r.m33 = this.m33 * t;
	      r.m34 = this.m34 * t;
	      r.m41 = this.m41 * t;
	      r.m42 = this.m42 * t;
	      r.m43 = this.m43 * t;
	      r.m44 = this.m44 * t;
	      return r;
	    }

	    /**
	     * @access public
	     * @param {SCNMatrix4} m -
	     * @returns {SCNMatrix4} - 
	     */

	  }, {
	    key: 'mult',
	    value: function mult(m) {
	      var r = new SCNMatrix4();
	      r.m11 = this.m11 * m.m11 + this.m12 * m.m21 + this.m13 * m.m31 + this.m14 * m.m41;
	      r.m12 = this.m11 * m.m12 + this.m12 * m.m22 + this.m13 * m.m32 + this.m14 * m.m42;
	      r.m13 = this.m11 * m.m13 + this.m12 * m.m23 + this.m13 * m.m33 + this.m14 * m.m43;
	      r.m14 = this.m11 * m.m14 + this.m12 * m.m24 + this.m13 * m.m34 + this.m14 * m.m44;
	      r.m21 = this.m21 * m.m11 + this.m22 * m.m21 + this.m23 * m.m31 + this.m24 * m.m41;
	      r.m22 = this.m21 * m.m12 + this.m22 * m.m22 + this.m23 * m.m32 + this.m24 * m.m42;
	      r.m23 = this.m21 * m.m13 + this.m22 * m.m23 + this.m23 * m.m33 + this.m24 * m.m43;
	      r.m24 = this.m21 * m.m14 + this.m22 * m.m24 + this.m23 * m.m34 + this.m24 * m.m44;
	      r.m31 = this.m31 * m.m11 + this.m32 * m.m21 + this.m33 * m.m31 + this.m34 * m.m41;
	      r.m32 = this.m31 * m.m12 + this.m32 * m.m22 + this.m33 * m.m32 + this.m34 * m.m42;
	      r.m33 = this.m31 * m.m13 + this.m32 * m.m23 + this.m33 * m.m33 + this.m34 * m.m43;
	      r.m34 = this.m31 * m.m14 + this.m32 * m.m24 + this.m33 * m.m34 + this.m34 * m.m44;
	      r.m41 = this.m41 * m.m11 + this.m42 * m.m21 + this.m43 * m.m31 + this.m44 * m.m41;
	      r.m42 = this.m41 * m.m12 + this.m42 * m.m22 + this.m43 * m.m32 + this.m44 * m.m42;
	      r.m43 = this.m41 * m.m13 + this.m42 * m.m23 + this.m43 * m.m33 + this.m44 * m.m43;
	      r.m44 = this.m41 * m.m14 + this.m42 * m.m24 + this.m43 * m.m34 + this.m44 * m.m44;
	      return r;
	    }

	    /**
	     * @access public
	     * @param {SCNMatrix4} m -
	     * @param {number} rate -
	     * @returns {SCNMatrix4} - 
	     */

	  }, {
	    key: 'lerp',
	    value: function lerp(m, rate) {
	      var r = new SCNMatrix4();
	      r.m11 = this.m11 + rate * (this.m11 - m.m11);
	      r.m12 = this.m12 + rate * (this.m12 - m.m12);
	      r.m13 = this.m13 + rate * (this.m13 - m.m13);
	      r.m14 = this.m14 + rate * (this.m14 - m.m14);
	      r.m21 = this.m21 + rate * (this.m21 - m.m21);
	      r.m22 = this.m22 + rate * (this.m22 - m.m22);
	      r.m23 = this.m23 + rate * (this.m23 - m.m23);
	      r.m24 = this.m24 + rate * (this.m24 - m.m24);
	      r.m31 = this.m31 + rate * (this.m31 - m.m31);
	      r.m32 = this.m32 + rate * (this.m32 - m.m32);
	      r.m33 = this.m33 + rate * (this.m33 - m.m33);
	      r.m34 = this.m34 + rate * (this.m34 - m.m34);
	      r.m41 = this.m41 + rate * (this.m41 - m.m41);
	      r.m42 = this.m42 + rate * (this.m42 - m.m42);
	      r.m43 = this.m43 + rate * (this.m43 - m.m43);
	      r.m44 = this.m44 + rate * (this.m44 - m.m44);
	      return r;
	    }

	    /**
	     * @access public
	     * @returns {SCNVector4} -
	     */

	  }, {
	    key: 'quaternion',
	    value: function quaternion() {
	      var r = new _SCNVector4.default();
	      r.x = this.m32 - this.m23;
	      r.y = this.m13 - this.m31;
	      r.z = this.m21 - this.m12;
	      r.w = Math.acos((this.m11 + this.m22 + this.m33 - 1) * 0.5);
	      return r;
	    }

	    /**
	     * @access public
	     * @returns {SCNMatrix4} -
	     */

	  }, {
	    key: 'invert',
	    value: function invert() {
	      var mat = SCNMatrix4._identity();
	      var tmp = new SCNMatrix4(this);

	      var buf = 0;
	      var w1 = Math.abs(tmp.m11);
	      var w2 = Math.abs(tmp.m21);
	      var w3 = Math.abs(tmp.m31);
	      var w4 = Math.abs(tmp.m41);
	      var max = w1 > w2 ? w1 : w2;
	      if (max < w3) max = w3;

	      // 1
	      if (max < w4) {
	        buf = 1.0 / tmp.m41;
	        w1 = tmp.m11;
	        w2 = tmp.m12;
	        w3 = tmp.m13;
	        w4 = tmp.m14;
	        tmp.m12 = tmp.m42 * buf;
	        tmp.m13 = tmp.m43 * buf;
	        tmp.m14 = tmp.m44 * buf;
	        tmp.m41 = w1;
	        tmp.m42 = w2;
	        tmp.m43 = w3;
	        tmp.m44 = w4;
	        mat.m11 = 0.0;
	        mat.m14 = buf;
	        mat.m41 = 1.0;
	        mat.m44 = 0.0;
	      } else if (max === w1) {
	        buf = 1.0 / tmp.m11;
	        tmp.m12 *= buf;
	        tmp.m13 *= buf;
	        tmp.m14 *= buf;
	        mat.m11 = buf;
	      } else if (max === w2) {
	        buf = 1.0 / tmp.m21;
	        w1 = tmp.m11;
	        w2 = tmp.m12;
	        w3 = tmp.m13;
	        w4 = tmp.m14;
	        tmp.m12 = tmp.m22 * buf;
	        tmp.m13 = tmp.m23 * buf;
	        tmp.m14 = tmp.m24 * buf;
	        tmp.m21 = w1;
	        tmp.m22 = w2;
	        tmp.m23 = w3;
	        tmp.m24 = w4;
	        mat.m11 = 0.0;
	        mat.m12 = buf;
	        mat.m21 = 1.0;
	        mat.m22 = 0.0;
	      } else {
	        buf = 1.0 / tmp.m31;
	        w1 = tmp.m11;
	        w2 = tmp.m12;
	        w3 = tmp.m13;
	        w4 = tmp.m14;
	        tmp.m12 = tmp.m32 * buf;
	        tmp.m13 = tmp.m33 * buf;
	        tmp.m14 = tmp.m34 * buf;
	        tmp.m31 = w1;
	        tmp.m32 = w2;
	        tmp.m33 = w3;
	        tmp.m34 = w4;
	        mat.m11 = 0.0;
	        mat.m13 = buf;
	        mat.m31 = 1.0;
	        mat.m33 = 0.0;
	      }

	      buf = tmp.m21;
	      tmp.m22 -= tmp.m12 * buf;
	      tmp.m23 -= tmp.m13 * buf;
	      tmp.m24 -= tmp.m14 * buf;
	      mat.m21 -= mat.m11 * buf;
	      mat.m22 -= mat.m12 * buf;
	      mat.m23 -= mat.m13 * buf;
	      mat.m24 -= mat.m14 * buf;

	      buf = tmp.m31;
	      tmp.m32 -= tmp.m12 * buf;
	      tmp.m33 -= tmp.m13 * buf;
	      tmp.m34 -= tmp.m14 * buf;
	      mat.m31 -= mat.m11 * buf;
	      mat.m32 -= mat.m12 * buf;
	      mat.m33 -= mat.m13 * buf;
	      mat.m34 -= mat.m14 * buf;

	      buf = tmp.m41;
	      tmp.m42 -= tmp.m12 * buf;
	      tmp.m43 -= tmp.m13 * buf;
	      tmp.m44 -= tmp.m14 * buf;
	      mat.m41 -= mat.m11 * buf;
	      mat.m42 -= mat.m12 * buf;
	      mat.m43 -= mat.m13 * buf;
	      mat.m44 -= mat.m14 * buf;

	      // 2
	      w2 = Math.abs(tmp.m22);
	      w3 = Math.abs(tmp.m32);
	      w4 = Math.abs(tmp.m42);
	      max = w2 > w3 ? w2 : w3;
	      if (max < w4) {
	        buf = 1.0 / tmp.m42;
	        w2 = tmp.m22;
	        w3 = tmp.m23;
	        w4 = tmp.m24;
	        tmp.m23 = tmp.m43 * buf;
	        tmp.m24 = tmp.m44 * buf;
	        tmp.m42 = w2;
	        tmp.m43 = w3;
	        tmp.m44 = w4;
	        w1 = mat.m21;
	        w2 = mat.m22;
	        w3 = mat.m23;
	        w4 = mat.m24;
	        mat.m21 = mat.m41 * buf;
	        mat.m22 = mat.m42 * buf;
	        mat.m23 = mat.m43 * buf;
	        mat.m24 = mat.m44 * buf;
	        mat.m41 = w1;
	        mat.m42 = w2;
	        mat.m43 = w3;
	        mat.m44 = w4;
	      } else if (w2 > w3) {
	        buf = 1.0 / tmp.m22;
	        tmp.m23 *= buf;
	        tmp.m24 *= buf;
	        mat.m21 *= buf;
	        mat.m22 *= buf;
	        mat.m23 *= buf;
	        mat.m24 *= buf;
	      } else {
	        buf = 1.0 / tmp.m32;
	        w2 = tmp.m22;
	        w3 = tmp.m23;
	        w4 = tmp.m24;
	        tmp.m23 = tmp.m33 * buf;
	        tmp.m24 = tmp.m34 * buf;
	        tmp.m32 = w2;
	        tmp.m33 = w3;
	        tmp.m34 = w4;
	        w1 = mat.m21;
	        w2 = mat.m22;
	        w3 = mat.m23;
	        w4 = mat.m24;
	        mat.m21 = mat.m31 * buf;
	        mat.m22 = mat.m32 * buf;
	        mat.m23 = mat.m33 * buf;
	        mat.m24 = mat.m34 * buf;
	        mat.m31 = w1;
	        mat.m32 = w2;
	        mat.m33 = w3;
	        mat.m34 = w4;
	      }

	      buf = tmp.m12;
	      tmp.m13 -= tmp.m23 * buf;
	      tmp.m14 -= tmp.m24 * buf;
	      mat.m11 -= mat.m21 * buf;
	      mat.m12 -= mat.m22 * buf;
	      mat.m13 -= mat.m23 * buf;
	      mat.m14 -= mat.m24 * buf;

	      buf = tmp.m32;
	      tmp.m33 -= tmp.m23 * buf;
	      tmp.m34 -= tmp.m24 * buf;
	      mat.m31 -= mat.m21 * buf;
	      mat.m32 -= mat.m22 * buf;
	      mat.m33 -= mat.m23 * buf;
	      mat.m34 -= mat.m24 * buf;

	      buf = tmp.m42;
	      tmp.m43 -= tmp.m23 * buf;
	      tmp.m44 -= tmp.m24 * buf;
	      mat.m41 -= mat.m21 * buf;
	      mat.m42 -= mat.m22 * buf;
	      mat.m43 -= mat.m23 * buf;
	      mat.m44 -= mat.m24 * buf;

	      // 3
	      if (Math.abs(tmp.m33) > Math.abs(tmp.m43)) {
	        buf = 1.0 / tmp.m33;
	        tmp.m34 *= buf;
	        mat.m31 *= buf;
	        mat.m32 *= buf;
	        mat.m33 *= buf;
	        mat.m34 *= buf;
	      } else {
	        buf = 1.0 / tmp.m43;
	        w3 = tmp.m33;
	        w4 = tmp.m34;
	        tmp.m34 = tmp.m44 * buf;
	        tmp.m43 = w3;
	        tmp.m44 = w4;
	        w1 = mat.m31;
	        w2 = mat.m32;
	        w3 = mat.m33;
	        w4 = mat.m34;
	        mat.m31 = mat.m41 * buf;
	        mat.m32 = mat.m42 * buf;
	        mat.m33 = mat.m43 * buf;
	        mat.m34 = mat.m44 * buf;
	        mat.m41 = w1;
	        mat.m42 = w2;
	        mat.m43 = w3;
	        mat.m44 = w4;
	      }
	      buf = tmp.m13;
	      tmp.m14 -= tmp.m34 * buf;
	      mat.m11 -= mat.m31 * buf;
	      mat.m12 -= mat.m32 * buf;
	      mat.m13 -= mat.m33 * buf;
	      mat.m14 -= mat.m34 * buf;

	      buf = tmp.m23;
	      tmp.m24 -= tmp.m34 * buf;
	      mat.m21 -= mat.m31 * buf;
	      mat.m22 -= mat.m32 * buf;
	      mat.m23 -= mat.m33 * buf;
	      mat.m24 -= mat.m34 * buf;

	      buf = tmp.m43;
	      tmp.m44 -= tmp.m34 * buf;
	      mat.m41 -= mat.m31 * buf;
	      mat.m42 -= mat.m32 * buf;
	      mat.m43 -= mat.m33 * buf;
	      mat.m44 -= mat.m34 * buf;

	      // 4
	      buf = 1.0 / tmp.m44;
	      mat.m41 *= buf;
	      mat.m42 *= buf;
	      mat.m43 *= buf;
	      mat.m44 *= buf;

	      buf = tmp.m14;
	      mat.m11 -= mat.m41 * buf;
	      mat.m12 -= mat.m42 * buf;
	      mat.m13 -= mat.m43 * buf;
	      mat.m14 -= mat.m44 * buf;

	      buf = tmp.m24;
	      mat.m21 -= mat.m41 * buf;
	      mat.m22 -= mat.m42 * buf;
	      mat.m23 -= mat.m43 * buf;
	      mat.m24 -= mat.m44 * buf;

	      buf = tmp.m34;
	      mat.m31 -= mat.m41 * buf;
	      mat.m32 -= mat.m42 * buf;
	      mat.m33 -= mat.m43 * buf;
	      mat.m34 -= mat.m44 * buf;

	      return mat;
	    }

	    /**
	     * @access public
	     * @returns {SCNMatrix4} -
	     */

	  }, {
	    key: 'transpose',
	    value: function transpose() {
	      var r = new SCNMatrix4();
	      r.m11 = this.m11;
	      r.m12 = this.m21;
	      r.m13 = this.m31;
	      r.m14 = this.m41;
	      r.m21 = this.m12;
	      r.m22 = this.m22;
	      r.m23 = this.m32;
	      r.m24 = this.m42;
	      r.m31 = this.m13;
	      r.m32 = this.m23;
	      r.m33 = this.m33;
	      r.m34 = this.m43;
	      r.m41 = this.m14;
	      r.m42 = this.m24;
	      r.m43 = this.m34;
	      r.m44 = this.m44;
	      return r;
	    }

	    /**
	     * @access public
	     * @param {number} x -
	     * @param {number} y -
	     * @param {number} z -
	     * @returns {SCNMatrix4} -
	     */

	  }, {
	    key: 'scale',
	    value: function scale(x, y, z) {
	      var m = SCNMatrix4.matrixWithScale(x, y, z);
	      return this.mult(m);
	    }

	    /**
	     * @access public
	     * @param {number} x -
	     * @param {number} y -
	     * @param {number} z -
	     * @returns {SCNMatrix4} -
	     */

	  }, {
	    key: 'rotation',


	    /**
	     * @access public
	     * @param {number} x -
	     * @param {number} y -
	     * @param {number} z -
	     * @param {number} w -
	     * @returns {SCNMatrix4} -
	     */
	    value: function rotation(x, y, z, w) {
	      if (x instanceof _SCNVector4.default) {
	        var v = x;
	        x = v.x;
	        y = v.y;
	        z = v.z;
	        w = v.w;
	      }

	      var m = SCNMatrix4.matrixWithRotation(x, y, z, w);
	      return this.mult(m);
	    }

	    /**
	     * @access public
	     * @param {number} x -
	     * @param {number} y -
	     * @param {number} z -
	     * @param {number} w -
	     * @returns {SCNMatrix4} -
	     */

	  }, {
	    key: 'translation',


	    /**
	     * @access public
	     * @param {number} x -
	     * @param {number} y -
	     * @param {number} z -
	     * @returns {SCNMatrix4} -
	     */
	    value: function translation(x, y, z) {
	      var m = SCNMatrix4.matrixWithTranslation(x, y, z);
	      return this.mult(m);
	    }

	    /**
	     * @access public
	     * @param {number} x -
	     * @param {number} y -
	     * @param {number} z -
	     * @returns {SCNMatrix4} -
	     */

	  }, {
	    key: 'equalTo',


	    /**
	     * Returns a Boolean value that indicates whether the corresponding elements of two matrices are equal.
	     * @access public
	     * @param {SCNMatrix4} m -
	     * @returns {boolean} -
	     * @desc This function performs a numeric (not bitwise) comparison of each pair of elements.
	     * @see https://developer.apple.com/reference/scenekit/1409665-scnmatrix4equaltomatrix4
	     */
	    value: function equalTo(m) {
	      if (!(m instanceof SCNMatrix4)) {
	        return false;
	      }

	      return Math.abs(this.m11 - m.m11) < _epsilon && Math.abs(this.m12 - m.m12) < _epsilon && Math.abs(this.m13 - m.m13) < _epsilon && Math.abs(this.m14 - m.m14) < _epsilon && Math.abs(this.m21 - m.m21) < _epsilon && Math.abs(this.m22 - m.m22) < _epsilon && Math.abs(this.m23 - m.m23) < _epsilon && Math.abs(this.m24 - m.m24) < _epsilon && Math.abs(this.m31 - m.m31) < _epsilon && Math.abs(this.m32 - m.m32) < _epsilon && Math.abs(this.m33 - m.m33) < _epsilon && Math.abs(this.m34 - m.m34) < _epsilon && Math.abs(this.m41 - m.m41) < _epsilon && Math.abs(this.m42 - m.m42) < _epsilon && Math.abs(this.m43 - m.m43) < _epsilon && Math.abs(this.m44 - m.m44) < _epsilon;
	    }

	    /**
	     * Returns a Boolean value that indicates whether the matrix is equal to the identity matrix.
	     * @access public
	     * @returns {boolean} - 
	     * @see https://developer.apple.com/reference/scenekit/1409715-scnmatrix4isidentity
	     */

	  }, {
	    key: 'isIdentity',
	    value: function isIdentity() {
	      return this.equalTo(SCNMatrix4._identity());
	    }

	    /**
	     * @access public
	     * @returns {SCNVector3} -
	     */

	  }, {
	    key: 'getScale',
	    value: function getScale() {
	      var det = this.m11 * this.m22 * this.m33 + this.m12 * this.m23 * this.m31 + this.m13 * this.m21 * this.m32 - this.m11 * this.m23 * this.m32 - this.m12 * this.m21 * this.m33 - this.m13 * this.m22 * this.m31;
	      var sign = det > 0 ? 1 : -1;
	      var r = sign / this.m44;
	      var sx = new _SCNVector2.default(this.m11, this.m12, this.m13);
	      var sy = new _SCNVector2.default(this.m21, this.m22, this.m23);
	      var sz = new _SCNVector2.default(this.m31, this.m32, this.m33);
	      return new _SCNVector2.default(sx.length() * r, sy.length() * r, sz.length() * r);
	    }

	    /**
	     * @access public
	     * @returns {SCNVector3} -
	     */

	  }, {
	    key: 'getTranslation',
	    value: function getTranslation() {
	      return new _SCNVector2.default(this.m41 / this.m44, this.m42 / this.m44, this.m43 / this.m44);
	    }

	    /**
	     * @access public
	     * @returns {SCNVector4} -
	     */

	  }, {
	    key: 'getRotation',
	    value: function getRotation() {
	      var e = [];
	      var scale = this.getScale().mul(this.m44);
	      var v = new _SCNVector4.default();
	      var n1 = new _SCNVector2.default(this.m11, this.m12, this.m13).mul(1.0 / scale.x);
	      var n2 = new _SCNVector2.default(this.m21, this.m22, this.m23).mul(1.0 / scale.y);
	      var n3 = new _SCNVector2.default(this.m31, this.m32, this.m33).mul(1.0 / scale.z);
	      e[0] = n1.x - n2.y - n3.z + 1.0;
	      e[1] = -n1.x + n2.y - n3.z + 1.0;
	      e[2] = -n1.x - n2.y + n3.z + 1.0;
	      e[3] = n1.x + n2.y + n3.z + 1.0;
	      var maxIndex = 0;
	      for (var i = 1; i < 4; i++) {
	        if (e[i] > e[maxIndex]) {
	          maxIndex = i;
	        }
	      }
	      if (e[maxIndex] < 0) {
	        throw new Error('something is wrong...');
	      }
	      var d = Math.sqrt(e[maxIndex]) * 0.5;
	      var r = 0.25 / d;

	      //console.log(`n1: ${n1.x}, ${n1.y}, ${n1.z}`)
	      //console.log(`n2: ${n2.x}, ${n2.y}, ${n2.z}`)
	      //console.log(`n3: ${n3.x}, ${n3.y}, ${n3.z}`)
	      //console.log(`d: ${d}, r: ${r}`)
	      switch (maxIndex) {
	        case 0:
	          v.x = d;
	          v.y = (n1.y + n2.x) * r;
	          v.z = (n3.x + n1.z) * r;
	          v.w = (n2.z - n3.y) * r;
	          break;
	        case 1:
	          v.x = (n1.y + n2.x) * r;
	          v.y = d;
	          v.z = (n2.z + n3.y) * r;
	          v.w = (n3.x - n1.z) * r;
	          break;
	        case 2:
	          v.x = (n3.x + n1.z) * r;
	          v.y = (n2.z + n3.y) * r;
	          v.z = d;
	          v.w = (n1.y - n2.x) * r;
	          break;
	        case 3:
	          v.x = (n2.z - n3.y) * r;
	          v.y = (n3.x - n1.z) * r;
	          v.z = (n1.y - n2.x) * r;
	          v.w = d;
	          break;
	      }
	      if (v.x === 0 && v.y === 0 && v.z === 0) {
	        v.w = 0;
	      } else {
	        var w = Math.acos(v.w);
	        if (isNaN(w)) {
	          v.w = 0;
	        } else {
	          v.w = w * 2.0;
	        }
	      }

	      return v;
	    }

	    /**
	     * @access public
	     * @returns {SCNVector4} -
	     */

	  }, {
	    key: 'getOrientation',
	    value: function getOrientation() {
	      return this.getRotation().rotationToQuat();
	      /*
	      const e = []
	      const scale = this.getScale().mul(this.m44)
	      const v = new SCNVector4()
	      const n1 = (new SCNVector3(this.m11, this.m12, this.m13)).mul(1.0 / scale.x)
	      const n2 = (new SCNVector3(this.m21, this.m22, this.m23)).mul(1.0 / scale.y)
	      const n3 = (new SCNVector3(this.m31, this.m32, this.m33)).mul(1.0 / scale.z)
	      e[0] = n1.x - n2.y - n3.z + 1.0
	      e[1] = -n1.x + n2.y - n3.z + 1.0
	      e[2] = -n1.x - n2.y + n3.z + 1.0
	      e[3] = n1.x + n2.y + n3.z + 1.0
	      let maxIndex = 0
	      for(let i=1; i<4; i++){
	        if(e[i] > e[maxIndex]){
	          maxIndex = i
	        }
	      }
	      console.log(`maxIndex: ${maxIndex} => ${e[maxIndex]}`)
	      if(e[maxIndex] < 0){
	        throw new Error('something is wrong...')
	      }
	      const d = Math.sqrt(e[maxIndex]) * 0.5
	      const r = 0.25 / d
	       //console.log(`n1: ${n1.x}, ${n1.y}, ${n1.z}`)
	      //console.log(`n2: ${n2.x}, ${n2.y}, ${n2.z}`)
	      //console.log(`n3: ${n3.x}, ${n3.y}, ${n3.z}`)
	      //console.log(`d: ${d}, r: ${r}`)
	      switch(maxIndex){
	        case 0:
	          v.x = d
	          v.y = (n1.y + n2.x) * r
	          v.z = (n3.x + n1.z) * r
	          v.w = (n2.z - n3.y) * r
	          break
	        case 1:
	          v.x = (n1.y + n2.x) * r
	          v.y = d
	          v.z = (n2.z + n3.y) * r
	          v.w = (n3.x - n1.z) * r
	          break
	        case 2:
	          v.x = (n3.x + n1.z) * r
	          v.y = (n2.z + n3.y) * r
	          v.z = d
	          v.w = (n1.y - n2.x) * r
	          break
	        case 3:
	          v.x = (n2.z - n3.y) * r
	          v.y = (n3.x - n1.z) * r
	          v.z = (n1.y - n2.x) * r
	          v.w = d
	          break
	      }
	      const len = 1.0 / Math.sqrt(v.x * v.x + v.y * v.y + v.z * v.z)
	      v.x *= len
	      v.y *= len
	      v.z *= len
	       return v
	      */
	    }

	    /**
	     * @access public
	     * @returns {number[]} -
	     */

	  }, {
	    key: 'floatArray',
	    value: function floatArray() {
	      return [this.m11, this.m12, this.m13, this.m14, this.m21, this.m22, this.m23, this.m24, this.m31, this.m32, this.m33, this.m34, this.m41, this.m42, this.m43, this.m44];
	    }

	    /**
	     * @access public
	     * @returns {Float32Array} -
	     */

	  }, {
	    key: 'float32Array',
	    value: function float32Array() {
	      return new Float32Array([this.m11, this.m12, this.m13, this.m14, this.m21, this.m22, this.m23, this.m24, this.m31, this.m32, this.m33, this.m34, this.m41, this.m42, this.m43, this.m44]);
	    }

	    /**
	     * @access public
	     * @returns {number[]} -
	     */

	  }, {
	    key: 'floatArray3x4f',
	    value: function floatArray3x4f() {
	      return [this.m11, this.m21, this.m31, this.m41, this.m12, this.m22, this.m32, this.m42, this.m13, this.m23, this.m33, this.m43];
	    }

	    /**
	     * @access public
	     * @returns {Float32Array} -
	     */

	  }, {
	    key: 'float32Array3x4f',
	    value: function float32Array3x4f() {
	      return new Float32Array([this.m11, this.m21, this.m31, this.m41, this.m12, this.m22, this.m32, this.m42, this.m13, this.m23, this.m33, this.m43]);
	    }
	  }], [{
	    key: '_initWithData',
	    value: function _initWithData(data) {
	      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

	      var instance = new SCNMatrix4();
	      instance.m11 = data.readFloatLE(offset + 0);
	      instance.m12 = data.readFloatLE(offset + 4);
	      instance.m13 = data.readFloatLE(offset + 8);
	      instance.m14 = data.readFloatLE(offset + 12);
	      instance.m21 = data.readFloatLE(offset + 16);
	      instance.m22 = data.readFloatLE(offset + 20);
	      instance.m23 = data.readFloatLE(offset + 24);
	      instance.m24 = data.readFloatLE(offset + 28);
	      instance.m31 = data.readFloatLE(offset + 32);
	      instance.m32 = data.readFloatLE(offset + 36);
	      instance.m33 = data.readFloatLE(offset + 40);
	      instance.m34 = data.readFloatLE(offset + 44);
	      instance.m41 = data.readFloatLE(offset + 48);
	      instance.m42 = data.readFloatLE(offset + 52);
	      instance.m43 = data.readFloatLE(offset + 56);
	      instance.m44 = data.readFloatLE(offset + 60);
	      return instance;
	    }
	  }, {
	    key: 'matrixWithScale',
	    value: function matrixWithScale(x, y, z) {
	      var _x = x;
	      var _y = y;
	      var _z = z;
	      if (x instanceof _SCNVector2.default) {
	        var v = x;
	        _x = v.x;
	        _y = v.y;
	        _z = v.z;
	      }

	      //const m = new SCNMatrix4()
	      var m = SCNMatrix4._identity();
	      m.m11 = _x;
	      m.m22 = _y;
	      m.m33 = _z;
	      return m;
	    }
	  }, {
	    key: 'matrixWithRotation',
	    value: function matrixWithRotation(x, y, z, w) {
	      if (x instanceof _SCNVector4.default) {
	        var _v = x;
	        x = _v.x;
	        y = _v.y;
	        z = _v.z;
	        w = _v.w;
	      }

	      var c = Math.cos(w);
	      var s = Math.sin(w);
	      var v = new _SCNVector2.default(x, y, z).normalize();
	      var m = SCNMatrix4._identity();

	      var nx = v.x;
	      var ny = v.y;
	      var nz = v.z;

	      m.m11 = nx * nx * (1.0 - c) + c;
	      m.m12 = ny * nx * (1.0 - c) + nz * s;
	      m.m13 = nz * nx * (1.0 - c) - ny * s;
	      m.m14 = 0.0;
	      m.m21 = nx * ny * (1.0 - c) - nz * s;
	      m.m22 = ny * ny * (1.0 - c) + c;
	      m.m23 = nz * ny * (1.0 - c) + nx * s;
	      m.m24 = 0.0;
	      m.m31 = nx * nz * (1.0 - c) + ny * s;
	      m.m32 = ny * nz * (1.0 - c) - nx * s;
	      m.m33 = nz * nz * (1.0 - c) + c;
	      m.m34 = 0.0;
	      m.m41 = 0.0;
	      m.m42 = 0.0;
	      m.m43 = 0.0;
	      m.m44 = 1.0;

	      return m;
	    }
	  }, {
	    key: 'matrixWithTranslation',
	    value: function matrixWithTranslation(x, y, z) {
	      var _x = x;
	      var _y = y;
	      var _z = z;
	      if (x instanceof _SCNVector2.default) {
	        var v = x;
	        _x = v.x;
	        _y = v.y;
	        _z = v.z;
	      }

	      //const m = new SCNMatrix4()
	      var m = SCNMatrix4._identity();
	      m.m41 = _x;
	      m.m42 = _y;
	      m.m43 = _z;
	      return m;
	    }
	  }, {
	    key: '_identity',
	    value: function _identity() {
	      return new SCNMatrix4(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
	    }
	  }]);

	  return SCNMatrix4;
	}();

	exports.default = SCNMatrix4;

/***/ },
/* 47 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * An interface that allows objects to respond to actions triggered by a CALayer.
	 * @interface
	 * @see https://developer.apple.com/reference/quartzcore/caaction
	 */

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var CAAction = function () {
	  function CAAction() {
	    _classCallCheck(this, CAAction);
	  }

	  _createClass(CAAction, [{
	    key: 'init',


	    /**
	     * constructor
	     * @access public
	     * @returns {void}
	     */
	    value: function init() {}

	    // Responding to an action

	    /**
	     * Required. Called to trigger the action specified by the identifier.
	     * @access public
	     * @param {string} event - 
	     * @param {Object} anObject - The layer on which the action should occur.
	     * @param {?Map<AnyHashable, Object>} dict - A dictionary containing parameters associated with this event. May be nil.
	     * @returns {void}
	     * @see https://developer.apple.com/reference/quartzcore/caaction/1410806-run
	     */

	  }, {
	    key: 'runForKeyObjectArguments',
	    value: function runForKeyObjectArguments(event, anObject, dict) {}
	  }]);

	  return CAAction;
	}();

	exports.default = CAAction;

/***/ },
/* 48 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

	var _constants = __webpack_require__(49);

	var Constants = _interopRequireWildcard(_constants);

	var _NSObject2 = __webpack_require__(2);

	var _NSObject3 = _interopRequireDefault(_NSObject2);

	var _CAAction = __webpack_require__(47);

	var _CAAction2 = _interopRequireDefault(_CAAction);

	var _CAMediaTiming = __webpack_require__(50);

	var _CAMediaTiming2 = _interopRequireDefault(_CAMediaTiming);

	var _CAMediaTimingFunction = __webpack_require__(51);

	var _CAMediaTimingFunction2 = _interopRequireDefault(_CAMediaTimingFunction);

	var _CAAnimationDelegate = __webpack_require__(52);

	var _CAAnimationDelegate2 = _interopRequireDefault(_CAAnimationDelegate);

	var _SCNAnimationEvent = __webpack_require__(53);

	var _SCNAnimationEvent2 = _interopRequireDefault(_SCNAnimationEvent);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * The abstract superclass for Core Animation animations. 
	 * @access public
	 * @extends {NSObject}
	 * @implements {CAAction}
	 * @implements {CAMediaTiming}
	 * @see https://developer.apple.com/reference/quartzcore/caanimation
	 */
	var CAAnimation = function (_NSObject) {
	  _inherits(CAAnimation, _NSObject);

	  /**
	   * constructor
	   * @access public
	   * @constructor
	   */
	  function CAAnimation() {
	    _classCallCheck(this, CAAnimation);

	    // Animation attributes

	    /**
	     * Determines if the animation is removed from the target layers animations upon completion.
	     * @type {boolean}
	     * @see https://developer.apple.com/reference/quartzcore/caanimation/1412458-isremovedoncompletion
	     */
	    var _this = _possibleConstructorReturn(this, (CAAnimation.__proto__ || Object.getPrototypeOf(CAAnimation)).call(this));

	    _this.isRemovedOnCompletion = true;

	    /**
	     * An optional timing function defining the pacing of the animation.
	     * @type {?CAMediaTimingFunction}
	     * @see https://developer.apple.com/reference/quartzcore/caanimation/1412456-timingfunction
	     */
	    _this.timingFunction = null;

	    // Getting and setting the delegate

	    /**
	     * Specifies the receivers delegate object.
	     * @type {?CAAnimationDelegate}
	     * @see https://developer.apple.com/reference/quartzcore/caanimation/1412490-delegate
	     */
	    _this.delegate = null;

	    // Controlling SceneKit Animation Timing

	    /**
	     * For animations attached to SceneKit objects, a Boolean value that determines whether the animation is evaluated using the scene time or the system time.
	     * @type {boolean}
	     * @see https://developer.apple.com/reference/quartzcore/caanimation/1523819-usesscenetimebase
	     */
	    _this.usesSceneTimeBase = false;

	    // Fading Between SceneKit Animations

	    /**
	     * For animations attached to SceneKit objects, the duration for transitioning into the animations effect as it beins.
	     * @type {number}
	     * @see https://developer.apple.com/reference/quartzcore/caanimation/1523370-fadeinduration
	     */
	    _this.fadeInDuration = 0;

	    /**
	     * For animations attached to SceneKit objects, the duration for transitioning out of the animations effect as it ends.
	     * @type {number}
	     * @see https://developer.apple.com/reference/quartzcore/caanimation/1522959-fadeoutduration
	     */
	    _this.fadeOutDuration = 0;

	    // Attaching SceneKit Animation Events

	    /**
	     * For animations attached to SceneKit objects, a list of events attached to an animation.
	     * @type {?SCNAnimationEvent[]}
	     * @see https://developer.apple.com/reference/quartzcore/caanimation/1523940-animationevents
	     */
	    _this.animationEvents = null;

	    ///////////////////
	    // CAMediaTiming //
	    ///////////////////

	    // Animation Start Time

	    /**
	     * Required. Specifies the begin time of the receiver in relation to its parent object, if applicable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/quartzcore/camediatiming/1427654-begintime
	     */
	    _this.beginTime = 0;

	    /**
	     * Required. Specifies an additional time offset in active local time.
	     * @type {number}
	     * @see https://developer.apple.com/reference/quartzcore/camediatiming/1427650-timeoffset
	     */
	    _this.timeOffset = 0;

	    // Repeating Animations

	    /**
	     * Required. Determines the number of times the animation will repeat.
	     * @type {number}
	     * @see https://developer.apple.com/reference/quartzcore/camediatiming/1427666-repeatcount
	     */
	    _this.repeatCount = 0;

	    /**
	     * Required. Determines how many seconds the animation will repeat for.
	     * @type {number}
	     * @see https://developer.apple.com/reference/quartzcore/camediatiming/1427643-repeatduration
	     */
	    _this.repeatDuration = 0;

	    // Duration and Speed

	    /**
	     * Required. Specifies the basic duration of the animation, in seconds.
	     * @type {number}
	     * @see https://developer.apple.com/reference/quartzcore/camediatiming/1427652-duration
	     */
	    _this.duration = 0;

	    /**
	     * Required. Specifies how time is mapped to receivers time space from the parent time space. 
	     * @type {number}
	     * @see https://developer.apple.com/reference/quartzcore/camediatiming/1427647-speed
	     */
	    _this.speed = 1;

	    // Playback Modes

	    /**
	     * Required. Determines if the receiver plays in the reverse upon completion.
	     * @type {boolean}
	     * @see https://developer.apple.com/reference/quartzcore/camediatiming/1427645-autoreverses
	     */
	    _this.autoreverses = false;

	    /**
	     * Required. Determines if the receivers presentation is frozen or removed once its active duration has completed.
	     * @type {string}
	     * @see https://developer.apple.com/reference/quartzcore/camediatiming/1427656-fillmode
	     */
	    _this.fillMode = Constants.kCAFillModeRemoved;

	    _this._isFinished = false;

	    _this._prevTime = null;
	    _this._animationStartTime = null;
	    return _this;
	  }

	  // Archiving properties

	  /**
	   * Specifies whether the value of the property for a given key is archived.
	   * @access public
	   * @param {string} key - The name of one of the receivers properties.
	   * @returns {boolean} - 
	   * @desc Called by the object's implementation of encodeWithCoder:. The object must implement keyed archiving. The default implementation returns true. 
	   * @see https://developer.apple.com/reference/quartzcore/caanimation/1412525-shouldarchivevalue
	   */


	  _createClass(CAAnimation, [{
	    key: 'shouldArchiveValueForKey',
	    value: function shouldArchiveValueForKey(key) {
	      return false;
	    }

	    // Providing default values for properties

	    /**
	     * Specifies the default value of the property with the specified key. 
	     * @access public
	     * @param {string} key - The name of one of the receivers properties.
	     * @returns {?Object} - 
	     * @desc If this method returns nil a suitable zero default value for the property is provided, based on the declared type of the key. For example, if key is a CGSize object, a size of (0.0,0.0) is returned. For a CGRect an empty rectangle is returned. For CGAffineTransform and CATransform3D, the appropriate identity matrix is returned. Special ConsiderationsIf key is not a known for property of the class, the result of the method is undefined.
	     * @see https://developer.apple.com/reference/quartzcore/caanimation/1412530-defaultvalue
	     */

	  }, {
	    key: 'copy',


	    /**
	     * @access public
	     * @returns {CAAnimation} -
	     */
	    value: function copy() {
	      var anim = _get(CAAnimation.prototype.__proto__ || Object.getPrototypeOf(CAAnimation.prototype), 'copy', this).call(this);

	      anim.isRemovedOnCompletion = this.isRemovedOnCompletion;
	      anim.timingFunction = this.timingFunction;
	      anim.delegate = this.delegate;
	      anim.usesSceneTimeBase = this.usesSceneTimeBase;
	      anim.fadeInDuration = this.fadeInDuration;
	      anim.fadeOutDuration = this.fadeOutDuration;
	      anim.animationEvents = this.animationEvents ? this.animationEvents.slice(0) : null;
	      anim.beginTime = this.beginTime;
	      anim.timeOffset = this.timeOffset;
	      anim.repeatCount = this.repeatCount;
	      anim.repeatDuration = this.repeatDuration;
	      anim.duration = this.duration;
	      anim.speed = this.speed;
	      anim.autoreverses = this.autoreverses;
	      anim.fillMode = this.fillMode;

	      return anim;
	    }

	    /*
	    _copyValue(src) {
	      console.log('CAAnimation._copyValue')
	      this.isRemovedOnCompletion = src.isRemovedOnCompletion
	      this.timingFunction = src.timingFunction
	      this.delegate = src.delegate
	      this.usesSceneTimeBase = src.usesSceneTimeBase
	      this.fadeInDuration = src.fadeInDuration
	      this.fadeOutDuration = src.fadeOutDuration
	      this.animationEvents = src.animationEvents
	      this.beginTime = src.beginTime
	      this.timeOffset = src.timeOffset
	      this.repeatCount = src.repeatCount
	      this.repeatDuration = src.repeatDuration
	      this.duration = src.duration
	      this.speed = src.speed
	      this.autoreverses = src.autoreverses
	      this.fillMode = src.fillMode
	    }
	    */

	    /**
	     * apply animation to the given node.
	     * @access private
	     * @param {Object} obj - target object to apply this animation.
	     * @param {number} time - active time
	     * @param {boolean} [needTimeConversion = true] -
	     * @returns {void}
	     */

	  }, {
	    key: '_applyAnimation',
	    value: function _applyAnimation(obj, time) {
	      var needTimeConversion = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

	      var t = time;
	      if (needTimeConversion) {
	        var baseTime = this._basetimeFromTime(time);
	        t = baseTime;
	        if (this.timingFunction !== null) {
	          t = this.timingFunction._getValueAtTime(baseTime);
	        }
	      }
	      this._handleEvents(obj, t);
	    }
	  }, {
	    key: '_handleEvents',
	    value: function _handleEvents(obj, time) {
	      var _this2 = this;

	      if (this.animationEvents === null) {
	        return;
	      }
	      var prevTime = this._prevTime;
	      if (prevTime === null) {
	        if (this.delegate && this.delegate.animationDidStart) {
	          this.delegate.animationDidStart(this);
	        }
	        prevTime = time - 0.0000001;
	      }
	      this.animationEvents.forEach(function (event) {
	        if (prevTime < event._time && event._time <= time) {
	          if (event._eventBlock) {
	            // FIXME: set playingBackward
	            // SCNAnimationEventBlock(animation, animatedObject, playingBackward)
	            event._eventBlock(_this2, obj, false);
	          }
	        }
	      });
	      this._prevTime = time;
	    }

	    /**
	     * convert parent time to base time
	     * @access private
	     * @param {number} time - parent time
	     * @returns {number} - animation base time for the current frame (0-1 or null).
	     */

	  }, {
	    key: '_basetimeFromTime',
	    value: function _basetimeFromTime(time) {
	      var activeTime = time - this._animationStartTime;
	      return this._basetimeFromActivetime(activeTime);
	    }

	    /**
	     * convert active time to base time
	     * @access private
	     * @param {number} time - active time
	     * @returns {number} - animation base time for the current frame (0-1 or null).
	     */

	  }, {
	    key: '_basetimeFromActivetime',
	    value: function _basetimeFromActivetime(time) {
	      var beginTime = 0;
	      if (this.beginTime > 0) {
	        // FIXME: check usesSceneTimeBase value
	        beginTime = this.beginTime - this._animationStartTime;
	      }
	      var dt = time - beginTime;
	      if (dt < 0) {
	        if (this.fillMode === Constants.kCAFillModeBackwards || this.fillMode === Constants.kCAFillModeBoth) {
	          dt = 0;
	        } else {
	          // the animation hasn't started yet.
	          return null;
	        }
	      }
	      if (this.speed === 0) {
	        return 0;
	      }
	      var oneLoopDuration = this.duration / Math.abs(this.speed);
	      var duration = oneLoopDuration;
	      if (duration === 0) {
	        duration = 0.25;
	      }

	      var repeatCount = this.repeatCount;
	      if (this.usesSceneTimeBase) {
	        // FIXME: I don't know why, but if you set usesSceneTimeBase = true, it will animate repeatedly...
	        repeatCount = Infinity;
	      }

	      if (this.repeatDuration > 0) {
	        duration = this.repeatDuration;
	      } else {
	        if (repeatCount > 0) {
	          duration *= repeatCount;
	        }
	        if (this.autoreverses) {
	          oneLoopDuration *= 2.0;
	          duration *= 2.0;
	        }
	      }

	      if (dt > duration) {
	        // the animation is over.
	        if (!this._isFinished) {
	          this._isFinished = true;
	          if (this.delegate && this.delegate.animationDidStop) {
	            this.delegate.animationDidStop(this, true);
	          }
	        }
	        if (this.fillMode === Constants.kCAFillModeForwards || this.fillMode === Constants.kCAFillModeBoth) {
	          dt = duration;
	        } else {
	          return null;
	        }
	      }

	      var t = (dt + this.timeOffset) / oneLoopDuration;
	      if (Math.abs(t) > 1) {
	        t = t - Math.floor(t);
	      }
	      if (t < 0) {
	        t = 1 + t;
	      }
	      if (this.autoreverses) {
	        if (t <= 0.5) {
	          return t * 2.0;
	        }
	        return (1 - t) * 2.0;
	      }
	      return t;
	    }
	  }], [{
	    key: 'defaultValueForKey',
	    value: function defaultValueForKey(key) {
	      return null;
	    }
	  }]);

	  return CAAnimation;
	}(_NSObject3.default);

	exports.default = CAAnimation;

/***/ },
/* 49 */
/***/ function(module, exports) {

	'use strict';

	/*global exports*/

	// 
	exports.kCAFillModeRemoved = 'removed';
	exports.kCAFillModeForwards = 'forwards';
	exports.kCAFillModeBackwards = 'backwards';
	exports.kCAFillModeBoth = 'both';

	// 
	exports.kCAMediaTimingFunctionLinear = 'linear';
	exports.kCAMediaTimingFunctionEaseIn = 'easeIn';
	exports.kCAMediaTimingFunctionEaseOut = 'easeOut';
	exports.kCAMediaTimingFunctionEaseInEaseOut = 'easeInEaseOut';
	exports.kCAMediaTimingFunctionDefault = 'default';

	// Value calculation modes
	exports.kCAAnimationLinear = 'linear';
	exports.kCAAnimationDiscrete = 'discrete';
	exports.kCAAnimationPaced = 'paced';
	exports.kCAAnimationCubic = 'cubic';
	exports.kCAAnimationCubicPaced = 'cubicPaced';

	// Rotation Mode Values
	exports.kCAAnimationRotateAuto = 'auto';
	exports.kCAAnimationRotateAutoReverse = 'autoReverse';

/***/ },
/* 50 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * Methods that model a hierarchical timing system, allowing objects to map time between their parent and local time. 
	 * @interface
	 * @see https://developer.apple.com/reference/quartzcore/camediatiming
	 */

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var CAMediaTiming =

	/**
	 * constructor
	 * @access public
	 * @constructor
	 */
	function CAMediaTiming() {
	  _classCallCheck(this, CAMediaTiming);

	  // Animation Start Time

	  /**
	   * Required. Specifies the begin time of the receiver in relation to its parent object, if applicable.
	   * @type {number}
	   * @see https://developer.apple.com/reference/quartzcore/camediatiming/1427654-begintime
	   */
	  this.beginTime = 0;

	  /**
	   * Required. Specifies an additional time offset in active local time.
	   * @type {number}
	   * @see https://developer.apple.com/reference/quartzcore/camediatiming/1427650-timeoffset
	   */
	  this.timeOffset = 0;

	  // Repeating Animations

	  /**
	   * Required. Determines the number of times the animation will repeat.
	   * @type {number}
	   * @see https://developer.apple.com/reference/quartzcore/camediatiming/1427666-repeatcount
	   */
	  this.repeatCount = 0;

	  /**
	   * Required. Determines how many seconds the animation will repeat for.
	   * @type {number}
	   * @see https://developer.apple.com/reference/quartzcore/camediatiming/1427643-repeatduration
	   */
	  this.repeatDuration = 0;

	  // Duration and Speed

	  /**
	   * Required. Specifies the basic duration of the animation, in seconds.
	   * @type {number}
	   * @see https://developer.apple.com/reference/quartzcore/camediatiming/1427652-duration
	   */
	  this.duration = 0;

	  /**
	   * Required. Specifies how time is mapped to receivers time space from the parent time space. 
	   * @type {number}
	   * @see https://developer.apple.com/reference/quartzcore/camediatiming/1427647-speed
	   */
	  this.speed = 0;

	  // Playback Modes

	  /**
	   * Required. Determines if the receiver plays in the reverse upon completion.
	   * @type {boolean}
	   * @see https://developer.apple.com/reference/quartzcore/camediatiming/1427645-autoreverses
	   */
	  this.autoreverses = false;

	  /**
	   * Required. Determines if the receivers presentation is frozen or removed once its active duration has completed.
	   * @type {string}
	   * @see https://developer.apple.com/reference/quartzcore/camediatiming/1427656-fillmode
	   */
	  this.fillMode = '';
	};

	exports.default = CAMediaTiming;

/***/ },
/* 51 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _NSObject2 = __webpack_require__(2);

	var _NSObject3 = _interopRequireDefault(_NSObject2);

	var _constants = __webpack_require__(49);

	var Constants = _interopRequireWildcard(_constants);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * A function that defines the pacing of an animation as a timing curve. 
	 * @access public
	 * @extends {NSObject}
	 * @see https://developer.apple.com/reference/quartzcore/camediatimingfunction
	 */
	var CAMediaTimingFunction = function (_NSObject) {
	  _inherits(CAMediaTimingFunction, _NSObject);

	  // Creating Timing Functions

	  /**
	   * Returns an initialized timing function modeled as a cubic Bzier curve using the specified control points.
	   * @access public
	   * @constructor
	   * @param {number} c1x - A floating point number representing the x position of the c1 control point.
	   * @param {number} c1y - A floating point number representing the y position of the c1 control point.
	   * @param {number} c2x - A floating point number representing the x position of the c2 control point.
	   * @param {number} c2y - A floating point number representing the y position of the c2 control point.
	   * @desc The end points of the Bzier curve are automatically set to (0.0,0.0) and (1.0,1.0). The control points defining the Bzier curve are: [(0.0,0.0), (c1x,c1y), (c2x,c2y), (1.0,1.0)].
	   * @see https://developer.apple.com/reference/quartzcore/camediatimingfunction/1522235-init
	   */
	  function CAMediaTimingFunction(c1x, c1y, c2x, c2y) {
	    _classCallCheck(this, CAMediaTimingFunction);

	    var _this = _possibleConstructorReturn(this, (CAMediaTimingFunction.__proto__ || Object.getPrototypeOf(CAMediaTimingFunction)).call(this));

	    _this._c1x = c1x;
	    _this._c1y = c1y;
	    _this._c2x = c2x;
	    _this._c2y = c2y;
	    return _this;
	  }

	  /**
	   * Creates and returns a new instance of CAMediaTimingFunction configured with the predefined timing function specified by name.
	   * @access public
	   * @param {string} name - The timing function to use as specified in Predefined Timing Functions. 
	   * @returns {CAMediaTimingFunction} -
	   * @see https://developer.apple.com/reference/quartzcore/camediatimingfunction/1521979-init
	   */


	  _createClass(CAMediaTimingFunction, [{
	    key: 'getControlPointAtValues',


	    // Accessing the Control Points

	    /**
	     * Returns the control point for the specified index.
	     * @access public
	     * @param {number} idx - 
	     * @param {!UnsafeMutablePointer<Float>} ptr - A pointer to an array that, upon return, will contain the x and y values of the specified point.
	     * @returns {void}
	     * @desc The value of index must be between 0 and 3.
	     * @see https://developer.apple.com/reference/quartzcore/camediatimingfunction/1522057-getcontrolpoint
	     */
	    value: function getControlPointAtValues(idx, ptr) {}
	  }, {
	    key: '_getValueAtTime',
	    value: function _getValueAtTime(time) {
	      var t0 = 0;
	      var t1 = 1;
	      var t = 0.5;
	      var r = 0;

	      if (time <= 0) {
	        return 0;
	      } else if (time >= 1) {
	        return 1;
	      }

	      for (var i = 0; i < 8; i++) {
	        r = 1 - t;
	        var tval = 3 * t * r * (this._c1x * r + this._c2x * t) + t * t * t;
	        if (time > tval) {
	          t0 = t;
	        } else {
	          t1 = t;
	        }
	        t = (t0 + t1) * 0.5;
	      }
	      r = 1 - t;
	      var val = 3 * t * r * (this._c1y * r + this._c2y * t) + t * t * t;

	      return val;
	    }
	  }], [{
	    key: 'functionWithName',
	    value: function functionWithName(name) {
	      switch (name) {
	        case Constants.kCAMediaTimingFunctionLinear:
	          return new CAMediaTimingFunction(0.0, 0.0, 1.0, 1.0);
	        case Constants.kCAMediaTimingFunctionEaseIn:
	          return new CAMediaTimingFunction(0.42, 0.0, 1.0, 1.0);
	        case Constants.kCAMediaTimingFunctionEaseOut:
	          return new CAMediaTimingFunction(0.0, 0.0, 0.58, 1.0);
	        case Constants.kCAMediaTimingFunctionEaseInEaseOut:
	          return new CAMediaTimingFunction(0.42, 0.0, 0.58, 1.0);
	        case Constants.kCAMediaTimingFunctionDefault:
	          return new CAMediaTimingFunction(0.25, 0.1, 0.25, 1.0);
	        default:
	          throw new Error('CAMediaTimingFunction: unknown name: ' + name);
	      }
	    }

	    /**
	     * Returns an initialized timing function modeled as a cubic Bzier curve using the specified control points.
	     * @access public
	     * @param {number} c1x - A floating point number representing the x position of the c1 control point.
	     * @param {number} c1y - A floating point number representing the y position of the c1 control point.
	     * @param {number} c2x - A floating point number representing the x position of the c2 control point.
	     * @param {number} c2y - A floating point number representing the y position of the c2 control point.
	     * @returns {CAMediaTimingFunction} -
	     * @desc The end points of the Bzier curve are automatically set to (0.0,0.0) and (1.0,1.0). The control points defining the Bzier curve are: [(0.0,0.0), (c1x,c1y), (c2x,c2y), (1.0,1.0)].
	     * @see https://developer.apple.com/reference/quartzcore/camediatimingfunction/1522235-init
	     */

	  }, {
	    key: 'functionWithControlPoints',
	    value: function functionWithControlPoints(c1x, c1y, c2x, c2y) {
	      return new CAMediaTimingFunction(c1x, c1y, c2x, c2y);
	    }
	  }]);

	  return CAMediaTimingFunction;
	}(_NSObject3.default);

	exports.default = CAMediaTimingFunction;

/***/ },
/* 52 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _CAAnimation = __webpack_require__(48);

	var _CAAnimation2 = _interopRequireDefault(_CAAnimation);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	/**
	 * Methods your app can implement to respond when animations start and stop.
	 * @interface
	 * @see https://developer.apple.com/reference/quartzcore/caanimationdelegate
	 */
	var CAAnimationDelegate = function () {
	  function CAAnimationDelegate() {
	    _classCallCheck(this, CAAnimationDelegate);
	  }

	  _createClass(CAAnimationDelegate, [{
	    key: 'init',


	    /**
	     * constructor
	     * @access public
	     * @returns {void}
	     */
	    value: function init() {}

	    // Instance Methods

	    /**
	     * Tells the delegate the animation has started. 
	     * @access public
	     * @param {CAAnimation} anim - The CAAnimation object that has started.
	     * @returns {void}
	     * @see https://developer.apple.com/reference/quartzcore/caanimationdelegate/2097265-animationdidstart
	     */

	  }, {
	    key: 'animationDidStart',
	    value: function animationDidStart(anim) {}

	    /**
	     * Tells the delegate the animation has ended. 
	     * @access public
	     * @param {CAAnimation} anim - The CAAnimation object that has ended.
	     * @param {boolean} flag - A flag indicating whether the animation has completed by reaching the end of its duration.
	     * @returns {void}
	     * @desc The animation may have ended because it has completed its active duration or because it has been removed from the layer it is attached to. flag is true if the animation reached the end of its duration without being removed.
	     * @see https://developer.apple.com/reference/quartzcore/caanimationdelegate/2097259-animationdidstop
	     */

	  }, {
	    key: 'animationDidStopFinished',
	    value: function animationDidStopFinished(anim, flag) {}
	  }]);

	  return CAAnimationDelegate;
	}();

	exports.default = CAAnimationDelegate;

/***/ },
/* 53 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _NSObject2 = __webpack_require__(2);

	var _NSObject3 = _interopRequireDefault(_NSObject2);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	//import SCNAnimationEventBlock from './SCNAnimationEventBlock'

	/**
	 * A container for a closure to be executed at a specific time during playback of an animation.
	 * @access public
	 * @extends {NSObject}
	 * @see https://developer.apple.com/reference/scenekit/scnanimationevent
	 */
	var SCNAnimationEvent = function (_NSObject) {
	  _inherits(SCNAnimationEvent, _NSObject);

	  // Creating an Animation Event

	  /**
	   * Creates an animation event.
	   * @access public
	   * @param {number} time - A number between 0.0 and 1.0 specifying the relative time for triggering the event.
	   * @param {SCNAnimationEventBlock} eventBlock - A block to call at the specified time.
	   * @constructor
	   * @desc The time parameter is relative to the duration of the animation the event is attached to. For example, an event with a time of 0.5 triggers when the animation is halfway complete, and an event with a time of 1.0 triggers when the animation ends.
	   * @see https://developer.apple.com/reference/scenekit/scnanimationevent/1524004-init
	   */
	  function SCNAnimationEvent(time, eventBlock) {
	    _classCallCheck(this, SCNAnimationEvent);

	    var _this = _possibleConstructorReturn(this, (SCNAnimationEvent.__proto__ || Object.getPrototypeOf(SCNAnimationEvent)).call(this));

	    _this._time = time;
	    _this._eventBlock = eventBlock;
	    return _this;
	  }

	  _createClass(SCNAnimationEvent, null, [{
	    key: 'eventWithTimeEventBlock',
	    value: function eventWithTimeEventBlock(time, eventBlock) {
	      return new SCNAnimationEvent(time, eventBlock);
	    }
	  }]);

	  return SCNAnimationEvent;
	}(_NSObject3.default);

	exports.default = SCNAnimationEvent;

/***/ },
/* 54 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

	var _CAAnimation2 = __webpack_require__(48);

	var _CAAnimation3 = _interopRequireDefault(_CAAnimation2);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * An object that allows multiple animations to be grouped and run concurrently. 
	 * @access public
	 * @extends {CAAnimation}
	 * @see https://developer.apple.com/reference/quartzcore/caanimationgroup
	 */
	var CAAnimationGroup = function (_CAAnimation) {
	  _inherits(CAAnimationGroup, _CAAnimation);

	  /**
	   * constructor
	   * @access public
	   * @constructor
	   */
	  function CAAnimationGroup() {
	    _classCallCheck(this, CAAnimationGroup);

	    // Grouped animations

	    /**
	     * An array of CAAnimation objects to be evaluated in the time space of the receiver.
	     * @type {?CAAnimation[]}
	     * @see https://developer.apple.com/reference/quartzcore/caanimationgroup/1412516-animations
	     */
	    var _this = _possibleConstructorReturn(this, (CAAnimationGroup.__proto__ || Object.getPrototypeOf(CAAnimationGroup)).call(this));

	    _this.animations = [];
	    return _this;
	  }

	  /**
	   * apply animation to the given node.
	   * @access private
	   * @param {Object} obj - target object to apply this animation.
	   * @param {number} time - active time
	   * @param {boolean} [needTimeConversion = true] -
	   * @returns {void}
	   */


	  _createClass(CAAnimationGroup, [{
	    key: '_applyAnimation',
	    value: function _applyAnimation(obj, time) {
	      var needTimeConversion = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

	      var t = time;
	      if (needTimeConversion) {
	        var baseTime = this._basetimeFromTime(time);
	        t = baseTime;
	        if (this.timingFunction !== null) {
	          t = this.timingFunction._getValueAtTime(baseTime);
	        }
	        //console.log(`time ${time} activeTime ${time - this._animationStartTime} baseTime ${baseTime}`)
	      }

	      this.animations.forEach(function (animation) {
	        animation._applyAnimation(obj, t, false);
	      });
	      this._handleEvents(obj, t);
	    }

	    /**
	      * @access public
	      * @returns {CAAnimationGroup} -
	      */

	  }, {
	    key: 'copy',
	    value: function copy() {
	      //console.log('CAAnimationGroup.copy')
	      var anim = _get(CAAnimationGroup.prototype.__proto__ || Object.getPrototypeOf(CAAnimationGroup.prototype), 'copy', this).call(this);

	      anim.animations = this.animations.slice();

	      return anim;
	    }

	    /*
	    _copyValue(src) {
	      console.log('CAAnimationGroup._copyValue')
	      //super._copyValue(src)
	      this.animations = src.animations.slice()
	    }
	    */

	  }]);

	  return CAAnimationGroup;
	}(_CAAnimation3.default);

	exports.default = CAAnimationGroup;

/***/ },
/* 55 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

	var _CAPropertyAnimation2 = __webpack_require__(56);

	var _CAPropertyAnimation3 = _interopRequireDefault(_CAPropertyAnimation2);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * An object that provides basic, single-keyframe animation capabilities for a layer property. 
	 * @access public
	 * @extends {CAPropertyAnimation}
	 * @see https://developer.apple.com/reference/quartzcore/cabasicanimation
	 */
	var CABasicAnimation = function (_CAPropertyAnimation) {
	  _inherits(CABasicAnimation, _CAPropertyAnimation);

	  /**
	   * constructor
	   * @access public
	   * @param {?string} path -
	   * @constructor
	   */
	  function CABasicAnimation(path) {
	    _classCallCheck(this, CABasicAnimation);

	    // Interpolation values

	    /**
	     * Defines the value the receiver uses to start interpolation.
	     * @type {?Object}
	     * @see https://developer.apple.com/reference/quartzcore/cabasicanimation/1412519-fromvalue
	     */
	    var _this = _possibleConstructorReturn(this, (CABasicAnimation.__proto__ || Object.getPrototypeOf(CABasicAnimation)).call(this, path));

	    _this.fromValue = null;

	    /**
	     * Defines the value the receiver uses to end interpolation.
	     * @type {?Object}
	     * @see https://developer.apple.com/reference/quartzcore/cabasicanimation/1412523-tovalue
	     */
	    _this.toValue = null;

	    /**
	     * Defines the value the receiver uses to perform relative interpolation.
	     * @type {?Object}
	     * @see https://developer.apple.com/reference/quartzcore/cabasicanimation/1412445-byvalue
	     */
	    _this.byValue = null;

	    _this._baseValue = null;
	    return _this;
	  }

	  /**
	   * @access public
	   * @returns {CABasicAnimation} -
	   */


	  _createClass(CABasicAnimation, [{
	    key: 'copy',
	    value: function copy() {
	      var anim = _get(CABasicAnimation.prototype.__proto__ || Object.getPrototypeOf(CABasicAnimation.prototype), 'copy', this).call(this);
	      //anim._copyValue(this)

	      anim.fromValue = this.fromValue;
	      anim.toValue = this.toValue;
	      anim.byValue = this.byValue;

	      return anim;
	    }

	    /*
	    _copyValue(src) {
	      this.fromValue = src.fromValue
	      this.toValue = src.toValue
	      this.byValue = src.byValue
	    }
	    */

	    /**
	     * apply animation to the given node.
	     * @access private
	     * @param {Object} obj - target object to apply this animation.
	     * @param {number} time - active time
	     * @param {boolean} [needTimeConversion = true] -
	     * @returns {void}
	     */

	  }, {
	    key: '_applyAnimation',
	    value: function _applyAnimation(obj, time) {
	      var needTimeConversion = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

	      var t = time;
	      if (needTimeConversion) {
	        var baseTime = this._basetimeFromTime(time);
	        if (baseTime === null) {
	          return;
	        }
	        t = baseTime;
	        if (this.timingFunction !== null) {
	          t = this.timingFunction._getValueAtTime(baseTime);
	        }
	        if (t < 0) {
	          t = 0;
	        }
	        if (t > 1) {
	          t = 1;
	        }
	        if (this.keyPath === 'rotation.w') {
	          console.log('time: ' + time + ', activeTime: ' + (time - this._animationStartTime) + ', baseTime: ' + baseTime + ', t: ' + t);
	        }
	      }

	      var isObject = false;
	      if (this._baseValue === null || this.isAdditive) {
	        this._baseValue = obj.valueForKeyPath(this.keyPath, false);
	      }
	      if (typeof this._baseValue !== 'number' && this._baseValue !== null) {
	        isObject = true;
	      }

	      var fromValue = 0;
	      var toValue = 0;
	      if (this.fromValue !== null && this.toValue !== null) {
	        fromValue = this.fromValue;
	        toValue = this.toValue;
	      } else if (this.fromValue !== null && this.byValue !== null) {
	        fromValue = this.fromValue;
	        if (isObject) {
	          toValue = this.fromValue.add(this.byValue);
	        } else {
	          toValue = this.fromValue + this.byValue;
	        }
	      } else if (this.byValue !== null && this.toValue !== null) {
	        if (isObject) {
	          fromValue = this.toValue.sub(this.byValue);
	        } else {
	          fromValue = this.toValue - this.byValue;
	        }
	        toValue = toValue;
	      } else if (this.fromValue !== null) {
	        fromValue = this.fromValue;
	        if (this.isAdditive) {
	          if (isObject) {
	            toValue = this._baseValue.zero();
	          } else {
	            toValue = 0;
	          }
	        } else {
	          toValue = this._baseValue;
	        }
	      } else if (this.toValue !== null) {
	        if (this.isAdditive) {
	          if (isObject) {
	            fromValue = this._baseValue.zero();
	          } else {
	            fromValue = 0;
	          }
	        } else {
	          fromValue = this._baseValue;
	        }
	        toValue = this.toValue;
	      } else if (this.byValue !== null) {
	        if (this.isAdditive) {
	          if (isObject) {
	            fromValue = this._baseValue.zero();
	          } else {
	            fromValue = 0;
	          }
	          toValue = this.byValue;
	        } else {
	          fromValue = this._baseValue;
	          if (isObject) {
	            toValue = this._baseValue.add(this.byValue);
	          } else {
	            toValue = this._baseValue + this.byValue;
	          }
	        }
	      } else {
	        // TODO: retain prevValue
	        //value = this._lerp(prevValue, currentValue, t)
	      }
	      var value = this._lerp(fromValue, toValue, t);

	      if (this.keyPath === 'rotation.w') {
	        console.log('from: ' + fromValue + ', to: ' + toValue + ', t: ' + t + ', value: ' + value);
	      }

	      if (this.isAdditive) {
	        if (isObject) {
	          //value = value.add(obj.valueForKeyPath(this.keyPath))
	          value = value.add(this._baseValue);
	        } else {
	          value += this._baseValue;
	        }
	      }

	      if (this.keyPath === 'rotation.w') {
	        console.log('value after: ' + value);
	      }

	      //console.log(`CABasicAnimation._applyAnimation: keyPath: ${this.keyPath}, time: ${time}, baseTime: ${baseTime}, t: ${t}, value: ${value}`)
	      this._applyValue(obj, value);
	      this._handleEvents(obj, t);
	    }
	  }]);

	  return CABasicAnimation;
	}(_CAPropertyAnimation3.default);

	exports.default = CABasicAnimation;

/***/ },
/* 56 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

	var _CAAnimation2 = __webpack_require__(48);

	var _CAAnimation3 = _interopRequireDefault(_CAAnimation2);

	var _CGPoint = __webpack_require__(7);

	var _CGPoint2 = _interopRequireDefault(_CGPoint);

	var _CGSize = __webpack_require__(9);

	var _CGSize2 = _interopRequireDefault(_CGSize);

	var _CGRect = __webpack_require__(8);

	var _CGRect2 = _interopRequireDefault(_CGRect);

	var _SCNMatrix = __webpack_require__(46);

	var _SCNMatrix2 = _interopRequireDefault(_SCNMatrix);

	var _SCNQuaternion = __webpack_require__(57);

	var _SCNQuaternion2 = _interopRequireDefault(_SCNQuaternion);

	var _SCNVector = __webpack_require__(45);

	var _SCNVector2 = _interopRequireDefault(_SCNVector);

	var _SCNVector3 = __webpack_require__(44);

	var _SCNVector4 = _interopRequireDefault(_SCNVector3);

	var _SKColor = __webpack_require__(11);

	var _SKColor2 = _interopRequireDefault(_SKColor);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * An abstract subclass of CAAnimation for creating animations that manipulate the value of layer properties. 
	 * @access public
	 * @extends {CAAnimation}
	 * @see https://developer.apple.com/reference/quartzcore/capropertyanimation
	 */
	var CAPropertyAnimation = function (_CAAnimation) {
	  _inherits(CAPropertyAnimation, _CAAnimation);

	  // Creating an Animation

	  /**
	   * Creates and returns an CAPropertyAnimation instance for the specified key path.
	   * @access public
	   * @constructor
	   * @param {?string} path - 
	   * @see https://developer.apple.com/reference/quartzcore/capropertyanimation/1412534-init
	   */
	  function CAPropertyAnimation(path) {
	    _classCallCheck(this, CAPropertyAnimation);

	    // Animated Key Path

	    /**
	     * Specifies the key path the receiver animates.
	     * @type {?string}
	     * @see https://developer.apple.com/reference/quartzcore/capropertyanimation/1412496-keypath
	     */
	    var _this = _possibleConstructorReturn(this, (CAPropertyAnimation.__proto__ || Object.getPrototypeOf(CAPropertyAnimation)).call(this));

	    _this.keyPath = path;

	    // Property Value Calculation Behavior

	    /**
	     * Determines if the value of the property is the value at the end of the previous repeat cycle, plus the value of the current repeat cycle.
	     * @type {boolean}
	     * @see https://developer.apple.com/reference/quartzcore/capropertyanimation/1412538-iscumulative
	     */
	    _this.isCumulative = false;

	    /**
	     * Determines if the value specified by the animation is added to the current render tree value to produce the new render tree value.
	     * @type {boolean}
	     * @see https://developer.apple.com/reference/quartzcore/capropertyanimation/1412493-isadditive
	     */
	    _this.isAdditive = false;

	    /**
	     * An optional value function that is applied to interpolated values.
	     * @type {?CAValueFunction}
	     * @see https://developer.apple.com/reference/quartzcore/capropertyanimation/1412447-valuefunction
	     */
	    _this.valueFunction = null;

	    _this._isMultiplicative = false;
	    return _this;
	  }

	  /**
	   * @access public
	   * @returns {CAPropertyAnimation} -
	   */


	  _createClass(CAPropertyAnimation, [{
	    key: 'copy',
	    value: function copy() {
	      var anim = _get(CAPropertyAnimation.prototype.__proto__ || Object.getPrototypeOf(CAPropertyAnimation.prototype), 'copy', this).call(this);
	      //anim._copyValue(this)
	      anim.keyPath = this.keyPath;
	      anim.isCumulative = this.isCumulative;
	      anim.isAdditive = this.isAdditive;
	      anim.valueFunction = this.valueFunction;
	      anim._isMultiplicative = this._isMultiplicative;

	      return anim;
	    }

	    /*
	    _copyValue(src) {
	      console.log('CAPropertyAnimation._copyValue: ' + src.keyPath)
	      this.keyPath = src.keyPath
	      this.isCumulative = src.isCumulative
	      this.isAdditive = src.isAdditive
	      this.valueFunction = src.valueFunction
	    }
	    */

	    /**
	     * apply animation to the given node.
	     * @access private
	     * @param {Object} obj - target object to apply this animation.
	     * @param {number} time - active time
	     * @param {boolean} [needTimeConversion = true] -
	     * @returns {void}
	     */

	  }, {
	    key: '_applyAnimation',
	    value: function _applyAnimation(obj, time) {
	      var needTimeConversion = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

	      var t = time;
	      if (needTimeConversion) {
	        var baseTime = this._basetimeFromTime(time);
	        t = baseTime;
	        if (this.timingFunction !== null) {
	          t = this.timingFunction._getValueAtTime(baseTime);
	        }
	      }

	      var value = t;
	      if (this.valueFunction !== null) {
	        value = this.valueFunction._getValueAtTime(t);
	      }
	      value = this._calculateWithBaseValue(obj, value);
	      //console.log(`CAPropertyAnimation: obj: ${obj.name}, time: ${time}, keyPath: ${this.keyPath}, value: ${value}`)
	      this._applyValue(obj, value);
	      this._handleEvents(obj, t);
	    }
	  }, {
	    key: '_calculateWithBaseValue',
	    value: function _calculateWithBaseValue(obj, value) {
	      if (this.isAdditive) {
	        var baseValue = obj.valueForKeyPath(this.keyPath);
	        return this._addValues(baseValue, value);
	      } else if (this._isMultiplicative) {
	        var _baseValue = obj.valueForKeyPath(this.keyPath);
	        return this._mulValues(_baseValue, value);
	      }
	      return value;
	    }
	  }, {
	    key: '_applyValue',
	    value: function _applyValue(obj, value) {
	      obj.setValueForKeyPath(value, this.keyPath);
	    }
	  }, {
	    key: '_addValues',
	    value: function _addValues(v1, v2) {
	      if (v1 instanceof Object) {
	        return v1.add(v2);
	      }
	      return v1 + v2;
	    }
	  }, {
	    key: '_mulValues',
	    value: function _mulValues(v1, v2) {
	      if (v1 instanceof Object) {
	        return v1.mul(v2);
	      }
	      return v1 * v2;
	    }
	  }, {
	    key: '_lerp',
	    value: function _lerp(from, to, t) {
	      if (t === null) {
	        // the animation is over.
	        return to;
	      }
	      if (from instanceof _SCNVector2.default) {
	        // TODO: slerp for Quaternion
	        return from.lerp(to, t);
	      } else if (from instanceof _SCNVector4.default) {
	        return from.lerp(to, t);
	      } else if (from instanceof _CGSize2.default) {
	        // TODO: implement
	      } else if (from instanceof _CGPoint2.default) {
	        // TODO: implement
	      } else if (from instanceof _CGRect2.default) {
	        // TODO: implement
	      } else if (from instanceof _SKColor2.default) {
	        return from._lerp(to, t);
	      }
	      return from + (to - from) * t;
	    }
	  }, {
	    key: '_slerp',
	    value: function _slerp(from, to, t) {
	      if (!(from instanceof _SCNVector2.default)) {
	        throw new Error('CABasicAnimation._slerp: object is not SCNVector4');
	      }
	      return from.slerp(to, t);
	    }
	  }]);

	  return CAPropertyAnimation;
	}(_CAAnimation3.default);

	exports.default = CAPropertyAnimation;

/***/ },
/* 57 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _SCNVector = __webpack_require__(45);

	var _SCNVector2 = _interopRequireDefault(_SCNVector);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * A representation of a quaternion.
	 * @type {SCNVector4}
	 * @desc A quaternion is a mathematical construct useful for describing rotations in three-dimensional space. Although its implementation differs from that of a 4-component vector, you specify a quaternion value using the same fields as an SCNVector4 structure.SceneKit uses unit quaternions (those whose components satisfy the equation x*x + y*y + z*z + w*w == 1) for the orientation property of nodes.
	 * @see https://developer.apple.com/reference/scenekit/scnquaternion
	 */
	var SCNQuaternion = _SCNVector2.default;

	exports.default = SCNQuaternion;

/***/ },
/* 58 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * Returns the current absolute time, in seconds.
	 * @access public
	 * @returns {number} - 
	 * @see https://developer.apple.com/reference/quartzcore/1395996-cacurrentmediatime
	 */

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var CACurrentMediaTime = function CACurrentMediaTime() {
	  return Date.now() * 0.001;
	};

	exports.default = CACurrentMediaTime;

/***/ },
/* 59 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

	var _CAPropertyAnimation2 = __webpack_require__(56);

	var _CAPropertyAnimation3 = _interopRequireDefault(_CAPropertyAnimation2);

	var _CGPath = __webpack_require__(19);

	var _CGPath2 = _interopRequireDefault(_CGPath);

	var _CAMediaTimingFunction = __webpack_require__(51);

	var _CAMediaTimingFunction2 = _interopRequireDefault(_CAMediaTimingFunction);

	var _constants = __webpack_require__(49);

	var Constants = _interopRequireWildcard(_constants);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * An object that provides keyframe animation capabilities for a layer object. 
	 * @access public
	 * @extends {CAPropertyAnimation}
	 * @see https://developer.apple.com/reference/quartzcore/cakeyframeanimation
	 */
	var CAKeyframeAnimation = function (_CAPropertyAnimation) {
	  _inherits(CAKeyframeAnimation, _CAPropertyAnimation);

	  // Creating an Animation

	  /**
	   * Creates and returns an CAKeyframeAnimation instance for the specified key path.
	   * @access public
	   * @constructor
	   * @param {?string} path - 
	   */
	  function CAKeyframeAnimation(path) {
	    _classCallCheck(this, CAKeyframeAnimation);

	    // Providing keyframe values

	    /**
	     * An array of objects that specify the keyframe values to use for the animation.
	     * @type {?Object[]}
	     * @see https://developer.apple.com/reference/quartzcore/cakeyframeanimation/1412498-values
	     */
	    var _this = _possibleConstructorReturn(this, (CAKeyframeAnimation.__proto__ || Object.getPrototypeOf(CAKeyframeAnimation)).call(this, path));

	    _this.values = null;

	    /**
	     * The path for a point-based property to follow.
	     * @type {?CGPath}
	     * @see https://developer.apple.com/reference/quartzcore/cakeyframeanimation/1412474-path
	     */
	    _this.path = null;

	    // Keyframe timing

	    /**
	     * An optional array of NSNumber objects that define the time at which to apply a given keyframe segment.
	     * @type {?number[]}
	     * @see https://developer.apple.com/reference/quartzcore/cakeyframeanimation/1412522-keytimes
	     */
	    _this.keyTimes = null;

	    /**
	     * An optional array of CAMediaTimingFunction objects that define the pacing for each keyframe segment.
	     * @type {?CAMediaTimingFunction[]}
	     * @see https://developer.apple.com/reference/quartzcore/cakeyframeanimation/1412465-timingfunctions
	     */
	    _this.timingFunctions = null;

	    /**
	     * Specifies how intermediate keyframe values are calculated by the receiver.
	     * @type {string}
	     * @see https://developer.apple.com/reference/quartzcore/cakeyframeanimation/1412500-calculationmode
	     */
	    _this.calculationMode = Constants.kCAAnimationLinear;

	    // Rotation Mode Attribute

	    /**
	     * Determines whether objects animating along the path rotate to match the path tangent.
	     * @type {?string}
	     * @see https://developer.apple.com/reference/quartzcore/cakeyframeanimation/1412454-rotationmode
	     */
	    _this.rotationMode = null;

	    // Cubic Mode Attributes

	    /**
	     * An array of NSNumber objects that define the tightness of the curve. 
	     * @type {?number[]}
	     * @see https://developer.apple.com/reference/quartzcore/cakeyframeanimation/1412475-tensionvalues
	     */
	    _this.tensionValues = null;

	    /**
	     * An array of NSNumber objects that define the sharpness of the timing curves corners.
	     * @type {?number[]}
	     * @see https://developer.apple.com/reference/quartzcore/cakeyframeanimation/1412491-continuityvalues
	     */
	    _this.continuityValues = null;

	    /**
	     * An array of NSNumber objects that define the position of the curve relative to a control point.
	     * @type {?number[]}
	     * @see https://developer.apple.com/reference/quartzcore/cakeyframeanimation/1412485-biasvalues
	     */
	    _this.biasValues = null;

	    /**
	     * @access private
	     * @type {number}
	     */
	    _this._indexCache = 0;
	    return _this;
	  }

	  /**
	   * @access public
	   * @returns {CAKeyframeAnimation} -
	   */


	  _createClass(CAKeyframeAnimation, [{
	    key: 'copy',
	    value: function copy() {
	      var anim = _get(CAKeyframeAnimation.prototype.__proto__ || Object.getPrototypeOf(CAKeyframeAnimation.prototype), 'copy', this).call(this);

	      anim.values = this.values ? this.values.slice() : null;
	      anim.path = this.path;
	      anim.keyTimes = this.keyTimes ? this.keyTimes.slice() : null;
	      anim.timingFunctions = this.timingFunctions ? this.timingFunctions.slice() : null;
	      anim.calculationMode = this.calculationMode;
	      anim.rotationMode = this.rotationMode;
	      anim.tensionValues = this.tensionValues ? this.tensionValues.slice() : null;
	      anim.continuityValues = this.continuityValues ? this.continuityValues.slice() : null;
	      anim.biasValues = this.biasValues ? this.biasValues.slice() : null;

	      return anim;
	    }

	    /**
	     * apply animation to the given node.
	     * @access private
	     * @param {Object} obj - target object to apply this animation.
	     * @param {number} time - active time
	     * @param {boolean} [needTimeConversion = true] -
	     * @returns {void}
	     */

	  }, {
	    key: '_applyAnimation',
	    value: function _applyAnimation(obj, time) {
	      var needTimeConversion = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

	      var t = time;
	      if (needTimeConversion) {
	        var baseTime = this._basetimeFromTime(time);
	        t = baseTime;
	      }

	      var index = this._indexCache;
	      var key0 = 0;
	      var key1 = 0;

	      if (t > 1) {
	        throw new Error('CAKeyframeAnimation._applyAnimation: t ' + t + ' > 1');
	      }

	      var len = this.keyTimes.length;
	      if (index >= len) {
	        console.log('CAKeyframeAnimation index >= len  ' + index + ' >= ' + len);
	        index = len - 1;
	      }

	      // search keyTime linearly
	      if (this.keyTimes[index] < t) {
	        for (; index < len; index++) {
	          if (this.keyTimes[index] >= t) break;
	        }
	        key0 = index - 1;
	        key1 = index;
	      } else {
	        for (; index >= 0; index--) {
	          if (this.keyTimes[index] < t) break;
	        }
	        key0 = index;
	        key1 = index + 1;
	      }
	      if (key0 <= 0) {
	        key0 = 0;
	      }
	      if (key1 >= len) {
	        key1 = len - 1;
	      }

	      this._indexCache = key0;

	      var time0 = this.keyTimes[key0];
	      var time1 = this.keyTimes[key1];
	      var val0 = this.values[key0];
	      var val1 = this.values[key1];

	      var value = val0;
	      if (time0 !== time1) {
	        var dt = (t - time0) / (time1 - time0);
	        var r = dt;
	        if (this.timingFunctions !== null) {
	          r = this.timingFunctions[key0]._getValueAtTime(dt);
	        }

	        switch (this.calculationMode) {
	          case Constants.kCAAnimationLinear:
	            value = this._lerp(val0, val1, r);
	            break;
	          case Constants.kCAAnimationDiscrete:
	            // TODO: implement
	            throw new Error('kCAAnimationDiscrete not implemented');
	          case Constants.kCAAnimationPaced:
	            // TODO: implement
	            throw new Error('kCAAnimationPaced not implemented');
	          case Constants.kCAAnimationCubic:
	            // TODO: implement
	            throw new Error('kCAAnimationCubic not implemented');
	          case Constants.kCAAnimationCubicPaced:
	            // TODO: impelement
	            throw new Error('kCAAnimationCubicPaced not implemented');
	          default:
	            throw new Error('unknown calculation mode: ' + this.calculationMode);
	        }

	        //console.log(`t: ${t}, time0: ${time0}, time1: ${time1}, dt: ${dt}, r: ${r}, value: ${value}`)
	      } else {
	          //console.log(`t: ${t}, time0: ${time0}, time1: ${time1}, value: ${value}`)
	        }

	      value = this._calculateWithBaseValue(obj, value);

	      this._applyValue(obj, value);
	      this._handleEvents(obj, t);
	    }
	  }]);

	  return CAKeyframeAnimation;
	}(_CAPropertyAnimation3.default);

	exports.default = CAKeyframeAnimation;

/***/ },
/* 60 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

	var _NSObject2 = __webpack_require__(2);

	var _NSObject3 = _interopRequireDefault(_NSObject2);

	var _CGPoint = __webpack_require__(7);

	var _CGPoint2 = _interopRequireDefault(_CGPoint);

	var _CGRect = __webpack_require__(8);

	var _CGRect2 = _interopRequireDefault(_CGRect);

	var _CGSize = __webpack_require__(9);

	var _CGSize2 = _interopRequireDefault(_CGSize);

	var _SCNVector = __webpack_require__(44);

	var _SCNVector2 = _interopRequireDefault(_SCNVector);

	var _SCNVector3 = __webpack_require__(45);

	var _SCNVector4 = _interopRequireDefault(_SCNVector3);

	var _SCNActionTimingMode = __webpack_require__(61);

	var _SCNActionTimingMode2 = _interopRequireDefault(_SCNActionTimingMode);

	var _SKColor = __webpack_require__(11);

	var _SKColor2 = _interopRequireDefault(_SKColor);

	var _constants = __webpack_require__(49);

	var Constants = _interopRequireWildcard(_constants);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	//import SCNAudioSource from './SCNAudioSource'
	//import SCNNode from './SCNNode'

	//import SCNActionTimingFunction from './SCNActionTimingFunction'
	//import SCNActionRotate from './SCNActionRotate'
	//import SCNActionSequence from './SCNActionSequence'
	//import SCNActionRepeat from './SCNActionRepeat'
	//import SCNActionGroup from './SCNActionGroup'
	//import SCNActionFade from './SCNActionFade'
	//import SCNActionPlaySound from './SCNActionPlaySound'
	//import SCNActionJavaScript from './SCNActionJavaScript'
	//import SCNActionRunBlock from './SCNActionRunBlock'
	//import SCNActionReference from './SCNActionReference'
	//import SCNActionCustom from './SCNActionCustom'
	//import SCNActionWait from './SCNActionWait'
	//import SCNActionRemove from './SCNActionRemove'
	//import SCNActionPerformSelector from './SCNActionPerformSelector'
	//import SCNActionScale from './SCNActionScale'
	//import SCNActionMove from './SCNActionMove'
	//import SCNActionHide from './SCNActionHide'
	//import SCNActionRunAction from './SCNActionRunAction'


	/**
	 * A simple, reusable animation that changes attributes of any node you attach it to.
	 * @access public
	 * @extends {NSObject}
	 * @see https://developer.apple.com/reference/scenekit/scnaction
	 */
	var SCNAction = function (_NSObject) {
	  _inherits(SCNAction, _NSObject);

	  /**
	   * constructor
	   * @access public
	   * @constructor
	   */
	  function SCNAction() {
	    _classCallCheck(this, SCNAction);

	    // Adjusting an Actions Animation Properties

	    /**
	     * The duration required to complete an action.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnaction/1524162-duration
	     */
	    var _this = _possibleConstructorReturn(this, (SCNAction.__proto__ || Object.getPrototypeOf(SCNAction)).call(this));

	    _this._duration = 0;

	    /**
	     * A speed factor that modifies how fast an action runs.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnaction/1522811-speed
	     */
	    _this._speed = 1.0;

	    /**
	     * The timing mode used to execute an action.
	     * @type {SCNActionTimingMode}
	     * @see https://developer.apple.com/reference/scenekit/scnaction/1524055-timingmode
	     */
	    _this._timingMode = _SCNActionTimingMode2.default.linear;

	    /**
	     * A block SceneKit calls to determine the actions animation timing.
	     * @type {?SCNActionTimingFunction}
	     * @see https://developer.apple.com/reference/scenekit/scnaction/1524130-timingfunction
	     */
	    _this._timingFunction = null;

	    /**
	     * @access private
	     * @type {boolean}
	     */
	    _this._finished = false;

	    _this._beginTime = 0;
	    _this._isRunning = false;
	    _this._pausedTime = 0;
	    _this._completionHandler = null;

	    _this.__actionStartTime = null;
	    return _this;
	  }

	  // Creating Actions That Move a Node

	  /**
	   * Creates an action that moves a node relative to its current position.
	   * @access public
	   * @param {number} deltaX - The distance to move the node in the X direction of its parent nodes local coordinate space.
	   * @param {number} deltaY - The distance to move the node in the Y direction of its parent nodes local coordinate space.
	   * @param {number} deltaZ - The distance to move the node in the Z direction of its parent nodes local coordinate space.
	   * @param {number} duration - The duration, in seconds, of the animation.
	   * @returns {SCNAction} - 
	   * @desc When the action executes, the nodes position property animates from its current position to its new position.This action is reversible; the reverse is created as if the following code had been executed:[SCNAction moveByX: -deltaX y: -deltaY z: -deltaZ duration: duration];
	  [SCNAction moveByX: -deltaX y: -deltaY z: -deltaZ duration: duration];
	    * @see https://developer.apple.com/reference/scenekit/scnaction/1523238-moveby
	   */


	  _createClass(SCNAction, [{
	    key: 'reversed',


	    // Reversing an Action

	    /**
	     * Creates an action that reverses the behavior of another action.
	     * @access public
	     * @returns {SCNAction} - 
	     * @desc This method always returns an action object; however, not all actions are reversible. When reversed, some actions return an object that either does nothing or performs the same action as the original action. For details on how an action is reversed, see the description of the class method used to create that action.
	     * @see https://developer.apple.com/reference/scenekit/scnaction/1522815-reversed
	     */
	    value: function reversed() {
	      return null;
	    }

	    /**
	     * @access public
	     * @returns {SCNAction} -
	     */

	  }, {
	    key: 'copy',
	    value: function copy() {
	      var action = _get(SCNAction.prototype.__proto__ || Object.getPrototypeOf(SCNAction.prototype), 'copy', this).call(this);

	      action._beginTime = this._beginTime;
	      action._duration = this._duration;
	      action._speed = this.speed;
	      action._timingMode = this.timingMode;
	      action._timingFunction = this.timingFunction;
	      action._finished = this._finished;
	      //action._isRunning = this._isRunning
	      //action._pausedTime = this._pausedTime
	      //action._completionHandler = this._completionHandler

	      return action;
	    }
	  }, {
	    key: '_applyAction',


	    /**
	     * apply action to the given node.
	     * @access private
	     * @param {Object} obj - target object to apply this action.
	     * @param {number} time - active time
	     * @param {boolean} [needTimeConversion = true] -
	     * @returns {void}
	     */
	    value: function _applyAction(obj, time) {
	      var needTimeConversion = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

	      var t = this._getTime(time, needTimeConversion);
	      //this._handleEvents(obj, t)
	    }
	  }, {
	    key: '_getTime',
	    value: function _getTime(time, needTimeConversion) {
	      if (!needTimeConversion) {
	        if (time >= 1.0 && !this._finished) {
	          this._finished = true;
	        }
	        return time;
	      }

	      var baseTime = this._basetimeFromTime(time);
	      if (this.timingFunction === null) {
	        return baseTime;
	      }

	      return this.timingFunction._getValueAtTime(baseTime);
	    }

	    /**
	     * convert parent time to base time
	     * @access private
	     * @param {number} time - parent time
	     * @returns {number} - animation base time for the current frame (0-1 or null).
	     */

	  }, {
	    key: '_basetimeFromTime',
	    value: function _basetimeFromTime(time) {
	      var activeTime = time - this._actionStartTime;
	      return this._basetimeFromActivetime(activeTime);
	    }

	    /**
	     * convert parent time to active time
	     * @access private
	     * @param {number} time - parent time
	     * @returns {number} - animation active time for the current frame.
	     */

	  }, {
	    key: '_activetimeFromTime',
	    value: function _activetimeFromTime(time) {
	      return time - this._actionStartTime;
	    }

	    /**
	     * convert active time to base time
	     * @access private
	     * @param {number} time - active time
	     * @returns {number} - animation base time for the current frame (0-1 or null).
	     */

	  }, {
	    key: '_basetimeFromActivetime',
	    value: function _basetimeFromActivetime(time) {
	      var dt = time - this._beginTime;
	      //let dt = time
	      if (this.speed === 0) {
	        return 0;
	      }
	      if (this._duration === 0) {
	        return dt / Math.abs(this.speed);
	      }
	      var duration = this._duration / Math.abs(this.speed);
	      if (duration === 0) {
	        duration = 0.25;
	      }

	      if (dt >= duration) {
	        // the action is over.
	        if (!this._finished) {
	          this._finished = true;
	        }
	      }

	      return dt / duration;
	    }

	    /**
	     * @access private
	     * @param {Object} from -
	     * @param {Object} to -
	     * @param {number} t -
	     * @returns {Object} -
	     */

	  }, {
	    key: '_lerp',
	    value: function _lerp(from, to, t) {
	      if (t === null) {
	        // the action is over.
	        return to;
	      }
	      if (from instanceof _SCNVector4.default) {
	        // TODO: slerp for Quaternion
	        return from.lerp(to, t);
	      } else if (from instanceof _SCNVector2.default) {
	        return from.lerp(to, t);
	      } else if (from instanceof _CGSize2.default) {
	        return from.lerp(to, t);
	      } else if (from instanceof _CGPoint2.default) {
	        return from.lerp(to, t);
	      } else if (from instanceof _CGRect2.default) {
	        return from.lerp(to, t);
	      } else if (from instanceof _SKColor2.default) {
	        return from._lerp(to, t);
	      }
	      return from + (to - from) * t;
	    }

	    /**
	     * @access private
	     * @param {Object} from -
	     * @param {Object} to -
	     * @param {number} t -
	     * @returns {Object} -
	     */

	  }, {
	    key: '_slerp',
	    value: function _slerp(from, to, t) {
	      if (!(from instanceof _SCNVector4.default)) {
	        throw new Error('SCNAction._slerp: object is not SCNVector4');
	      }
	      return from.slerp(to, t);
	    }
	  }, {
	    key: '_resetFinished',
	    value: function _resetFinished() {
	      this._finished = false;
	    }
	  }, {
	    key: '_actionStartTime',
	    get: function get() {
	      return this.__actionStartTime;
	    },
	    set: function set(newValue) {
	      this.__actionStartTime = newValue;
	    }
	  }, {
	    key: 'duration',
	    get: function get() {
	      return this._duration;
	    },
	    set: function set(newValue) {
	      this._duration = newValue;
	    }
	  }, {
	    key: 'speed',
	    get: function get() {
	      return this._speed;
	    },
	    set: function set(newValue) {
	      this._speed = newValue;
	    }
	  }, {
	    key: 'timingMode',
	    get: function get() {
	      return this._timingMode;
	    },
	    set: function set(newValue) {
	      this._timingMode = newValue;
	    }
	  }, {
	    key: 'timingFunction',
	    get: function get() {
	      return this._timingFunction;
	    },
	    set: function set(newValue) {
	      this._timingFunction = newValue;
	    }
	  }], [{
	    key: 'moveByXYZ',
	    value: function moveByXYZ(deltaX, deltaY, deltaZ, duration) {
	      //return SCNActionMove.moveByXYZ(deltaX, deltaY, deltaZ, duration)
	      throw new Error('not implemented');
	    }

	    /**
	     * Creates an action that moves a node relative to its current position.
	     * @access public
	     * @param {SCNVector3} delta - A vector that describes the change to be applied to the nodes position.
	     * @param {number} duration - The duration, in seconds, of the animation.
	     * @returns {SCNAction} - 
	     * @desc When the action executes, the nodes position property animates from its current position to its new position.This action is reversible; the reverse is created as if the following code had been executed:SCNVector3 reverseDelta = SCNVector3Make(-delta.x, -delta.y, -delta.z);
	    [SCNAction moveBy: reverseDelta duration: duration];
	    SCNVector3 reverseDelta = SCNVector3Make(-delta.x, -delta.y, -delta.z);
	    [SCNAction moveBy: reverseDelta duration: duration];
	      * @see https://developer.apple.com/reference/scenekit/scnaction/1522605-move
	     */

	  }, {
	    key: 'moveBy',
	    value: function moveBy(delta, duration) {
	      //return SCNActionMove.moveBy(delta, duration)
	      throw new Error('not implemented');
	    }

	    /**
	     * Creates an action that moves a node to a new position.
	     * @access public
	     * @param {SCNVector3} location - The coordinates for the nodes new position in its parent nodes local coordinate space.
	     * @param {number} duration - The duration, in seconds, of the animation.
	     * @returns {SCNAction} - 
	     * @desc When the action executes, the nodes position property animates from its current position to its new position.This action is not reversible; the reverse of this action has the same duration but does not move the node.
	     * @see https://developer.apple.com/reference/scenekit/scnaction/1522826-move
	     */

	  }, {
	    key: 'moveTo',
	    value: function moveTo(location, duration) {
	      //return SCNActionMove.moveTo(location, duration)
	      throw new Error('not implemented');
	    }

	    // Creating Actions That Rotate a Node

	    /**
	     * Creates an action that rotates the node in each of the three principal axes by angles relative to its current orientation.
	     * @access public
	     * @param {number} xAngle - The amount to rotate the node counterclockwise around the x-axis of its local coordinate space, in radians.
	     * @param {number} yAngle - The amount to rotate the node counterclockwise around the y-axis of its local coordinate space, in radians.
	     * @param {number} zAngle - The amount to rotate the node counterclockwise around the z-axis of its local coordinate space, in radians.
	     * @param {number} duration - The duration, in seconds, of the animation.
	     * @returns {SCNAction} - 
	     * @desc When the action executes, the nodes rotation property animates to the new angle.This action is reversible; the reverse is created as if the following code had been executed:[SCNAction rotateByX: -xAngle y: -yAngle z: -zAngle duration: duration];
	    [SCNAction rotateByX: -xAngle y: -yAngle z: -zAngle duration: duration];
	      * @see https://developer.apple.com/reference/scenekit/scnaction/1523522-rotateby
	     */

	  }, {
	    key: 'rotateByXYZ',
	    value: function rotateByXYZ(xAngle, yAngle, zAngle, duration) {
	      //return SCNActionRotate.rotateByXYZ(xAngle, yAngle, zAngle, duration)
	      throw new Error('not implemented');
	    }

	    /**
	     * Creates an action that rotates the node to absolute angles in each of the three principal axes.
	     * @access public
	     * @param {number} xAngle - The amount to rotate the node counterclockwise around the x-axis of its local coordinate space, in radians.
	     * @param {number} yAngle - The amount to rotate the node counterclockwise around the y-axis of its local coordinate space, in radians.
	     * @param {number} zAngle - The amount to rotate the node counterclockwise around the z-axis of its local coordinate space, in radians.
	     * @param {number} duration - The duration, in seconds, of the animation.
	     * @returns {SCNAction} - 
	     * @desc When the action executes, the nodes rotation property animates to the new angle. Calling this method is equivalent to calling rotateTo(x:y:z:duration:usesShortestUnitArc:) and passing false for the shortestUnitArc parameter.This action is not reversible; the reverse of this action has the same duration but does not change anything.
	     * @see https://developer.apple.com/reference/scenekit/scnaction/1524044-rotateto
	     */

	  }, {
	    key: 'rotateToXYZ',
	    value: function rotateToXYZ(xAngle, yAngle, zAngle, duration) {
	      //return SCNActionRotate.rotateToXYZ(xAngle, yAngle, zAngle, duration)
	      throw new Error('not implemented');
	    }

	    /**
	     * Creates an action that rotates the node to absolute angles in each of the three principal axes.
	     * @access public
	     * @param {number} xAngle - The amount to rotate the node counterclockwise around the x-axis of its local coordinate space, in radians.
	     * @param {number} yAngle - The amount to rotate the node counterclockwise around the y-axis of its local coordinate space, in radians.
	     * @param {number} zAngle - The amount to rotate the node counterclockwise around the z-axis of its local coordinate space, in radians.
	     * @param {number} duration - The duration, in seconds, of the animation.
	     * @param {boolean} shortestUnitArc - If false (the default), the animation interpolates each component of the nodes rotation between its current value and the new value. If true, the animation makes the most direct rotation possible from the nodes current orientation to the new orientation.
	     * @returns {SCNAction} - 
	     * @desc When the action executes, the nodes rotation property animates to the new angle.This action is not reversible; the reverse of this action has the same duration but does not change anything.
	     * @see https://developer.apple.com/reference/scenekit/scnaction/1522808-rotateto
	     */

	  }, {
	    key: 'rotateToXYZUsesShortestUnitArc',
	    value: function rotateToXYZUsesShortestUnitArc(xAngle, yAngle, zAngle, duration, shortestUnitArc) {
	      //return SCNActionRotate.rotateToXYZUsesShortestUnitArc(xAngle, yAngle, zAngle, duration, shortestUnitArc)
	      throw new Error('not implemented');
	    }

	    /**
	     * Creates an action that rotates the node by an angle around a specified axis.
	     * @access public
	     * @param {number} angle - The amount to rotate the node counterclockwise around the specified axis, in radians.
	     * @param {SCNVector3} axis - A vector in the nodes local coordinate space whose direction specifies the axis of rotation.
	     * @param {number} duration - The duration, in seconds, of the animation.
	     * @returns {SCNAction} - 
	     * @desc When the action executes, the nodes rotation property animates to the new angle.This action is reversible; the reverse is created as if the following code had been executed:[SCNAction rotateByAngle: -angle aroundAxis: axis duration: sec];
	    [SCNAction rotateByAngle: -angle aroundAxis: axis duration: sec];
	      * @see https://developer.apple.com/reference/scenekit/scnaction/1523805-rotate
	     */

	  }, {
	    key: 'rotateByAround',
	    value: function rotateByAround(angle, axis, duration) {
	      //return SCNActionRotate.rotateByAround(angle, axis, duration)
	      throw new Error('not implemented');
	    }

	    /**
	     * Creates an action that rotates the node to an absolute angle around a specified axis.
	     * @access public
	     * @param {SCNVector4} axisAngle - A four-component vector whose first three components are a vector in the nodes local coordinate space specifying an axis and whose fourth component is the amount to rotate the node counterclockwise around that axis, in radians.
	     * @param {number} duration - The duration, in seconds, of the animation.
	     * @returns {SCNAction} - 
	     * @desc When the action executes, the nodes rotation property animates to the new angle.This action is not reversible; the reverse of this action has the same duration but does not change anything.
	     * @see https://developer.apple.com/reference/scenekit/scnaction/1524191-rotate
	     */

	  }, {
	    key: 'rotateToAxisAngle',
	    value: function rotateToAxisAngle(axisAngle, duration) {
	      //return SCNActionRotate.rotateToAxisAngle(axisAngle, duration)
	      throw new Error('not implemented');
	    }

	    // Creating Actions That Change a Nodes Scale

	    /**
	     * Creates an action that uniformly changes the scale factor of a node by a relative value.
	     * @access public
	     * @param {number} scale - The amount of change to make to all three components of the nodes scale.
	     * @param {number} sec - The duration, in seconds, of the animation.
	     * @returns {SCNAction} - 
	     * @desc When the action executes, the nodes scale property animates to the new value.This action is reversible; the reverse is created as if the following code had been executed:[SCNAction scaleBy: -scale duration: sec];
	    [SCNAction scaleBy: -scale duration: sec];
	      * @see https://developer.apple.com/reference/scenekit/scnaction/1523129-scale
	     */

	  }, {
	    key: 'scaleByDuration',
	    value: function scaleByDuration(scale, sec) {
	      //return SCNActionScale.scaleByDuration(scale, sec)
	      throw new Error('not implemented');
	    }

	    /**
	     * Creates an action that uniformly changes the scale factor of a node to an absolute value.
	     * @access public
	     * @param {number} scale - The new value for all three components of the nodes scale.
	     * @param {number} sec - The duration, in seconds, of the animation.
	     * @returns {SCNAction} - 
	     * @desc When the action executes, the nodes scale property animates to the new value.This action is not reversible; the reverse of this action has the same duration but does not change anything.
	     * @see https://developer.apple.com/reference/scenekit/scnaction/1523322-scale
	     */

	  }, {
	    key: 'scaleToDuration',
	    value: function scaleToDuration(scale, sec) {
	      //return SCNActionScale.scaleToDuration(scale, sec)
	      throw new Error('not implemented');
	    }

	    // Creating Actions That Change a Nodes Opacity

	    /**
	     * Creates an action that changes the opacity of the node to 1.0.
	     * @access public
	     * @param {number} sec - The duration, in seconds, of the animation.
	     * @returns {SCNAction} - 
	     * @desc When the action executes, the nodes opacity property animates from its current value to 1.0.This action is reversible; the reverse is created as if the following code had been executed:[SCNAction fadeOutWithDuration: sec];
	    [SCNAction fadeOutWithDuration: sec];
	      * @see https://developer.apple.com/reference/scenekit/scnaction/1522777-fadein
	     */

	  }, {
	    key: 'fadeInDuration',
	    value: function fadeInDuration(sec) {
	      //return SCNActionFade.fadeInDuration(sec)
	      throw new Error('not implemented');
	    }

	    /**
	     * Creates an action that changes the opacity of the node to 0.0.
	     * @access public
	     * @param {number} sec - The duration, in seconds, of the animation.
	     * @returns {SCNAction} - 
	     * @desc When the action executes, the nodes opacity property animates from its current value to 0.0.This action is reversible; the reverse is created as if the following code had been executed:[SCNAction fadeInWithDuration: sec];
	    [SCNAction fadeInWithDuration: sec];
	      * @see https://developer.apple.com/reference/scenekit/scnaction/1523922-fadeout
	     */

	  }, {
	    key: 'fadeOutDuration',
	    value: function fadeOutDuration(sec) {
	      //return SCNActionFade.fadeOutDuration(sec)
	      throw new Error('not implemented');
	    }

	    /**
	     * Creates an action that adjusts the opacity of a node by a relative value.
	     * @access public
	     * @param {number} factor - The amount to change the nodes opacity by.
	     * @param {number} sec - The duration, in seconds, of the animation.
	     * @returns {SCNAction} - 
	     * @desc When the action executes, the nodes opacity property animates to its new value.This action is reversible; the reverse is created as if the following code had been executed:[SCNAction fadeOpacityBy: -factor duration: sec];
	    [SCNAction fadeOpacityBy: -factor duration: sec];
	      * @see https://developer.apple.com/reference/scenekit/scnaction/1523595-fadeopacity
	     */

	  }, {
	    key: 'fadeOpacityByDuration',
	    value: function fadeOpacityByDuration(factor, sec) {
	      //return SCNActionFade.fadeOpacityByDuration(factor, sec)
	      throw new Error('not implemented');
	    }

	    /**
	     * Creates an action that adjusts the opacity of a node to a new value.
	     * @access public
	     * @param {number} opacity - The new opacity value of the node.
	     * @param {number} sec - The duration, in seconds, of the animation.
	     * @returns {SCNAction} - 
	     * @desc When the action executes, the nodes opacity property animates to its new value.This action is not reversible; the reverse of this action has the same duration but does not change anything.
	     * @see https://developer.apple.com/reference/scenekit/scnaction/1523875-fadeopacity
	     */

	  }, {
	    key: 'fadeOpacityToDuration',
	    value: function fadeOpacityToDuration(opacity, sec) {
	      //return SCNActionFade.fadeOpacityToDuration(opacity, sec)
	      throw new Error('not implemented');
	    }

	    // Creating Actions That Change a Nodes Visibility

	    /**
	     * Creates an action that hides a node.
	     * @access public
	     * @returns {SCNAction} - 
	     * @desc When the action executes, the nodes isHidden property is set to true.This action is reversible; the reverse is equivalent to the unhide() action.
	     * @see https://developer.apple.com/reference/scenekit/scnaction/1523487-hide
	     */

	  }, {
	    key: 'hide',
	    value: function hide() {
	      //return SCNActionHide.hide()
	      throw new Error('not implemented');
	    }

	    /**
	     * Creates an action that ensures a node is not hidden.
	     * @access public
	     * @returns {SCNAction} - 
	     * @desc When the action executes, the nodes isHidden property is set to false.This action is reversible; the reverse is equivalent to the hide() action.
	     * @see https://developer.apple.com/reference/scenekit/scnaction/1524205-unhide
	     */

	  }, {
	    key: 'unhide',
	    value: function unhide() {
	      //return SCNActionHide.unhide()
	      throw new Error('not implemented');
	    }

	    // Creating Actions That Remove Nodes from the Scene

	    /**
	     * Creates an action that removes the node from its parent.
	     * @access public
	     * @returns {SCNAction} - 
	     * @desc When the action executes, the node is immediately removed from its parent.This action is not reversible; the reverse of this action is the same action.
	     * @see https://developer.apple.com/reference/scenekit/scnaction/1522966-removefromparentnode
	     */

	  }, {
	    key: 'removeFromParentNode',
	    value: function removeFromParentNode() {
	      //return SCNActionRemove.removeFromParentNode()
	      throw new Error('not implemented');
	    }

	    // Creating Actions That Play Audio

	    /**
	     * Creates an action that plays an audio source.
	     * @access public
	     * @param {SCNAudioSource} source - The audio source to play.
	     * @param {boolean} wait - If true, the duration of this action is the same as the length of the audio playback. If false, the action is considered to have completed immediately.
	     * @returns {SCNAction} - 
	     * @desc When the action executes, SceneKit plays the audio source on the target nodeany positional audio effects are based on the nodes position. For more information about positional audio in SceneKit, see SCNAudioPlayer.This action is not reversible; the reverse of this action is the same action.
	     * @see https://developer.apple.com/reference/scenekit/scnaction/1523651-playaudio
	     */

	  }, {
	    key: 'playAudioWaitForCompletion',
	    value: function playAudioWaitForCompletion(source, wait) {
	      //return SCNActionPlaySound.playAudioWaitForCompletion(source, wait)
	      throw new Error('not implemented');
	    }

	    // Creating Actions That Combine or Repeat Other Actions

	    /**
	     * Creates an action that runs a collection of actions in parallel.
	     * @access public
	     * @param {SCNAction[]} actions - An array of SCNAction objects.
	     * @returns {SCNAction} - 
	     * @desc When the action executes, the actions that make up the group all start immediately and run in parallel. The duration of the group action is the longest duration among the collection of actions. If an action in the group has a duration less than the groups duration, the action completes and then idles until the group completes the remaining actions. This matters most when creating a repeating action that repeats a group.This action is reversible; it creates a new group action that contains the reverse of each action specified in the group. 
	     * @see https://developer.apple.com/reference/scenekit/scnaction/1522779-group
	     */

	  }, {
	    key: 'group',
	    value: function group(actions) {
	      //return SCNActionGroup.group(actions)
	      throw new Error('not implemented');
	    }

	    /**
	     * Creates an action that runs a collection of actions sequentially.
	     * @access public
	     * @param {SCNAction[]} actions - An array of SCNAction objects.
	     * @returns {SCNAction} - 
	     * @desc When the action executes, the first action in the sequence starts and runs to completion. Subsequent actions in the sequence run in a similar fashion until all of the actions in the sequence have executed. The duration of the sequence action is the sum of the durations of the actions in the sequence.This action is reversible; it creates a new sequence action that reverses the order of the actions. Each action in the reversed sequence is itself reversed. For example, the actions reverseSequence and sequenceReverse in the code example below are equivalent:SCNAction *sequence = [SCNAction sequence:@[ actionA, actionB, actionC ]];
	    SCNAction *reverseSequence = [SCNAction sequence:@[ [actionC reversedAction],
	                                                      [actionB reversedAction],
	                                                      [actionA reversedAction] ]];
	    SCNAction *sequenceReverse = [sequence reversedAction];
	    SCNAction *sequence = [SCNAction sequence:@[ actionA, actionB, actionC ]];
	    SCNAction *reverseSequence = [SCNAction sequence:@[ [actionC reversedAction],
	                                                      [actionB reversedAction],
	                                                      [actionA reversedAction] ]];
	    SCNAction *sequenceReverse = [sequence reversedAction];
	      * @see https://developer.apple.com/reference/scenekit/scnaction/1522793-sequence
	     */

	  }, {
	    key: 'sequence',
	    value: function sequence(actions) {
	      //return SCNActionSequence.sequence(actions)
	      throw new Error('not implemented');
	    }

	    /**
	     * Creates an action that repeats another action a specified number of times.
	     * @access public
	     * @param {SCNAction} action - The action to be executed.
	     * @param {number} count - The number of times to execute the action.
	     * @returns {SCNAction} - 
	     * @desc When the action executes, the associated action runs to completion and then repeats, until the count is reached.This action is reversible; it creates a new action that is the reverse of the specified action and then repeats it the same number of times.
	     * @see https://developer.apple.com/reference/scenekit/scnaction/1522764-repeat
	     */

	  }, {
	    key: 'repeat',
	    value: function repeat(action, count) {
	      //return SCNActionRepeat.repeat(action, count)
	      throw new Error('not implemented');
	    }

	    /**
	     * Creates an action that repeats another action forever.
	     * @access public
	     * @param {SCNAction} action - The action to execute.
	     * @returns {SCNAction} - 
	     * @desc When the action executes, the associated action runs to completion and then repeats.This action is reversible; it creates a new action that is the reverse of the specified action and then repeats it forever.NoteThe action to be repeated must have a non-instantaneous duration.
	     * @see https://developer.apple.com/reference/scenekit/scnaction/1522908-repeatforever
	     */

	  }, {
	    key: 'repeatForever',
	    value: function repeatForever(action) {
	      //return SCNActionRepeat.repeatForever(action)
	      throw new Error('not implemented');
	    }

	    // Creating Actions That Add Delays to Action Sequences

	    /**
	     * Creates an action that idles for a specified period of time.
	     * @access public
	     * @param {number} sec - The amount of time to wait.
	     * @returns {SCNAction} - 
	     * @desc When the action executes, the action waits for the specified amount of time and then ends. This is typically used as part of a sequence of actions to insert a delay between two other actions. You might also use it in conjunction with the runAction(_:completionHandler:) method to trigger code that needs to run at a later time.This action is not reversible; the reverse of this action is the same action.
	     * @see https://developer.apple.com/reference/scenekit/scnaction/1523915-wait
	     */

	  }, {
	    key: 'waitDuration',
	    value: function waitDuration(sec) {
	      //return SCNActionWait.waitDuration(sec)
	      throw new Error('not implemented');
	    }

	    /**
	     * Creates an action that idles for a randomized period of time.
	     * @access public
	     * @param {number} sec - The average amount of time to wait.
	     * @param {number} durationRange - The range of possible values for the duration.
	     * @returns {SCNAction} - 
	     * @desc When the action executes, the action waits for the specified amount of time and then ends. This is typically used as part of a sequence of actions to insert a delay between two other actions. However, you might also use it in conjunction with the runAction(_:completionHandler:) method to trigger code that needs to run at a later time.Each time the action is executed, the action computes a new random value for the duration. The duration may vary in either direction by up to half of the value of the durationRange parameter.This action is not reversible; the reverse of this action is the same action.
	     * @see https://developer.apple.com/reference/scenekit/scnaction/1523086-wait
	     */

	  }, {
	    key: 'waitDurationWithRange',
	    value: function waitDurationWithRange(sec, durationRange) {
	      //return SCNActionWait.waitDurationWithRange(sec, durationRange)
	      throw new Error('not implemented');
	    }

	    // Creating Custom Actions

	    /**
	     * Creates an action that executes a block.
	     * @access public
	     * @param {function(arg1: SCNNode): void} block - The block to run. The block takes a single parameter:nodeThe node on which the action is running.
	     * @returns {SCNAction} - 
	     * @desc When the action executes, SceneKit calls the block. This action takes place instantaneously.This action is not reversible; the reverse action executes the same block.
	     * @see https://developer.apple.com/reference/scenekit/scnaction/1523637-run
	     */

	  }, {
	    key: 'run',
	    value: function run(block) {
	      //return SCNActionRunBlock.run(block)
	      throw new Error('not implemented');
	    }

	    /**
	     * Creates an action that executes a block periodically over a specified duration.
	     * @access public
	     * @param {number} seconds - The duration of the action, in seconds.
	     * @param {function(arg1: SCNNode, arg2: number): void} block - The block to run. The block takes the following parameters:nodeThe node on which the action is running.elapsedTimeThe amount of time that has passed since the action began executing.
	     * @returns {SCNAction} - 
	     * @desc When the action executes, SceneKit calls the block repeatedly until the actions duration expires. For each call, SceneKit computes the elapsed time and passes it to the block.This action is not reversible; the reverse action executes the same block.
	     * @see https://developer.apple.com/reference/scenekit/scnaction/1523692-customaction
	     */

	  }, {
	    key: 'customActionDurationAction',
	    value: function customActionDurationAction(seconds, block) {
	      //return SCNActionCustom.customActionDurationAction(seconds, block)
	      throw new Error('not implemented');
	    }

	    /**
	     * Creates an action that executes a JavaScript script periodically over a specified duration.
	     * @access public
	     * @param {string} script - A string containing JavaScript source code.
	     * @param {number} seconds - The duration of the action, in seconds.
	     * @returns {SCNAction} - 
	     * @desc SceneKit exposes its classes, methods, and functions in the JavaScript context that runs the scriptsee the SCNJavaScript.h header file for details.When the action executes, SceneKit runs the script repeatedly until the actions duration expires. Each time SceneKit runs the script, it computes the elapsed time since the action began executing (as a fraction of the actions duration between 0.0 and 1.0) and makes it available to the script as a variable named elapsedTime. The script can also reference the SCNNode object running the action as a variable named node.This action is not reversible; the reverse action executes the same script.
	     * @see https://developer.apple.com/reference/scenekit/scnaction/1523984-javascriptaction
	     */

	  }, {
	    key: 'javaScriptActionWithScriptDuration',
	    value: function javaScriptActionWithScriptDuration(script, seconds) {
	      //return SCNActionJavaScript.javaScriptActionWithScriptDuration(script, seconds)
	      throw new Error('not implemented');
	    }
	  }]);

	  return SCNAction;
	}(_NSObject3.default);

	exports.default = SCNAction;

/***/ },
/* 61 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * Constants affecting the animation curve of an action, used by the timingMode property.
	 * @typedef {Object} SCNActionTimingMode
	 * @property {number} linear - Linear pacing. The animation progresses evenly throughout its duration.
	 * @property {number} easeIn - Ease-in pacing. The animation begins slowly, and then speeds up as it progresses.
	 * @property {number} easeOut - Ease-out pacing. The animation begins quickly, and then slows as it completes.
	 * @property {number} easeInEaseOut - Ease-in ease-out pacing. The animation begins slowly, accelerates through the middle of its duration, and then slows again before completing.
	 * @see https://developer.apple.com/reference/scenekit/scnactiontimingmode
	 */

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var SCNActionTimingMode = {
	  linear: 0,
	  easeIn: 1,
	  easeOut: 2,
	  easeInEaseOut: 3
	};

	exports.default = SCNActionTimingMode;

/***/ },
/* 62 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _SCNAction = __webpack_require__(60);

	var _SCNAction2 = _interopRequireDefault(_SCNAction);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	/**
	 * Methods for running actions on nodes.
	 * @interface
	 * @see https://developer.apple.com/reference/scenekit/scnactionable
	 */
	var SCNActionable = function () {
	  function SCNActionable() {
	    _classCallCheck(this, SCNActionable);
	  }

	  _createClass(SCNActionable, [{
	    key: 'init',


	    /**
	     * constructor
	     * @access public
	     * @returns {void}
	     */
	    value: function init() {

	      // Inspecting a Nodes Running Actions

	      this._hasActions = false;
	      this._actionKeys = null;
	    }

	    // Running Actions

	    /**
	     * Required. Adds an action to the list of actions executed by the node.
	     * @access public
	     * @param {SCNAction} action - The action to be performed.
	     * @returns {void}
	     * @desc SceneKit begins running a newly added action when it prepares to render the next frame.
	     * @see https://developer.apple.com/reference/scenekit/scnactionable/1523164-runaction
	     */

	  }, {
	    key: 'runAction',
	    value: function runAction(action) {}

	    /**
	     * Required. Adds an action to the list of actions executed by the node. SceneKit calls the specified block when the action completes.
	     * @access public
	     * @param {SCNAction} action - The action to be performed.
	     * @param {?function(): void} [block = null] - A completion block that SceneKit calls when the action completes.
	     * @returns {void}
	     * @desc The new action is processed the next time SceneKit prepares to render a frame.SceneKit calls your block after the actions duration is complete. For example, in a game you could use this method to show a Game Over message after performing a fade-out action on a node that displays a player character.
	     * @see https://developer.apple.com/reference/scenekit/scnactionable/1524219-runaction
	     */

	  }, {
	    key: 'runActionCompletionHandler',
	    value: function runActionCompletionHandler(action) {
	      var block = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
	    }

	    /**
	     * Required. Adds an identifiable action to the list of actions executed by the node.
	     * @access public
	     * @param {SCNAction} action - The action to be performed.
	     * @param {?string} key - A unique key used to identify the action.
	     * @returns {void}
	     * @desc This method is identical to runAction(_:), but the action is stored and identified so that you can retrieve or cancel it later. If an action using the same key is already running, SceneKit removes it before adding the new action.
	     * @see https://developer.apple.com/reference/scenekit/scnactionable/1524222-runaction
	     */

	  }, {
	    key: 'runActionForKey',
	    value: function runActionForKey(action, key) {}

	    /**
	     * Required. Adds an identifiable action to the list of actions executed by the node. SceneKit calls the specified block when the action completes.
	     * @access public
	     * @param {SCNAction} action - The action to be performed.
	     * @param {?string} key - A unique key used to identify the action.
	     * @param {?function(): void} [block = null] - A completion block called when the action completes.
	     * @returns {void}
	     * @desc This method is identical to runAction(_:completionHandler:), but the action is stored and identified so that you can retrieve or cancel it later. If an action using the same key is already running, SceneKit removes it before adding the new action.SceneKit calls your block after the actions duration is complete. For example, you can use this method with a wait action to execute some code after a timed delay. If during the delay period you need to prevent the code from running, use the removeAction(forKey:) method to cancel it.
	     * @see https://developer.apple.com/reference/scenekit/scnactionable/1522791-runaction
	     */

	  }, {
	    key: 'runActionForKeyCompletionHandler',
	    value: function runActionForKeyCompletionHandler(action, key) {
	      var block = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
	    }

	    // Inspecting a Nodes Running Actions

	    /**
	     * Required. Returns an action associated with a specific key.
	     * @access public
	     * @param {string} key - A string that uniquely identifies a action.
	     * @returns {?SCNAction} - 
	     * @desc Use this method to retrieve actions you scheduled using the runAction(_:forKey:) or runAction(_:forKey:completionHandler:) method.
	     * @see https://developer.apple.com/reference/scenekit/scnactionable/1523287-action
	     */

	  }, {
	    key: 'actionForKey',
	    value: function actionForKey(key) {
	      return null;
	    }
	    /**
	     * Required. A Boolean value that indicates whether the node is currently executing any actions.
	     * @type {boolean}
	     * @desc This value is true if the node has any executing actions; otherwise the value is false.
	     * @see https://developer.apple.com/reference/scenekit/scnactionable/1523794-hasactions
	     */

	  }, {
	    key: 'removeActionForKey',


	    // Canceling a Nodes Running Actions

	    /**
	     * Required. Removes an action associated with a specific key.
	     * @access public
	     * @param {string} key - A string that uniquely identifies a action.
	     * @returns {void}
	     * @desc If the node is currently running an action that matches the key, SceneKit removes that action from the node, skipping any remaining animation it would perform but keeping any changes already made to the node.Use this method to cancel actions you scheduled using the runAction(_:forKey:) or runAction(_:forKey:completionHandler:) method.
	     * @see https://developer.apple.com/reference/scenekit/scnactionable/1523617-removeaction
	     */
	    value: function removeActionForKey(key) {}

	    /**
	     * Required. Ends and removes all actions from the node.
	     * @access public
	     * @returns {void}
	     * @desc When SceneKit removes an action from a node, it skips any remaining animation the action would perform. However, any changes the action has already made to the nodes state remain in effect.
	     * @see https://developer.apple.com/reference/scenekit/scnactionable/1524181-removeallactions
	     */

	  }, {
	    key: 'removeAllActions',
	    value: function removeAllActions() {}
	  }, {
	    key: 'hasActions',
	    get: function get() {
	      return this._hasActions;
	    }
	    /**
	     * Required. The list of keys for which the node has attached actions.
	     * @type {string[]}
	     * @desc Use this property to list actions you scheduled using the runAction(_:forKey:) or runAction(_:forKey:completionHandler:) method.
	     * @see https://developer.apple.com/reference/scenekit/scnactionable/1523036-actionkeys
	     */

	  }, {
	    key: 'actionKeys',
	    get: function get() {
	      return this._actionKeys;
	    }
	  }]);

	  return SCNActionable;
	}();

	exports.default = SCNActionable;

/***/ },
/* 63 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _SCNAction2 = __webpack_require__(60);

	var _SCNAction3 = _interopRequireDefault(_SCNAction2);

	var _SCNActionTimingMode = __webpack_require__(61);

	var _SCNActionTimingMode2 = _interopRequireDefault(_SCNActionTimingMode);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var SCNActionCustom = function (_SCNAction) {
	  _inherits(SCNActionCustom, _SCNAction);

	  _createClass(SCNActionCustom, null, [{
	    key: '_propTypes',
	    get: function get() {
	      return {
	        _actions: 'NSArray',
	        _finished: 'boolean',
	        _duration: 'float',
	        _timingMode: 'integer',
	        _beginTime: 'float',
	        _isRunning: 'boolean',
	        _pausedTime: 'float'
	      };
	    }

	    /**
	     * constructor
	     * @access public
	     * @constructor
	     */

	  }]);

	  function SCNActionCustom() {
	    _classCallCheck(this, SCNActionCustom);

	    var _this = _possibleConstructorReturn(this, (SCNActionCustom.__proto__ || Object.getPrototypeOf(SCNActionCustom)).call(this));

	    _this._actions = [];
	    _this._finished = false;
	    _this._duration = 0;
	    _this._timingMode = _SCNActionTimingMode2.default.linear;
	    _this._beginTime = 0;
	    _this._isRunning = false;
	    _this._pausedTime = 0;
	    return _this;
	  }

	  return SCNActionCustom;
	}(_SCNAction3.default);

	exports.default = SCNActionCustom;

/***/ },
/* 64 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _SCNAction2 = __webpack_require__(60);

	var _SCNAction3 = _interopRequireDefault(_SCNAction2);

	var _SCNActionTimingMode = __webpack_require__(61);

	var _SCNActionTimingMode2 = _interopRequireDefault(_SCNActionTimingMode);

	var _SCNNode = __webpack_require__(65);

	var _SCNNode2 = _interopRequireDefault(_SCNNode);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var SCNActionFade = function (_SCNAction) {
	  _inherits(SCNActionFade, _SCNAction);

	  _createClass(SCNActionFade, null, [{
	    key: '_propTypes',
	    get: function get() {
	      return {
	        _actions: 'NSArray',
	        _finished: 'boolean',
	        _duration: 'float',
	        _timingMode: 'integer',
	        _beginTime: 'float',
	        _isRunning: 'boolean',
	        _pausedTime: 'float',

	        name: ['string', null]
	      };
	    }

	    /**
	     * constructor
	     * @access public
	     * @constructor
	     */

	  }]);

	  function SCNActionFade() {
	    _classCallCheck(this, SCNActionFade);

	    var _this = _possibleConstructorReturn(this, (SCNActionFade.__proto__ || Object.getPrototypeOf(SCNActionFade)).call(this));

	    _this._actions = [];
	    _this._finished = false;
	    _this._duration = 0;
	    _this._timingMode = _SCNActionTimingMode2.default.linear;
	    _this._beginTime = 0;
	    _this._isRunning = false;
	    _this._pausedTime = 0;

	    _this._toValue = null;
	    _this._byValue = null;
	    return _this;
	  }

	  /**
	   * Creates an action that changes the opacity of the node to 1.0.
	   * @access public
	   * @param {number} sec - The duration, in seconds, of the animation.
	   * @returns {SCNAction} - 
	   * @desc When the action executes, the nodes opacity property animates from its current value to 1.0.This action is reversible; the reverse is created as if the following code had been executed:[SCNAction fadeOutWithDuration: sec];
	  [SCNAction fadeOutWithDuration: sec];
	    * @see https://developer.apple.com/reference/scenekit/scnaction/1522777-fadein
	   */


	  _createClass(SCNActionFade, [{
	    key: 'copy',


	    /**
	     * @access public
	     * @returns {SCNActionFade} -
	     */
	    value: function copy() {
	      var action = _get(SCNActionFade.prototype.__proto__ || Object.getPrototypeOf(SCNActionFade.prototype), 'copy', this).call(this);

	      action._toValue = this._toValue;
	      action._byValue = this._byValue;
	      action._duration = this._duration;

	      return action;
	    }

	    /**
	     * apply action to the given node.
	     * @access private
	     * @param {Object} obj - target object to apply this action.
	     * @param {number} time - active time
	     * @param {boolean} [needTimeConversion = true] -
	     * @returns {void}
	     */

	  }, {
	    key: '_applyAction',
	    value: function _applyAction(obj, time) {
	      var needTimeConversion = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

	      var t = this._getTime(time, needTimeConversion);
	      if (!(obj instanceof _SCNNode2.default)) {
	        throw new Error('unsupported class for SCNActionFade: ' + obj.constructor.name);
	      }

	      var baseValue = obj.opacity;
	      var toValue = 0;
	      if (this._toValue !== null) {
	        toValue = this._toValue;
	      } else if (this._byValue !== null) {
	        toValue = baseValue + this._byValue;
	      } else {
	        throw new Error('both toValue and byValue are null');
	      }

	      var value = this._lerp(baseValue, toValue, t);
	      //console.warn(`opacity time: ${time}, t: ${t}, base: ${baseValue}, to: ${toValue}, val: ${value}`)
	      obj.presentation.opacity = value;

	      if (this._finished) {
	        obj.opacity = toValue;
	      }
	    }
	  }], [{
	    key: 'fadeInDuration',
	    value: function fadeInDuration(sec) {
	      var action = new SCNActionFade();
	      action._toValue = 1;
	      action._duration = sec;
	      return action;
	    }

	    /**
	     * Creates an action that changes the opacity of the node to 0.0.
	     * @access public
	     * @param {number} sec - The duration, in seconds, of the animation.
	     * @returns {SCNAction} - 
	     * @desc When the action executes, the nodes opacity property animates from its current value to 0.0.This action is reversible; the reverse is created as if the following code had been executed:[SCNAction fadeInWithDuration: sec];
	    [SCNAction fadeInWithDuration: sec];
	      * @see https://developer.apple.com/reference/scenekit/scnaction/1523922-fadeout
	     */

	  }, {
	    key: 'fadeOutDuration',
	    value: function fadeOutDuration(sec) {
	      var action = new SCNActionFade();
	      action._toValue = 0;
	      action._duration = sec;
	      return action;
	    }

	    /**
	     * Creates an action that adjusts the opacity of a node by a relative value.
	     * @access public
	     * @param {number} factor - The amount to change the nodes opacity by.
	     * @param {number} sec - The duration, in seconds, of the animation.
	     * @returns {SCNAction} - 
	     * @desc When the action executes, the nodes opacity property animates to its new value.This action is reversible; the reverse is created as if the following code had been executed:[SCNAction fadeOpacityBy: -factor duration: sec];
	    [SCNAction fadeOpacityBy: -factor duration: sec];
	      * @see https://developer.apple.com/reference/scenekit/scnaction/1523595-fadeopacity
	     */

	  }, {
	    key: 'fadeOpacityByDuration',
	    value: function fadeOpacityByDuration(factor, sec) {
	      var action = new SCNActionFade();
	      action._byValue = factor;
	      action._duration = sec;
	      return action;
	    }

	    /**
	     * Creates an action that adjusts the opacity of a node to a new value.
	     * @access public
	     * @param {number} opacity - The new opacity value of the node.
	     * @param {number} sec - The duration, in seconds, of the animation.
	     * @returns {SCNAction} - 
	     * @desc When the action executes, the nodes opacity property animates to its new value.This action is not reversible; the reverse of this action has the same duration but does not change anything.
	     * @see https://developer.apple.com/reference/scenekit/scnaction/1523875-fadeopacity
	     */

	  }, {
	    key: 'fadeOpacityToDuration',
	    value: function fadeOpacityToDuration(opacity, sec) {
	      var action = new SCNActionFade();
	      action._toValue = opacity;
	      action._duration = sec;
	      return action;
	    }
	  }]);

	  return SCNActionFade;
	}(_SCNAction3.default);

	exports.default = SCNActionFade;


	_SCNAction3.default.fadeInDuration = SCNActionFade.fadeInDuration;
	_SCNAction3.default.fadeOutDuration = SCNActionFade.fadeOutDuration;
	_SCNAction3.default.fadeOpacityByDuration = SCNActionFade.fadeOpacityByDuration;
	_SCNAction3.default.fadeOpacityToDuration = SCNActionFade.fadeOpacityToDuration;

/***/ },
/* 65 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _CAAnimationGroup = __webpack_require__(54);

	var _CAAnimationGroup2 = _interopRequireDefault(_CAAnimationGroup);

	var _CABasicAnimation = __webpack_require__(55);

	var _CABasicAnimation2 = _interopRequireDefault(_CABasicAnimation);

	var _CAMediaTimingFunction = __webpack_require__(51);

	var _CAMediaTimingFunction2 = _interopRequireDefault(_CAMediaTimingFunction);

	var _CAKeyframeAnimation = __webpack_require__(59);

	var _CAKeyframeAnimation2 = _interopRequireDefault(_CAKeyframeAnimation);

	var _NSObject2 = __webpack_require__(2);

	var _NSObject3 = _interopRequireDefault(_NSObject2);

	var _SCNActionable = __webpack_require__(62);

	var _SCNActionable2 = _interopRequireDefault(_SCNActionable);

	var _SCNAnimatable = __webpack_require__(66);

	var _SCNAnimatable2 = _interopRequireDefault(_SCNAnimatable);

	var _SCNBoundingVolume = __webpack_require__(67);

	var _SCNBoundingVolume2 = _interopRequireDefault(_SCNBoundingVolume);

	var _SCNGeometry = __webpack_require__(68);

	var _SCNGeometry2 = _interopRequireDefault(_SCNGeometry);

	var _SCNGeometrySource = __webpack_require__(71);

	var _SCNGeometrySource2 = _interopRequireDefault(_SCNGeometrySource);

	var _SCNLight = __webpack_require__(84);

	var _SCNLight2 = _interopRequireDefault(_SCNLight);

	var _SCNCamera = __webpack_require__(130);

	var _SCNCamera2 = _interopRequireDefault(_SCNCamera);

	var _SCNMorpher = __webpack_require__(137);

	var _SCNMorpher2 = _interopRequireDefault(_SCNMorpher);

	var _SCNSkinner = __webpack_require__(139);

	var _SCNSkinner2 = _interopRequireDefault(_SCNSkinner);

	var _SCNMatrix = __webpack_require__(46);

	var _SCNMatrix2 = _interopRequireDefault(_SCNMatrix);

	var _SCNMatrix4MakeScale = __webpack_require__(140);

	var _SCNMatrix4MakeScale2 = _interopRequireDefault(_SCNMatrix4MakeScale);

	var _SCNMatrix4MakeTranslation = __webpack_require__(78);

	var _SCNMatrix4MakeTranslation2 = _interopRequireDefault(_SCNMatrix4MakeTranslation);

	var _SCNVector = __webpack_require__(44);

	var _SCNVector2 = _interopRequireDefault(_SCNVector);

	var _SCNVector3 = __webpack_require__(45);

	var _SCNVector4 = _interopRequireDefault(_SCNVector3);

	var _SCNQuaternion = __webpack_require__(57);

	var _SCNQuaternion2 = _interopRequireDefault(_SCNQuaternion);

	var _SCNConstraint = __webpack_require__(141);

	var _SCNConstraint2 = _interopRequireDefault(_SCNConstraint);

	var _SCNMovabilityHint = __webpack_require__(142);

	var _SCNMovabilityHint2 = _interopRequireDefault(_SCNMovabilityHint);

	var _SCNNodeRendererDelegate = __webpack_require__(143);

	var _SCNNodeRendererDelegate2 = _interopRequireDefault(_SCNNodeRendererDelegate);

	var _SCNOrderedDictionary = __webpack_require__(79);

	var _SCNOrderedDictionary2 = _interopRequireDefault(_SCNOrderedDictionary);

	var _SCNPhysicsBody = __webpack_require__(103);

	var _SCNPhysicsBody2 = _interopRequireDefault(_SCNPhysicsBody);

	var _SCNPhysicsField = __webpack_require__(144);

	var _SCNPhysicsField2 = _interopRequireDefault(_SCNPhysicsField);

	var _SCNParticleSystem = __webpack_require__(107);

	var _SCNParticleSystem2 = _interopRequireDefault(_SCNParticleSystem);

	var _SCNTransaction = __webpack_require__(80);

	var _SCNTransaction2 = _interopRequireDefault(_SCNTransaction);

	var _SCNAudioPlayer = __webpack_require__(147);

	var _SCNAudioPlayer2 = _interopRequireDefault(_SCNAudioPlayer);

	var _SCNHitTestResult = __webpack_require__(106);

	var _SCNHitTestResult2 = _interopRequireDefault(_SCNHitTestResult);

	var _SKColor = __webpack_require__(11);

	var _SKColor2 = _interopRequireDefault(_SKColor);

	var _constants = __webpack_require__(49);

	var Constants = _interopRequireWildcard(_constants);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/*global Ammo*/

	/**
	 * A structural element of a scene graph, representing a position and transform in a 3D coordinate space, to which you can attach geometry, lights, cameras, or other displayable content.
	 * @access public
	 * @extends {NSObject}
	 * @implements {SCNActionable}
	 * @implements {SCNAnimatable}
	 * @implements {SCNBoundingVolume}
	 * @see https://developer.apple.com/reference/scenekit/scnnode
	 */
	var SCNNode = function (_NSObject) {
	  _inherits(SCNNode, _NSObject);

	  _createClass(SCNNode, null, [{
	    key: '_propTypes',
	    get: function get() {
	      var _this2 = this;

	      return {
	        name: 'string',
	        light: 'SCNLight',
	        camera: 'SCNCamera',
	        geometry: ['SCNGeometry', function (obj, value) {
	          obj.geometry = value;
	          obj.boundingBox = value.boundingBox;
	        }],
	        morpher: 'SCNMorpher',
	        skinner: 'SCNSkinner',
	        categoryBitMask: 'integer',
	        paused: ['boolean', 'isPaused'],
	        position: ['SCNVector3', '_position'],
	        rotation: ['SCNVector4', '_rotation'],
	        scale: ['SCNVector3', '_scale'],
	        hidden: ['boolean', 'isHidden'],
	        opacity: 'float',
	        renderingOrder: 'integer',
	        castsShadow: 'boolean',
	        childNodes: ['NSArray', function (obj, childNodes) {
	          childNodes.forEach(function (child) {
	            obj.addChildNode(child);
	          });
	        }],
	        physicsBody: ['SCNPhysicsBody', function (obj, body) {
	          obj.physicsBody = body;
	        }],
	        physicsField: 'SCNPhysicsField',
	        particleSystem: ['NSArray', '_particleSystems'],
	        'animation-keys': ['NSArray', null],
	        animations: ['NSMutableDictionary', function (obj, anims) {
	          _this2._loadAnimationArray(obj, anims);
	        }],
	        'action-keys': ['NSArray', null],
	        actions: ['NSMutableDictionary', function (obj, acts) {
	          _this2._loadActionArray(obj, acts);
	        }],
	        eulerAngles: ['SCNVector3', function (obj, value) {
	          obj.eulerAngles = value;
	        }],
	        movabilityHint: 'integer',

	        clientAttributes: ['NSMutableDictionary', null],
	        nodeID: ['string', '_nodeID'],
	        entityID: ['string', '_entityID']
	      };
	    }

	    // Creating a Node

	    /**
	     * Creates and returns a node object with the specified geometry attached.
	     * @access public
	     * @constructor
	     * @param {?SCNGeometry} [geometry = null] - The geometry to be attached.
	     * @see https://developer.apple.com/reference/scenekit/scnnode/1408020-init
	     */

	  }]);

	  function SCNNode() {
	    var geometry = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

	    _classCallCheck(this, SCNNode);

	    // Managing Node Attributes

	    /**
	     * A name associated with the node.
	     * @type {?string}
	     * @see https://developer.apple.com/reference/scenekit/scnnode/1408014-name
	     */
	    var _this = _possibleConstructorReturn(this, (SCNNode.__proto__ || Object.getPrototypeOf(SCNNode)).call(this));

	    _this.name = null;

	    /**
	     * The light attached to the node.
	     * @type {?SCNLight}
	     * @see https://developer.apple.com/reference/scenekit/scnnode/1408004-light
	     */
	    _this.light = null;

	    /**
	     * The camera attached to the node.
	     * @type {?SCNCamera}
	     * @see https://developer.apple.com/reference/scenekit/scnnode/1407976-camera
	     */
	    _this.camera = null;

	    /**
	     * The geometry attached to the node.
	     * @type {?SCNGeometry}
	     * @see https://developer.apple.com/reference/scenekit/scnnode/1407966-geometry
	     */
	    _this._geometry = geometry;

	    /**
	     * The morpher object responsible for blending the nodes geometry.
	     * @type {?SCNMorpher}
	     * @see https://developer.apple.com/reference/scenekit/scnnode/1408022-morpher
	     */
	    _this.morpher = null;

	    /**
	     * The skinner object responsible for skeletal animations of nodes contents.
	     * @type {?SCNSkinner}
	     * @see https://developer.apple.com/reference/scenekit/scnnode/1407953-skinner
	     */
	    _this.skinner = null;

	    /**
	     * A mask that defines which categories the node belongs to.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnnode/1407994-categorybitmask
	     */
	    _this.categoryBitMask = 0;

	    // Working With Node Animation

	    /**
	     * A Boolean value that determines whether to run actions and animations attached to the node and its child nodes.
	     * @type {boolean}
	     * @see https://developer.apple.com/reference/scenekit/scnnode/1407962-ispaused
	     */
	    _this.isPaused = false;

	    /**
	     * A node object representing the state of the node as it currently appears onscreen.
	     * @type {SCNNode}
	     * @access private
	     * @see https://developer.apple.com/reference/scenekit/scnnode/1408030-presentation
	     */
	    _this._presentation = null;

	    /**
	     * 
	     * @type {boolean}
	     * @access private
	     */
	    _this._isPresentationInstance = false;

	    // Managing the Nodes Transformation

	    /**
	     * The transformation applied to the node relative to its parent. Animatable.
	     * @type {SCNMatrix4}
	     * @access private
	     * @see https://developer.apple.com/reference/scenekit/scnnode/1407964-transform
	     */
	    _this._transform = new _SCNMatrix2.default();

	    _this._worldTransform = new _SCNMatrix2.default();

	    /**
	     * 
	     * @type {boolean}
	     * @access private
	     */
	    _this._transformUpToDate = false;

	    /**
	     * The translation applied to the node. Animatable.
	     * @type {SCNVector3}
	     * @see https://developer.apple.com/reference/scenekit/scnnode/1408026-position
	     */
	    _this._position = new _SCNVector2.default(0, 0, 0);

	    /**
	     * The nodes orientation, expressed as a rotation angle about an axis. Animatable.
	     * @type {SCNVector4}
	     * @see https://developer.apple.com/reference/scenekit/scnnode/1408034-rotation
	     */
	    _this._rotation = new _SCNVector4.default(1, 0, 0, 0);

	    /**
	     * The nodes orientation, expressed as pitch, yaw, and roll angles, each in radians. Animatable.
	     * @type {SCNVector3}
	     * @see https://developer.apple.com/reference/scenekit/scnnode/1407980-eulerangles
	     */
	    //this.eulerAngles = null

	    /**
	     * The nodes orientation, expressed as a quaternion. Animatable.
	     * @type {SCNQuaternion}
	     * @see https://developer.apple.com/reference/scenekit/scnnode/1408048-orientation
	     */
	    //this.orientation = null

	    /**
	     * The scale factor applied to the node. Animatable.
	     * @type {SCNVector3}
	     * @see https://developer.apple.com/reference/scenekit/scnnode/1408050-scale
	     */
	    _this._scale = new _SCNVector2.default(1, 1, 1);

	    /**
	     * The pivot point for the nodes position, rotation, and scale. Animatable.
	     * @type {SCNMatrix4}
	     * @see https://developer.apple.com/reference/scenekit/scnnode/1408044-pivot
	     */
	    _this.pivot = null;

	    /**
	     * A list of constraints affecting the nodes transformation.
	     * @type {?SCNConstraint[]}
	     * @see https://developer.apple.com/reference/scenekit/scnnode/1408016-constraints
	     */
	    _this.constraints = null;

	    //this._worldTransform = null

	    // Modifying the Node Visibility

	    /**
	     * A Boolean value that determines the visibility of the nodes contents. Animatable.
	     * @type {boolean}
	     * @see https://developer.apple.com/reference/scenekit/scnnode/1407967-ishidden
	     */
	    _this.isHidden = false;

	    /**
	     * The opacity value of the node. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnnode/1408010-opacity
	     */
	    _this.opacity = 1;

	    /**
	     * The order the nodes content is drawn in relative to that of other nodes.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnnode/1407978-renderingorder
	     */
	    _this.renderingOrder = 0;

	    /**
	     * A Boolean value that determines whether SceneKit renders the nodes contents into shadow maps.
	     * @type {boolean}
	     * @see https://developer.apple.com/reference/scenekit/scnnode/1407955-castsshadow
	     */
	    _this.castsShadow = false;

	    /**
	     * A value that indicates how SceneKit should handle the node when rendering movement-related effects.
	     * @type {SCNMovabilityHint}
	     * @see https://developer.apple.com/reference/scenekit/scnnode/1690499-movabilityhint
	     */
	    _this.movabilityHint = _SCNMovabilityHint2.default.fixed;

	    // Managing the Node Hierarchy

	    /**
	     * The nodes parent in the scene graph hierarchy.
	     * @type {?SCNNode}
	     * @access private
	     * @see https://developer.apple.com/reference/scenekit/scnnode/1407968-parent
	     */
	    _this._parent = null;

	    /**
	     * An array of the nodes children in the scene graph hierarchy.
	     * @type {SCNNode[]}
	     * @access private
	     * @see https://developer.apple.com/reference/scenekit/scnnode/1407984-childnodes
	     */
	    _this._childNodes = [];

	    // Customizing Node Rendering

	    /**
	     * An array of Core Image filters to be applied to the rendered contents of the node.
	     * @type {?CIFilter[]}
	     * @see https://developer.apple.com/reference/scenekit/scnnode/1407949-filters
	     */
	    _this.filters = null;

	    /**
	     * An object responsible for rendering custom contents for the node using Metal or OpenGL.
	     * @type {?SCNNodeRendererDelegate}
	     * @see https://developer.apple.com/reference/scenekit/scnnode/1408012-rendererdelegate
	     */
	    _this.rendererDelegate = null;

	    // Adding Physics to a Node

	    /**
	     * The physics body associated with the node.
	     * @type {?SCNPhysicsBody}
	     * @see https://developer.apple.com/reference/scenekit/scnnode/1407988-physicsbody
	     */
	    _this._physicsBody = null;

	    /**
	     * The physics field associated with the node.
	     * @type {?SCNPhysicsField}
	     * @see https://developer.apple.com/reference/scenekit/scnnode/1408006-physicsfield
	     */
	    _this.physicsField = null;

	    // Working With Particle Systems

	    _this._particleSystems = null;

	    // Working With Positional Audio

	    _this._audioPlayers = [];

	    ///////////////////
	    // SCNActionable //
	    ///////////////////

	    // Inspecting a Nodes Running Action
	    //this._hasActions = false

	    /**
	     * @access private
	     * @type {Map}
	     */
	    _this._actions = new Map();

	    ///////////////////
	    // SCNAnimatable //
	    ///////////////////

	    /**
	     * @access private
	     * @type {SCNOrderedDictionary}
	     */
	    _this._animations = new _SCNOrderedDictionary2.default();

	    ///////////////////////
	    // SCNBoundingVolume //
	    ///////////////////////

	    // Working with Bounding Volumes

	    /**
	     * The minimum and maximum corner points of the objects bounding box.
	     * @type {{min: SCNVector3, max: SCNVector3}}
	     * @see https://developer.apple.com/reference/scenekit/scnboundingvolume/2034705-boundingbox
	     */
	    _this._boundingBox = null;
	    _this._fixedBoundingBox = null;

	    //this._boundingSphere = null


	    /**
	     * @access private
	     * @type {?string}
	     */
	    _this._entityID = null;

	    /**
	     * @access private
	     * @type {?string}
	     */
	    _this._nodeID = null;

	    _this._updateBoundingBox();
	    return _this;
	  }

	  _createClass(SCNNode, [{
	    key: '_updateWorldTransform',
	    value: function _updateWorldTransform() {
	      var p = null;
	      if (this._parent === null) {
	        p = (0, _SCNMatrix4MakeTranslation2.default)(0, 0, 0);
	      } else {
	        p = this._parent._worldTransform;
	      }
	      this._worldTransform = this.transform.mult(p);

	      if (this._presentation) {
	        var pp = null;
	        if (this._parent === null) {
	          pp = (0, _SCNMatrix4MakeTranslation2.default)(0, 0, 0);
	        } else if (this._parent._presentation === null) {
	          pp = this._parent._worldTransform;
	        } else {
	          pp = this._parent._presentation._worldTransform;
	        }
	        this._presentation._updateTransform();
	        this._presentation._worldTransform = this._presentation.transform.mult(pp);
	      }

	      this._childNodes.forEach(function (child) {
	        child._updateWorldTransform();
	      });
	    }

	    /*
	    _updatePresentationTransform() {
	      let p = null
	      if(this._parent === null){
	        p = SCNMatrix4MakeTranslation(0, 0, 0)
	      }else{
	        p = this._parent._presentation._worldTransform
	      }
	      
	      this._presentation._worldTransform = this._presentation.transform.mult(parentTransform)
	      this._childNodes.forEach((child) => {
	        child._updatePrsentationTransform(this._presentation._worldTransform)
	      })
	    }
	    */

	    /**
	     * The translation applied to the node. Animatable.
	     * @type {SCNVector3}
	     * @see https://developer.apple.com/reference/scenekit/scnnode/1408026-position
	     */

	  }, {
	    key: 'addChildNode',


	    // Managing the Node Hierarchy

	    /**
	     * Adds a node to the nodes array of children.
	     * @access public
	     * @param {SCNNode} child - The node to be added.
	     * @returns {void}
	     * @desc Calling this method appends the node to the end of the childNodes array.
	     * @see https://developer.apple.com/reference/scenekit/scnnode/1407974-addchildnode
	     */
	    value: function addChildNode(child) {
	      if (this._childNodes.indexOf(child) >= 0) {
	        return;
	      }
	      child.removeFromParentNode();
	      this._childNodes.push(child);
	      child._parent = this;
	    }

	    /**
	     * Adds a node to the nodes array of children at a specified index.
	     * @access public
	     * @param {SCNNode} child - The node to be inserted.ImportantRaises an exception (invalidArgumentException) if child is nil.
	     * @param {number} index - The position at which to insert the new child node.ImportantRaises an exception (rangeException) if index is greater than the number of elements in the nodes childNodes array.
	     * @returns {void}
	     * @see https://developer.apple.com/reference/scenekit/scnnode/1407958-insertchildnode
	     */

	  }, {
	    key: 'insertChildNodeAt',
	    value: function insertChildNodeAt(child, index) {
	      if (this._childNodes.indexOf(child) >= 0) {
	        return;
	      }
	      child.removeFromParentNode();
	      this._insertObjectInChildNodesAtIndex(child, index);
	      this._parent = this;
	    }

	    /**
	     * Removes the node from its parents array of child nodes.
	     * @access public
	     * @returns {void}
	     * @desc Removing nodes from the node hierarchy serves two purposes. Nodes own their contents (child nodes or attached lights, geometries, and other objects), so deallocating unneeded nodes can reduce memory usage. Additionally, SceneKit does more work at rendering time with a large, complex node hierarchy, so removing nodes whose contents you dont need to display can improve rendering performance.
	     * @see https://developer.apple.com/reference/scenekit/scnnode/1407991-removefromparentnode
	     */

	  }, {
	    key: 'removeFromParentNode',
	    value: function removeFromParentNode() {
	      var parentNode = this._parent;
	      if (parentNode === null) {
	        return;
	      }
	      var index = parentNode._childNodes.indexOf(this);
	      if (index < 0) {
	        return;
	      }
	      parentNode._removeObjectFromChildNodesAtIndex(index);
	    }

	    /**
	     * Removes a child from the nodes array of children and inserts another node in its place. 
	     * @access public
	     * @param {SCNNode} oldChild - 
	     * @param {SCNNode} newChild - 
	     * @returns {void}
	     * @desc If both the child and child2 nodes are children of the node, calling this method swaps their positions in the array. Note that removing a node from the node hierarchy may result in it being deallocated.Calling this method results in undefined behavior if the child parameter does not refer to a child of this node.
	     * @see https://developer.apple.com/reference/scenekit/scnnode/1408002-replacechildnode
	     */

	  }, {
	    key: 'replaceChildNodeWith',
	    value: function replaceChildNodeWith(oldChild, newChild) {
	      var index = this._childNodes.indexOf(oldChild);
	      if (index < 0) {
	        return;
	      }
	      this._removeObjectFromChildNodesAtIndex(index);
	      this._insertObjectInChildNodesAtIndex(newChild, index);
	    }

	    /**
	     *
	     * @access private
	     * @param {number} index -
	     * @returns {void}
	     */

	  }, {
	    key: '_removeObjectFromChildNodesAtIndex',
	    value: function _removeObjectFromChildNodesAtIndex(index) {
	      var arr = this._childNodes.splice(index, 1);
	      if (arr.length === 0) {
	        return;
	      }
	      var obj = arr[0];

	      obj._parent = null;
	      obj._transformUpToDate = false;
	    }

	    /**
	     *
	     * @access private
	     * @param {SCNNode} object -
	     * @param {number} index -
	     * @returns {void}
	     */

	  }, {
	    key: '_insertObjectInChildNodesAtIndex',
	    value: function _insertObjectInChildNodesAtIndex(object, index) {
	      var length = this._childNodes.length;
	      if (index > length) {
	        throw new Error('SCNNode.childNodes out of index: ' + index + ' > ' + length);
	      }
	      this._childNodes.splice(index, 0, object);
	    }

	    /**
	     * The nodes parent in the scene graph hierarchy.
	     * @type {?SCNNode}
	     * @desc For a scenes rootNode object, the value of this property is nil.
	     * @see https://developer.apple.com/reference/scenekit/scnnode/1407968-parent
	     */

	  }, {
	    key: 'childNodesPassingTest',


	    // Searching the Node Hierarchy

	    /**
	     * Returns all nodes in the nodes child node subtree that satisfy the test applied by a block.
	     * @access public
	     * @param {function(child: SCNNode, stop: UnsafeMutablePointer<ObjCBool>): boolean} predicate - The block to apply to the nodes child and descendant nodes .The block takes two parameters:child The child node currently being searched. stop A reference to a Boolean value. Set *stop to true in the block to abort further processing of the child node subtree.The block returns a Boolean value indicating whether to include the child node in the search results array.
	     * @returns {SCNNode[]} - 
	     * @desc Use this method to search for nodes using a test you specify. For example, you can search for empty nodes using a block that returns YES for nodes whose light, camera, and geometry properties are all nil.SceneKit uses a recursive preorder traversal to search the child node subtreethat is, the block searches a node before it searches each of the nodes children, and it searches all children of a node before searching any of that nodes sibling nodes.
	     * @see https://developer.apple.com/reference/scenekit/scnnode/1407982-childnodes
	     */
	    value: function childNodesPassingTest(predicate) {
	      var result = [];
	      return result;
	    }

	    /**
	     * Returns the first node in the nodes child node subtree with the specified name.
	     * @access public
	     * @param {string} name - The name of the node to search for.
	     * @param {boolean} [recursively = true] - true to search the entire child node subtree, or false to search only the nodes immediate children.
	     * @returns {?SCNNode} - 
	     * @desc If the recursive parameter is true, SceneKit uses a preorder traversal to search the child node subtreethat is, the block searches a node before it searches each of the nodes children, and it searches all children of a node before searching any of that nodes sibling nodes. Otherwise, SceneKit searches only those nodes in the nodes childNodes array.
	     * @see https://developer.apple.com/reference/scenekit/scnnode/1407951-childnode
	     */

	  }, {
	    key: 'childNodeWithNameRecursively',
	    value: function childNodeWithNameRecursively(name) {
	      var recursively = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

	      for (var i = 0; i < this._childNodes.length; i++) {
	        if (this._childNodes[i].name === name) {
	          return this._childNodes[i];
	        }
	        if (recursively) {
	          var result = this._childNodes[i].childNodeWithNameRecursively(name, recursively);
	          if (result !== null) {
	            return result;
	          }
	        }
	      }

	      return null;
	    }

	    /**
	     * Returns the first node in the nodes child nodearray with the specified name.
	     * @access public
	     * @param {string} name - The name of the node to search for.
	     * @returns {?SCNNode} - 
	     * @desc SceneKit searches only those nodes in the nodes childNodes array.
	     * @see https://developer.apple.com/reference/scenekit/scnnode/1407951-childnode
	     */

	  }, {
	    key: 'childNodeWithName',
	    value: function childNodeWithName(name) {
	      return this.childNodeWithNameRecursively(name, false);
	    }

	    /**
	     * @access private
	     * @param {string} nodeID -
	     * @param {boolean} recursively -
	     * @returns {?SCNNode} -
	     */

	  }, {
	    key: '_childNodeWithNodeIDRecursively',
	    value: function _childNodeWithNodeIDRecursively(nodeID) {
	      var recursively = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

	      for (var i = 0; i < this._childNodes.length; i++) {
	        if (this._childNodes[i]._nodeID === nodeID) {
	          return this._childNodes[i];
	        }
	        if (recursively) {
	          var result = this._childNodes[i]._childNodeWithNodeIDRecursively(nodeID, recursively);
	          if (result !== null) {
	            return result;
	          }
	        }
	      }

	      return null;
	    }

	    /**
	     * @access private
	     * @param {string} nodeID -
	     * @returns {?SCNNode} -
	     */

	  }, {
	    key: '_childNodeWithNodeID',
	    value: function _childNodeWithNodeID(nodeID) {
	      return this._childNodeWithNodeIDRecursively(name, false);
	    }

	    /**
	     * Executes the specified block for each of the nodes child and descendant nodes.
	     * @access public
	     * @param {function(child: SCNNode, stop: UnsafeMutablePointer<ObjCBool>): void} block - The block to apply to the nodes child and descendant nodes.The block takes two parameters:childThe child node currently being evaluated.stopA reference to a Boolean value. Set *stop to true in the block to abort further processing of the child node subtree.
	     * @returns {void}
	     * @desc SceneKit uses a recursive preorder traversal to process the child node subtreethat is, the block runs for a node before it runs for each of the nodes children, and it processes all children of a node before processing any of that nodes sibling nodes.
	     * @see https://developer.apple.com/reference/scenekit/scnnode/1408032-enumeratechildnodes
	     */

	  }, {
	    key: 'enumerateChildNodes',
	    value: function enumerateChildNodes(block) {
	      var _this3 = this;

	      //this._childNodes.some((child) => {
	      this.childNodes.some(function (child) {
	        return _this3._enumerateChildNodesRecursive(child, block);
	      });
	    }

	    /**
	     * Executes the specified block for each of the nodes child and descendant nodes, as well as for the node itself.
	     * @access public
	     * @param {function(arg1: SCNNode, arg2: UnsafeMutablePointer<ObjCBool>): void} block - The block to apply to the nodes child and descendant nodes.The block takes two parameters:childThe child node currently being evaluated.stopA reference to a Boolean value. Set *stop to true in the block to abort further processing of the child node subtree.
	     * @returns {void}
	     * @desc SceneKit uses a recursive preorder traversal to process the child node subtreethat is, the block runs for a node before it runs for each of the nodes children, and it processes all children of a node before processing any of that nodes sibling nodes.This method is equivalent to the enumerateChildNodes(_:) method, but unlike that method it also runs the block to process the node itself, not just its child nodes.
	     * @see https://developer.apple.com/reference/scenekit/scnnode/1642248-enumeratehierarchy
	     */

	  }, {
	    key: 'enumerateHierarchy',
	    value: function enumerateHierarchy(block) {
	      this._enumerateChildNodesRecursive(this, block);
	    }
	  }, {
	    key: '_enumerateChildNodesRecursive',
	    value: function _enumerateChildNodesRecursive(node, block) {
	      var _this4 = this;

	      var stop = block(node);
	      if (stop === true) {
	        return true;
	      }
	      stop = node._childNodes.some(function (child) {
	        return _this4._enumerateChildNodesRecursive(child, block);
	      });
	      return stop;
	    }

	    // Adding Physics to a Node

	  }, {
	    key: 'addParticleSystem',


	    // Working With Particle Systems

	    /**
	     * Attaches a particle system to the node.
	     * @access public
	     * @param {SCNParticleSystem} system - A particle system.
	     * @returns {void}
	     * @desc When attached to a node, a particle systems emitter location follows that node as it moves through the scene. To instead attach a particle system to a location in the scenes world coordinate space, use the corresponding method on SCNScene.For details on particle systems, see SCNParticleSystem.
	     * @see https://developer.apple.com/reference/scenekit/scnnode/1523123-addparticlesystem
	     */
	    value: function addParticleSystem(system) {
	      if (this._particleSystems === null) {
	        this._particleSystems = [];
	      }
	      system.reset();
	      this._particleSystems.push(system);
	    }

	    /**
	     * Removes a particle system attached to the node.
	     * @access public
	     * @param {SCNParticleSystem} system - A particle system.
	     * @returns {void}
	     * @desc This method has no effect if the system parameter does not reference a particle system directly attached to the node.
	     * @see https://developer.apple.com/reference/scenekit/scnnode/1524014-removeparticlesystem
	     */

	  }, {
	    key: 'removeParticleSystem',
	    value: function removeParticleSystem(system) {
	      if (this._particleSystems === null) {
	        return;
	      }
	      var index = this._particleSystems.indexOf(system);
	      this._particleSystems.splice(index, 1);
	    }

	    /**
	     * Removes any particle systems directly attached to the node.
	     * @access public
	     * @returns {void}
	     * @see https://developer.apple.com/reference/scenekit/scnnode/1522801-removeallparticlesystems
	     */

	  }, {
	    key: 'removeAllParticleSystems',
	    value: function removeAllParticleSystems() {
	      this._particleSystems = [];
	    }

	    /**
	     * The particle systems attached to the node.
	     * @access public
	     * @type {?SCNParticleSystem[]}
	     * @desc An array of SCNParticleSystem objects directly attached to the node. This array does not include particle systems attached to the node's child nodes. For details on particle systems, see SCNParticleSystem.
	     * @see https://developer.apple.com/reference/scenekit/scnnode/1522705-particlesystems
	     */

	  }, {
	    key: 'addAudioPlayer',


	    // Working With Positional Audio

	    /**
	     * Adds the specified auto player to the node and begins playback.
	     * @access public
	     * @param {SCNAudioPlayer} player - An audio player object.
	     * @returns {void}
	     * @desc Positional audio effects from a player attached to a node are based on that nodes position relative to the audioListener position in the scene.After playback has completed, SceneKit automatically removes the audio player from the node.
	     * @see https://developer.apple.com/reference/scenekit/scnnode/1523464-addaudioplayer
	     */
	    value: function addAudioPlayer(player) {
	      if (this._audioPlayers.indexOf(player) < 0) {
	        this._audioPlayers.push(player);
	        player._play();
	      }
	    }

	    /**
	     * Removes the specified audio player from the node, stopping playback.
	     * @access public
	     * @param {SCNAudioPlayer} player - An audio player attached to the node.
	     * @returns {void}
	     * @desc This method has no effect if the player parameter does not reference an audio player directly attached to the node.
	     * @see https://developer.apple.com/reference/scenekit/scnnode/1522767-removeaudioplayer
	     */

	  }, {
	    key: 'removeAudioPlayer',
	    value: function removeAudioPlayer(player) {
	      var index = this._audioPlayers.indexOf(player);
	      if (index >= 0) {
	        player._stop();
	        delete this._audioPlayers[index];
	      }
	    }

	    /**
	     * Removes all audio players attached to the node, stopping playback.
	     * @access public
	     * @returns {void}
	     * @see https://developer.apple.com/reference/scenekit/scnnode/1523570-removeallaudioplayers
	     */

	  }, {
	    key: 'removeAllAudioPlayers',
	    value: function removeAllAudioPlayers() {
	      this._audioPlayers.forEach(function (player) {
	        player._stop();
	      });
	      this._audioPlayers = [];
	    }

	    /**
	     * The audio players currently attached to the node.
	     * @type {SCNAudioPlayer[]}
	     * @desc Positional audio effects from a player attached to a node are based on that nodes position relative to the audioListener position in the scene.After an audio player completes playback, SceneKit automatically removes it from the node. Therefore, this array always contains audio players that are currently playing back audio.
	     * @see https://developer.apple.com/reference/scenekit/scnnode/1523244-audioplayers
	     */

	  }, {
	    key: 'clone',


	    // Copying a Node

	    /**
	     * Creates a copy of the node and its children.
	     * @access public
	     * @returns {SCNNode} - 
	     * @desc This method recursively copies the node and its child nodes. For a nonrecursive copy, use the inherited copy() method, which creates a copy of the node without any child nodes.Cloning or copying a node creates a duplicate of the node object, but not the geometries, lights, cameras, and other SceneKit objects attached to itinstead, each copied node shares references to these objects.This behavior means that you can use cloning to, for example, place the same geometry at several locations within a scene without  maintaining multiple copies of the geometry and its materials. However, it also means that changes to the objects attached to one node will affect other nodes that share the same attachments. For example, to render two copies of a node using different materials, you must copy both the node and its geometry before assigning a new material.- (void)duplicateNode:(SCNNode *)node withMaterial:(SCNMaterial *)material
	    {
	      SCNNode *newNode = [node clone];
	      newNode.geometry = [node.geometry copy];
	      newNode.geometry.firstMaterial = material;
	    }
	    Multiple copies of an SCNGeometry object efficiently share the same vertex data, so you can copy geometries without a significant performance penalty.- (void)duplicateNode:(SCNNode *)node withMaterial:(SCNMaterial *)material
	    {
	      SCNNode *newNode = [node clone];
	      newNode.geometry = [node.geometry copy];
	      newNode.geometry.firstMaterial = material;
	    }
	      * @see https://developer.apple.com/reference/scenekit/scnnode/1408046-clone
	     */
	    value: function clone() {
	      var node = this.copy();

	      this._childNodes.forEach(function (child) {
	        node.addChildNode(child.clone());
	      });

	      return node;
	    }

	    /**
	     * Creates an optimized copy of the node and its children.
	     * @access public
	     * @returns {SCNNode} - 
	     * @desc Rendering complex node hierarchies can incur a performance cost. Each geometry and material requires a separate draw command to be sent to the GPU, and each draw command comes with a performance overhead. If you plan for a portion of your scenes node hierarchy to remain static (with respect to itself, if not the rest of the scene), use this method to create a single node containing all elements of that node hierarchy that SceneKit can render using fewer draw commands.
	     * @see https://developer.apple.com/reference/scenekit/scnnode/1407960-flattenedclone
	     */

	  }, {
	    key: 'flattenedClone',
	    value: function flattenedClone() {
	      return null;
	    }

	    // Hit-Testing

	    /**
	     * Searches the nodes child node subtree for objects intersecting a line segment between two specified points.
	     * @access public
	     * @param {SCNVector3} pointA - An endpoint of the line segment to search along, specified in the nodes local coordinate system.
	     * @param {SCNVector3} pointB - The other endpoint of the line segment to search along, specified in the nodes local coordinate system.
	     * @param {?Map<string, Object>} [options = null] - A dictionary of options affecting the search. See Hit Testing Options Keys for acceptable values.
	     * @returns {SCNHitTestResult[]} - 
	     * @desc Hit-testing is the process of finding elements of a scene located along a specified line segment in the scenes coordinate space (or that of a particular node in the scene). For example, you can use this method to determine whether a projectile launched by a game character will hit its target.To search for the scene element corresponding to a two-dimensional point in the rendered image, use the renderers hitTest(_:options:) method instead.
	     * @see https://developer.apple.com/reference/scenekit/scnnode/1407998-hittestwithsegment
	     */

	  }, {
	    key: 'hitTestWithSegmentFromTo',
	    value: function hitTestWithSegmentFromTo(pointA, pointB) {
	      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

	      return null;
	    }

	    // Converting Between Node Coordinate Spaces

	    /**
	     * Converts a position to the nodes coordinate space from that defined by another node.
	     * @access public
	     * @param {SCNVector3} position - A position in the local coordinate space defined by the other node.
	     * @param {?SCNNode} node - Another node in the same scene graph as the node, or nil to convert from the scenes world coordinate space.
	     * @returns {SCNVector3} - 
	     * @see https://developer.apple.com/reference/scenekit/scnnode/1408018-convertposition
	     */

	  }, {
	    key: 'convertPositionFrom',
	    value: function convertPositionFrom(position, node) {
	      if (node === null) {
	        return position.transform(this._worldTransform.invert());
	      }
	      return position.transform(node._worldTransform).transform(this._worldTransoform.invert());
	    }

	    /**
	     * Converts a position from the nodes coordinate space to that defined by another node.
	     * @access public
	     * @param {SCNVector3} position - A position in the nodes local coordinate space.
	     * @param {?SCNNode} node - Another node in the same scene graph as the node, or nil to convert to the scenes world coordinate space.
	     * @returns {SCNVector3} - 
	     * @see https://developer.apple.com/reference/scenekit/scnnode/1407990-convertposition
	     */

	  }, {
	    key: 'convertPositionTo',
	    value: function convertPositionTo(position, node) {
	      if (node === null) {
	        return position.transform(this._worldTransform);
	      }
	      return position.transform(this._worldTransform).transform(node._worldTransform.invert());
	    }

	    /**
	     * Converts a transformation to the nodes coordinate space from that defined by another node.
	     * @access public
	     * @param {SCNMatrix4} transform - A transformation relative to the local coordinate space defined by the other node.
	     * @param {?SCNNode} node - Another node in the same scene graph as the node, or nil to convert from the scenes world coordinate space.
	     * @returns {SCNMatrix4} - 
	     * @see https://developer.apple.com/reference/scenekit/scnnode/1407996-converttransform
	     */

	  }, {
	    key: 'convertTransformFrom',
	    value: function convertTransformFrom(transform) {
	      var node = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

	      if (node === null) {
	        return transform.mult(this._worldTransform.invert());
	      }
	      return transform.mult(node._worldTransform).mult(this._worldTransform.invert());
	    }

	    /**
	     * Converts a transformation from the nodes coordinate space to that defined by another node.
	     * @access public
	     * @param {SCNMatrix4} transform - A transformation relative to the nodes coordinate space.
	     * @param {?SCNNode} node - Another node in the same scene graph as the node, or nil to convert to the scenes world coordinate space.
	     * @returns {SCNMatrix4} - 
	     * @see https://developer.apple.com/reference/scenekit/scnnode/1407986-converttransform
	     */

	  }, {
	    key: 'convertTransformTo',
	    value: function convertTransformTo(transform) {
	      var node = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

	      if (node === null) {
	        return transform.mult(this._worldTransform);
	      }
	      return transform.mult(this._worldTransform).mult(node._worldTransform.invert());
	    }

	    ///////////////////
	    // SCNActionable //
	    ///////////////////

	    // Running Actions

	    /**
	     * Required. Adds an action to the list of actions executed by the node.
	     * @access public
	     * @param {SCNAction} action - The action to be performed.
	     * @returns {void}
	     * @desc SceneKit begins running a newly added action when it prepares to render the next frame.
	     * @see https://developer.apple.com/reference/scenekit/scnactionable/1523164-runaction
	     */

	  }, {
	    key: 'runAction',
	    value: function runAction(action) {
	      this.runActionForKey(action, Symbol());
	    }

	    /**
	     * Required. Adds an action to the list of actions executed by the node. SceneKit calls the specified block when the action completes.
	     * @access public
	     * @param {SCNAction} action - The action to be performed.
	     * @param {?function(): void} [block = null] - A completion block that SceneKit calls when the action completes.
	     * @returns {void}
	     * @desc The new action is processed the next time SceneKit prepares to render a frame.SceneKit calls your block after the actions duration is complete. For example, in a game you could use this method to show a Game Over message after performing a fade-out action on a node that displays a player character.
	     * @see https://developer.apple.com/reference/scenekit/scnactionable/1524219-runaction
	     */

	  }, {
	    key: 'runActionCompletionHandler',
	    value: function runActionCompletionHandler(action) {
	      var block = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
	    }

	    /**
	     * Required. Adds an identifiable action to the list of actions executed by the node.
	     * @access public
	     * @param {SCNAction} action - The action to be performed.
	     * @param {?string} key - A unique key used to identify the action.
	     * @returns {void}
	     * @desc This method is identical to runAction(_:), but the action is stored and identified so that you can retrieve or cancel it later. If an action using the same key is already running, SceneKit removes it before adding the new action.
	     * @see https://developer.apple.com/reference/scenekit/scnactionable/1524222-runaction
	     */

	  }, {
	    key: 'runActionForKey',
	    value: function runActionForKey(action, key) {
	      this.runActionForKeyCompletionHandler(action, key, null);
	    }

	    /**
	     * Required. Adds an identifiable action to the list of actions executed by the node. SceneKit calls the specified block when the action completes.
	     * @access public
	     * @param {SCNAction} action - The action to be performed.
	     * @param {?string} key - A unique key used to identify the action.
	     * @param {?function(): void} [block = null] - A completion block called when the action completes.
	     * @returns {void}
	     * @desc This method is identical to runAction(_:completionHandler:), but the action is stored and identified so that you can retrieve or cancel it later. If an action using the same key is already running, SceneKit removes it before adding the new action.SceneKit calls your block after the actions duration is complete. For example, you can use this method with a wait action to execute some code after a timed delay. If during the delay period you need to prevent the code from running, use the removeAction(forKey:) method to cancel it.
	     * @see https://developer.apple.com/reference/scenekit/scnactionable/1522791-runaction
	     */

	  }, {
	    key: 'runActionForKeyCompletionHandler',
	    value: function runActionForKeyCompletionHandler(action, key) {
	      var block = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

	      if (typeof key === 'undefined' || key === null) {
	        key = Symbol();
	      }
	      var act = action.copy();
	      // FIXME: use current frame time
	      act._actionStartTime = Date.now() * 0.001;
	      act._completionHandler = block;
	      this._actions.set(key, act);
	      //this._copyTransformToPresentationRecursive()
	    }

	    // Inspecting a Nodes Running Actions

	    /**
	     * Required. Returns an action associated with a specific key.
	     * @access public
	     * @param {string} key - A string that uniquely identifies a action.
	     * @returns {?SCNAction} - 
	     * @desc Use this method to retrieve actions you scheduled using the runAction(_:forKey:) or runAction(_:forKey:completionHandler:) method.
	     * @see https://developer.apple.com/reference/scenekit/scnactionable/1523287-action
	     */

	  }, {
	    key: 'actionForKey',
	    value: function actionForKey(key) {
	      return this._actions.get(key);
	    }

	    /**
	     * Required. A Boolean value that indicates whether the node is currently executing any actions.
	     * @type {boolean}
	     * @desc This value is true if the node has any executing actions; otherwise the value is false.
	     * @see https://developer.apple.com/reference/scenekit/scnactionable/1523794-hasactions
	     */

	  }, {
	    key: 'removeActionForKey',


	    // Canceling a Nodes Running Actions

	    /**
	     * Required. Removes an action associated with a specific key.
	     * @access public
	     * @param {string} key - A string that uniquely identifies a action.
	     * @returns {void}
	     * @desc If the node is currently running an action that matches the key, SceneKit removes that action from the node, skipping any remaining animation it would perform but keeping any changes already made to the node.Use this method to cancel actions you scheduled using the runAction(_:forKey:) or runAction(_:forKey:completionHandler:) method.
	     * @see https://developer.apple.com/reference/scenekit/scnactionable/1523617-removeaction
	     */
	    value: function removeActionForKey(key) {
	      // TODO: stop action
	      this._actions.delete(key);
	    }

	    /**
	     * Required. Ends and removes all actions from the node.
	     * @access public
	     * @returns {void}
	     * @desc When SceneKit removes an action from a node, it skips any remaining animation the action would perform. However, any changes the action has already made to the nodes state remain in effect.
	     * @see https://developer.apple.com/reference/scenekit/scnactionable/1524181-removeallactions
	     */

	  }, {
	    key: 'removeAllActions',
	    value: function removeAllActions() {
	      // TODO: stop actions
	      this._actions.clear();
	    }

	    ///////////////////
	    // SCNAnimatable //
	    ///////////////////

	    // Managing Animations

	    /**
	     * Required. Adds an animation object for the specified key.
	     * @access public
	     * @param {CAAnimation} animation - The animation object to be added.
	     * @param {?string} key - An string identifying the animation for later retrieval. You may pass nil if you dont need to reference the animation later.
	     * @returns {void}
	     * @desc Newly added animations begin executing after the current run loop cycle ends.SceneKit does not define any requirements for the contents of the key parameterit need only be unique among the keys for other animations you add. If you add an animation with an existing key, this method overwrites the existing animation.
	     * @see https://developer.apple.com/reference/scenekit/scnanimatable/1523386-addanimation
	     */

	  }, {
	    key: 'addAnimationForKey',
	    value: function addAnimationForKey(animation, key) {
	      if (typeof key === 'undefined' || key === null) {
	        key = Symbol();
	      }
	      var anim = animation.copy();
	      // FIXME: use current frame time
	      anim._animationStartTime = Date.now() * 0.001;

	      this._animations.set(key, anim);
	      this._copyTransformToPresentationRecursive();
	    }

	    /**
	     * @access private
	     * @param {CAAnimation} animatino -
	     * @param {number} time -
	     * @returns {void}
	     */
	    /*
	    _setAnimationStartTime(animation, time) {
	      animation._animationStartTime = time
	      animation._prevTime = time - 0.0000001
	      if(animation instanceof CAAnimationGroup){
	        animation.animations.forEach((anim) => {
	          this._setAnimationStartTime(anim, time)
	        })
	      }
	    }
	    */

	    /**
	     * Required. Returns the animation with the specified key.
	     * @access public
	     * @param {string} key - A string identifying a previously added animation.
	     * @returns {?CAAnimation} - 
	     * @desc Attempting to modify any properties of the returned object results in undefined behavior.
	     * @see https://developer.apple.com/reference/scenekit/scnanimatable/1524020-animation
	     */

	  }, {
	    key: 'animationForKey',
	    value: function animationForKey(key) {
	      return this._animations.get(key);
	    }

	    /**
	     * Required. Removes all the animations currently attached to the object.
	     * @access public
	     * @returns {void}
	     * @see https://developer.apple.com/reference/scenekit/scnanimatable/1522762-removeallanimations
	     */

	  }, {
	    key: 'removeAllAnimations',
	    value: function removeAllAnimations() {
	      // TODO: stop animations
	      this._animations.clear();
	    }

	    /**
	     * Required. Removes the animation attached to the object with the specified key.
	     * @access public
	     * @param {string} key - A string identifying an attached animation to remove.
	     * @returns {void}
	     * @see https://developer.apple.com/reference/scenekit/scnanimatable/1522880-removeanimation
	     */

	  }, {
	    key: 'removeAnimationForKey',
	    value: function removeAnimationForKey(key) {
	      this._animations.delete(key);
	      this._copyTransformToPresentationRecursive();
	    }

	    /**
	     * Required. Removes the animation attached to the object with the specified key, smoothly transitioning out of the animations effect.
	     * @access public
	     * @param {string} key - A string identifying an attached animation to remove.
	     * @param {number} duration - The duration for transitioning out of the animations effect before it is removed.
	     * @returns {void}
	     * @desc Use this method to create smooth transitions between the effects of multiple animations. For example, the geometry loaded from a scene file for a game character may have associated animations for player actions such as walking and jumping. When the player lands from a jump, you remove the jump animation so the character continues walking. If you use the removeAnimation(forKey:) method to remove the jump animation, SceneKit abruptly switches from the current frame of the jump animation to the current frame of the walk animation. If you use the removeAnimation(forKey:fadeOutDuration:) method instead, SceneKit plays both animations at once during that duration and interpolates vertex positions from one animation to the other, creating a smooth transition.
	     * @see https://developer.apple.com/reference/scenekit/scnanimatable/1522841-removeanimation
	     */

	  }, {
	    key: 'removeAnimationForKeyFadeOutDuration',
	    value: function removeAnimationForKeyFadeOutDuration(key, duration) {
	      // FIXME: use fadeout duration
	      this.removeAnimationForKey(key);
	    }

	    /**
	     * Required. An array containing the keys of all animations currently attached to the object.
	     * @type {string[]}
	     * @desc This array contains all keys for which animations are attached to the object, or is empty if there are no attached animations. The ordering of animation keys in the array is arbitrary.
	     * @see https://developer.apple.com/reference/scenekit/scnanimatable/1523610-animationkeys
	     */

	  }, {
	    key: 'pauseAnimationForKey',


	    // Pausing and Resuming Animations

	    /**
	     * Required. Pauses the animation attached to the object with the specified key.
	     * @access public
	     * @param {string} key - A string identifying an attached animation.
	     * @returns {void}
	     * @desc This method has no effect if no animation is attached to the object with the specified key.
	     * @see https://developer.apple.com/reference/scenekit/scnanimatable/1523592-pauseanimation
	     */
	    value: function pauseAnimationForKey(key) {}

	    /**
	     * Required. Resumes a previously paused animation attached to the object with the specified key.
	     * @access public
	     * @param {string} key - A string identifying an attached animation.
	     * @returns {void}
	     * @desc This method has no effect if no animation is attached to the object with the specified key or if the specified animation is not currently paused.
	     * @see https://developer.apple.com/reference/scenekit/scnanimatable/1523332-resumeanimation
	     */

	  }, {
	    key: 'resumeAnimationForKey',
	    value: function resumeAnimationForKey(key) {}

	    /**
	     * Required. Returns a Boolean value indicating whether the animation attached to the object with the specified key is paused.
	     * @access public
	     * @param {string} key - A string identifying an attached animation.
	     * @returns {boolean} - 
	     * @see https://developer.apple.com/reference/scenekit/scnanimatable/1523703-isanimationpaused
	     */

	  }, {
	    key: 'isAnimationPausedForKey',
	    value: function isAnimationPausedForKey(key) {
	      return false;
	    }

	    // Instance Methods

	    /**
	     * Required. 
	     * @access public
	     * @param {number} speed - 
	     * @param {string} key - 
	     * @returns {void}
	     * @see https://developer.apple.com/reference/scenekit/scnanimatable/1778343-setanimationspeed
	     */

	  }, {
	    key: 'setAnimationSpeedForKey',
	    value: function setAnimationSpeedForKey(speed, key) {}

	    ///////////////////////
	    // SCNBoundingVolume //
	    ///////////////////////

	    // Working with Bounding Volumes

	    /**
	     * The minimum and maximum corner points of the objects bounding box.
	     * @type {{min: SCNVector3, max: SCNVector3}}
	     * @see https://developer.apple.com/reference/scenekit/scnboundingvolume/2034705-boundingbox
	     */

	  }, {
	    key: '_geometryBoundingBox',
	    value: function _geometryBoundingBox() {
	      if (this._geometry === null) {
	        return {
	          min: new _SCNVector2.default(Infinity, Infinity, Infinity),
	          max: new _SCNVector2.default(-Infinity, -Infinity, -Infinity)
	        };
	      }
	      return this._geometry.boundingBox;
	    }
	  }, {
	    key: '_updateBoundingBox',
	    value: function _updateBoundingBox() {
	      // FIXME: use rotation of the node
	      var box = this._geometryBoundingBox();
	      var p = this.presentation ? this.presentation : this;
	      if (p.geometry !== null) {
	        box = this._unionBoundingBox(box, p.geometry.boundingBox);
	      }
	      var scale = p._scale;
	      if (scale.x < 0) {
	        var minX = box.max.x * scale.x;
	        var maxX = box.min.x * scale.x;
	        box.min.x = minX;
	        box.max.x = maxX;
	      } else {
	        box.min.x *= scale.x;
	        box.max.x *= scale.x;
	      }
	      if (scale.y < 0) {
	        var minY = box.max.y * scale.y;
	        var maxY = box.min.y * scale.y;
	        box.min.y = minY;
	        box.max.y = maxY;
	      } else {
	        box.min.y *= scale.y;
	        box.max.y *= scale.y;
	      }
	      if (scale.z < 0) {
	        var minZ = box.max.z * scale.z;
	        var maxZ = box.min.z * scale.z;
	        box.min.z = minZ;
	        box.max.z = maxZ;
	      } else {
	        box.min.z *= scale.z;
	        box.max.z *= scale.z;
	      }

	      var _iteratorNormalCompletion = true;
	      var _didIteratorError = false;
	      var _iteratorError = undefined;

	      try {
	        for (var _iterator = this._childNodes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	          var child = _step.value;

	          var cbox = child._updateBoundingBox();
	          box = this._unionChildBoundingBox(box, cbox);
	        }
	      } catch (err) {
	        _didIteratorError = true;
	        _iteratorError = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion && _iterator.return) {
	            _iterator.return();
	          }
	        } finally {
	          if (_didIteratorError) {
	            throw _iteratorError;
	          }
	        }
	      }

	      this._boundingBox = box;
	      return box;
	    }
	  }, {
	    key: '_unionBoundingBox',
	    value: function _unionBoundingBox(box1, box2) {
	      if (box1 === null) {
	        return box2;
	      }
	      if (box2 === null) {
	        return box1;
	      }
	      var min = new _SCNVector2.default();
	      var max = new _SCNVector2.default();
	      min.x = Math.min(box1.min.x, box2.min.x);
	      min.y = Math.min(box1.min.y, box2.min.y);
	      min.z = Math.min(box1.min.z, box2.min.z);
	      max.x = Math.max(box1.max.x, box2.max.x);
	      max.y = Math.max(box1.max.y, box2.max.y);
	      max.z = Math.max(box1.max.z, box2.max.z);
	      return { min: min, max: max };
	    }
	  }, {
	    key: '_unionChildBoundingBox',
	    value: function _unionChildBoundingBox(box, cbox) {
	      var p = this.presentation ? this.presentation : this;
	      var pos = p._position;
	      var scale = p._scale;
	      var min = new _SCNVector2.default((cbox.min.x + pos.x) * scale.x, (cbox.min.y + pos.y) * scale.y, (cbox.min.z + pos.z) * scale.z);
	      var max = new _SCNVector2.default((cbox.max.x + pos.x) * scale.x, (cbox.max.y + pos.y) * scale.y, (cbox.max.z + pos.z) * scale.z);
	      return this._unionBoundingBox(box, { min: min, max: max });
	    }
	  }, {
	    key: '_updateTransform',
	    value: function _updateTransform() {
	      var m1 = _SCNMatrix2.default.matrixWithScale(this._scale);
	      var m2 = m1.rotation(this._rotation);
	      var m3 = m2.translation(this._position);
	      this._transform = m3;
	      this._transformUpToDate = true;
	    }

	    /**
	     *
	     * @access public
	     * @returns {SCNNode} -
	     */

	  }, {
	    key: 'copy',
	    value: function copy() {
	      var node = new SCNNode();
	      node.name = this.name;
	      node.light = this.light;
	      node.camera = this.camera;
	      node._geometry = this._geometry;
	      node.morpher = this.morpher;
	      node.skinner = this.skinner;
	      node.categoryBitMask = this.categoryBitMask;
	      node.isPaused = this.isPaused;
	      node._presentation = this._presentation ? this._presentation.copy() : null;
	      node._isPresentationInstance = this._isPresentationInstance;
	      node.constraints = this.constraints ? this.constraints.slice(0) : null;
	      node.isHidden = this.isHidden;
	      node.opacity = this.opacity;
	      node.renderingOrder = this.renderingOrder;
	      node.castsShadow = this.castsShadow;
	      node.movabilityHint = this.movabilityHint;
	      node.filters = this.filters ? this.filters.slice() : null;
	      node.rendererDelegate = this.rendererDelegate;
	      node._physicsBody = this._physicsBody; // FIXME: copy
	      node.physicsField = this.physicsField;
	      node._particleSystems = this._particleSystems ? this._particleSystems.slice(0) : null;
	      node._audioPlayers = this._audioPlayers;
	      //node._hasActions = this._hasActions
	      node._actions = new Map(this._actions);
	      node._animations = this._animations.copy();
	      node._boundingBox = this._boundingBox;
	      //node._boundingSphere = this._boundingSphere

	      node._position = new _SCNVector2.default(this._position.x, this._position.y, this._position.z);
	      node._rotation = new _SCNVector4.default(this._rotation.x, this._rotation.y, this._rotation.z, this._rotation.w);
	      node._scale = new _SCNVector2.default(this._scale.x, this._scale.y, this._scale.z);
	      node._transformUpToDate = false;

	      return node;
	    }
	  }, {
	    key: '_copyTransformToPresentation',
	    value: function _copyTransformToPresentation() {
	      if (this._presentation === null) {
	        return;
	      }
	      var p = this._presentation;
	      p._position = this._position._copy();
	      p._rotation = this._rotation._copy();
	      p._scale = this._scale._copy();
	    }
	  }, {
	    key: '_copyTransformToPresentationRecursive',
	    value: function _copyTransformToPresentationRecursive() {
	      var nodes = [this];
	      while (nodes.length > 0) {
	        var node = nodes.shift();
	        node._copyTransformToPresentation();
	        nodes.push.apply(nodes, _toConsumableArray(node._childNodes));
	      }
	    }
	  }, {
	    key: '_copyMaterialPropertiesToPresentation',
	    value: function _copyMaterialPropertiesToPresentation() {
	      if (this._geometry) {
	        var _iteratorNormalCompletion2 = true;
	        var _didIteratorError2 = false;
	        var _iteratorError2 = undefined;

	        try {
	          for (var _iterator2 = this._geometry.materials[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
	            var material = _step2.value;

	            material._copyPresentationProperties();
	          }
	        } catch (err) {
	          _didIteratorError2 = true;
	          _iteratorError2 = err;
	        } finally {
	          try {
	            if (!_iteratorNormalCompletion2 && _iterator2.return) {
	              _iterator2.return();
	            }
	          } finally {
	            if (_didIteratorError2) {
	              throw _iteratorError2;
	            }
	          }
	        }
	      }
	    }
	  }, {
	    key: 'valueForUndefinedKey',


	    /**
	     * Invoked by value(forKey:) when it finds no property corresponding to a given key.
	     * @access public
	     * @param {string} key - A string that is not equal to the name of any of the receiver's properties.
	     * @returns {?Object} - 
	     * @desc Subclasses can override this method to return an alternate value for undefined keys. The default implementation raises an NSUndefinedKeyException.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1413457-value
	     */
	    value: function valueForUndefinedKey(key) {
	      if (key.charAt(0) === '/') {
	        var nodeID = key.substr(1);
	        if (this._nodeID === nodeID) {
	          return this;
	        }
	        var node = this._childNodeWithNodeIDRecursively(nodeID);
	        if (node) {
	          return node;
	        }
	      }
	      return _get(SCNNode.prototype.__proto__ || Object.getPrototypeOf(SCNNode.prototype), 'valueForUndefinedKey', this).call(this, key);
	    }
	  }, {
	    key: 'valueForKeyPath',
	    value: function valueForKeyPath(keyPath) {
	      var usePresentation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

	      // FIXME: check flags to decide to use a presentation node
	      var target = usePresentation && this._presentation ? this._presentation : this;
	      var paths = keyPath.split('.');
	      var key = paths[0];
	      var key2 = paths[1];

	      if (key === 'position') {
	        if (key2) {
	          return target.position[key2];
	        }
	        return target.position;
	      } else if (key === 'rotation') {
	        if (key2) {
	          return target.rotation[key2];
	        }
	        return target.rotation;
	      } else if (key === 'scale') {
	        if (key2) {
	          return target.scale[key2];
	        }
	        return target.scale;
	      } else if (key === 'eulerAngles') {
	        if (key2) {
	          return target.eulerAngles[key2];
	        }
	        return target.eulerAngles;
	      } else if (key === 'orientation') {
	        if (key2) {
	          return target.orientation[key2];
	        }
	        return target.orientation;
	      } else if (key === 'transform') {
	        if (key2) {
	          return target.transform[key2];
	        }
	        return target.transform;
	      }
	      return _get(SCNNode.prototype.__proto__ || Object.getPrototypeOf(SCNNode.prototype), 'valueForKeyPath', this).call(this, keyPath);
	    }
	  }, {
	    key: 'setValueForKey',
	    value: function setValueForKey(value, key) {
	      // FIXME: check flags to decide to use a presentation node
	      var target = this._presentation ? this._presentation : this;

	      if (key === 'position') {
	        target.position = value;
	      } else if (key === 'rotation') {
	        target.rotation = value;
	      } else if (key === 'scale') {
	        target.scale = value;
	      } else if (key === 'eulerAngles') {
	        target.eulerAngles = value;
	      } else if (key === 'orientation') {
	        target.orientation = value;
	      } else if (key === 'transform') {
	        target.transform = value;
	      } else {
	        _get(SCNNode.prototype.__proto__ || Object.getPrototypeOf(SCNNode.prototype), 'setValueForKey', this).call(this, value, key);
	      }
	    }
	  }, {
	    key: 'setValueForKeyPath',
	    value: function setValueForKeyPath(value, keyPath) {
	      var target = this._presentation ? this._presentation : this;

	      var paths = keyPath.split('.');
	      var key = paths.shift();
	      var restPath = paths.join('.');
	      //console.log(`SCNNode setValueForKeyPath ${this.name} ${key} ${restPath}`)
	      if (key === 'transform') {
	        switch (restPath) {
	          case 'rotation.x':
	            target._rotation.x = value;
	            target._transformUpToDate = false;
	            return;
	          case 'rotation.y':
	            target._rotation.y = value;
	            target._transformUpToDate = false;
	            return;
	          case 'rotation.z':
	            target._rotation.z = value;
	            target._transformUpToDate = false;
	            return;
	          case 'rotation':
	            target._rotation.z = value;
	            target._transformUpToDate = false;
	            return;
	          case 'quaternion':
	            target.orientation = value;
	            target._transformUpToDate = false;
	            return;
	          case 'scale.x':
	            target._scale.x = value;
	            target._transformUpToDate = false;
	            return;
	          case 'scale.y':
	            target._scale.y = value;
	            target._transformUpToDate = false;
	            return;
	          case 'scale.z':
	            target._scale.z = value;
	            target._transformUpToDate = false;
	            return;
	          case 'scale':
	            {
	              target._scale.x = value.x;
	              target._scale.y = value.y;
	              target._scale.z = value.z;
	              target._transformUpToDate = false;
	              return;
	            }
	          case 'translation.x':
	            target._position.x = value;
	            target._transformUpToDate = false;
	            return;
	          case 'translation.y':
	            target._position.y = value;
	            target._transformUpToDate = false;
	            return;
	          case 'translation.z':
	            target._position.z = value;
	            target._transformUpToDate = false;
	            return;
	          case 'translation':
	            target._position.x = value.x;
	            target._position.y = value.y;
	            target._transformUpToDate = false;
	            return;
	          default:
	          // do nothing
	        }
	      } else if (key === 'position') {
	        if (restPath !== '') {
	          target._position[restPath] = value;
	        } else {
	          target._position = value;
	        }
	        return;
	      } else if (key === 'rotation') {
	        if (restPath !== '') {
	          target._rotation[restPath] = value;
	        } else {
	          target._rotation = value;
	        }
	        return;
	      } else if (key === 'orientation') {
	        if (restPath !== '') {
	          var v = target.orientation;
	          v[restPath] = value;
	          target.orientation = v;
	        } else {
	          target.orientation = value;
	        }
	        return;
	      } else if (key === 'eulerAngles') {
	        if (restPath !== '') {
	          var _v = target.eulerAngles;
	          _v[restPath] = value;
	          target.eulerAngles = _v;
	        } else {
	          target.eulerAngles = value;
	        }
	        return;
	      } else if (key === 'scale') {
	        if (restPath !== '') {
	          target._scale[restPath] = value;
	        } else {
	          target._scale = value;
	        }
	        return;
	      } else if (key === 'morpher') {
	        if (target.morpher === null) {
	          throw new Error('target morpher === null');
	        }
	        target.morpher.setValueForKeyPath(value, restPath);
	        return;
	      }
	      // TODO: add other properties

	      _get(SCNNode.prototype.__proto__ || Object.getPrototypeOf(SCNNode.prototype), 'setValueForKeyPath', this).call(this, value, keyPath);
	    }

	    /**
	     * @access private
	     * @returns {Ammo.btTransform}
	     * @desc call Ammo.destroy(transform) after using it.
	     */

	  }, {
	    key: '_createBtTransform',
	    value: function _createBtTransform() {
	      //const transform = new Ammo.btTransform()
	      //const pos = this.position.createBtVector3()
	      //const rot = this.orientation.craeteBtQuaternion()
	      //transform.setIdentity()
	      //transform.setOrigin(pos)
	      //transform.setRotation(rot)
	      //Ammo.destroy(pos)
	      //Ammo.destroy(rot)
	      //return transform
	    }
	  }, {
	    key: '_createBtCollisionShape',
	    value: function _createBtCollisionShape() {
	      //if(this._geometry === null){
	      //  throw new Error('geometry is null')
	      //}
	      //return this._geometry._createBtCollisionShape()
	    }
	  }, {
	    key: 'destory',
	    value: function destory() {
	      //if(this.physicsBody !== null){
	      //  this.physicsBody.destory()
	      //  this.physicsBody = null
	      //}
	      //if(this._geometry !== null){
	      //  // the geometry might be shared with other nodes...
	      //  //this.geometry.destroy()
	      //}
	    }
	  }, {
	    key: 'geometry',


	    // Managing Node Attributes
	    get: function get() {
	      return this._geometry;
	    },
	    set: function set(newValue) {
	      this._geometry = newValue;
	      this._updateBoundingBox();
	    }

	    // Working With Node Animation

	    /**
	     * A node object representing the state of the node as it currently appears onscreen.
	     * @type {SCNNode}
	     * @desc When you use implicit animation (see SCNTransaction) to change a nodes properties, those node properties are set immediately to their target values, even though the animated node content appears to transition from the old property values to the new. During the animation SceneKit maintains a copy of the node, called the presentation node, whose properties reflect the transitory values determined by any in-flight animations currently affecting the node. The presentation nodes properties provide a close approximation to the version of the node that is currently displayed. SceneKit also uses the presentation node when computing the results of explicit animations, physics, and constraints.Do not modify the properties of the presentation node. (Attempting to do so results in undefined behavior.) Instead, you use the presentation node to read current animation valuesfor example, to create a new animation starting at those values. The presentation node has no parent or child nodes. To access animated properties of related nodes, use the nodes own parent and childNodes properties and the presentation property of each related node.
	     * @see https://developer.apple.com/reference/scenekit/scnnode/1408030-presentation
	     */

	  }, {
	    key: 'presentation',
	    get: function get() {
	      if (this._presentation === null) {
	        return null;
	      }

	      return this._presentation;
	    }

	    // Managing the Nodes Transformation

	    /**
	     * The transformation applied to the node relative to its parent. Animatable.
	     * @type {SCNMatrix4}
	     * @see https://developer.apple.com/reference/scenekit/scnnode/1407964-transform
	     */

	  }, {
	    key: 'transform',
	    get: function get() {
	      // FIXME: it should return the copy of _transform,
	      //        but you should be able to change value with this statement:
	      //          let node = new SCNNode()
	      //          node.transform.m14 = 123
	      //          console.log(node.transform.m14)   // '123'
	      if (!this._transformUpToDate) {
	        this._updateTransform();
	      }
	      return this._transform;
	    },
	    set: function set(newValue) {
	      this._transform = newValue;
	      // TODO: update position, rotation, scale
	      this._position = this._transform.getTranslation();
	      this._rotation = this._transform.getRotation();
	      this._scale = this._transform.getScale();
	      this._transformUpToDate = true;
	    }

	    /**
	     * The world transform applied to the node.
	     * @type {SCNMatrix4}
	     * @desc A world transform is the nodes coordinate space transformation relative to the scenes coordinate space. This transformation is the concatenation of the nodes transform property with that of its parent node, the parents parent, and so on up to the rootNode object of the scene.
	     * @see https://developer.apple.com/reference/scenekit/scnnode/1407970-worldtransform
	     */

	  }, {
	    key: 'worldTransform',
	    get: function get() {
	      /*
	      if(this._parent === null){
	        if(this._isPresentationInstance){
	          return this._worldTransform
	        }
	        return this.transform
	      }
	      return this.transform.mult(this._parent.worldTransform)
	      */
	      return this._worldTransform;
	    }
	  }, {
	    key: 'position',
	    get: function get() {
	      return this._position;
	    },
	    set: function set(newValue) {
	      if (typeof newValue.x !== 'number' || typeof newValue.y !== 'number' || typeof newValue.z !== 'number') {
	        throw new Error('error: SCNNode.position must have x, y, z values');
	      }
	      this._position.x = newValue.x;
	      this._position.y = newValue.y;
	      this._position.z = newValue.z;
	      this._transformUpToDate = false;
	      this._updateWorldTransform();
	    }
	  }, {
	    key: 'rotation',
	    get: function get() {
	      return this._rotation;
	    },
	    set: function set(newValue) {
	      if (typeof newValue.x !== 'number' || typeof newValue.y !== 'number' || typeof newValue.z !== 'number' || typeof newValue.w !== 'number') {
	        throw new Error('error: SCNNode.rotation must have x, y, z, w values');
	      }
	      var oldValue = this._rotation._copy();
	      this._rotation.x = newValue.x;
	      this._rotation.y = newValue.y;
	      this._rotation.z = newValue.z;
	      this._rotation.w = newValue.w;
	      this._transformUpToDate = false;
	      this._updateWorldTransform();
	      _SCNTransaction2.default._addChange(this, 'rotation', oldValue, newValue);
	    }
	    //_setRotation(newValue){
	    //  if(typeof newValue.x !== 'number'
	    //    || typeof newValue.y !== 'number'
	    //    || typeof newValue.z !== 'number'
	    //    || typeof newValue.w !== 'number'){
	    //    throw new Error('error: SCNNode.rotation must have x, y, z, w values')
	    //  }
	    //  this._rotation.x = newValue.x
	    //  this._rotation.y = newValue.y
	    //  this._rotation.z = newValue.z
	    //  this._rotation.w = newValue.w
	    //  this._transformUpToDate = false
	    //  this._updateWorldTransform()
	    //}

	  }, {
	    key: 'scale',
	    get: function get() {
	      return this._scale;
	    },
	    set: function set(newValue) {
	      if (typeof newValue.x !== 'number' || typeof newValue.y !== 'number' || typeof newValue.z !== 'number') {
	        throw new Error('error: SCNNode.scale must have x, y, z values');
	      }
	      this._scale.x = newValue.x;
	      this._scale.y = newValue.y;
	      this._scale.z = newValue.z;
	      this._transformUpToDate = false;
	      this._updateWorldTransform();
	    }

	    /**
	     * The nodes orientation, expressed as pitch, yaw, and roll angles, each in radians. Animatable.
	     * @type {SCNVector3}
	     * @see https://developer.apple.com/reference/scenekit/scnnode/1407980-eulerangles
	     */

	  }, {
	    key: 'eulerAngles',
	    get: function get() {
	      /*
	      const rot = this._rotation
	      const euler = new SCNVector3()
	      const sinW = Math.sin(rot.w)
	      const cosWR = 1.0 - Math.cos(rot.w)
	      const len2 = rot.x * rot.x + rot.y * rot.y + rot.z * rot.z
	      if(len2 === 0){
	        return euler
	      }
	      const r = 1.0 / Math.sqrt(len2)
	      const x = rot.x * r
	      const y = rot.y * r
	      const z = rot.z * r
	      const s = y * sinW - x * z * cosWR
	       if(s > 0.998){
	        // TODO: check SceneKit implementation
	        euler.x = 0
	        euler.y = -Math.PI * 0.5
	        euler.z = -2.0 * Math.atan2(z * Math.sin(rot.w * 0.5), Math.cos(rot.w * 0.5))
	      }else if(s < -0.998){
	        // TODO: check SceneKit implementation
	        euler.x = 0
	        euler.y = Math.PI * 0.5
	        euler.z = 2.0 * Math.atan2(z * Math.sin(rot.w * 0.5), Math.cos(rot.w * 0.5))
	      }else{
	        euler.x = Math.atan2(x * sinW + y * z * cosWR, 1 - (y * y + x * x) * cosWR)
	        euler.y = Math.asin(s)
	        euler.z = Math.atan2(z * sinW + x * y * cosWR, 1 - (z * z + y * y) * cosWR)
	      }
	       return euler
	      */
	      return this._rotation.rotationToEulerAngles();
	    },
	    set: function set(newValue) {
	      /*
	      const halfX = newValue.x * 0.5
	      const halfY = newValue.y * 0.5
	      const halfZ = newValue.z * 0.5
	      const cosX = Math.cos(halfX)
	      const sinX = Math.sin(halfX)
	      const cosY = Math.cos(halfY)
	      const sinY = Math.sin(halfY)
	      const cosZ = Math.cos(halfZ)
	      const sinZ = Math.sin(halfZ)
	       const q = new SCNVector4()
	      const x = sinX * cosY * cosZ - cosX * sinY * sinZ
	      const y = cosX * sinY * cosZ + sinX * cosY * sinZ
	      const z = cosX * cosY * sinZ - sinX * sinY * cosZ
	      const r = 1.0 / Math.sqrt(x * x + y * y + z * z)
	      q.x = x * r
	      q.y = y * r
	      q.z = z * r
	      q.w = 2 * Math.acos(cosX * cosY * cosZ + sinX * sinY * sinZ)
	      */
	      this._rotation = newValue.eulerAnglesToRotation();
	      this._transformUpToDate = false;
	    }

	    /**
	     * The nodes orientation, expressed as a quaternion. Animatable.
	     * @type {SCNQuaternion}
	     * @see https://developer.apple.com/reference/scenekit/scnnode/1408048-orientation
	     */

	  }, {
	    key: 'orientation',
	    get: function get() {
	      /*
	      const quat = new SCNVector4()
	      const rot = this._rotation
	       if(rot.x === 0 && rot.y === 0 && rot.z === 0){
	        quat.x = 0
	        quat.y = 0
	        quat.z = 0
	        quat.w = 1.0
	      }else{
	        const r = 1.0 / Math.sqrt(rot.x * rot.x + rot.y * rot.y + rot.z * rot.z)
	        const cosW = Math.cos(rot.w)
	        const sinW = Math.sin(rot.w)
	        quat.x = rot.x * sinW
	        quat.y = rot.y * sinW
	        quat.z = rot.z * sinW
	        quat.w = cosW
	      }
	      return quat
	      */
	      //console.log(`SCNNode get orientation: ${this._rotation.rotationToQuat()}`)
	      return this._rotation.rotationToQuat();
	    },
	    set: function set(newValue) {
	      /*
	      const rot = new SCNVector4()
	       if(newValue.x === 0 && newValue.y === 0 && newValue.z === 0){
	        rot.x = 0
	        rot.y = 0
	        rot.z = 0
	        rot.w = 0
	      }else{
	        rot.x = newValue.x
	        rot.y = newValue.y
	        rot.z = newValue.z
	        let quatW = newValue.w
	        if(quatW > 1){
	          quatW = 1.0
	        }else if(quatW < -1){
	          quatW = -1.0
	        }
	        const w = Math.acos(quatW)
	         if(isNaN(w)){
	          rot.w = 0
	        }else{
	          rot.w = w
	        }
	      }
	          
	      this._rotation = rot
	      */
	      if (!(newValue instanceof _SCNVector4.default)) {
	        throw new Error('orientation must be SCNVector4');
	      }

	      this._rotation = newValue.quatToRotation();
	      //console.log(`SCNNode set orientation: ${this._rotation.float32Array()}`)
	      this._transformUpToDate = false;
	    }

	    /**
	     * @access private
	     * @returns {SCNVector4} -
	     */

	  }, {
	    key: '_presentationWorldOrientation',
	    get: function get() {
	      if (this._parent === null) {
	        return this.presentation.orientation;
	      }
	      return this._parent._presentationWorldOrientation.cross(this.presentation.orientation);
	    }

	    /**
	     * @access private
	     * @returns {SCNVector4} -
	     */

	  }, {
	    key: '_worldOrientation',
	    get: function get() {
	      if (this._parent === null) {
	        return this.orientation;
	      }
	      return this._parent._worldOrientation.cross(this.orientation);
	    }

	    /**
	     * @access private
	     * @returns {SCNVector4} -
	     */

	  }, {
	    key: '_worldRotation',
	    get: function get() {
	      return this._worldOrientation.quatToRotation();
	    }

	    /**
	     * @access private
	     * @returns {SCNVector3} -
	     */

	  }, {
	    key: '_presentationWorldTranslation',
	    get: function get() {
	      return this.presentation.worldTransform.getTranslation();
	    }

	    /**
	     * @access private
	     * @returns {SCNVector3} -
	     */

	  }, {
	    key: '_worldTranslation',
	    get: function get() {
	      return this.worldTransform.getTranslation();
	    }

	    /**
	     * @access private
	     * @returns {SCNVector3} -
	     */

	  }, {
	    key: '_worldScale',
	    get: function get() {}
	  }, {
	    key: 'parent',
	    get: function get() {
	      return this._parent;
	    }
	    /**
	     * An array of the nodes children in the scene graph hierarchy.
	     * @type {SCNNode[]}
	     * @see https://developer.apple.com/reference/scenekit/scnnode/1407984-childnodes
	     */

	  }, {
	    key: 'childNodes',
	    get: function get() {
	      return this._childNodes.slice(0);
	    }
	  }, {
	    key: 'physicsBody',
	    get: function get() {
	      return this._physicsBody;
	    },
	    set: function set(newValue) {
	      if (this._physicsBody) {
	        this._physicsBody._node = null;
	      }
	      this._physicsBody = newValue;
	      this._physicsBody._node = this;
	    }
	  }, {
	    key: 'particleSystems',
	    get: function get() {
	      return this._particleSystems;
	    }
	  }, {
	    key: 'audioPlayers',
	    get: function get() {
	      return this._audioPlayers.slice(0);
	    }
	  }, {
	    key: 'hasActions',
	    get: function get() {
	      return this._actions.size > 0;
	    }

	    /**
	     * Required. The list of keys for which the node has attached actions.
	     * @type {string[]}
	     * @desc Use this property to list actions you scheduled using the runAction(_:forKey:) or runAction(_:forKey:completionHandler:) method.
	     * @see https://developer.apple.com/reference/scenekit/scnactionable/1523036-actionkeys
	     */

	  }, {
	    key: 'actionKeys',
	    get: function get() {
	      var keys = [];
	      var _iteratorNormalCompletion3 = true;
	      var _didIteratorError3 = false;
	      var _iteratorError3 = undefined;

	      try {
	        for (var _iterator3 = this._actions.keys()[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
	          var key = _step3.value;

	          keys.push(key);
	        }
	      } catch (err) {
	        _didIteratorError3 = true;
	        _iteratorError3 = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion3 && _iterator3.return) {
	            _iterator3.return();
	          }
	        } finally {
	          if (_didIteratorError3) {
	            throw _iteratorError3;
	          }
	        }
	      }

	      return keys;
	    }
	  }, {
	    key: 'animationKeys',
	    get: function get() {
	      var keys = [];
	      var _iteratorNormalCompletion4 = true;
	      var _didIteratorError4 = false;
	      var _iteratorError4 = undefined;

	      try {
	        for (var _iterator4 = this._animations.keys()[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
	          var key = _step4.value;

	          keys.push(key);
	        }
	      } catch (err) {
	        _didIteratorError4 = true;
	        _iteratorError4 = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion4 && _iterator4.return) {
	            _iterator4.return();
	          }
	        } finally {
	          if (_didIteratorError4) {
	            throw _iteratorError4;
	          }
	        }
	      }

	      return keys;
	    }
	  }, {
	    key: 'boundingBox',
	    get: function get() {
	      if (this._fixedBoundingBox) {
	        return this._fixedBoundingBox;
	      }
	      //if(!this._boundingBox){
	      this._updateBoundingBox();
	      //}
	      return this._boundingBox;
	    },
	    set: function set(newValue) {
	      this._fixedBoundingBox = newValue;
	    }

	    /**
	     * The center point and radius of the objects bounding sphere.
	     * @type {{center: SCNVector3, radius: number}}
	     * @desc Scene Kit defines a bounding sphere in the local coordinate space using a center point and a radius. For example, if a nodes bounding sphere has the center point {3, 1, 4} and radius 2.0, all points in the vertex data of nodes geometry (and any geometry attached to its child nodes) lie within 2.0 units of the center point.The coordinates provided when reading this property are valid only if the object has a volume to be measured. For a geometry containing no vertex data or a node containing no geometry (and whose child nodes, if any, contain no geometry), the values center and radius are both zero.
	     * @see https://developer.apple.com/reference/scenekit/scnboundingvolume/2034707-boundingsphere
	     */

	  }, {
	    key: 'boundingSphere',
	    get: function get() {
	      // TODO: calculate bounding sphere
	      return { center: new _SCNVector2.default(), radius: 0 };
	    }
	  }, {
	    key: 'viewTransform',
	    get: function get() {
	      return this.worldTransform.invert();
	    }
	  }, {
	    key: 'projectionTransform',
	    get: function get() {
	      if (this.camera === null) {
	        return null;
	      }
	      return this.camera.projectionTransform;
	    }
	  }, {
	    key: 'viewProjectionTransform',
	    get: function get() {
	      if (this.camera === null) {
	        return null;
	      }
	      var proj = this.camera.projectionTransform;
	      var view = this.viewTransform;
	      return view.mult(proj);
	    }
	  }, {
	    key: 'lightViewProjectionTransform',
	    get: function get() {
	      if (this.light === null) {
	        return null;
	      }
	      this.light._updateProjectionTransform();
	      var proj = this.light._projectionTransform;
	      var view = this.viewTransform;
	      return view.mult(proj);
	    }
	  }, {
	    key: 'shadowProjectionTransform',
	    get: function get() {
	      if (this.light === null) {
	        return null;
	      }
	      var vp = this.lightViewProjectionTransform;
	      var scale = (0, _SCNMatrix4MakeTranslation2.default)(1.0, 1.0, 0.0).scale(0.5, 0.5, 1.0); // [-1, 1] => [0, 1]
	      return vp.mult(scale);
	    }
	  }], [{
	    key: '_loadAnimationArray',
	    value: function _loadAnimationArray(node, animations) {
	      //console.log('_loadAnimationArray start')
	      var _iteratorNormalCompletion5 = true;
	      var _didIteratorError5 = false;
	      var _iteratorError5 = undefined;

	      try {
	        for (var _iterator5 = Object.keys(animations)[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
	          var animName = _step5.value;

	          var data = animations[animName];
	          var animation = this._loadAnimationData(data, animName);
	          node.addAnimationForKey(animation, animName);
	        }
	        //console.log('_loadAnimationArray done')
	      } catch (err) {
	        _didIteratorError5 = true;
	        _iteratorError5 = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion5 && _iterator5.return) {
	            _iterator5.return();
	          }
	        } finally {
	          if (_didIteratorError5) {
	            throw _iteratorError5;
	          }
	        }
	      }
	    }
	  }, {
	    key: '_loadAnimationData',
	    value: function _loadAnimationData(data, key) {
	      //console.log(`_loadAnimationData ${key} start`)
	      if (data.class === 'group') {
	        return this._loadAnimationGroup(data);
	      } else if (data.class === 'keyframe') {
	        return this._loadKeyframeAnimation(data.animation, key);
	      } else if (data.class === 'basic') {
	        var keyPath = data.keyPath || key;
	        return this._loadBasicAnimation(data.animation, keyPath);
	      } else if (data.type === 'keyframedAnimation') {
	        return this._loadKeyframeAnimation(data, key);
	      }

	      //console.error(`unknown animation class: ${data.class}, type: ${data.type}, key: ${key}`)
	      throw new Error('unknown animation class: ' + data.class + ', type: ' + data.type + ', key: ' + key);
	    }
	  }, {
	    key: '_loadAnimationGroup',
	    value: function _loadAnimationGroup(animation) {
	      var _this5 = this;

	      //console.log('_loadAnimationGroup start')
	      var group = new _CAAnimationGroup2.default();
	      var data = animation.animation;
	      group.isRemovedOnCompletion = !!animation.removeOnCompletion;
	      // group.timingFunction
	      // group.delegate
	      group.usesSceneTimeBase = !!animation.usesSceneTimeBase;
	      group.fadeInDuration = data.fadeInDuration;
	      group.fadeOutDuration = data.fadeOutDuration;
	      group.beginTime = data.beginTime;
	      group.timeOffset = data.timeOffset;
	      group.repeatCount = data.repeatCount;
	      // group.repeatDuration
	      group.duration = data.duration;
	      group.speed = data.speed;
	      group.autoreverses = data.autoreverses;
	      var fillMode = [Constants.kCAFillModeRemoved, Constants.kCAFillModeForwards, Constants.kCAFillModeBackwards, Constants.kCAFillModeBoth];
	      group.fillMode = fillMode[data.fillModeMask];
	      // data.cumulative
	      // data.additive
	      // data.attributes
	      data.channels.forEach(function (channel) {
	        var keyPath = channel.targetPath.join('.');
	        //console.error(`SCNNode animation group keyPath: ${keyPath}`)
	        var chAnim = _this5._loadAnimationData(channel.animation, keyPath);
	        group.animations.push(chAnim);
	      });
	      //console.log('_loadAnimationGroup done')

	      return group;
	    }
	  }, {
	    key: '_loadKeyframeAnimation',
	    value: function _loadKeyframeAnimation(data, keyPath) {
	      //console.log(`_loadKeyframeAnimation ${keyPath} start`)
	      var anim = new _CAKeyframeAnimation2.default(keyPath);

	      anim.isRemovedOnCompletion = !!data.removeOnCompletion;
	      // anim.timingFunction
	      // anim.delegate
	      anim.usesSceneTimeBase = !!data.sceneTimeBased;
	      anim.fadeInDuration = data.fadeInDuration;
	      anim.fadeOutDuration = data.fadeOutDuration;
	      anim.beginTime = data.beginTime;
	      anim.timeOffset = data.timeOffset;
	      anim.repeatCount = data.repeatCount;
	      // anim.repeatDuration
	      anim.duration = data.duration;
	      anim.speed = data.speed;
	      anim.autoreverses = data.autoreverses;
	      var fillMode = [Constants.kCAFillModeRemoved, Constants.kCAFillModeForwards, Constants.kCAFillModeBackwards, Constants.kCAFillModeBoth];
	      anim.fillMode = fillMode[data.fillModeMask];
	      anim.isCumulative = !!data.cumulative;
	      anim.isAdditive = !!data.additive;
	      // data.attributes

	      var keyframe = data.keyframeController;
	      anim.values = this._loadData(keyframe, 'values');
	      //anim.path
	      anim.keyTimes = this._loadData(keyframe, 'keytimes');
	      switch (keyframe.interpolationMode) {
	        case 0:
	        default:
	          //anim.timingFunctions =
	          break;
	      }
	      anim.keyTimes = anim.keyTimes.map(function (keyTime) {
	        return keyTime / anim.duration;
	      });

	      var calculationModes = [Constants.kCAAnimationLinear, Constants.kCAAnimationDiscrete, Constants.kCAAnimationPaced, Constants.kCAAnimationCubic, Constants.kCAAnimationCubicPaced];
	      anim.calculationMode = calculationModes[keyframe.calculationMode];
	      //anim.rotationMode
	      //anim.tensionValues
	      //anim.continuityValues
	      //anim.biasValues

	      //console.log(`_loadKeyframeAnimation ${keyPath} done`)

	      return anim;
	    }
	  }, {
	    key: '_loadBasicAnimation',
	    value: function _loadBasicAnimation(data, keyPath) {
	      //console.log(`_loadBasicAnimation ${keyPath} start`)
	      var anim = new _CABasicAnimation2.default(keyPath);

	      anim.isRemovedOnCompletion = !!data.removeOnCompletion;
	      anim.timingFunction = new _CAMediaTimingFunction2.default(data.timingFunction.c0, data.timingFunction.c1, data.timingFunction.c2, data.timingFunction.c3);
	      // anim.delegate
	      anim.usesSceneTimeBase = !!data.sceneTimeBased;
	      anim.fadeInDuration = data.fadeInDuration;
	      anim.fadeOutDuration = data.fadeOutDuration;
	      anim.beginTime = data.beginTime;
	      anim.timeOffset = data.timeOffset;
	      anim.repeatCount = data.repeatCount;
	      // anim.repeatDuration
	      anim.duration = data.duration;
	      anim.speed = data.speed;
	      anim.autoreverses = data.autoreverses;
	      var fillMode = [Constants.kCAFillModeRemoved, Constants.kCAFillModeForwards, Constants.kCAFillModeBackwards, Constants.kCAFillModeBoth];
	      anim.fillMode = fillMode[data.fillModeMask];
	      anim.isCumulative = !!data.cumulative;
	      anim.isAdditive = !!data.additive;
	      // data.attributes
	      // data.baseType

	      //console.log(`_loadBasicAnimation ${keyPath} done`)

	      return anim;
	    }
	  }, {
	    key: '_loadActionArray',
	    value: function _loadActionArray(node, actions) {
	      //console.log('_loadActionArray start')
	      var _iteratorNormalCompletion6 = true;
	      var _didIteratorError6 = false;
	      var _iteratorError6 = undefined;

	      try {
	        for (var _iterator6 = Object.keys(actions)[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
	          var actName = _step6.value;

	          var data = actions[actName];
	          //const action = this._loadActionData(data, actName)
	          //node.runActionForKey(action, actName)
	          node.runActionForKey(data, actName);
	        }
	        //console.log('_loadAnimationArray done')
	      } catch (err) {
	        _didIteratorError6 = true;
	        _iteratorError6 = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion6 && _iterator6.return) {
	            _iterator6.return();
	          }
	        } finally {
	          if (_didIteratorError6) {
	            throw _iteratorError6;
	          }
	        }
	      }
	    }

	    //static _loadActionData(data, key) {
	    //  console.log(`_loadActionData ${key} start`)
	    //}

	  }, {
	    key: '_loadData',
	    value: function _loadData(data, key) {
	      //console.log(`_loadData ${key} start`)

	      var accessor = data[key].accessor;
	      var components = accessor.componentsPerValue;
	      var stride = accessor.stride;
	      var offset = accessor.offset;
	      var typeId = accessor.sourceTypeID;
	      var padding = accessor.padding;
	      var count = accessor.valuesCount;

	      var sourceKey = key + '-data';
	      var source = data[sourceKey];

	      var result = [];
	      var pos = offset;
	      if (accessor.componentsType === 1) {
	        for (var i = 0; i < count; i++) {
	          result.push(source.readFloatBE(pos));
	          pos += stride;
	        }
	      } else if (accessor.componentsType === 6) {
	        for (var _i = 0; _i < count; _i++) {
	          result.push(source.readDoubleBE(pos));
	          pos += stride;
	        }
	      } else if (accessor.componentsType === 9) {
	        for (var _i2 = 0; _i2 < count; _i2++) {
	          result.push(_SCNVector2.default._initWithData(source, pos, true));
	          pos += stride;
	        }
	      } else if (accessor.componentsType === 10) {
	        for (var _i3 = 0; _i3 < count; _i3++) {
	          result.push(_SCNVector4.default._initWithData(source, pos, true));
	          pos += stride;
	        }
	      } else if (accessor.componentsType === 13) {
	        for (var _i4 = 0; _i4 < count; _i4++) {
	          result.push(_SKColor2.default._initWithData(source, pos, true));
	          pos += stride;
	        }
	      } else {
	        console.error('unknown accessor componentsType: ' + accessor.componentsType);
	      }

	      //console.log(`_loadData ${key} done`)

	      return result;
	    }

	    /**
	     * Constructor for JSExport compatibility
	     * @access public
	     * @returns {SCNNode} -
	     */

	  }, {
	    key: 'node',
	    value: function node() {
	      return new SCNNode();
	    }

	    /**
	     * Constructor for JSExport compatibility
	     * @access public
	     * @param {?SCNGeometry} [geometry] - The geometry to be attached.
	     * @returns {SCNNode} -
	     */

	  }, {
	    key: 'nodeWithGeometry',
	    value: function nodeWithGeometry(geometry) {
	      return new SCNNode(geometry);
	    }
	  }]);

	  return SCNNode;
	}(_NSObject3.default);

	exports.default = SCNNode;

/***/ },
/* 66 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _CAAnimation = __webpack_require__(48);

	var _CAAnimation2 = _interopRequireDefault(_CAAnimation);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	/**
	 * The common interface for attaching animations to nodes, geometries, materials, and other SceneKit objects.
	 * @interface
	 * @see https://developer.apple.com/reference/scenekit/scnanimatable
	 */
	var SCNAnimatable = function () {
	  function SCNAnimatable() {
	    _classCallCheck(this, SCNAnimatable);
	  }

	  _createClass(SCNAnimatable, [{
	    key: 'init',


	    /**
	     * constructor
	     * @access public
	     * @returns {void}
	     */
	    value: function init() {

	      // Managing Animations

	      this._animationKeys = null;
	    }

	    // Managing Animations

	    /**
	     * Required. Adds an animation object for the specified key.
	     * @access public
	     * @param {CAAnimation} animation - The animation object to be added.
	     * @param {?string} key - An string identifying the animation for later retrieval. You may pass nil if you dont need to reference the animation later.
	     * @returns {void}
	     * @desc Newly added animations begin executing after the current run loop cycle ends.SceneKit does not define any requirements for the contents of the key parameterit need only be unique among the keys for other animations you add. If you add an animation with an existing key, this method overwrites the existing animation.
	     * @see https://developer.apple.com/reference/scenekit/scnanimatable/1523386-addanimation
	     */

	  }, {
	    key: 'addAnimationForKey',
	    value: function addAnimationForKey(animation, key) {}

	    /**
	     * Required. Returns the animation with the specified key.
	     * @access public
	     * @param {string} key - A string identifying a previously added animation.
	     * @returns {?CAAnimation} - 
	     * @desc Attempting to modify any properties of the returned object results in undefined behavior.
	     * @see https://developer.apple.com/reference/scenekit/scnanimatable/1524020-animation
	     */

	  }, {
	    key: 'animationForKey',
	    value: function animationForKey(key) {
	      return null;
	    }

	    /**
	     * Required. Removes all the animations currently attached to the object.
	     * @access public
	     * @returns {void}
	     * @see https://developer.apple.com/reference/scenekit/scnanimatable/1522762-removeallanimations
	     */

	  }, {
	    key: 'removeAllAnimations',
	    value: function removeAllAnimations() {}

	    /**
	     * Required. Removes the animation attached to the object with the specified key.
	     * @access public
	     * @param {string} key - A string identifying an attached animation to remove.
	     * @returns {void}
	     * @see https://developer.apple.com/reference/scenekit/scnanimatable/1522880-removeanimation
	     */

	  }, {
	    key: 'removeAnimationForKey',
	    value: function removeAnimationForKey(key) {}

	    /**
	     * Required. Removes the animation attached to the object with the specified key, smoothly transitioning out of the animations effect.
	     * @access public
	     * @param {string} key - A string identifying an attached animation to remove.
	     * @param {number} duration - The duration for transitioning out of the animations effect before it is removed.
	     * @returns {void}
	     * @desc Use this method to create smooth transitions between the effects of multiple animations. For example, the geometry loaded from a scene file for a game character may have associated animations for player actions such as walking and jumping. When the player lands from a jump, you remove the jump animation so the character continues walking. If you use the removeAnimation(forKey:) method to remove the jump animation, SceneKit abruptly switches from the current frame of the jump animation to the current frame of the walk animation. If you use the removeAnimation(forKey:fadeOutDuration:) method instead, SceneKit plays both animations at once during that duration and interpolates vertex positions from one animation to the other, creating a smooth transition.
	     * @see https://developer.apple.com/reference/scenekit/scnanimatable/1522841-removeanimation
	     */

	  }, {
	    key: 'removeAnimationForKeyFadeOutDuration',
	    value: function removeAnimationForKeyFadeOutDuration(key, duration) {}
	    /**
	     * Required. An array containing the keys of all animations currently attached to the object.
	     * @type {string[]}
	     * @desc This array contains all keys for which animations are attached to the object, or is empty if there are no attached animations. The ordering of animation keys in the array is arbitrary.
	     * @see https://developer.apple.com/reference/scenekit/scnanimatable/1523610-animationkeys
	     */

	  }, {
	    key: 'pauseAnimationForKey',


	    // Pausing and Resuming Animations

	    /**
	     * Required. Pauses the animation attached to the object with the specified key.
	     * @access public
	     * @param {string} key - A string identifying an attached animation.
	     * @returns {void}
	     * @desc This method has no effect if no animation is attached to the object with the specified key.
	     * @see https://developer.apple.com/reference/scenekit/scnanimatable/1523592-pauseanimation
	     */
	    value: function pauseAnimationForKey(key) {}

	    /**
	     * Required. Resumes a previously paused animation attached to the object with the specified key.
	     * @access public
	     * @param {string} key - A string identifying an attached animation.
	     * @returns {void}
	     * @desc This method has no effect if no animation is attached to the object with the specified key or if the specified animation is not currently paused.
	     * @see https://developer.apple.com/reference/scenekit/scnanimatable/1523332-resumeanimation
	     */

	  }, {
	    key: 'resumeAnimationForKey',
	    value: function resumeAnimationForKey(key) {}

	    /**
	     * Required. Returns a Boolean value indicating whether the animation attached to the object with the specified key is paused.
	     * @access public
	     * @param {string} key - A string identifying an attached animation.
	     * @returns {boolean} - 
	     * @see https://developer.apple.com/reference/scenekit/scnanimatable/1523703-isanimationpaused
	     */

	  }, {
	    key: 'isAnimationPausedForKey',
	    value: function isAnimationPausedForKey(key) {
	      return false;
	    }

	    // Instance Methods

	    /**
	     * Required. 
	     * @access public
	     * @param {number} speed - 
	     * @param {string} key - 
	     * @returns {void}
	     * @see https://developer.apple.com/reference/scenekit/scnanimatable/1778343-setanimationspeed
	     */

	  }, {
	    key: 'setAnimationSpeedForKey',
	    value: function setAnimationSpeedForKey(speed, key) {}
	  }, {
	    key: 'animationKeys',
	    get: function get() {
	      return this._animationKeys;
	    }
	  }]);

	  return SCNAnimatable;
	}();

	exports.default = SCNAnimatable;

/***/ },
/* 67 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _SCNVector = __webpack_require__(44);

	var _SCNVector2 = _interopRequireDefault(_SCNVector);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	/**
	 * Properties for measuring an object's location and size, expressed as either a box or a sphere.
	 * @interface
	 * @see https://developer.apple.com/reference/scenekit/scnboundingvolume
	 */
	var SCNBoundingVolume = function () {
	  function SCNBoundingVolume() {
	    _classCallCheck(this, SCNBoundingVolume);
	  }

	  _createClass(SCNBoundingVolume, [{
	    key: 'init',


	    /**
	     * constructor
	     * @access public
	     * @returns {void}
	     */
	    value: function init() {

	      // Working with Bounding Volumes

	      /**
	       * The minimum and maximum corner points of the objects bounding box.
	       * @type {{min: SCNVector3, max: SCNVector3}}
	       * @see https://developer.apple.com/reference/scenekit/scnboundingvolume/2034705-boundingbox
	       */
	      this.boundingBox = null;

	      this._boundingSphere = null;
	    }

	    // Working with Bounding Volumes
	    /**
	     * The center point and radius of the objects bounding sphere.
	     * @type {{center: SCNVector3, radius: number}}
	     * @desc Scene Kit defines a bounding sphere in the local coordinate space using a center point and a radius. For example, if a nodes bounding sphere has the center point {3, 1, 4} and radius 2.0, all points in the vertex data of nodes geometry (and any geometry attached to its child nodes) lie within 2.0 units of the center point.The coordinates provided when reading this property are valid only if the object has a volume to be measured. For a geometry containing no vertex data or a node containing no geometry (and whose child nodes, if any, contain no geometry), the values center and radius are both zero.
	     * @see https://developer.apple.com/reference/scenekit/scnboundingvolume/2034707-boundingsphere
	     */

	  }, {
	    key: 'boundingSphere',
	    get: function get() {
	      return this._boundingSphere;
	    }
	  }]);

	  return SCNBoundingVolume;
	}();

	exports.default = SCNBoundingVolume;

/***/ },
/* 68 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _NSObject2 = __webpack_require__(2);

	var _NSObject3 = _interopRequireDefault(_NSObject2);

	var _SCNAnimatable = __webpack_require__(66);

	var _SCNAnimatable2 = _interopRequireDefault(_SCNAnimatable);

	var _SCNCullMode = __webpack_require__(69);

	var _SCNCullMode2 = _interopRequireDefault(_SCNCullMode);

	var _SCNBoundingVolume = __webpack_require__(67);

	var _SCNBoundingVolume2 = _interopRequireDefault(_SCNBoundingVolume);

	var _SCNShadable = __webpack_require__(70);

	var _SCNShadable2 = _interopRequireDefault(_SCNShadable);

	var _SCNGeometrySource = __webpack_require__(71);

	var _SCNGeometrySource2 = _interopRequireDefault(_SCNGeometrySource);

	var _SCNGeometryElement = __webpack_require__(72);

	var _SCNGeometryElement2 = _interopRequireDefault(_SCNGeometryElement);

	var _SCNLevelOfDetail = __webpack_require__(74);

	var _SCNLevelOfDetail2 = _interopRequireDefault(_SCNLevelOfDetail);

	var _SCNMaterial = __webpack_require__(75);

	var _SCNMaterial2 = _interopRequireDefault(_SCNMaterial);

	var _SCNOrderedDictionary = __webpack_require__(79);

	var _SCNOrderedDictionary2 = _interopRequireDefault(_SCNOrderedDictionary);

	var _SCNVector = __webpack_require__(44);

	var _SCNVector2 = _interopRequireDefault(_SCNVector);

	var _SKColor = __webpack_require__(11);

	var _SKColor2 = _interopRequireDefault(_SKColor);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/*global Ammo*/

	/**
	 * A three-dimensional shape (also called a model or mesh) that can be displayed in a scene, with attached materials that define its appearance.
	 * @access public
	 * @extends {NSObject}
	 * @implements {SCNAnimatable}
	 * @implements {SCNBoundingVolume}
	 * @implements {SCNShadable}
	 * @see https://developer.apple.com/reference/scenekit/scngeometry
	 */
	var SCNGeometry = function (_NSObject) {
	  _inherits(SCNGeometry, _NSObject);

	  _createClass(SCNGeometry, null, [{
	    key: '_propTypes',
	    get: function get() {
	      var addSources = function addSources(obj, sources, key, coder) {
	        var _obj$_geometrySources;

	        //console.log(`addSources source.length: ${sources.length}, key: ${key}`)
	        (_obj$_geometrySources = obj._geometrySources).push.apply(_obj$_geometrySources, _toConsumableArray(sources));
	      };
	      return {
	        name: 'string',
	        levelsOfDetail: 'NSArray',
	        materials: 'NSArray',
	        subdivisionLevel: 'integer',
	        // program
	        // shaderModifiers
	        elements: ['NSArray', '_geometryElements'],
	        kGeometrySourceSemanticColor: ['NSArray', addSources],
	        kGeometrySourceSemanticEdgeCrease: ['NSArray', addSources],
	        kGeometrySourceSemanticNormal: ['NSArray', addSources],
	        kGeometrySourceSemanticTangent: ['NSArray', addSources],
	        kGeometrySourceSemanticTexcoord: ['NSArray', addSources],
	        kGeometrySourceSemanticVertex: ['NSArray', function (obj, sources) {
	          addSources(obj, sources);
	          var min = new _SCNVector2.default(Infinity, Infinity, Infinity);
	          var max = new _SCNVector2.default(-Infinity, -Infinity, -Infinity);
	          var _iteratorNormalCompletion = true;
	          var _didIteratorError = false;
	          var _iteratorError = undefined;

	          try {
	            for (var _iterator = sources[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	              var src = _step.value;

	              var result = src._createBoundingBox();
	              if (result.min.x < min.x) {
	                min.x = result.min.x;
	              }
	              if (result.max.x > max.x) {
	                max.x = result.max.x;
	              }
	              if (result.min.y < min.y) {
	                min.y = result.min.y;
	              }
	              if (result.max.y > max.y) {
	                max.y = result.max.y;
	              }
	              if (result.min.z < min.z) {
	                min.z = result.min.z;
	              }
	              if (result.max.z > max.z) {
	                max.z = result.max.z;
	              }
	            }
	          } catch (err) {
	            _didIteratorError = true;
	            _iteratorError = err;
	          } finally {
	            try {
	              if (!_iteratorNormalCompletion && _iterator.return) {
	                _iterator.return();
	              }
	            } finally {
	              if (_didIteratorError) {
	                throw _iteratorError;
	              }
	            }
	          }

	          obj.boundingBox = { min: min, max: max };
	        }],
	        kGeometrySourceSemanticVertexCrease: ['NSArray', addSources],

	        entityID: ['string', '_entityID'],
	        subdivisionSettings: ['bytes', null],
	        shadableHelper: ['SCNShadableHelper', '_shadableHelper']
	      };
	    }

	    // Creating a Geometry Object

	    /**
	     * Creates a new geometry built from the specified geometry sources and elements.
	     * @access public
	     * @constructor
	     * @param {SCNGeometrySource[]} sources - An array of SCNGeometrySource objects describing vertices in the geometry and their attributes.
	     * @param {?SCNGeometryElement[]} elements - An array of SCNGeometryElement objects describing how to connect the geometrys vertices.
	     * @desc A geometry's visible content comes from the combination of geometry sources, which contain data describing its vertices, with geometry elements, which contain data describing how the vertices connect to form a surface. Each SCNGeometrySource object describes an attribute of all vertices in the geometry (vertex position, surface normal vector, color, or texture mapping coordinates) identified by the source's semantic property. To create a custom geometry you must provide at least one source, for the vertex semantic. Typically, you also provide sources for normals and texture coordinates for use in lighting and shading.Sources for the vertex, normal, and color semantics must be unique-if multiple objects in the sources array have the same semantic, SceneKit uses only the first. A geometry may have multiple sources for the texcoord semantic-the order of texture coordinate sources in the sources array determines the value to use for the mappingChannel property when attaching materials.Each SCNGeometryElement object describes how vertices from the geometry sources are combined into polygons to create the geometry's shape. Creating a custom geometry requires at least one element. If the elements array contains multiple objects, their order determines the arrangement of the geometry's materials-for details, see the discussion of the materials property.
	     * @see https://developer.apple.com/reference/scenekit/scngeometry/1522803-init
	     */

	  }]);

	  function SCNGeometry() {
	    var sources = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
	    var elements = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

	    _classCallCheck(this, SCNGeometry);

	    var _this = _possibleConstructorReturn(this, (SCNGeometry.__proto__ || Object.getPrototypeOf(SCNGeometry)).call(this));

	    if (!Array.isArray(sources)) {
	      throw new Error('SCNGeometry(sources, elements): sources must be Array');
	    }
	    if (!Array.isArray(elements)) {
	      throw new Error('SCNGeometry(sources, elements): elements must be Array');
	    }

	    // Managing Geometry Attributes

	    /**
	     * A name associated with the geometry object.
	     * @type {?string}
	     * @see https://developer.apple.com/reference/scenekit/scngeometry/1522953-name
	     */
	    _this.name = null;

	    /**
	     * An array of SCNLevelOfDetail objects for managing the geometrys appearance when viewed from far away.
	     * @type {?SCNLevelOfDetail[]}
	     * @see https://developer.apple.com/reference/scenekit/scngeometry/1523745-levelsofdetail
	     */
	    _this.levelsOfDetail = null;

	    // Managing a Geometrys Materials

	    /**
	     * An array of SCNMaterial objects that determine the geometrys appearance when rendered.
	     * @type {SCNMaterial[]}
	     * @see https://developer.apple.com/reference/scenekit/scngeometry/1523472-materials
	     */
	    _this.materials = [];

	    // Managing Geometry Data

	    _this._geometryElements = elements;
	    _this._geometrySources = sources;
	    _this._vertexArrayObjects = null;
	    _this._materialBuffer = null;
	    //this._textureFlagBuffer = null
	    _this._shadowVAO = null;
	    _this._hitTestVAO = null;

	    // Working with Subdivision Surfaces

	    /**
	     * The number of subdivisions SceneKit uses to smooth the geometrys surface at render time.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scngeometry/1524177-subdivisionlevel
	     */
	    _this.subdivisionLevel = 0;

	    /**
	     * The geometry element identifying which edges of the geometrys surface should remain sharp after subdivision.
	     * @type {?SCNGeometryElement}
	     * @see https://developer.apple.com/reference/scenekit/scngeometry/1523246-edgecreaseselement
	     */
	    _this.edgeCreasesElement = null;

	    /**
	     * The geometry source specifying the smoothness or sharpness of edges after surface subdivision.
	     * @type {?SCNGeometrySource}
	     * @see https://developer.apple.com/reference/scenekit/scngeometry/1523479-edgecreasessource
	     */
	    _this.edgeCreasesSource = null;

	    /////////////////
	    // SCNShadable //
	    /////////////////

	    // Assigning a Custom Shader Program

	    /**
	     * A program used when rendering the object.
	     * @type {?SCNProgram}
	     * @see https://developer.apple.com/reference/scenekit/scnshadable/1523689-program
	     */
	    _this.program = null;

	    // Customizing SceneKits Shader Programs

	    /**
	     * A dictionary of GLSL source code snippets for customizing the shader programs provided by SceneKit.
	     * @type {?Map<SCNShaderModifierEntryPoint, string>}
	     * @see https://developer.apple.com/reference/scenekit/scnshadable/1523348-shadermodifiers
	     */
	    _this.shaderModifiers = null;

	    ///////////////////
	    // SCNAnimatable //
	    ///////////////////

	    /**
	     * @access private
	     * @type {SCNOrderedDictionary}
	     */
	    _this._animations = new _SCNOrderedDictionary2.default();

	    ///////////////////////
	    // SCNBoundingVolume //
	    ///////////////////////

	    // Working with Bounding Volumes

	    /**
	     * The minimum and maximum corner points of the objects bounding box.
	     * @type {{min: SCNVector3, max: SCNVector3}}
	     * @see https://developer.apple.com/reference/scenekit/scnboundingvolume/2034705-boundingbox
	     */
	    _this.boundingBox = null;

	    /**
	     * The center point and radius of the objects bounding sphere.
	     * @access private
	     * @type {Object}
	     * @parameter {SCNVector3} _boundingSphere.center
	     * @parameter {number} _boundingSphere.radius
	     */
	    //this._boundingSphere = null

	    _this._vertexBuffer = null;
	    _this._indexBuffer = null;

	    _this._isPresentationInstance = false;
	    _this._presentation = null;

	    /**
	     * @access private
	     * @type {?string}
	     */
	    _this._entityID = null;

	    /**
	     * @access private
	     * @type {?SCNShadableHelper}
	     */
	    _this._shadableHelper = null;

	    _this._btVertices = null;
	    _this._btMesh = null;
	    _this._btShape = null;
	    return _this;
	  }

	  // Managing a Geometrys Materials

	  /**
	   * The first material attached to the geometry.
	   * @type {?SCNMaterial}
	   * @see https://developer.apple.com/reference/scenekit/scngeometry/1523485-firstmaterial
	   */


	  _createClass(SCNGeometry, [{
	    key: 'materialNamed',


	    /**
	     * Returns the first material attached to the geometry with the specified name.
	     * @access public
	     * @param {string} name - The name of the material to be retrieved.
	     * @returns {?SCNMaterial} - 
	     * @desc You can use the name property of each SCNMaterial object to make managing your scene graph easier. Materials loaded from a scene file may have names assigned by an artist using a 3D authoring tool.If a geometry has multiple materials attached with the same name, this method returns the first according to the order of the materials array.
	     * @see https://developer.apple.com/reference/scenekit/scngeometry/1523789-material
	     */
	    value: function materialNamed(name) {
	      return null;
	    }

	    /**
	     * Attaches a material to the geometry at the specified index.
	     * @access public
	     * @param {SCNMaterial} material - The material to attach.
	     * @param {number} index - The location in the geometrys materials array at which to add the new material.ImportantRaises an exception (rangeException) if index is greater than the number of elements in the materials array.
	     * @returns {void}
	     * @see https://developer.apple.com/reference/scenekit/scngeometry/1522876-insertmaterial
	     */

	  }, {
	    key: 'insertMaterialAt',
	    value: function insertMaterialAt(material, index) {}

	    /**
	     * Removes a material attached to the geometry.
	     * @access public
	     * @param {number} index - The index of the attached material to be removed.ImportantRaises an exception (rangeException) if index is beyond the bounds of the materials array.
	     * @returns {void}
	     * @see https://developer.apple.com/reference/scenekit/scngeometry/1522646-removematerial
	     */

	  }, {
	    key: 'removeMaterialAt',
	    value: function removeMaterialAt(index) {}

	    /**
	     * Replaces a material attached to the geometry with another.
	     * @access public
	     * @param {number} index - The index of the attached material to be replaced.ImportantRaises an exception (rangeException) if index is beyond the bounds of the materials array.
	     * @param {SCNMaterial} material - The material with which to replace the attached material.
	     * @returns {void}
	     * @see https://developer.apple.com/reference/scenekit/scngeometry/1522714-replacematerial
	     */

	  }, {
	    key: 'replaceMaterialAtIndexWith',
	    value: function replaceMaterialAtIndexWith(index, material) {}

	    // Managing Geometry Data

	    /**
	     * Returns the geometry element at a specified index.
	     * @access public
	     * @param {number} elementIndex - The index of the geometry element.
	     * @returns {SCNGeometryElement} - 
	     * @desc Each SCNGeometryElement object describes how vertices from the geometrys sources are combined into polygons to create the geometrys shape. Visible geometries contain at least one element.
	     * @see https://developer.apple.com/reference/scenekit/scngeometry/1523266-geometryelement
	     */

	  }, {
	    key: 'geometryElementAtIndex',
	    value: function geometryElementAtIndex(elementIndex) {
	      return this._geometryElements[elementIndex];
	    }

	    /**
	     * Returns the geometry sources for a specified semantic.
	     * @access public
	     * @param {SCNGeometrySource.Semantic} semantic - A constant identifying a semantic for which to return geometry sources. See Geometry Semantic Identifiers for possible values.
	     * @returns {SCNGeometrySource[]} - 
	     * @desc Each SCNGeometrySource object describes an attribute of all vertices in the geometry (such as vertex position, surface normal vector, color, or texture mapping coordinates) identified by the sources semantic property. A geometry always has at least one source, for the vertex semantic, typically has additional sources for use in lighting and shading, and may have other sources for skeletal animation or surface subdivision information.The vertex, normal, and color semantics each refer to at most one source. A geometry may have multiple sources for the texcoord semanticin this case, indices in the returned array correspond to values for the mappingChannel property used when attaching textures to materials.
	     * @see https://developer.apple.com/reference/scenekit/scngeometry/1522926-getgeometrysources
	     */

	  }, {
	    key: 'getGeometrySourcesForSemantic',
	    value: function getGeometrySourcesForSemantic(semantic) {
	      return this._geometrySources.filter(function (source) {
	        return source.semantic === semantic;
	      });
	    }

	    /**
	     * An array of geometry elements that describe the geometrys shape.
	     * @type {SCNGeometryElement[]}
	     * @desc Each SCNGeometryElement object describes how vertices from the geometrys sources are combined into polygons to create the geometrys shape. Visible geometries contain at least one element.For geometries with multiple elements, you can use the materials property to attach different materials to each element.
	     * @see https://developer.apple.com/reference/scenekit/scngeometry/1523046-geometryelements
	     */

	  }, {
	    key: 'getBoundingSphere',


	    ///////////////////////
	    // SCNBoundingVolume //
	    ///////////////////////

	    // Working with Bounding Volumes

	    /**
	     * The center point and radius of the objects bounding sphere.
	     * @type {Object}
	     * @parameter {SCNVector3} _boundingSphere.center -
	     * @parameter {number} _boundingSphere.radius -
	     * @returns {Object} -
	     * @desc Scene Kit defines a bounding sphere in the local coordinate space using a center point and a radius. For example, if a nodes bounding sphere has the center point {3, 1, 4} and radius 2.0, all points in the vertex data of nodes geometry (and any geometry attached to its child nodes) lie within 2.0 units of the center point.The coordinates provided when reading this property are valid only if the object has a volume to be measured. For a geometry containing no vertex data or a node containing no geometry (and whose child nodes, if any, contain no geometry), the values center and radius are both zero.
	     * @see https://developer.apple.com/reference/scenekit/scnboundingvolume/2034707-boundingsphere
	     */
	    value: function getBoundingSphere() {
	      if (this.boundingBox === null) {
	        return { center: new _SCNVector2.default(0, 0, 0), radius: 0 };
	      }
	      var max = this.boundingBox.max;
	      var min = this.boundingBox.min;
	      var w = (max.x - min.x) * 0.5;
	      var h = (max.y - min.y) * 0.5;
	      var l = (max.z - min.z) * 0.5;
	      var r = Math.sqrt(w * w + h * h + l * l);
	      var c = new _SCNVector2.default(min.x + w, min.y + h, min.z + l);

	      return { center: c, radius: r };
	    }

	    /////////////////
	    // SCNShadable //
	    /////////////////

	    // Handling Parameters in Custom OpenGL Shader Programs

	    /**
	     * Specifies a block to be called before rendering with programs with the specified GLSL uniform variable or attribute name.
	     * @access public
	     * @param {string} symbol - A GLSL uniform variable or attribute name.
	     * @param {?SCNBindingBlock} [block = null] - A block to be called by SceneKit.
	     * @returns {void}
	     * @desc Use this method to associate a block with a SceneKit object (geometry or material) to handle setup of an attribute or uniform variable in a custom SCNProgram shader associated with that object. SceneKit calls your block before rendering the object. In the block, you can execute any OpenGL commands or other code necessary for preparing your custom shader. For example, the following block updates the time uniform variable in a custom fragment shader for producing animated effects:CFTimeInterval startTime = CFAbsoluteTimeGetCurrent();
	    [myNode.geometry.firstMaterial handleBindingOfSymbol:@"time" usingBlock:
	      ^(unsigned int programID, unsigned int location, SCNNode *renderedNode, SCNRenderer *renderer) {
	          glUniform1f(location, CFAbsoluteTimeGetCurrent() - startTime);
	      }];
	    This method is for OpenGL shader programs only. To bind custom variable data for Metal shader programs, use the handleBinding(ofBufferNamed:frequency:handler:) method.CFTimeInterval startTime = CFAbsoluteTimeGetCurrent();
	    [myNode.geometry.firstMaterial handleBindingOfSymbol:@"time" usingBlock:
	      ^(unsigned int programID, unsigned int location, SCNNode *renderedNode, SCNRenderer *renderer) {
	          glUniform1f(location, CFAbsoluteTimeGetCurrent() - startTime);
	      }];
	      * @see https://developer.apple.com/reference/scenekit/scnshadable/1523063-handlebinding
	     */

	  }, {
	    key: 'handleBindingOfSymbolHandler',
	    value: function handleBindingOfSymbolHandler(symbol) {
	      var block = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
	    }

	    /**
	     * Specifies a block to be called after rendering with programs with the specified GLSL uniform variable or attribute name.
	     * @access public
	     * @param {string} symbol - A GLSL uniform variable or attribute name.
	     * @param {?SCNBindingBlock} [block = null] - A block to be called by SceneKit.
	     * @returns {void}
	     * @desc Use this method to associate a block with a SceneKit object (geometry or material) to handle cleanup related to an attribute or uniform variable in a custom SCNProgram shader associated with that object. SceneKit will call your block after rendering the object. In the block, you can execute any OpenGL commands or other code necessary for post-rendering tasks.This method is for OpenGL shader programs only. To bind custom variable data for Metal shader programs, use the handleBinding(ofBufferNamed:frequency:handler:) method.
	     * @see https://developer.apple.com/reference/scenekit/scnshadable/1522783-handleunbinding
	     */

	  }, {
	    key: 'handleUnbindingOfSymbolHandler',
	    value: function handleUnbindingOfSymbolHandler(symbol) {
	      var block = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
	    }

	    ///////////////////
	    // SCNAnimatable //
	    ///////////////////

	    // Managing Animations

	    /**
	     * Required. Adds an animation object for the specified key.
	     * @access public
	     * @param {CAAnimation} animation - The animation object to be added.
	     * @param {?string} key - An string identifying the animation for later retrieval. You may pass nil if you dont need to reference the animation later.
	     * @returns {void}
	     * @desc Newly added animations begin executing after the current run loop cycle ends.SceneKit does not define any requirements for the contents of the key parameterit need only be unique among the keys for other animations you add. If you add an animation with an existing key, this method overwrites the existing animation.
	     * @see https://developer.apple.com/reference/scenekit/scnanimatable/1523386-addanimation
	     */

	  }, {
	    key: 'addAnimationForKey',
	    value: function addAnimationForKey(animation, key) {
	      if (typeof key === 'undefined' || key === null) {
	        key = Symbol();
	      }
	      var anim = animation.copy();
	      // FIXME: use current frame time
	      anim._animationStartTime = Date.now() * 0.001;
	      anim._prevTime = anim._animationStartTime - 0.0000001;

	      this._animations.set(key, anim);
	    }

	    /**
	     * Required. Returns the animation with the specified key.
	     * @access public
	     * @param {string} key - A string identifying a previously added animation.
	     * @returns {?CAAnimation} - 
	     * @desc Attempting to modify any properties of the returned object results in undefined behavior.
	     * @see https://developer.apple.com/reference/scenekit/scnanimatable/1524020-animation
	     */

	  }, {
	    key: 'animationForKey',
	    value: function animationForKey(key) {
	      return this._animations.get(key);
	    }

	    /**
	     * Required. Removes all the animations currently attached to the object.
	     * @access public
	     * @returns {void}
	     * @see https://developer.apple.com/reference/scenekit/scnanimatable/1522762-removeallanimations
	     */

	  }, {
	    key: 'removeAllAnimations',
	    value: function removeAllAnimations() {
	      this._animations.clear();
	    }

	    /**
	     * Required. Removes the animation attached to the object with the specified key.
	     * @access public
	     * @param {string} key - A string identifying an attached animation to remove.
	     * @returns {void}
	     * @see https://developer.apple.com/reference/scenekit/scnanimatable/1522880-removeanimation
	     */

	  }, {
	    key: 'removeAnimationForKey',
	    value: function removeAnimationForKey(key) {
	      this._animations.delete(key);
	      // TODO: reset values
	    }

	    /**
	     * Required. Removes the animation attached to the object with the specified key, smoothly transitioning out of the animations effect.
	     * @access public
	     * @param {string} key - A string identifying an attached animation to remove.
	     * @param {number} duration - The duration for transitioning out of the animations effect before it is removed.
	     * @returns {void}
	     * @desc Use this method to create smooth transitions between the effects of multiple animations. For example, the geometry loaded from a scene file for a game character may have associated animations for player actions such as walking and jumping. When the player lands from a jump, you remove the jump animation so the character continues walking. If you use the removeAnimation(forKey:) method to remove the jump animation, SceneKit abruptly switches from the current frame of the jump animation to the current frame of the walk animation. If you use the removeAnimation(forKey:fadeOutDuration:) method instead, SceneKit plays both animations at once during that duration and interpolates vertex positions from one animation to the other, creating a smooth transition.
	     * @see https://developer.apple.com/reference/scenekit/scnanimatable/1522841-removeanimation
	     */

	  }, {
	    key: 'removeAnimationForKeyFadeOutDuration',
	    value: function removeAnimationForKeyFadeOutDuration(key, duration) {}

	    /**
	     * Required. An array containing the keys of all animations currently attached to the object.
	     * @type {string[]}
	     * @desc This array contains all keys for which animations are attached to the object, or is empty if there are no attached animations. The ordering of animation keys in the array is arbitrary.
	     * @see https://developer.apple.com/reference/scenekit/scnanimatable/1523610-animationkeys
	     */

	  }, {
	    key: 'pauseAnimationForKey',


	    // Pausing and Resuming Animations

	    /**
	     * Required. Pauses the animation attached to the object with the specified key.
	     * @access public
	     * @param {string} key - A string identifying an attached animation.
	     * @returns {void}
	     * @desc This method has no effect if no animation is attached to the object with the specified key.
	     * @see https://developer.apple.com/reference/scenekit/scnanimatable/1523592-pauseanimation
	     */
	    value: function pauseAnimationForKey(key) {}

	    /**
	     * Required. Resumes a previously paused animation attached to the object with the specified key.
	     * @access public
	     * @param {string} key - A string identifying an attached animation.
	     * @returns {void}
	     * @desc This method has no effect if no animation is attached to the object with the specified key or if the specified animation is not currently paused.
	     * @see https://developer.apple.com/reference/scenekit/scnanimatable/1523332-resumeanimation
	     */

	  }, {
	    key: 'resumeAnimationForKey',
	    value: function resumeAnimationForKey(key) {}

	    /**
	     * Required. Returns a Boolean value indicating whether the animation attached to the object with the specified key is paused.
	     * @access public
	     * @param {string} key - A string identifying an attached animation.
	     * @returns {boolean} - 
	     * @see https://developer.apple.com/reference/scenekit/scnanimatable/1523703-isanimationpaused
	     */

	  }, {
	    key: 'isAnimationPausedForKey',
	    value: function isAnimationPausedForKey(key) {
	      return false;
	    }

	    // Instance Methods

	    /**
	     * Required. 
	     * @access public
	     * @param {number} speed - 
	     * @param {string} key - 
	     * @returns {void}
	     * @see https://developer.apple.com/reference/scenekit/scnanimatable/1778343-setanimationspeed
	     */

	  }, {
	    key: 'setAnimationSpeedForKey',
	    value: function setAnimationSpeedForKey(speed, key) {}

	    /**
	     * @access private
	     * @param {WebGLContext} gl -
	     * @param {SCNGeometry} geometry - 
	     * @param {boolean} update -
	     * @returns {WebGLBuffer} -
	     */
	    //_createVertexBuffer(gl, baseGeometry, update = false) {

	  }, {
	    key: '_createVertexBuffer',
	    value: function _createVertexBuffer(gl, node) {
	      var update = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

	      var _base = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

	      var baseGeometry = _base === null ? node.geometry : _base;
	      var baseSkinner = node.skinner;
	      var skinner = node.presentation.skinner;
	      if (this._vertexBuffer === null) {
	        this._vertexBuffer = gl.createBuffer();
	      } else if (!update) {
	        return this._vertexBuffer;
	      }

	      gl.bindBuffer(gl.ARRAY_BUFFER, this._vertexBuffer);
	      var arr = [];
	      var vertexSource = baseGeometry.getGeometrySourcesForSemantic(_SCNGeometrySource2.default.Semantic.vertex)[0];
	      var normalSource = baseGeometry.getGeometrySourcesForSemantic(_SCNGeometrySource2.default.Semantic.normal)[0];
	      var tangentSource = baseGeometry.getGeometrySourcesForSemantic(_SCNGeometrySource2.default.Semantic.tangent)[0];
	      var colorSource = baseGeometry.getGeometrySourcesForSemantic(_SCNGeometrySource2.default.Semantic.color)[0];
	      var texcoordSource0 = baseGeometry.getGeometrySourcesForSemantic(_SCNGeometrySource2.default.Semantic.texcoord)[0];
	      var texcoordSource1 = baseGeometry.getGeometrySourcesForSemantic(_SCNGeometrySource2.default.Semantic.texcoord)[1];
	      var indexSource = baseSkinner ? baseSkinner._boneIndices : null;
	      var weightSource = baseSkinner ? baseSkinner._boneWeights : null;
	      var vectorCount = vertexSource.vectorCount;

	      var pVertexSource = this.getGeometrySourcesForSemantic(_SCNGeometrySource2.default.Semantic.vertex)[0];
	      var pNormalSource = this.getGeometrySourcesForSemantic(_SCNGeometrySource2.default.Semantic.normal)[0];
	      var pTangentSource = this.getGeometrySourcesForSemantic(_SCNGeometrySource2.default.Semantic.tangent)[0];
	      var pColorSource = this.getGeometrySourcesForSemantic(_SCNGeometrySource2.default.Semantic.color)[0];
	      var pTexcoordSource0 = this.getGeometrySourcesForSemantic(_SCNGeometrySource2.default.Semantic.texcoord)[0];
	      var pTexcoordSource1 = this.getGeometrySourcesForSemantic(_SCNGeometrySource2.default.Semantic.texcoord)[1];
	      //const pIndexSource = this.getGeometrySourcesForSemantic(SCNGeometrySource.Semantic.boneIndices)[0]
	      var pIndexSource = skinner ? skinner._boneIndices : null;
	      //const pWeightSource = this.getGeometrySourcesForSemantic(SCNGeometrySource.Semantic.boneWeights)[0]
	      var pWeightSource = skinner ? skinner._boneWeights : null;

	      if (typeof vertexSource === 'undefined') {
	        throw new Error('vertexSource is undefined');
	      }
	      if (typeof normalSource !== 'undefined' && normalSource.vectorCount !== vectorCount) {
	        throw new Error('normalSource.vectorCount !== vertexSource.vectorCount');
	      }
	      if (typeof tangentSource !== 'undefined' && tangentSource.vectorCount !== vectorCount) {
	        throw new Error('tangentSource.vectorCount !== vertexSource.vectorCount');
	      }
	      if (typeof colorSource !== 'undefined' && colorSource.vectorCount !== vectorCount) {
	        throw new Error('colorSource.vectorCount !== vertexSource.vectorCount');
	      }
	      if (typeof texcoordSource0 !== 'undefined' && texcoordSource0.vectorCount !== vectorCount) {
	        throw new Error('texcoordSource0.vectorCount !== vertexSource.vectorCount');
	      }
	      if (typeof texcoordSource1 !== 'undefined' && texcoordSource1.vectorCount !== vectorCount) {
	        throw new Error('texcoordSource1.vectorCount !== vertexSource.vectorCount');
	      }
	      if (typeof tangentSource === 'undefined' && this.materials.find(function (m) {
	        return !(m._normal._contents instanceof _SKColor2.default);
	      })) {
	        tangentSource = this._createTangentSource();
	        pTangentSource = tangentSource;
	        this._geometrySources.push(tangentSource);
	        if (baseGeometry !== this) {
	          baseGeometry._geometrySources.push(tangentSource);
	        }
	      }

	      //const vertexArray = vertexSource ? vertexSource.data : null
	      var vertexComponents = vertexSource ? vertexSource.componentsPerVector : 0;
	      //const normalArray = normalSource ? normalSource.data : null
	      var normalComponents = normalSource ? normalSource.componentsPerVector : 0;
	      var tangentComponents = tangentSource ? tangentSource.componentsPerVector : 0;
	      var colorComponents = colorSource ? colorSource.componentsPerVector : 0;
	      //const texcoordArray = texcoordSource ? texcoordSource.data : null
	      var texcoord0Components = texcoordSource0 ? texcoordSource0.componentsPerVector : 0;
	      var texcoord1Components = texcoordSource1 ? texcoordSource1.componentsPerVector : 0;

	      for (var i = 0; i < vectorCount; i++) {
	        if (vertexSource) {
	          arr.push.apply(arr, _toConsumableArray(vertexSource._vectorAt(i)));
	        }
	        if (normalSource) {
	          arr.push.apply(arr, _toConsumableArray(normalSource._vectorAt(i)));
	        }
	        if (tangentSource) {
	          arr.push.apply(arr, _toConsumableArray(tangentSource._vectorAt(i)));
	        }
	        if (colorSource) {
	          arr.push.apply(arr, _toConsumableArray(colorSource._vectorAt(i)));
	        }
	        if (texcoordSource0) {
	          arr.push.apply(arr, _toConsumableArray(texcoordSource0._vectorAt(i)));
	        }
	        if (texcoordSource1) {
	          arr.push.apply(arr, _toConsumableArray(texcoordSource1._vectorAt(i)));
	        }
	      }

	      //console.log(`vertex(0): ${vertexSource._vectorAt(0)}`)
	      //console.log(`normal(0): ${normalSource._vectorAt(0)}`)
	      //console.log(`texcoord(0): ${texcoordSource._vectorAt(0)}`)

	      // update geometry sources
	      // FIXME: Don't change geometry sources. Use other variables
	      var bytesPerComponent = 4;
	      var offset = 0;
	      var stride = (vertexComponents + normalComponents + tangentComponents + colorComponents + texcoord0Components + texcoord1Components) * bytesPerComponent;

	      pVertexSource._bytesPerComponent = bytesPerComponent;
	      pVertexSource._dataOffset = offset;
	      pVertexSource._dataStride = stride;
	      offset += vertexComponents * bytesPerComponent;

	      if (pNormalSource) {
	        pNormalSource._bytesPerComponent = bytesPerComponent;
	        pNormalSource._dataOffset = offset;
	        pNormalSource._dataStride = stride;
	        offset += normalComponents * bytesPerComponent;
	      }
	      if (pTangentSource) {
	        pTangentSource._bytesPerComponent = bytesPerComponent;
	        pTangentSource._dataOffset = offset;
	        pTangentSource._dataStride = stride;
	        offset += tangentComponents * bytesPerComponent;
	      }
	      if (pColorSource) {
	        pColorSource._bytesPerComponent = bytesPerComponent;
	        pColorSource._dataOffset = offset;
	        pColorSource._dataStride = stride;
	        offset += colorComponents * bytesPerComponent;
	      }
	      if (pTexcoordSource0) {
	        pTexcoordSource0._bytesPerComponent = bytesPerComponent;
	        pTexcoordSource0._dataOffset = offset;
	        pTexcoordSource0._dataStride = stride;
	        offset += texcoord0Components * bytesPerComponent;
	      }
	      if (pTexcoordSource1) {
	        pTexcoordSource1._bytesPerComponent = bytesPerComponent;
	        pTexcoordSource1._dataOffset = offset;
	        pTexcoordSource1._dataStride = stride;
	        offset += texcoord1Components * bytesPerComponent;
	      }

	      //console.log(`offset: ${offset}, vectorCount: ${vectorCount}`)
	      offset *= vectorCount;

	      var indexArray = indexSource ? indexSource.data : null;
	      var indexComponents = indexSource ? indexSource.componentsPerVector : 0;
	      var weightArray = weightSource ? weightSource.data : null;
	      var weightComponents = weightSource ? weightSource.componentsPerVector : 0;
	      var boneStride = (indexComponents + weightComponents) * bytesPerComponent;

	      for (var _i = 0; _i < vectorCount; _i++) {
	        if (indexSource) {
	          arr.push.apply(arr, _toConsumableArray(indexSource._vectorAt(_i)));
	        }
	        if (weightSource) {
	          arr.push.apply(arr, _toConsumableArray(weightSource._vectorAt(_i)));
	        }
	      }

	      if (pIndexSource) {
	        pIndexSource._bytesPerComponent = bytesPerComponent;
	        pIndexSource._dataOffset = offset;
	        pIndexSource._dataStride = boneStride;
	        offset += indexComponents * bytesPerComponent;
	      }
	      if (pWeightSource) {
	        pWeightSource._bytesPerComponent = bytesPerComponent;
	        pWeightSource._dataOffset = offset;
	        pWeightSource._dataStride = boneStride;
	        offset += weightComponents * bytesPerComponent;
	      }

	      var vertexData = new Float32Array(arr);
	      //console.log(`vertexData length: ${arr.length}`)
	      gl.bufferData(gl.ARRAY_BUFFER, vertexData, gl.DYNAMIC_DRAW);

	      // set new data
	      pVertexSource._data = arr;
	      if (pNormalSource) {
	        pNormalSource._data = arr;
	      }
	      if (pTangentSource) {
	        pTangentSource._data = arr;
	      }
	      if (pColorSource) {
	        pColorSource._data = arr;
	      }
	      if (pTexcoordSource0) {
	        pTexcoordSource0._data = arr;
	      }
	      if (pTexcoordSource1) {
	        pTexcoordSource1._data = arr;
	      }
	      if (pIndexSource) {
	        pIndexSource._data = arr;
	      }
	      if (pWeightSource) {
	        pWeightSource._data = arr;
	      }

	      return this._vertexBuffer;
	    }

	    /**
	     * @access private
	     * @param {WebGLContext} gl -
	     * @param {boolean} update -
	     * @returns {WebGLBuffer} -
	     */

	  }, {
	    key: '_createIndexBuffer',
	    value: function _createIndexBuffer(gl) {
	      var update = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

	      if (this._indexBuffer && !update) {
	        return this._indexBuffer;
	      }
	      this._indexBuffer = this._geometryElements[0]._createBuffer(gl);
	      return this._indexBuffer;
	    }

	    /**
	     * @access private
	     * @param {WebGLRenderingContext} gl -
	     * @param {SCNGeometry} baseGeometry - 
	     * @returns {void}
	     */

	  }, {
	    key: '_updateVertexBuffer',
	    value: function _updateVertexBuffer(gl, baseGeometry) {
	      //this._createVertexBuffer(gl, baseGeometry, true)
	      var pVertexSource = this.getGeometrySourcesForSemantic(_SCNGeometrySource2.default.Semantic.vertex)[0];
	      var vertexData = new Float32Array(pVertexSource._data);
	      gl.bindBuffer(gl.ARRAY_BUFFER, this._vertexBuffer);
	      gl.bufferData(gl.ARRAY_BUFFER, vertexData, gl.DYNAMIC_DRAW);
	    }

	    /**
	     * @access private
	     * @param {WebGLRenderingContext} gl -
	     * @param {WebGLProgram} program -
	     * @param {number} index - material index
	     * @param {number} opacity -
	     * @returns {void}
	     */

	  }, {
	    key: '_bufferMaterialData',
	    value: function _bufferMaterialData(gl, program, index, opacity) {
	      // TODO: move this function to SCNProgram
	      var materialCount = this.materials.length;
	      var material = this.materials[index % materialCount];
	      var diffuse = material.diffuse.float32Array();
	      diffuse[3] *= opacity;
	      var ambient = null;
	      if (material.locksAmbientWithDiffuse) {
	        ambient = diffuse;
	      } else {
	        ambient = material.ambient.float32Array();
	        ambient[3] *= opacity;
	      }
	      var materialData = new Float32Array([].concat(_toConsumableArray(ambient), _toConsumableArray(diffuse), _toConsumableArray(material.specular.float32Array()), _toConsumableArray(material.emission.float32Array()), [material.shininess * 100.0, material.fresnelExponent, 0, 0 // needs padding for 16-byte alignment
	      ]));
	      gl.bindBuffer(gl.UNIFORM_BUFFER, this._materialBuffer);
	      gl.bufferData(gl.UNIFORM_BUFFER, materialData, gl.DYNAMIC_DRAW);
	      gl.bindBuffer(gl.UNIFORM_BUFFER, null);

	      var textureFlags = [];
	      //const textures = [
	      //  { name: 'emission', symbol: 'TEXTURE0' },
	      //  { name: 'ambient', symbol: 'TEXTURE1' },
	      //  { name: 'diffuse', symbol: 'TEXTURE2' },
	      //  { name: 'specular', symbol: 'TEXTURE3' },
	      //  { name: 'reflective', symbol: 'TEXTURE4' },
	      //  { name: 'transparent', symbol: 'TEXTURE5' },
	      //  { name: 'multiply', symbol: 'TEXTURE6' },
	      //  { name: 'normal', symbol: 'TEXTURE7' }
	      //]

	      // emission
	      var selfIllumination = 0;
	      if (material._selfIllumination._contents instanceof Image || material._selfIllumination._contents instanceof WebGLTexture) {
	        this._setTextureToName(gl, material._selfIllumination, 'TEXTURE0', textureFlags);
	        selfIllumination = 1;
	      } else if (material._emission._contents instanceof Image || material._emission._contents instanceof WebGLTexture) {
	        this._setTextureToName(gl, material._emission, 'TEXTURE0', textureFlags);
	      } else {
	        textureFlags.push(0);
	      }
	      gl.uniform1i(gl.getUniformLocation(program, 'selfIllumination'), selfIllumination);

	      // ambient
	      this._setTextureToName(gl, material._ambient, 'TEXTURE1', textureFlags);

	      // diffuse
	      this._setTextureToName(gl, material._diffuse, 'TEXTURE2', textureFlags);

	      // specular
	      this._setTextureToName(gl, material._specular, 'TEXTURE3', textureFlags);

	      // reflective
	      this._setCubeTextureToName(gl, material._reflective, 'TEXTURE4', textureFlags);

	      // transparent
	      this._setTextureToName(gl, material._transparent, 'TEXTURE5', textureFlags);

	      // multiply
	      this._setTextureToName(gl, material._multiply, 'TEXTURE6', textureFlags);

	      // normal
	      this._setTextureToName(gl, material._normal, 'TEXTURE7', textureFlags);

	      //for(const texture of textures){
	      //  this._setTextureToName(gl, material[texture.name], texture.symbol, textureFlags)
	      //}

	      // TODO: cache uniform location
	      gl.uniform1iv(gl.getUniformLocation(program, 'textureFlags'), new Int32Array(textureFlags));

	      if (material.isDoubleSided) {
	        gl.disable(gl.CULL_FACE);
	      } else {
	        gl.enable(gl.CULL_FACE);
	        if (material.cullMode === _SCNCullMode2.default.back) {
	          gl.cullFace(gl.BACK);
	        } else {
	          gl.cullFace(gl.FRONT);
	        }
	      }
	    }

	    /**
	     * @access private
	     * @param {WebGLRenderingContext} gl -
	     * @param {SCNMaterialProperty} m -
	     * @param {string} name -
	     * @param {boolean[]} textureFlags -
	     * @returns {void}
	     */

	  }, {
	    key: '_setCubeTextureToName',
	    value: function _setCubeTextureToName(gl, m, name, textureFlags) {
	      if (m._contents instanceof Image) {
	        m._contents = this._createCubeTexture(gl, m._contents);
	      }
	      if (m._contents instanceof WebGLTexture) {
	        textureFlags.push(1);
	        gl.activeTexture(gl[name]);
	        gl.bindTexture(gl.TEXTURE_CUBE_MAP, m._contents);
	        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, m._magnificationFilterFor(gl));
	        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, m._minificationFilterFor(gl));
	        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, m._wrapSFor(gl));
	        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, m._wrapTFor(gl));
	      } else {
	        textureFlags.push(0);
	      }
	    }

	    /**
	     * @access private
	     * @param {WebGLRenderingContext} gl -
	     * @param {SCNMaterialProperty} m -
	     * @param {string} name -
	     * @param {boolean[]} textureFlags -
	     * @returns {void}
	     */

	  }, {
	    key: '_setTextureToName',
	    value: function _setTextureToName(gl, m, name, textureFlags) {
	      if (m._contents instanceof Image) {
	        m._contents = this._createTexture(gl, m._contents);
	      }
	      if (m._contents instanceof WebGLTexture) {
	        textureFlags.push(1);
	        gl.activeTexture(gl[name]);
	        gl.bindTexture(gl.TEXTURE_2D, m._contents);
	        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, m._magnificationFilterFor(gl));
	        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, m._minificationFilterFor(gl));
	        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, m._wrapSFor(gl));
	        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, m._wrapTFor(gl));
	      } else {
	        textureFlags.push(0);
	      }
	    }
	  }, {
	    key: '_createTangentSource',
	    value: function _createTangentSource() {
	      var elements = this._geometryElements;
	      var vertex = this.getGeometrySourcesForSemantic(_SCNGeometrySource2.default.Semantic.vertex)[0];
	      var texcoord = this.getGeometrySourcesForSemantic(_SCNGeometrySource2.default.Semantic.texcoord)[0];

	      var data = [];
	      var semantic = _SCNGeometrySource2.default.Semantic.tangent;
	      var vectorCount = vertex.vectorCount;
	      var floatComponents = true;
	      var componentsPerVector = 3;
	      var bytesPerComponent = 4;
	      var dataOffset = 0;
	      var dataStride = 12;

	      var tangent = [];
	      for (var i = 0; i < vectorCount; i++) {
	        tangent.push(new _SCNVector2.default(0, 0, 0));
	      }

	      var _iteratorNormalCompletion2 = true;
	      var _didIteratorError2 = false;
	      var _iteratorError2 = undefined;

	      try {
	        for (var _iterator2 = elements[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
	          var element = _step2.value;

	          var len = element.primitiveCount;
	          for (var _i3 = 0; _i3 < len; _i3++) {
	            var index = element._indexAt(_i3);
	            var pos0 = vertex._scnVectorAt(index[0]);
	            var pos1 = vertex._scnVectorAt(index[1]);
	            var pos2 = vertex._scnVectorAt(index[2]);
	            var tex0 = texcoord._scnVectorAt(index[0]);
	            var tex1 = texcoord._scnVectorAt(index[1]);
	            var tex2 = texcoord._scnVectorAt(index[2]);

	            var p1 = pos1.sub(pos0);
	            var p2 = pos2.sub(pos0);
	            var t1 = tex1.sub(tex0);
	            var t2 = tex2.sub(tex0);

	            var t = p1.mul(t2.y).sub(p2.mul(t1.y));
	            tangent[index[0]] = tangent[index[0]].add(t);
	            tangent[index[1]] = tangent[index[1]].add(t);
	            tangent[index[2]] = tangent[index[2]].add(t);
	          }
	        }
	      } catch (err) {
	        _didIteratorError2 = true;
	        _iteratorError2 = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion2 && _iterator2.return) {
	            _iterator2.return();
	          }
	        } finally {
	          if (_didIteratorError2) {
	            throw _iteratorError2;
	          }
	        }
	      }

	      for (var _i2 = 0; _i2 < vectorCount; _i2++) {
	        data.push.apply(data, _toConsumableArray(tangent[_i2].normalize().floatArray()));
	      }

	      return new _SCNGeometrySource2.default(data, semantic, vectorCount, floatComponents, componentsPerVector, bytesPerComponent, dataOffset, dataStride);
	    }
	  }, {
	    key: 'copy',
	    value: function copy() {
	      var geometry = new SCNGeometry();
	      geometry.name = this.name;
	      geometry.levelsOfDetail = this.levelsOfDetail;
	      geometry.materials = this.materials;
	      geometry._geometryElements = this._geometryElements.slice(0);
	      geometry._geometrySources = this._geometrySources.slice(0);
	      geometry._vertexArrayObjects = this._vertexArrayObjects ? this._vertexArrayObjects.slice(0) : null;
	      geometry.subdivisonLevel = this.subdivisionLevel;
	      geometry.edgeCreasesElement = this.edgeCreasesElement;
	      geometry.edgeCreasesSource = this.edgeCreasesSource;
	      geometry.program = this.program;
	      geometry.shaderModifiers = this.shaderModifiers;
	      //geometry._animationKeys = this._animationKeys
	      geometry.boundingBox = this.boundingBox;
	      //geometry._boundingSphere = this._boundingSphere
	      geometry._vertexBuffer = this._vertexBuffer;
	      geometry._indexBuffer = this._indexBuffer;
	      geometry._animations = this._animations.copy();
	      geometry._shadableHelper = this._shadableHelper;

	      return geometry;
	    }

	    /**
	     * @access private
	     * @param {WebGLRenderingContext} gl -
	     * @param {Image} image -
	     * @returns {WebGLTexture} -
	     */

	  }, {
	    key: '_createCubeTexture',
	    value: function _createCubeTexture(gl, image) {
	      var texture = gl.createTexture();

	      gl.bindTexture(gl.TEXTURE_CUBE_MAP, texture);
	      // texImage2D(target, level, internalformat, width, height, border, format, type, source)
	      // Safari complains that 'source' is not ArrayBufferView type, but WebGL2 should accept HTMLCanvasElement.
	      var targets = [gl.TEXTURE_CUBE_MAP_POSITIVE_Z, gl.TEXTURE_CUBE_MAP_POSITIVE_X, gl.TEXTURE_CUBE_MAP_NEGATIVE_Z, gl.TEXTURE_CUBE_MAP_NEGATIVE_X, gl.TEXTURE_CUBE_MAP_NEGATIVE_Y, gl.TEXTURE_CUBE_MAP_POSITIVE_Y];
	      //const tx = [0, 1.0/6.0, 2.0/6.0, 3.0/6.0, 4.0/6.0, 5.0/6.0, 1]
	      //const itx = [4, 1, 5, 0, 2, 3]
	      var margin = 0.001;
	      var sx = [4.0 / 6.0 + margin, 1.0 / 6.0 + margin, 5.0 / 6.0 + margin, 0 + margin, 2.0 / 6.0 + margin, 3.0 / 6.0 + margin];
	      var imageWidth = image.naturalWidth;
	      var imageHeight = image.naturalHeight;
	      var srcWidth = imageHeight - margin * 2;

	      for (var i = 0; i < 6; i++) {
	        var canvas = document.createElement('canvas');
	        canvas.width = imageHeight;
	        canvas.height = imageHeight;
	        canvas.getContext('2d').drawImage(image, sx[i], 0, srcWidth, imageHeight, 0, 0, imageHeight, imageHeight);

	        gl.texImage2D(targets[i], 0, gl.RGBA, imageHeight, imageHeight, 0, gl.RGBA, gl.UNSIGNED_BYTE, canvas);
	      }

	      gl.generateMipmap(gl.TEXTURE_CUBE_MAP);
	      return texture;
	    }

	    /**
	     * @access private
	     * @param {WebGLRenderingContext} gl -
	     * @param {Image} image -
	     * @returns {WebGLTexture} -
	     */

	  }, {
	    key: '_createTexture',
	    value: function _createTexture(gl, image) {
	      var texture = gl.createTexture();

	      var canvas = document.createElement('canvas');
	      canvas.width = image.naturalWidth;
	      canvas.height = image.naturalHeight;
	      //console.warn(`image size: ${image.naturalWidth} ${image.naturalHeight}`)
	      canvas.getContext('2d').drawImage(image, 0, 0);

	      gl.bindTexture(gl.TEXTURE_2D, texture);
	      // texImage2D(target, level, internalformat, width, height, border, format, type, source)
	      // Safari complains that 'source' is not ArrayBufferView type, but WebGL2 should accept HTMLCanvasElement.
	      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, image.width, image.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, canvas);
	      gl.generateMipmap(gl.TEXTURE_2D);
	      //gl.bindTexture(gl.TEXTURE_2D, null)
	      return texture;
	    }

	    /**
	     * @access private
	     * @returns {Ammo.btCollisionShape}
	     * @desc call Ammo.destroy(shape) after using it.
	     */

	  }, {
	    key: '_createBtCollisionShape',
	    value: function _createBtCollisionShape() {
	      return this._createBtConvexTriangleMeshShape();
	    }
	  }, {
	    key: '_createBtConvexTriangleMeshShape',
	    value: function _createBtConvexTriangleMeshShape() {
	      //this._destoryShape()
	      //this._btVertices = []

	      //const vertexSource = this.getGeometrySourcesForSemantic(SCNGeometrySource.Semantic.vertex)[0]
	      //const vertexCount = vertexSource.vectorCount
	      //for(let i=0; i<vertexCount; i++){
	      //  this._btVertices.push(vertexSource._scnVectorAt(i)._createBtVector3())
	      //}

	      //this._btMesh = new Ammo.btTriangleMesh(false, false) // 16bit indices, 3 component vertices
	      //for(const element of this._geometryElements){
	      //  const indexCount = element._primitiveCount
	      //  for(let i=0; i<indexCount; i++){
	      //    // TODO: check primitiveType
	      //    const indices = element._indexAt(i)
	      //    this._btMesh.addTriangle(
	      //      this._btVertices[indices[0]],
	      //      this._btVertices[indices[1]],
	      //      this._btVertices[indices[2]],
	      //      true
	      //    )
	      //  }
	      //}

	      //const calcAabb = true
	      //this._btShape = new Ammo.btTriangleMeshShape(this._btMesh, calcAabb)

	      //return this._btShape
	    }
	  }, {
	    key: '_destroyShape',
	    value: function _destroyShape() {
	      //if(this._btShape === null){
	      //  return
	      //}
	      //Ammo.destroy(this._btShape)
	      //this._btShape = null

	      //Ammo.destroy(this._btMesh)
	      //this._btMesh = null

	      //for(const v of this._btVertices){
	      //  Ammo.destroy(v)
	      //}
	      //this._btVerices = null
	    }
	  }, {
	    key: '_execDestory',
	    value: function _execDestory() {
	      // TODO: delete indexBuffer, vertexBuffer
	      this._destroyShape();
	    }
	  }, {
	    key: 'firstMaterial',
	    get: function get() {
	      return this.materials[0];
	    },
	    set: function set(newValue) {
	      this.materials[0] = newValue;
	    }
	  }, {
	    key: 'geometryElements',
	    get: function get() {
	      return this._geometryElements.slice(0);
	    }

	    /**
	     * An array of geometry sources that provide vertex data for the geometry.
	     * @type {SCNGeometrySource[]}
	     * @desc Each SCNGeometrySource object describes an attribute of all vertices in the geometry (such as vertex position, surface normal vector, color, or texture mapping coordinates) identified by the sources semantic property. A geometry always has at least one source (for the vertex semantic), typically has additional sources for use in lighting and shading, and may have other sources for skeletal animation or surface subdivision information.
	     * @see https://developer.apple.com/reference/scenekit/scngeometry/1523662-geometrysources
	     */

	  }, {
	    key: 'geometrySources',
	    get: function get() {
	      return this._geometrySources.slice(0);
	    }
	  }, {
	    key: 'geometryGLSource',
	    get: function get() {
	      return new Float32Array(this._geometrySources[0]);
	    }

	    /**
	     * The number of geometry elements in the geometry.
	     * @type {number}
	     * @desc Each SCNGeometryElement object describes how vertices from the geometrys sources are combined into polygons to create the geometrys shape. Visible geometries contain at least one element.For geometries with multiple elements, you can use the materials property to attach different materials to each element.
	     * @see https://developer.apple.com/reference/scenekit/scngeometry/1523800-geometryelementcount
	     */

	  }, {
	    key: 'geometryElementCount',
	    get: function get() {
	      return this._geometryElements.length;
	    }
	  }, {
	    key: 'animationKeys',
	    get: function get() {
	      var keys = [];
	      var _iteratorNormalCompletion3 = true;
	      var _didIteratorError3 = false;
	      var _iteratorError3 = undefined;

	      try {
	        for (var _iterator3 = this._animations.keys()[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
	          var key = _step3.value;

	          keys.push(key);
	        }
	      } catch (err) {
	        _didIteratorError3 = true;
	        _iteratorError3 = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion3 && _iterator3.return) {
	            _iterator3.return();
	          }
	        } finally {
	          if (_didIteratorError3) {
	            throw _iteratorError3;
	          }
	        }
	      }

	      return keys;
	    }
	  }]);

	  return SCNGeometry;
	}(_NSObject3.default);

	exports.default = SCNGeometry;

/***/ },
/* 69 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * The modes SceneKit uses to determine which polygons to render in a surface, used by the cullMode property.
	 * @typedef {Object} SCNCullMode
	 * @property {number} back - 
	 * @property {number} front - 
	 * @see https://developer.apple.com/reference/scenekit/scncullmode
	 */

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var SCNCullMode = {
	  back: 0,
	  front: 1
	};

	exports.default = SCNCullMode;

/***/ },
/* 70 */
/***/ function(module, exports) {

	'use strict';

	//import SCNProgram from './SCNProgram'
	//import SCNShaderModifierEntryPoint from './SCNShaderModifierEntryPoint'
	//import SCNBindingBlock from './SCNBindingBlock'


	/**
	 * Methods for customizing SceneKit's rendering of geometry and materials using Metal or OpenGL shader programs.
	 * @interface
	 * @see https://developer.apple.com/reference/scenekit/scnshadable
	 */

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var SCNShadable = function () {
	  function SCNShadable() {
	    _classCallCheck(this, SCNShadable);
	  }

	  _createClass(SCNShadable, [{
	    key: 'init',


	    /**
	     * constructor
	     * @access public
	     * @returns {void}
	     */
	    value: function init() {

	      // Assigning a Custom Shader Program

	      /**
	       * A program used when rendering the object.
	       * @type {?SCNProgram}
	       * @see https://developer.apple.com/reference/scenekit/scnshadable/1523689-program
	       */
	      this.program = null;

	      // Customizing SceneKits Shader Programs

	      /**
	       * A dictionary of GLSL source code snippets for customizing the shader programs provided by SceneKit.
	       * @type {?Map<SCNShaderModifierEntryPoint, string>}
	       * @see https://developer.apple.com/reference/scenekit/scnshadable/1523348-shadermodifiers
	       */
	      this.shaderModifiers = null;
	    }

	    // Handling Parameters in Custom OpenGL Shader Programs

	    /**
	     * Specifies a block to be called before rendering with programs with the specified GLSL uniform variable or attribute name.
	     * @access public
	     * @param {string} symbol - A GLSL uniform variable or attribute name.
	     * @param {?SCNBindingBlock} [block = null] - A block to be called by SceneKit.
	     * @returns {void}
	     * @desc Use this method to associate a block with a SceneKit object (geometry or material) to handle setup of an attribute or uniform variable in a custom SCNProgram shader associated with that object. SceneKit calls your block before rendering the object. In the block, you can execute any OpenGL commands or other code necessary for preparing your custom shader. For example, the following block updates the time uniform variable in a custom fragment shader for producing animated effects:CFTimeInterval startTime = CFAbsoluteTimeGetCurrent();
	    [myNode.geometry.firstMaterial handleBindingOfSymbol:@"time" usingBlock:
	      ^(unsigned int programID, unsigned int location, SCNNode *renderedNode, SCNRenderer *renderer) {
	          glUniform1f(location, CFAbsoluteTimeGetCurrent() - startTime);
	      }];
	    This method is for OpenGL shader programs only. To bind custom variable data for Metal shader programs, use the handleBinding(ofBufferNamed:frequency:handler:) method.CFTimeInterval startTime = CFAbsoluteTimeGetCurrent();
	    [myNode.geometry.firstMaterial handleBindingOfSymbol:@"time" usingBlock:
	      ^(unsigned int programID, unsigned int location, SCNNode *renderedNode, SCNRenderer *renderer) {
	          glUniform1f(location, CFAbsoluteTimeGetCurrent() - startTime);
	      }];
	      * @see https://developer.apple.com/reference/scenekit/scnshadable/1523063-handlebinding
	     */

	  }, {
	    key: 'handleBindingOfSymbolHandler',
	    value: function handleBindingOfSymbolHandler(symbol) {
	      var block = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
	    }

	    /**
	     * Specifies a block to be called after rendering with programs with the specified GLSL uniform variable or attribute name.
	     * @access public
	     * @param {string} symbol - A GLSL uniform variable or attribute name.
	     * @param {?SCNBindingBlock} [block = null] - A block to be called by SceneKit.
	     * @returns {void}
	     * @desc Use this method to associate a block with a SceneKit object (geometry or material) to handle cleanup related to an attribute or uniform variable in a custom SCNProgram shader associated with that object. SceneKit will call your block after rendering the object. In the block, you can execute any OpenGL commands or other code necessary for post-rendering tasks.This method is for OpenGL shader programs only. To bind custom variable data for Metal shader programs, use the handleBinding(ofBufferNamed:frequency:handler:) method.
	     * @see https://developer.apple.com/reference/scenekit/scnshadable/1522783-handleunbinding
	     */

	  }, {
	    key: 'handleUnbindingOfSymbolHandler',
	    value: function handleUnbindingOfSymbolHandler(symbol) {
	      var block = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
	    }
	  }]);

	  return SCNShadable;
	}();

	exports.default = SCNShadable;

/***/ },
/* 71 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _NSObject2 = __webpack_require__(2);

	var _NSObject3 = _interopRequireDefault(_NSObject2);

	var _SCNVector = __webpack_require__(44);

	var _SCNVector2 = _interopRequireDefault(_SCNVector);

	var _SCNVector3 = __webpack_require__(45);

	var _SCNVector4 = _interopRequireDefault(_SCNVector3);

	var _CGPoint = __webpack_require__(7);

	var _CGPoint2 = _interopRequireDefault(_CGPoint);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/*global Buffer*/

	var _Semantic = {
	  boneIndices: 'kGeometrySourceSemanticBoneIndices',
	  boneWeights: 'kGeometrySourceSemanticBoneWeights',
	  color: 'kGeometrySourceSemanticColor',
	  edgeCrease: 'kGeometrySourceSemanticEdgeCrease',
	  normal: 'kGeometrySourceSemanticNormal',
	  tangent: 'kGeometrySourceSemanticTangent',
	  texcoord: 'kGeometrySourceSemanticTexcoord',
	  vertex: 'kGeometrySourceSemanticVertex',
	  vertexCrease: 'kGeometrySourceSemanticVertexCrease'
	};

	/**
	 * A container for vertex data forming part of the definition for a three-dimensional object, or geometry.
	 * @access public
	 * @extends {NSObject}
	 * @see https://developer.apple.com/reference/scenekit/scngeometrysource
	 */

	var SCNGeometrySource = function (_NSObject) {
	  _inherits(SCNGeometrySource, _NSObject);

	  _createClass(SCNGeometrySource, null, [{
	    key: '_propTypes',
	    get: function get() {
	      return {
	        $constructor: function $constructor(propNames, propValues) {
	          return new SCNGeometrySource(propValues.data, propValues.semantic, propValues.vectorCount, propValues.floatComponents, propValues.componentsPerVector, propValues.bytesPerComponent, propValues.dataOffset, propValues.dataStride);
	        },
	        data: ['NSMutableData', null],
	        semantic: ['string', null],
	        vectorCount: ['integer', null],
	        floatComponents: ['boolean', null],
	        componentsPerVector: ['integer', null],
	        bytesPerComponent: ['integer', null],
	        dataOffset: ['integer', null],
	        dataStride: ['integer', null],
	        mkSemantic: ['boolean', null] // ?
	      };
	    }

	    /**
	     * Creates a geometry source from the specified data and options.
	     * @access public
	     * @constructor
	     * @param {number[]|Buffer} data - The data for the geometry source.
	     * @param {SCNGeometrySource.Semantic} semantic - The semantic value (or attribute) that the geometry source describes for each vertex. See Geometry Semantic Identifiers for available values.
	     * @param {number} vectorCount - The number of geometry source vectors.
	     * @param {boolean} floatComponents - A Boolean value that indicates whether vector components are floating-point values. Specify true for floating-point values, or false for integer values.
	     * @param {number} componentsPerVector - The number of scalar components in each vector.
	     * @param {number} bytesPerComponent - The size, in bytes, of each vector component.
	     * @param {number} offset - The offset, in bytes, from the beginning of the data to the first vector component to be used in the geometry source.
	     * @param {number} stride - The number of bytes from each vector to the next in the data.
	     * @desc A geometry sources data is an array of vectors, each of which represents a particular attribute (or semantic) of a vertex in the geometry. The other parameters determine how SceneKit interprets this data. For example, an array of vertex positions may have three 32-bit floating-point components per vector, but an array of texture coordinates may have two 8-bit integer coponents per vector. You can use the offset and stride parameters together to interleave data for multiple geometry sources in the same array, improving rendering performance. See SCNGeometrySource for details.To create a custom SCNGeometry object from the geometry source, use the init(sources:elements:) method.
	     * @see https://developer.apple.com/reference/scenekit/scngeometrysource/1523320-init
	     */

	  }]);

	  function SCNGeometrySource(data, semantic, vectorCount, floatComponents, componentsPerVector, bytesPerComponent, offset, stride) {
	    _classCallCheck(this, SCNGeometrySource);

	    // Inspecting a Geometry Source
	    var _this = _possibleConstructorReturn(this, (SCNGeometrySource.__proto__ || Object.getPrototypeOf(SCNGeometrySource)).call(this));

	    _this._data = data;
	    _this._semantic = semantic;
	    _this._vectorCount = vectorCount;
	    _this._usesFloatComponents = floatComponents;
	    _this._componentsPerVector = componentsPerVector;
	    _this._bytesPerComponent = bytesPerComponent;
	    _this._dataOffset = offset;
	    _this._dataStride = stride;

	    if (data instanceof Buffer) {
	      var loadFunc = null;
	      if (floatComponents) {
	        switch (bytesPerComponent) {
	          case 4:
	            loadFunc = function loadFunc(_offset) {
	              return data.readFloatLE(_offset);
	            };
	            break;
	          case 8:
	            loadFunc = function loadFunc(_offset) {
	              return data.readDoubleLE(_offset);
	            };
	            break;
	          default:
	            throw new Error('unknown float data size: ' + bytesPerComponent);
	        }
	      } else {
	        loadFunc = function loadFunc(_offset) {
	          return data.readIntLE(_offset, bytesPerComponent);
	        };
	      }

	      var _data = [];
	      var count = data.length / bytesPerComponent;
	      var _offset = 0;
	      for (var i = 0; i < count; i++) {
	        _data.push(loadFunc(_offset));
	        _offset += bytesPerComponent;
	      }
	      _this._data = _data;
	    }

	    /**
	     * @type {TypedArray}
	     * @access private
	     */
	    //this._glData = null
	    //if(this._hasTypedArrayData()){
	    //  this._glData = this._data
	    //}else{
	    //  if(floatComponents){
	    //    if(bytesPerComponent === 4){
	    //      this._glData = new Float32Array(this._data)
	    //    }else if(bytesPerComponent === 8){
	    //      this._glData = new Float64Array(this._data)
	    //    }
	    //  }else{
	    //    if(bytesPerComponent === 1){
	    //      this._glData = new Uint8Array(this._data)
	    //    }else if(bytesPerComponent === 2){
	    //      this._glData = new Uint16Array(this._data)
	    //    }else if(bytesPerComponent === 4){
	    //      this._glData = new Uint32Array(this._data)
	    //    }
	    //  }
	    //}

	    //if(this._glData === null){
	    //  throw new Error(`unknown buffer data type: float: ${floatComponents}, size: ${bytesPerComponent}`)
	    //}

	    _this._buffer = null;
	    return _this;
	  }

	  _createClass(SCNGeometrySource, [{
	    key: '_createBuffer',
	    value: function _createBuffer(context) {
	      var gl = context;
	      this._buffer = gl.createBuffer();
	      gl.bindBuffer(gl.ARRAY_BUFFER, this._buffer);
	      // FIXME: dynamic data
	      gl.bufferData(gl.ARRAY_BUFFER, this._glData, gl.STATIC_DRAW);
	      return this._buffer;
	    }

	    /**
	     * @access private
	     * @returns {boolean} -
	     */

	  }, {
	    key: '_hasTypedArrayData',
	    value: function _hasTypedArrayData() {
	      if (this._usesFloatComponents) {
	        if (this._bytesPerComponent === 4) {
	          return this._data instanceof Float32Array;
	        } else if (this._bytesPerComponent === 8) {
	          return this._data instanceof Float64Array;
	        }
	      } else {
	        if (this._bytesPerComponent === 1) {
	          return this._data instanceof Uint8Array;
	        } else if (this._bytesPerComponent === 2) {
	          return this._data instanceof Uint16Array;
	        } else if (this._bytesPerComponent === 4) {
	          return this._data instanceof Uint32Array;
	        }
	      }
	      return false;
	    }

	    // Creating Geometry Sources

	    /**
	     * Creates a geometry source from the specified data and options.
	     * @access public
	     * @param {number[]} data - The data for the geometry source.
	     * @param {SCNGeometrySource.Semantic} semantic - The semantic value (or attribute) that the geometry source describes for each vertex. See Geometry Semantic Identifiers for available values.
	     * @param {number} vectorCount - The number of geometry source vectors.
	     * @param {boolean} floatComponents - A Boolean value that indicates whether vector components are floating-point values. Specify true for floating-point values, or false for integer values.
	     * @param {number} componentsPerVector - The number of scalar components in each vector.
	     * @param {number} bytesPerComponent - The size, in bytes, of each vector component.
	     * @param {number} dataOffset - The offset, in bytes, from the beginning of the data to the first vector component to be used in the geometry source.
	     * @param {number} dataStride - The number of bytes from each vector to the next in the data.
	     * @returns {SCNGeometrySource} -
	     * @desc A geometry sources data is an array of vectors, each of which represents a particular attribute (or semantic) of a vertex in the geometry. The other parameters determine how SceneKit interprets this data. For example, an array of vertex positions may have three 32-bit floating-point components per vector, but an array of texture coordinates may have two 8-bit integer coponents per vector. You can use the offset and stride parameters together to interleave data for multiple geometry sources in the same array, improving rendering performance. See SCNGeometrySource for details.To create a custom SCNGeometry object from the geometry source, use the init(sources:elements:) method.
	     * @see https://developer.apple.com/reference/scenekit/scngeometrysource/1523320-init
	     */

	  }, {
	    key: '_vectorAt',


	    /**
	     * @access private
	     * @param {number} index -
	     * @returns {number[]} -
	     */
	    value: function _vectorAt(index) {
	      if (index < 0 || index >= this.vectorCount) {
	        throw new Error('index out of range: ' + index + ' (0 - ' + (this.vectorCount - 1) + ')');
	      }
	      var indexStride = this._dataStride / this._bytesPerComponent;
	      var ind = index * indexStride + this._dataOffset / this._bytesPerComponent;
	      var arr = [];
	      for (var i = 0; i < this._componentsPerVector; i++) {
	        arr.push(this._data[ind + i]);
	      }
	      return arr;
	    }

	    /**
	     * @access private
	     * @param {number} index -
	     * @returns {SCNVector3|SCNVector4|number[]} -
	     */

	  }, {
	    key: '_scnVectorAt',
	    value: function _scnVectorAt(index) {
	      var vec = this._vectorAt(index);
	      if (vec.length === 2) {
	        return new _CGPoint2.default(vec[0], vec[1]);
	      } else if (vec.length === 3) {
	        return new _SCNVector2.default(vec[0], vec[1], vec[2]);
	      } else if (vec.length === 4) {
	        return new _SCNVector4.default(vec[0], vec[1], vec[2], vec[3]);
	      }
	      return vec;
	    }

	    /**
	     * @access public
	     * @param {number[]|SCNVector3|SCNVector4} v -
	     * @param {number} index -
	     * @returns {void}
	     */

	  }, {
	    key: '_setVectorAt',
	    value: function _setVectorAt(v, index) {
	      if (index < 0 || index >= this.vectorCount) {
	        throw new Error('index out of range: ' + index + ' (0 - ' + (this.vectorCount - 1) + ')');
	      }
	      var data = v;
	      if (v instanceof _SCNVector2.default) {
	        data = [v.x, v.y, v.z];
	      } else if (v instanceof _SCNVector4.default) {
	        data = [v.x, v.y, v.z, v.w];
	      }
	      if (data.length !== this._componentsPerVector) {
	        throw new Error('vector size inconsistent: ' + data.length + ' != ' + this._componentsPerVector);
	      }

	      var indexStride = this._dataStride / this._bytesPerComponent;
	      var ind = index * indexStride + this._dataOffset / this._bytesPerComponent;
	      for (var i = 0; i < this._componentsPerVector; i++) {
	        this._data[ind + i] = v[i];
	      }
	    }

	    /**
	     * 
	     * @access private
	     * @returns {Object}
	     */

	  }, {
	    key: '_createBoundingBox',
	    value: function _createBoundingBox() {
	      var min = new _SCNVector2.default(Infinity, Infinity, Infinity);
	      var max = new _SCNVector2.default(-Infinity, -Infinity, -Infinity);
	      if (this._componentsPerVector !== 3) {
	        throw new Error('componentsPerVector !== 3');
	      }

	      var indexStride = this._dataStride / this._bytesPerComponent;
	      var ind = this._dataOffset / this._bytesPerComponent;
	      var len = this._vectorCount;
	      var arr = [];
	      for (var i = 0; i < len; i++) {
	        var x = this._data[ind + 0];
	        var y = this._data[ind + 1];
	        var z = this._data[ind + 2];
	        if (x < min.x) {
	          min.x = x;
	        }
	        if (x > max.x) {
	          max.x = x;
	        }
	        if (y < min.y) {
	          min.y = y;
	        }
	        if (y > max.y) {
	          max.y = y;
	        }
	        if (z < min.z) {
	          min.z = z;
	        }
	        if (z > max.z) {
	          max.z = z;
	        }
	        ind += indexStride;
	      }

	      console.log('boundingBox: min: ' + min.floatArray() + ', max: ' + max.floatArray());
	      return { min: min, max: max };
	    }

	    /**
	     * 
	     * @access public
	     * @param {number} value -
	     * @returns {void}
	     */

	  }, {
	    key: 'fill',
	    value: function fill(value) {
	      var index = this._dataOffset / this._bytesPerComponent;
	      var stride = this._dataStride / this._bytesPerComponent;
	      for (var i = 0; i < this._vectorCount; i++) {
	        for (var j = 0; j < this._componentsPerVector; j++) {
	          this._data[index + j] = value;
	        }
	        index += stride;
	      }
	    }
	  }, {
	    key: 'copy',
	    value: function copy() {
	      var source = new SCNGeometrySource(this._data.slice(0), this._semantic, this._vectorCount, this._usesFloatComponents, this._componentsPerVector, this._bytesPerComponent, this._dataOffset, this._dataStride);
	      return source;
	    }
	  }, {
	    key: 'data',


	    // Inspecting a Geometry Source

	    /**
	     * The data for the geometry source.
	     * @type {Data}
	     * @desc A geometry sources data is an array of vectors, each of which represents a particular attribute (or semantic) of a vertex in the geometry. The other properties of the geometry source determine how SceneKit interprets this data. For example, an array of vertex positions may have three 32-bit floating-point components per vector, but an array of texture coordinates may have two 8-bit integer coponents per vector.
	     * @see https://developer.apple.com/reference/scenekit/scngeometrysource/1522881-data
	     */
	    get: function get() {
	      return this._data.slice(0);
	    }

	    /**
	     * The semantic value (or attribute) the geometry source describes for each vertex.
	     * @type {SCNGeometrySource.Semantic}
	     * @desc A semantic describes an attribute for each vertex, such as position, color, surface normal vector, or texture coordinates.See Geometry Semantic Identifiers for available values.
	     * @see https://developer.apple.com/reference/scenekit/scngeometrysource/1523071-semantic
	     */

	  }, {
	    key: 'semantic',
	    get: function get() {
	      return this._semantic;
	    }

	    /**
	     * The number of vectors in the data.
	     * @type {number}
	     * @desc 
	     * @see https://developer.apple.com/reference/scenekit/scngeometrysource/1522648-vectorcount
	     */

	  }, {
	    key: 'vectorCount',
	    get: function get() {
	      return this._vectorCount;
	    }

	    /**
	     * A Boolean value that indicates whether vector components are floating-point values.
	     * @type {boolean}
	     * @desc If true, SceneKit interprets the geometry sources data as an array of vectors whose components are floating-point values. The type of floating-point value is determined by the SCNGeometrySource property: 4 bytes for float values or 8 bytes for double values. If false, SceneKit interprets the geometry sources data as an array of vectors whose components are integer values. The type of integer value is determined by the SCNGeometrySource property; for example, 2 bytes for unsigned short values or 4 bytes for unsigned int values.
	     * @see https://developer.apple.com/reference/scenekit/scngeometrysource/1522920-usesfloatcomponents
	     */

	  }, {
	    key: 'usesFloatComponents',
	    get: function get() {
	      return this._usesFloatComponents;
	    }

	    /**
	     * The number of scalar components in each vector.
	     * @type {number}
	     * @desc 
	     * @see https://developer.apple.com/reference/scenekit/scngeometrysource/1522832-componentspervector
	     */

	  }, {
	    key: 'componentsPerVector',
	    get: function get() {
	      return this._componentsPerVector;
	    }

	    /**
	     * The size, in bytes, of each vector component.
	     * @type {number}
	     * @desc 
	     * @see https://developer.apple.com/reference/scenekit/scngeometrysource/1522633-bytespercomponent
	     */

	  }, {
	    key: 'bytesPerComponent',
	    get: function get() {
	      return this._bytesPerComponent;
	    }

	    /**
	     * The offset, in bytes, from the beginning of the data to the first vector component to be used in the geometry source.
	     * @type {number}
	     * @desc You can use the SCNGeometrySource and SCNGeometrySource parameters can together to interleave data for multiple geometry sources in the same array, improving rendering performance. See SCNGeometrySource for details.
	     * @see https://developer.apple.com/reference/scenekit/scngeometrysource/1522834-dataoffset
	     */

	  }, {
	    key: 'dataOffset',
	    get: function get() {
	      return this._dataOffset;
	    }

	    /**
	     * The number of bytes from a vector to the next one in the data.
	     * @type {number}
	     * @desc You can use the SCNGeometrySource and SCNGeometrySource parameters can together to interleave data for multiple geometry sources in the same array, improving rendering performance. See SCNGeometrySource for details.
	     * @see https://developer.apple.com/reference/scenekit/scngeometrysource/1524197-datastride
	     */

	  }, {
	    key: 'dataStride',
	    get: function get() {
	      return this._dataStride;
	    }

	    // Creating GPU-Mutable Geometry Sources

	    /**
	     * Creates a geometry source whose vertex data resides in the specified Metal buffer, allowing modification through a Metal compute shader.
	     * @access public
	     * @param {MTLBuffer} mtlBuffer - A Metal buffer containing per-vertex data for the geometry source.
	     * @param {MTLVertexFormat} vertexFormat - The type of per-vertex data in the buffer. A MTLVertexFormat value defines the number of components for each vector in the geometry source and the data type and size of each component.
	     * @param {SCNGeometrySource.Semantic} semantic - The semantic value (or attribute) that the geometry source describes for each vertex. See Geometry Semantic Identifiers for available values.
	     * @param {number} vertexCount - The number of vertices in the geometry source.
	     * @param {number} offset - The offset, in bytes, from the beginning of the data to the first vector component to be used in the geometry source.
	     * @param {number} stride - The number of bytes from each vector to the next in the data.
	     * @returns {SCNGeometrySource} -
	     * @desc Use this method to create a geometry source whose underlying data can be modified at render time by a Metal compute shader running on the GPU. To create a MTLBuffer object for use with a geometry source, use the device property of the SceneKit view (or other renderer) responsible for drawing your scene.// Create and fill a buffer.
	    id <MTLDevice> device = self.scnView.device;
	    self.geometryBuffer = [device newBufferWithBytes:myData length:myLength options:myOptions];
	    // Create a geometry source from the buffer.
	    SCNGeometrySource *source = [SCNGeometrySource geometrySourceWithBuffer:buffer
	                               vertexFormat:myVertexFormat
	                                   semantic:SCNGeometrySourceSemanticVertex
	                                vertexCount:myVertexCount
	                                 dataOffset:0
	                                 dataStride:0];
	    Then, to modify the buffers contents at render time, implement a scene renderer delegate and schedule a compute command encoder during a render delegate method such as renderer(_:willRenderScene:atTime:).- (void)renderer:(id <SCNSceneRenderer>)aRenderer willRenderScene:(SCNScene *)scene atTime:(NSTimeInterval)time {
	       // Get a command buffer and compute encoder from the view (or other renderer).
	       id<MTLCommandBuffer> myCommandBuffer = [aRenderer.commandQueue commandBuffer];
	       id<MTLComputeCommandEncoder> myComputeEncoder = [myCommandBuffer computeCommandEncoder];
	         // Configure the compute command encoder.
	       // (Note pipeline state is preconfigured outside of the render loop.)
	       [myComputeEncoder setComputePipelineState:self.pipelineState];
	       [myComputeEncoder setBuffer:self.geometryBuffer offset:0 atIndex:0];
	         // Schedule the compute command and commit the command buffer.
	       [myComputeEncoder dispatchThreadgroups:myThreadgroupCount
	                        threadsPerThreadgroup:myThreadCount];
	       [myComputeEncoder endEncoding];
	       [myCommandBuffer commit];
	    }
	    NoteGeometry sources backed by a Metal buffer are available only with SceneKit views (or other renderers) whose renderingAPI property is metal. Metal commands that modify the buffers contents must be enqueued from within one of the render loop methods defined in the SCNSceneRendererDelegate protocol. The result of attempting to modify a buffer at any other time is undefined.// Create and fill a buffer.
	    id <MTLDevice> device = self.scnView.device;
	    self.geometryBuffer = [device newBufferWithBytes:myData length:myLength options:myOptions];
	    // Create a geometry source from the buffer.
	    SCNGeometrySource *source = [SCNGeometrySource geometrySourceWithBuffer:buffer
	                               vertexFormat:myVertexFormat
	                                   semantic:SCNGeometrySourceSemanticVertex
	                                vertexCount:myVertexCount
	                                 dataOffset:0
	                                 dataStride:0];
	    - (void)renderer:(id <SCNSceneRenderer>)aRenderer willRenderScene:(SCNScene *)scene atTime:(NSTimeInterval)time {
	       // Get a command buffer and compute encoder from the view (or other renderer).
	       id<MTLCommandBuffer> myCommandBuffer = [aRenderer.commandQueue commandBuffer];
	       id<MTLComputeCommandEncoder> myComputeEncoder = [myCommandBuffer computeCommandEncoder];
	         // Configure the compute command encoder.
	       // (Note pipeline state is preconfigured outside of the render loop.)
	       [myComputeEncoder setComputePipelineState:self.pipelineState];
	       [myComputeEncoder setBuffer:self.geometryBuffer offset:0 atIndex:0];
	         // Schedule the compute command and commit the command buffer.
	       [myComputeEncoder dispatchThreadgroups:myThreadgroupCount
	                        threadsPerThreadgroup:myThreadCount];
	       [myComputeEncoder endEncoding];
	       [myCommandBuffer commit];
	    }
	      * @see https://developer.apple.com/reference/scenekit/scngeometrysource/1522873-init
	     */

	  }], [{
	    key: 'geometrySourceWithDataSemanticVectorCountFloatComponentsComponentsPerVectorBytesPerComponentDataOffsetDataStride',
	    value: function geometrySourceWithDataSemanticVectorCountFloatComponentsComponentsPerVectorBytesPerComponentDataOffsetDataStride(data, semantic, vectorCount, floatComponents, componentsPerVector, bytesPerComponent, dataOffset, dataStride) {
	      var instance = new SCNGeometrySource(data, semantic, vectorCount, floatComponents, componentsPerVector, bytesPerComponent, dataOffset, dataStride);

	      return instance;
	    }

	    /**
	     * Creates a geometry source from an array of vertex positions. 
	     * @access public
	     * @param {SCNVector3[]} vertices - An array of three-component vectors, each of which represents a vertex position for the geometry source.
	     * @param {number} count - The number of vertices
	     * @returns {SCNGeometrySource} -
	     * @desc SceneKit converts this data to its own format to optimize rendering performance. To read the converted data, examine the properties of the created SCNGeometrySource object.To create a custom SCNGeometry object from the geometry source, use the init(sources:elements:) method.
	     * @see https://developer.apple.com/reference/scenekit/scngeometrysource/2034708-init
	     */

	  }, {
	    key: 'geometrySourceWithVerticesCount',
	    value: function geometrySourceWithVerticesCount(vertices, count) {
	      var data = [];
	      for (var i = 0; i < count; i++) {
	        data.push(vertices[i].x, vertices[i].y, vertices[i].z);
	      }

	      var instance = new SCNGeometrySource(data, // data
	      SCNGeometrySource.Semantic.vertex, // semantic
	      count, // vectorCount
	      true, // floatComponents
	      3, // componentsPerVector
	      4, // bytesPerComponent
	      0, // offset
	      12 // stride
	      );
	      return instance;
	    }

	    /**
	     * Creates a geometry source from an array of texture coordinate points.
	     * @access public
	     * @param {CGPoint[]} texcoord - An array of points, each of which represents a texture coordinate pair for the geometry source.
	     * @param {number} count - The number of texture coordinate points.
	     * @returns {SCNGeometrySource} -
	     * @desc SceneKit converts this data to its own format to optimize rendering performance. To read the converted data, examine the properties of the created SCNGeometrySource object.To create a custom SCNGeometry object from the geometry source, use the init(sources:elements:) method.
	     * @see https://developer.apple.com/reference/scenekit/scngeometrysource/1522718-init
	     */

	  }, {
	    key: 'geometrySourceWithTextureCoordinatesCount',
	    value: function geometrySourceWithTextureCoordinatesCount(texcoord, count) {
	      var data = [];
	      for (var i = 0; i < count; i++) {
	        data.push(texcoord[i].x, texcoord[i].y);
	      }

	      var instance = new SCNGeometrySource(data, // data
	      SCNGeometrySource.Semantic.texcoord, // semantic
	      count, // vectorCount
	      true, // floatComponents
	      2, // componentsPerVector
	      4, // bytesPerComponent
	      0, // offset
	      8 // stride
	      );
	      return instance;
	    }

	    /**
	     * Creates a geometry source from an array of normal vertices.
	     * @access public
	     * @param {SCNVector3[]} normals - An array of vectors, which represents a normal vector for the geometry source.
	     * @param {number} count - The number of normals
	     * @returns {SCNGeometrySource} -
	     */

	  }, {
	    key: 'geometrySourceWithNormalsCount',
	    value: function geometrySourceWithNormalsCount(normals, count) {
	      var data = [];
	      for (var i = 0; i < count; i++) {
	        data.push(normals[i].x, normals[i].y, normals[i].z);
	      }

	      var instance = new SCNGeometrySource(data, // data
	      SCNGeometrySource.Semantic.normal, // semantic
	      count, // vectorCount
	      true, // floatComponents
	      3, // componentsPerVector
	      4, // bytesPerComponent
	      0, // offset
	      12 // stride
	      );
	      return instance;
	    }
	  }, {
	    key: 'initBufferDataOffsetDataStride',
	    value: function initBufferDataOffsetDataStride(mtlBuffer, vertexFormat, semantic, vertexCount, offset, stride) {}

	    // Structures

	    /**
	     * @type {Object} Semantic
	     * @property {string} boneIndices The semantic for bone index data, used for skeletal animation of skinned surfaces.
	     * @property {string} boneWeights The semantic for bone weight data, used for skeletal animation of skinned surfaces.
	     * @property {string} color The semantic for per-vertex color data.
	     * @property {string} edgeCrease The semantic for edge crease data, used for subdividing surfaces.
	     * @property {string} normal The semantic for surface normal data.
	     * @property {string} tangent The semantic for surface tangent vector data.
	     * @property {string} texcoord The semantic for texture coordinate data.
	     * @property {string} vertex The semantic for vertex position data.
	     * @property {string} vertexCrease The semantic for vertex crease data, used for subdividing surfaces.
	     * @see https://developer.apple.com/reference/scenekit/scngeometrysource.semantic
	     */

	  }, {
	    key: 'Semantic',
	    get: function get() {
	      return _Semantic;
	    }
	  }]);

	  return SCNGeometrySource;
	}(_NSObject3.default);

	exports.default = SCNGeometrySource;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3).Buffer))

/***/ },
/* 72 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _NSObject2 = __webpack_require__(2);

	var _NSObject3 = _interopRequireDefault(_NSObject2);

	var _SCNGeometryPrimitiveType = __webpack_require__(73);

	var _SCNGeometryPrimitiveType2 = _interopRequireDefault(_SCNGeometryPrimitiveType);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/*global Buffer*/

	/**
	 * A container for index data describing how vertices connect to define a three-dimensional object, or geometry.
	 * @access public
	 * @extends {NSObject}
	 * @see https://developer.apple.com/reference/scenekit/scngeometryelement
	 */
	var SCNGeometryElement = function (_NSObject) {
	  _inherits(SCNGeometryElement, _NSObject);

	  _createClass(SCNGeometryElement, null, [{
	    key: '_propTypes',
	    get: function get() {
	      return {
	        $constructor: function $constructor(propNames, propValues) {
	          return new SCNGeometryElement(propValues.elementData, propValues.primitiveType, propValues.primitiveCount, propValues.bytesPerIndex);
	        },
	        primitiveType: ['integer', null],
	        primitiveCount: ['integer', null],
	        elementData: ['NSMutableData', null],
	        bytesPerIndex: ['integer', null]
	      };
	    }

	    // Creating a Geometry Element

	    /**
	     * Creates a geometry element from the specified array of index values. 
	     * @access public
	     * @constructor
	     * @param {number[]|Buffer} indices - An array of index values, each of which identifies a vertex in a geometry source.
	     * @param {SCNGeometryPrimitiveType} primitiveType - The drawing primitive that connects vertices when rendering the geometry element. For possible values, see SCNGeometryPrimitiveType.
	     * @desc SceneKit connects the vertices in the order specified by the indices array, arranged according to the primitiveType parameter.This initializer is equivalent to the init(data:primitiveType:primitiveCount:bytesPerIndex:) initializer, but does not require an intermediary Data object; instead, it automatically infers the necessary allocation size and bytesPerIndex values based on the contents of the indices array. To create a custom SCNGeometry object from the geometry element, use the init(sources:elements:) initializer.
	     * @see https://developer.apple.com/reference/scenekit/scngeometryelement/1523191-init
	     */

	  }]);

	  function SCNGeometryElement(indices, primitiveType) {
	    var primitiveCount = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
	    var bytesPerIndex = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 2;

	    _classCallCheck(this, SCNGeometryElement);

	    // Inspecting a Geometry Element

	    var _this = _possibleConstructorReturn(this, (SCNGeometryElement.__proto__ || Object.getPrototypeOf(SCNGeometryElement)).call(this));

	    _this._data = indices;
	    if (indices instanceof Buffer) {
	      var _data = [];
	      var count = indices.length / bytesPerIndex;
	      var _offset = 0;
	      for (var i = 0; i < count; i++) {
	        _data.push(indices.readUIntLE(_offset, bytesPerIndex));
	        _offset += bytesPerIndex;
	      }
	      _this._data = _data;
	    }

	    _this._primitiveType = primitiveType;
	    if (primitiveCount !== null) {
	      _this._primitiveCount = primitiveCount;
	    } else {
	      switch (primitiveType) {
	        case _SCNGeometryPrimitiveType2.default.triangles:
	          _this._primitiveCount = _this._data.length / 3;
	          break;
	        case _SCNGeometryPrimitiveType2.default.triangleStrip:
	          _this._primitiveCount = _this._data.length - 2;
	          break;
	        case _SCNGeometryPrimitiveType2.default.line:
	          _this._primitiveCount = _this._data.length / 2;
	          break;
	        case _SCNGeometryPrimitiveType2.default.point:
	          _this._primitiveCount = _this._data.length;
	          break;
	        case _SCNGeometryPrimitiveType2.default.polygon:
	          _this._primitiveCount = _this._data.length / 2;
	          break;
	      }
	    }
	    _this._bytesPerIndex = bytesPerIndex;

	    /**
	     * @type {TypedArray}
	     * @access private
	     */
	    _this._glData = null;
	    //console.log(`SCNGeometryElement: bytesPerIndex: ${bytesPerIndex}`)
	    if (bytesPerIndex === 1) {
	      _this._glData = new Uint8Array(_this._data);
	    } else if (bytesPerIndex === 2) {
	      _this._glData = new Uint16Array(_this._data);
	    } else if (bytesPerIndex === 4) {
	      _this._glData = new Uint32Array(_this._data);
	    } else {
	      throw new Error('unknown data size: ' + bytesPerIndex);
	    }
	    return _this;
	  }

	  /**
	   * Creates a geometry element from the specified Model I/O submesh object.
	   * @access public
	   * @param {MDLSubmesh} mdlSubMesh - 
	   * @returns {void}
	   * @desc The Model I/O framework provides universal support for import, export, description, and processing of several 3D asset file formats and related resources. (For details, see Model I/O.) The MDLSubmesh class is a generic description of an index buffer to be used in rendering a 3D object, along with an assigned material. In SceneKit, materials are assigned to a geometry rather than to its elements, so importing a submesh as a geometry element does not import its material assignment. To import a Model I/O mesh along with its materials, use the SCNGeometry init(mdlMesh:) method.
	   * @see https://developer.apple.com/reference/scenekit/scngeometryelement/1419843-init
	   */


	  _createClass(SCNGeometryElement, [{
	    key: 'initMdlSubmesh',
	    value: function initMdlSubmesh(mdlSubMesh) {}

	    // Inspecting a Geometry Element

	    /**
	     * The drawing primitive that connects vertices when rendering the geometry element.
	     * @type {SCNGeometryPrimitiveType}
	     * @desc For possible values, see SCNGeometryPrimitiveType.
	     * @see https://developer.apple.com/reference/scenekit/scngeometryelement/1522917-primitivetype
	     */

	  }, {
	    key: '_createBuffer',
	    value: function _createBuffer(context) {
	      var gl = context;
	      this._buffer = gl.createBuffer();
	      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._buffer);
	      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this._glData, gl.STATIC_DRAW);

	      return this._buffer;
	    }
	  }, {
	    key: 'copy',
	    value: function copy() {
	      var element = new SCNGeometryElement(this._data.slice(0), this._primitiveType, this._primitiveCount, this._bytesPerIndex);
	      return element;
	    }

	    /**
	     * @access private
	     * @param {number} index -
	     * @returns {number[]} -
	     */

	  }, {
	    key: '_indexAt',
	    value: function _indexAt(index) {
	      if (index < 0 || index >= this.primitiveCount) {
	        throw new Error('index out of range: ' + index + ' (0 - ' + (this.primitiveCount - 1) + ')');
	      }

	      var arr = [];
	      var len = this._primitiveCount;
	      if (this._primitiveType === _SCNGeometryPrimitiveType2.default.triangles) {
	        var i = index * 3;
	        return [this._data[i + 0], this._data[i + 1], this._data[i + 2]];
	      } else if (this._primitiveType === _SCNGeometryPrimitiveType2.default.triangleStrip) {
	        return [this._data[index + 0], this._data[index + 1], this._data[index + 2]];
	      } else if (this._primitiveType === _SCNGeometryPrimitiveType2.default.line) {
	        var _i = index * 2;
	        return [this._data[_i + 0], this._data[_i + 1]];
	      } else if (this._primitiveType === _SCNGeometryPrimitiveType2.default.point) {
	        return [this._data[index]];
	      } else if (this._primitiveType === _SCNGeometryPrimitiveType2.default.polygon) {
	        return [this._data[0], this._data[index + 1], this._data[index + 2]];
	      } else {
	        throw new Error('unknown primitive type: ' + this._primitiveType);
	      }
	    }
	  }, {
	    key: 'primitiveType',
	    get: function get() {
	      return this._primitiveType;
	    }

	    /**
	     * The number of primitives in the element.
	     * @type {number}
	     * @desc 
	     * @see https://developer.apple.com/reference/scenekit/scngeometryelement/1523404-primitivecount
	     */

	  }, {
	    key: 'primitiveCount',
	    get: function get() {
	      return this._primitiveCount;
	    }

	    /**
	     * The data describing the geometry element.
	     * @type {Data}
	     * @desc An elements data is an array of index values identifying vertices in a geometry source. SceneKit interprets the data as an array of unsigned integers, whose size is specified by the bytesPerIndex property.
	     * @see https://developer.apple.com/reference/scenekit/scngeometryelement/1523367-data
	     */

	  }, {
	    key: 'data',
	    get: function get() {
	      return this._data;
	    }

	    /**
	     * The number of bytes that represent each index value in the elements data.
	     * @type {number}
	     * @desc An elements data property holds an array of index values identifying vertices in a geometry source. SceneKit interprets the data as an array of unsigned integers, whose size is specified by the bytesPerIndex property.
	     * @see https://developer.apple.com/reference/scenekit/scngeometryelement/1522720-bytesperindex
	     */

	  }, {
	    key: 'bytesPerIndex',
	    get: function get() {
	      return this._bytesPerIndex;
	    }
	  }]);

	  return SCNGeometryElement;
	}(_NSObject3.default);

	exports.default = SCNGeometryElement;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3).Buffer))

/***/ },
/* 73 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * The drawing primitive that connects vertices when rendering a geometry element, used by the primitiveType property to specify how SceneKit interprets the geometry elements data.
	 * @typedef {Object} SCNGeometryPrimitiveType
	 * @property {number} triangles - The geometry elements data is a sequence of triangles, with each triangle described by three new vertices.
	 * @property {number} triangleStrip - The geometry elements data is a sequence of triangles, with each triangle described by one new vertex and two vertices from the previous triangle. 
	 * @property {number} line - The geometry elements data is a sequence of line segments, with each line segment described by two new vertices. 
	 * @property {number} point - The geometry elements data is a sequence of unconnected points.
	 * @property {number} polygon - 
	 * @see https://developer.apple.com/reference/scenekit/scngeometryprimitivetype
	 */

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var SCNGeometryPrimitiveType = {
	  triangles: 0,
	  triangleStrip: 1,
	  line: 2,
	  point: 3,
	  polygon: 4
	};

	exports.default = SCNGeometryPrimitiveType;

/***/ },
/* 74 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _NSObject2 = __webpack_require__(2);

	var _NSObject3 = _interopRequireDefault(_NSObject2);

	var _SCNGeometry = __webpack_require__(68);

	var _SCNGeometry2 = _interopRequireDefault(_SCNGeometry);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * An object that defines alternate resolutions for a geometry that SceneKit can automatically substitute to improve rendering performance.
	 * @access public
	 * @extends {NSObject}
	 * @see https://developer.apple.com/reference/scenekit/scnlevelofdetail
	 */
	var SCNLevelOfDetail = function (_NSObject) {
	  _inherits(SCNLevelOfDetail, _NSObject);

	  _createClass(SCNLevelOfDetail, null, [{
	    key: '_propTypes',
	    get: function get() {
	      return {
	        mode: ['integer', null],
	        threshold: ['float', null]
	      };
	    }

	    /**
	     * constructor
	     * @access public
	     * @constructor
	     */

	  }]);

	  function SCNLevelOfDetail() {
	    _classCallCheck(this, SCNLevelOfDetail);

	    // Inspecting a Level of Detail

	    var _this = _possibleConstructorReturn(this, (SCNLevelOfDetail.__proto__ || Object.getPrototypeOf(SCNLevelOfDetail)).call(this));

	    _this._geometry = null;
	    _this._screenSpaceRadius = 0;
	    _this._worldSpaceDistance = 0;
	    return _this;
	  }

	  // Creating a Level of Detail

	  /**
	   * Creates a level of detail with the specified geometry and threshold pixel radius.
	   * @access public
	   * @param {?SCNGeometry} geometry - The geometry to render for this level of detail.
	   * @param {number} radius - The maximum radius (in pixels) of the geometrys bounding sphere for this level of detail to appear.
	   * @returns {void}
	   * @desc When rendering a geometry with associated levels of detail, SceneKit calculates the radius in pixels of the circle covered by a geometrys bounding sphere, then renders the geometry for the SCNLevelOfDetail object with the largest radius parameter smaller than that circle.If you pass nil for the geometry parameter, SceneKit renders no geometry for the level of detail. Creating a level-of-detail object with no geometry allows you to skip rendering costs entirely for an object when it would appear very far away or very small.
	   * @see https://developer.apple.com/reference/scenekit/scnlevelofdetail/1523557-init
	   */


	  _createClass(SCNLevelOfDetail, [{
	    key: 'initScreenSpaceRadius',
	    value: function initScreenSpaceRadius(geometry, radius) {}

	    /**
	     * Creates a level of detail with the specified geometry and threshold camera distance.
	     * @access public
	     * @param {?SCNGeometry} geometry - The geometry to render for this level of detail, or nil if SceneKit should render no geometry at this level of detail.
	     * @param {number} distance - The minimum distance from the current point of view for this level of detail to appear.
	     * @returns {void}
	     * @desc When rendering a geometry with associated levels of detail, SceneKit calculates the distance from the current point of view to the geometrys parent node, then renders the geometry for the SCNLevelOfDetail object with the smallest distance parameter greater than that distance.If you pass nil for the geometry parameter, SceneKit renders no geometry for the level of detail. Creating a level-of-detail object with no geometry allows you to skip rendering costs entirely for an object when it would appear very far away or very small.
	     * @see https://developer.apple.com/reference/scenekit/scnlevelofdetail/1522802-init
	     */

	  }, {
	    key: 'initWorldSpaceDistance',
	    value: function initWorldSpaceDistance(geometry, distance) {}

	    // Inspecting a Level of Detail
	    /**
	     * The geometry associated with this level of detail.
	     * @type {?SCNGeometry}
	     * @desc SceneKit renders this geometry instead of the original geometry when the level of detail is appropriate. Generally, levels of detail with larger worldSpaceDistance values or smaller screenSpaceRadius values should contain less complex geometries.If the value of this property is nil, SceneKit renders no geometry at this level of detail.
	     * @see https://developer.apple.com/reference/scenekit/scnlevelofdetail/1522819-geometry
	     */

	  }, {
	    key: 'geometry',
	    get: function get() {
	      return this._geometry;
	    }

	    /**
	     * The maximum radius (in pixels) of the geometrys bounding sphere for this level of detail to appear.
	     * @type {number}
	     * @desc When rendering a geometry with associated levels of detail, SceneKit calculates the radius in pixels of the circle covered by a geometrys bounding sphere, then renders the geometry for the SCNLevelOfDetail object with the smallest radius parameter larger than that circle.
	     * @see https://developer.apple.com/reference/scenekit/scnlevelofdetail/1523554-screenspaceradius
	     */

	  }, {
	    key: 'screenSpaceRadius',
	    get: function get() {
	      return this._screenSpaceRadius;
	    }

	    /**
	     * The minimum distance from the current point of view for this level of detail to appear.
	     * @type {number}
	     * @desc When rendering a geometry with associated levels of detail, SceneKit calculates the distance from the current point of view to the geometrys parent node, then renders the geometry for the SCNLevelOfDetail object with the largest distance parameter less than that distance.
	     * @see https://developer.apple.com/reference/scenekit/scnlevelofdetail/1524159-worldspacedistance
	     */

	  }, {
	    key: 'worldSpaceDistance',
	    get: function get() {
	      return this._worldSpaceDistance;
	    }
	  }]);

	  return SCNLevelOfDetail;
	}(_NSObject3.default);

	exports.default = SCNLevelOfDetail;

/***/ },
/* 75 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _NSObject2 = __webpack_require__(2);

	var _NSObject3 = _interopRequireDefault(_NSObject2);

	var _SCNAnimatable = __webpack_require__(66);

	var _SCNAnimatable2 = _interopRequireDefault(_SCNAnimatable);

	var _SCNShadable = __webpack_require__(70);

	var _SCNShadable2 = _interopRequireDefault(_SCNShadable);

	var _SCNMaterialProperty = __webpack_require__(76);

	var _SCNMaterialProperty2 = _interopRequireDefault(_SCNMaterialProperty);

	var _SCNTransparencyMode = __webpack_require__(82);

	var _SCNTransparencyMode2 = _interopRequireDefault(_SCNTransparencyMode);

	var _SCNCullMode = __webpack_require__(69);

	var _SCNCullMode2 = _interopRequireDefault(_SCNCullMode);

	var _SCNBlendMode = __webpack_require__(83);

	var _SCNBlendMode2 = _interopRequireDefault(_SCNBlendMode);

	var _SCNOrderedDictionary = __webpack_require__(79);

	var _SCNOrderedDictionary2 = _interopRequireDefault(_SCNOrderedDictionary);

	var _SKColor = __webpack_require__(11);

	var _SKColor2 = _interopRequireDefault(_SKColor);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var _LightingModel = {
	  blinn: 'SCNLightingModelBlinn',
	  constant: 'SCNLightingModelConstant',
	  lambert: 'SCNLightingModelLambert',
	  phong: 'SCNLightingModelPhong',
	  physicallyBased: 'SCNLightingModelPhysicallyBased'
	};

	/**
	 * A set of shading attributes that define the appearance of a geometry's surface when rendered.
	 * @access public
	 * @extends {NSObject}
	 * @implements {SCNAnimatable}
	 * @implements {SCNShadable}
	 * @see https://developer.apple.com/reference/scenekit/scnmaterial
	 */

	var SCNMaterial = function (_NSObject) {
	  _inherits(SCNMaterial, _NSObject);

	  _createClass(SCNMaterial, null, [{
	    key: '_propTypes',
	    get: function get() {
	      return {
	        diffuse: ['SCNMaterialProperty', function (obj, value) {
	          obj._diffuse = value;
	          value._createPresentation();
	        }],
	        ambient: ['SCNMaterialProperty', function (obj, value) {
	          obj._ambient = value;
	          value._createPresentation();
	        }],
	        specular: ['SCNMaterialProperty', function (obj, value) {
	          obj._specular = value;
	          value._createPresentation();
	        }],
	        normal: ['SCNMaterialProperty', function (obj, value) {
	          obj._normal = value;
	          value._createPresentation();
	        }],
	        reflective: ['SCNMaterialProperty', function (obj, value) {
	          obj._reflective = value;
	          value._createPresentation();
	        }],
	        emission: ['SCNMaterialProperty', function (obj, value) {
	          obj._emission = value;
	          value._createPresentation();
	        }],
	        transparent: ['SCNMaterialProperty', function (obj, value) {
	          obj._transparent = value;
	          value._createPresentation();
	        }],
	        multiply: ['SCNMaterialProperty', function (obj, value) {
	          obj._multiply = value;
	          value._createPresentation();
	        }],
	        ambientOcclusion: ['SCNMaterialProperty', function (obj, value) {
	          obj._ambientOcclusion = value;
	          value._createPresentation();
	        }],
	        selfIllumination: ['SCNMaterialProperty', function (obj, value) {
	          obj._selfIllumination = value;
	          value._createPresentation();
	        }],
	        metalness: ['SCNMaterialProperty', function (obj, value) {
	          obj._metalness = value;
	          value._createPresentation();
	        }],
	        roughness: ['SCNMaterialProperty', function (obj, value) {
	          obj._roughness = value;
	          value._createPresentation();
	        }],
	        name: 'string',
	        shininess: 'float',
	        fresnelExponent: 'float',
	        transparency: 'integer',
	        transparencyMode: 'integer',
	        lightingModelName: ['string', 'lightingModel'],
	        litPerPixel: ['boolean', 'isLitPerPixel'],
	        doubleSided: ['boolean', 'isDoubleSided'],
	        cullMode: 'integer',
	        blendMode: 'integer',
	        locksAmbientWithDiffuse: 'boolean',
	        writesToDepthBuffer: 'boolean',
	        readsFromDepthBuffer: 'boolean',

	        avoidsOverLighting: ['boolean', null],
	        fillMode: ['integer', null],
	        entityID: ['string', '_entityID'],
	        indexOfRefraction: ['integer', null],
	        shadableHelper: ['SCNShadableHelper', null],
	        selfIlluminationOcclusion: ['integer', null]
	      };
	    }

	    // Creating a Material

	    /**
	     * Creates a material from the specified Model I/O material object.
	     * @access public
	     * @constructor
	     * @param {MDLMaterial} mdlMaterial - A Model I/O material object.
	     * @desc The Model I/O framework provides universal support for import, export, description, and processing of several 3D asset file formats and related resources. (For details, see Model I/O.) The MDLMaterial class is a generic description of surface rendering to be used in rendering 3D object, supporting a superset of the attributes described by the SCNMaterial class. 
	     * @see https://developer.apple.com/reference/scenekit/scnmaterial/1419835-init
	     */

	  }]);

	  function SCNMaterial(mdlMaterial) {
	    _classCallCheck(this, SCNMaterial);

	    // Configuring a Materials Visual Properties

	    var _this = _possibleConstructorReturn(this, (SCNMaterial.__proto__ || Object.getPrototypeOf(SCNMaterial)).call(this));

	    _this._diffuse = new _SCNMaterialProperty2.default(_SKColor2.default.white);
	    _this._ambient = new _SCNMaterialProperty2.default(new _SKColor2.default(0.485, 0.485, 0.485, 1.0));
	    _this._specular = new _SCNMaterialProperty2.default(_SKColor2.default.black);
	    _this._normal = new _SCNMaterialProperty2.default(_SKColor2.default.white);
	    _this._reflective = new _SCNMaterialProperty2.default(_SKColor2.default.black);
	    _this._emission = new _SCNMaterialProperty2.default(_SKColor2.default.black);
	    _this._transparent = new _SCNMaterialProperty2.default(_SKColor2.default.white);
	    _this._multiply = new _SCNMaterialProperty2.default(_SKColor2.default.white);
	    _this._ambientOcclusion = new _SCNMaterialProperty2.default(_SKColor2.default.white);
	    _this._selfIllumination = new _SCNMaterialProperty2.default(_SKColor2.default.black);
	    _this._metalness = new _SCNMaterialProperty2.default(_SKColor2.default.black);
	    _this._roughness = new _SCNMaterialProperty2.default(new _SKColor2.default(0.485, 0.485, 0.485, 1.0));

	    // Customizing a Material

	    /**
	     * A name associated with the material.
	     * @type {?string}
	     * @see https://developer.apple.com/reference/scenekit/scnmaterial/1462525-name
	     */
	    _this.name = null;

	    /**
	     * The sharpness of specular highlights. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnmaterial/1462533-shininess
	     */
	    _this.shininess = 1.0;

	    /**
	     * A factor affecting the materials reflectivity. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnmaterial/1462587-fresnelexponent
	     */
	    _this.fresnelExponent = 0.0;

	    /**
	     * The uniform transparency of the material. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnmaterial/1462567-transparency
	     */
	    _this.transparency = 1.0;

	    /**
	     * The mode SceneKit uses to calculate transparency for the material.
	     * @type {SCNTransparencyMode}
	     * @see https://developer.apple.com/reference/scenekit/scnmaterial/1462549-transparencymode
	     */
	    _this.transparencyMode = _SCNTransparencyMode2.default.aOne;

	    /**
	     * The lighting formula that SceneKit uses to render the material.
	     * @type {SCNMaterial.LightingModel}
	     * @see https://developer.apple.com/reference/scenekit/scnmaterial/1462518-lightingmodel
	     */
	    _this.lightingModel = _LightingModel.blinn;

	    /**
	     * A Boolean value that determines whether SceneKit performs lighting calculations per vertex or per pixel. Animatable.
	     * @type {boolean}
	     * @see https://developer.apple.com/reference/scenekit/scnmaterial/1462580-islitperpixel
	     */
	    _this.isLitPerPixel = true;

	    /**
	     * A Boolean value that determines whether SceneKit should render both front and back faces of a surface. Animatable.
	     * @type {boolean}
	     * @see https://developer.apple.com/reference/scenekit/scnmaterial/1462531-isdoublesided
	     */
	    _this.isDoubleSided = false;

	    /**
	     * The mode determining which faces of a surface SceneKit renders. Animatable.
	     * @type {SCNCullMode}
	     * @see https://developer.apple.com/reference/scenekit/scnmaterial/1462571-cullmode
	     */
	    _this.cullMode = _SCNCullMode2.default.back;

	    /**
	     * The mode that determines how pixel colors rendered using this material blend with other pixel colors in the rendering target.
	     * @type {SCNBlendMode}
	     * @see https://developer.apple.com/reference/scenekit/scnmaterial/1462585-blendmode
	     */
	    _this.blendMode = _SCNBlendMode2.default.alpha;

	    /**
	     * A Boolean value that determines whether the material responds identically to both ambient and diffuse lighting. Animatable.
	     * @type {boolean}
	     * @see https://developer.apple.com/reference/scenekit/scnmaterial/1462522-locksambientwithdiffuse
	     */
	    _this.locksAmbientWithDiffuse = true;

	    /**
	     * A Boolean value that determines whether SceneKit produces depth information when rendering the material.
	     * @type {boolean}
	     * @see https://developer.apple.com/reference/scenekit/scnmaterial/1462545-writestodepthbuffer
	     */
	    _this.writesToDepthBuffer = true;

	    /**
	     * A Boolean value that determines whether SceneKit uses depth information when rendering the material.
	     * @type {boolean}
	     * @see https://developer.apple.com/reference/scenekit/scnmaterial/1462562-readsfromdepthbuffer
	     */
	    _this.readsFromDepthBuffer = true;

	    /////////////////
	    // SCNShadable //
	    /////////////////

	    // Assigning a Custom Shader Program

	    /**
	     * A program used when rendering the object.
	     * @type {?SCNProgram}
	     * @see https://developer.apple.com/reference/scenekit/scnshadable/1523689-program
	     */
	    _this.program = null;

	    // Customizing SceneKits Shader Programs

	    /**
	     * A dictionary of GLSL source code snippets for customizing the shader programs provided by SceneKit.
	     * @type {?Map<SCNShaderModifierEntryPoint, string>}
	     * @see https://developer.apple.com/reference/scenekit/scnshadable/1523348-shadermodifiers
	     */
	    _this.shaderModifiers = null;

	    ///////////////////
	    // SCNAnimatable //
	    ///////////////////

	    /**
	     * @access private
	     * @type {Map}
	     */
	    _this._animations = new _SCNOrderedDictionary2.default();

	    /**
	     * @access private
	     * @type {?string}
	     */
	    _this._entityID = null;

	    _this._createPresentationProperties();
	    return _this;
	  }

	  // Configuring a Materials Visual Properties

	  /**
	   * An object that manages the materials diffuse response to lighting.
	   * @type {SCNMaterialProperty}
	   * @desc Diffuse shading describes the amount and color of light reflected equally in all directions from each point on the materials surface. The diffuse color of a pixel is independent of the point of view, so it can be thought of as a materials base color or texture. By default, the diffuse propertys contents object is a white color. Figure 1 shows the effect of setting the diffuse propertys contents to a texture image on a material whose other properties have default contents.Figure 1 Adding a diffuse texture to a materialThe materials lightingModel property determines the formula SceneKit uses to combine its diffuse color and other visual properties with lights and other contents in a scene to produce the final color for each rendered pixel in the rendered scene. For details, see Lighting Models.Adding a diffuse texture to a material
	   * @see https://developer.apple.com/reference/scenekit/scnmaterial/1462589-diffuse
	   */


	  _createClass(SCNMaterial, [{
	    key: '_createPresentationProperties',
	    value: function _createPresentationProperties() {
	      this._diffuse._createPresentation();
	      this._ambient._createPresentation();
	      this._specular._createPresentation();
	      this._normal._createPresentation();
	      this._reflective._createPresentation();
	      this._emission._createPresentation();
	      this._transparent._createPresentation();
	      this._multiply._createPresentation();
	      this._ambientOcclusion._createPresentation();
	      this._selfIllumination._createPresentation();
	      this._metalness._createPresentation();
	      this._roughness._createPresentation();
	    }
	  }, {
	    key: '_copyPresentationProperties',
	    value: function _copyPresentationProperties() {
	      this._diffuse._copyPresentation();
	      this._ambient._copyPresentation();
	      this._specular._copyPresentation();
	      this._normal._copyPresentation();
	      this._reflective._copyPresentation();
	      this._emission._copyPresentation();
	      this._transparent._copyPresentation();
	      this._multiply._copyPresentation();
	      this._ambientOcclusion._copyPresentation();
	      this._selfIllumination._copyPresentation();
	      this._metalness._copyPresentation();
	      this._roughness._copyPresentation();
	    }

	    // Structures

	    /**
	     * @type {Object} LightingModel
	     * @property {string} blinn Shading that incorporates ambient, diffuse, and specular properties, where specular highlights are calculated using the Blinn-Phong  formula.
	     * @property {string} constant Uniform shading that incorporates ambient lighting only.
	     * @property {string} lambert Shading that incorporates ambient and diffuse properties only.
	     * @property {string} phong Shading that incorporates ambient, diffuse, and specular properties, where specular highlights are calculated using the Phong  formula.
	     * @property {string} physicallyBased Shading based on a realistic abstraction of physical lights and materials.
	     * @see https://developer.apple.com/reference/scenekit/scnmaterial.lightingmodel
	     */

	  }, {
	    key: 'handleBindingOfSymbolHandler',


	    /////////////////
	    // SCNShadable //
	    /////////////////

	    // Handling Parameters in Custom OpenGL Shader Programs

	    /**
	     * Specifies a block to be called before rendering with programs with the specified GLSL uniform variable or attribute name.
	     * @access public
	     * @param {string} symbol - A GLSL uniform variable or attribute name.
	     * @param {?SCNBindingBlock} [block = null] - A block to be called by SceneKit.
	     * @returns {void}
	     * @desc Use this method to associate a block with a SceneKit object (geometry or material) to handle setup of an attribute or uniform variable in a custom SCNProgram shader associated with that object. SceneKit calls your block before rendering the object. In the block, you can execute any OpenGL commands or other code necessary for preparing your custom shader. For example, the following block updates the time uniform variable in a custom fragment shader for producing animated effects:CFTimeInterval startTime = CFAbsoluteTimeGetCurrent();
	    [myNode.geometry.firstMaterial handleBindingOfSymbol:@"time" usingBlock:
	      ^(unsigned int programID, unsigned int location, SCNNode *renderedNode, SCNRenderer *renderer) {
	          glUniform1f(location, CFAbsoluteTimeGetCurrent() - startTime);
	      }];
	    This method is for OpenGL shader programs only. To bind custom variable data for Metal shader programs, use the handleBinding(ofBufferNamed:frequency:handler:) method.CFTimeInterval startTime = CFAbsoluteTimeGetCurrent();
	    [myNode.geometry.firstMaterial handleBindingOfSymbol:@"time" usingBlock:
	      ^(unsigned int programID, unsigned int location, SCNNode *renderedNode, SCNRenderer *renderer) {
	          glUniform1f(location, CFAbsoluteTimeGetCurrent() - startTime);
	      }];
	      * @see https://developer.apple.com/reference/scenekit/scnshadable/1523063-handlebinding
	     */
	    value: function handleBindingOfSymbolHandler(symbol) {
	      var block = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
	    }

	    /**
	     * Specifies a block to be called after rendering with programs with the specified GLSL uniform variable or attribute name.
	     * @access public
	     * @param {string} symbol - A GLSL uniform variable or attribute name.
	     * @param {?SCNBindingBlock} [block = null] - A block to be called by SceneKit.
	     * @returns {void}
	     * @desc Use this method to associate a block with a SceneKit object (geometry or material) to handle cleanup related to an attribute or uniform variable in a custom SCNProgram shader associated with that object. SceneKit will call your block after rendering the object. In the block, you can execute any OpenGL commands or other code necessary for post-rendering tasks.This method is for OpenGL shader programs only. To bind custom variable data for Metal shader programs, use the handleBinding(ofBufferNamed:frequency:handler:) method.
	     * @see https://developer.apple.com/reference/scenekit/scnshadable/1522783-handleunbinding
	     */

	  }, {
	    key: 'handleUnbindingOfSymbolHandler',
	    value: function handleUnbindingOfSymbolHandler(symbol) {
	      var block = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
	    }

	    ///////////////////
	    // SCNAnimatable //
	    ///////////////////

	    // Managing Animations

	    /**
	     * Required. Adds an animation object for the specified key.
	     * @access public
	     * @param {CAAnimation} animation - The animation object to be added.
	     * @param {?string} key - An string identifying the animation for later retrieval. You may pass nil if you dont need to reference the animation later.
	     * @returns {void}
	     * @desc Newly added animations begin executing after the current run loop cycle ends.SceneKit does not define any requirements for the contents of the key parameterit need only be unique among the keys for other animations you add. If you add an animation with an existing key, this method overwrites the existing animation.
	     * @see https://developer.apple.com/reference/scenekit/scnanimatable/1523386-addanimation
	     */

	  }, {
	    key: 'addAnimationForKey',
	    value: function addAnimationForKey(animation, key) {
	      if (typeof key === 'undefined' || key === null) {
	        key = Symbol();
	      }
	      var anim = animation.copy();
	      // FIXME: use current frame time
	      anim._animationStartTime = Date.now() * 0.001;
	      anim._prevTime = anim._animationStartTime - 0.0000001;

	      this._animations.set(key, anim);
	    }

	    /**
	     * Required. Returns the animation with the specified key.
	     * @access public
	     * @param {string} key - A string identifying a previously added animation.
	     * @returns {?CAAnimation} - 
	     * @desc Attempting to modify any properties of the returned object results in undefined behavior.
	     * @see https://developer.apple.com/reference/scenekit/scnanimatable/1524020-animation
	     */

	  }, {
	    key: 'animationForKey',
	    value: function animationForKey(key) {
	      return this._animations.get(key);
	    }

	    /**
	     * Required. Removes all the animations currently attached to the object.
	     * @access public
	     * @returns {void}
	     * @see https://developer.apple.com/reference/scenekit/scnanimatable/1522762-removeallanimations
	     */

	  }, {
	    key: 'removeAllAnimations',
	    value: function removeAllAnimations() {
	      this._animations.clear();
	    }

	    /**
	     * Required. Removes the animation attached to the object with the specified key.
	     * @access public
	     * @param {string} key - A string identifying an attached animation to remove.
	     * @returns {void}
	     * @see https://developer.apple.com/reference/scenekit/scnanimatable/1522880-removeanimation
	     */

	  }, {
	    key: 'removeAnimationForKey',
	    value: function removeAnimationForKey(key) {
	      this._animations.delete(key);
	      // TODO: reset values
	    }

	    /**
	     * Required. Removes the animation attached to the object with the specified key, smoothly transitioning out of the animations effect.
	     * @access public
	     * @param {string} key - A string identifying an attached animation to remove.
	     * @param {number} duration - The duration for transitioning out of the animations effect before it is removed.
	     * @returns {void}
	     * @desc Use this method to create smooth transitions between the effects of multiple animations. For example, the geometry loaded from a scene file for a game character may have associated animations for player actions such as walking and jumping. When the player lands from a jump, you remove the jump animation so the character continues walking. If you use the removeAnimation(forKey:) method to remove the jump animation, SceneKit abruptly switches from the current frame of the jump animation to the current frame of the walk animation. If you use the removeAnimation(forKey:fadeOutDuration:) method instead, SceneKit plays both animations at once during that duration and interpolates vertex positions from one animation to the other, creating a smooth transition.
	     * @see https://developer.apple.com/reference/scenekit/scnanimatable/1522841-removeanimation
	     */

	  }, {
	    key: 'removeAnimationForKeyFadeOutDuration',
	    value: function removeAnimationForKeyFadeOutDuration(key, duration) {}

	    /**
	     * Required. An array containing the keys of all animations currently attached to the object.
	     * @type {string[]}
	     * @desc This array contains all keys for which animations are attached to the object, or is empty if there are no attached animations. The ordering of animation keys in the array is arbitrary.
	     * @see https://developer.apple.com/reference/scenekit/scnanimatable/1523610-animationkeys
	     */

	  }, {
	    key: 'pauseAnimationForKey',


	    // Pausing and Resuming Animations

	    /**
	     * Required. Pauses the animation attached to the object with the specified key.
	     * @access public
	     * @param {string} key - A string identifying an attached animation.
	     * @returns {void}
	     * @desc This method has no effect if no animation is attached to the object with the specified key.
	     * @see https://developer.apple.com/reference/scenekit/scnanimatable/1523592-pauseanimation
	     */
	    value: function pauseAnimationForKey(key) {}

	    /**
	     * Required. Resumes a previously paused animation attached to the object with the specified key.
	     * @access public
	     * @param {string} key - A string identifying an attached animation.
	     * @returns {void}
	     * @desc This method has no effect if no animation is attached to the object with the specified key or if the specified animation is not currently paused.
	     * @see https://developer.apple.com/reference/scenekit/scnanimatable/1523332-resumeanimation
	     */

	  }, {
	    key: 'resumeAnimationForKey',
	    value: function resumeAnimationForKey(key) {}

	    /**
	     * Required. Returns a Boolean value indicating whether the animation attached to the object with the specified key is paused.
	     * @access public
	     * @param {string} key - A string identifying an attached animation.
	     * @returns {boolean} - 
	     * @see https://developer.apple.com/reference/scenekit/scnanimatable/1523703-isanimationpaused
	     */

	  }, {
	    key: 'isAnimationPausedForKey',
	    value: function isAnimationPausedForKey(key) {
	      return false;
	    }

	    // Instance Methods

	    /**
	     * Required. 
	     * @access public
	     * @param {number} speed - 
	     * @param {string} key - 
	     * @returns {void}
	     * @see https://developer.apple.com/reference/scenekit/scnanimatable/1778343-setanimationspeed
	     */

	  }, {
	    key: 'setAnimationSpeedForKey',
	    value: function setAnimationSpeedForKey(speed, key) {}
	  }, {
	    key: 'diffuse',
	    get: function get() {
	      return this._diffuse;
	    }

	    /**
	     * An object that manages the materials response to ambient lighting.
	     * @type {SCNMaterialProperty}
	     * @desc Ambient shading describes the amount and color of ambient light reflected by the material. Ambient shading is uniform in all directions at all points on a surface. If a scene does not contain lights whose type is ambient, this property has no effect on a materials appearance. By default, the ambient propertys contents object is a dark gray color. Changing the ambient propertys contents lets you specify a different color or texture for the areas of a surface not directly illuminated by lights in a scene. To make the material respond identically to both ambient and diffuse light, set its locksAmbientWithDiffuse property to true. Figure 1 shows a material (with a texture for its diffuse property) before and after setting the ambient propertys contents to a solid color.Figure 1 Adding an ambient color to a materialThe materials lightingModel property determines the formula SceneKit uses to combine its ambient color and other visual properties with lights and other contents in a scene to produce the final color for each rendered pixel in the rendered scene. For details, see Lighting Models.This material property does not apply to physically-based materials (see physicallyBased).Adding an ambient color to a material
	     * @see https://developer.apple.com/reference/scenekit/scnmaterial/1462558-ambient
	     */

	  }, {
	    key: 'ambient',
	    get: function get() {
	      return this._ambient;
	    }

	    /**
	     * An object that manages the materials specular response to lighting.
	     * @type {SCNMaterialProperty}
	     * @desc Specular shading describes the amount and color of light reflected by the material directly toward the viewer, forming a bright highlight on the surface and simulating a glossy or shiny appearance. You adjust the sharpness of specular highlights using the materials shininess property.By default, the specular propertys contents object is a black color, causing the material to appear dull or matte. Changing the specular propertys contents to a brighter color causes specular highlights to appear in that color, making the surface appear shiny. When you apply a texture to the specular property, the texture image becomes a specular mapthe brightness of each pixel in the image determines the tendency of each point on the materials surface to create specular highlights when lit. Figure 1 shows a material (with a texture for its diffuse property) before and after providing a specular map image. Notice that the bright specular highlights appear only on portions of the surface where the specular map image is white.Figure 1 Adding a specular map to a materialThe materials lightingModel property determines the formula SceneKit uses to combine its specularity and other visual properties with lights and other contents in a scene to produce the final color for each rendered pixel in the rendered scene. For details, see Lighting Models.This material property does not apply to physically-based materials (see physicallyBased).Adding a specular map to a material
	     * @see https://developer.apple.com/reference/scenekit/scnmaterial/1462516-specular
	     */

	  }, {
	    key: 'specular',
	    get: function get() {
	      return this._specular;
	    }

	    /**
	     * An object that defines the nominal orientation of the surface at each point for use in lighting.
	     * @type {SCNMaterialProperty}
	     * @desc Simulating the interaction of lights with a material requires information about the orientation of the surface at each point. Typically, normal vectors provided by a geometry object provide this information. However, this limits the level of detail for surface contours because a geometry can only provide one unique surface normal vector per vertex (and increasing vertex count to model a highly detailed surface exacts a high performance cost).Alternatively, you can use a texture image as a normal map that describes the orientation of a surface for each pixel in the texture. When SceneKit uses an image, it treats the R, G, and B components of each as the X, Y, and Z components of a surface normal vector. Because a normal map texture can store much more detailed surface information than a geometry, you can use a materials normal property to simulate rough surfaces such as stone or add embossed or engraved designs to an otherwise smooth surface.By default, the normal propertys contents object is a white color. Setting the normal propertys contents to any solid color disables normal mapping, causing SceneKit to shade the material using only the surface normal information provided by its geometry. Setting the normal propertys contents to an image or other texture-mapped content enables normal mapping, which also automatically sets the materials isLitPerPixel property to true. Figure 1 shows the effect of setting the normal propertys contents to a texture image on a material whose other properties have default contents.Figure 1 Adding a normal map to a materialThe materials lightingModel property determines the formula SceneKit uses to combine its surface normals and other visual properties with lights and other contents in a scene to produce the final color for each rendered pixel in the rendered scene. For details, see Lighting Models.Adding a normal map to a material
	     * @see https://developer.apple.com/reference/scenekit/scnmaterial/1462542-normal
	     */

	  }, {
	    key: 'normal',
	    get: function get() {
	      return this._normal;
	    }

	    /**
	     * An object that defines the reflected color for each point on a surface.
	     * @type {SCNMaterialProperty}
	     * @desc You can simulate a mirrored or chromed finish on a surface by causing it to reflect its environment. SceneKit does not render real-time reflections of the objects in a scene, but it can use an environment map texture to simulate reflection of a static or animated image. When rendering each pixel on the surface, SceneKit traces the light from that point to a pixel in the environment map as if the surface was reflecting that image.By default, the reflective propertys contents object is a white color, causing the property to have no visible effect. Setting the reflective propertys contents to any solid color adds uniform shading to the material. To create a reflective effect, set the propertys contents to an image or other texture-mapped content.To produce a mirror-finish effect using an environment map, the texture image should take one of two forms:A sphere map, a square image whose content depicts an environment as reflected by a mirrored sphere.A cube map, an array of six square images which together form an imaginary cube enclosing the scene, whose inner surfaces are reflected by the material. You create a cube map by setting the reflective propertys contents object to an NSArray instance containing six images, each corresponding to a direction in the scenes world coordinate space in the following order: +X, -X, +Y, -Y, +Z, -Z (or Right, Left, Top, Bottom, Near, Far).Figure 1 shows a material (with a texture for its normal property) before and after providing a cube map for the reflective property.Figure 1 Adding a reflective cube map to a materialThis material property does not apply to physically-based materials (see physicallyBased). Instead, such materials reflect environment-based lighting (see the SCNScene lightingEnvironment property) based on their metalness and roughness properties.Adding a reflective cube map to a material
	     * @see https://developer.apple.com/reference/scenekit/scnmaterial/1462520-reflective
	     */

	  }, {
	    key: 'reflective',
	    get: function get() {
	      return this._reflective;
	    }

	    /**
	     * An object that defines the color emitted by each point on a surface.
	     * @type {SCNMaterialProperty}
	     * @desc You can use an emissive map texture to simulate parts of a surface that glow with their own light. SceneKit does not treat the material as a light sourcerather, the emission property determines colors for a material independent of lighting. (To create an object that appears to glow, you may wish to combine a geometry with an emissive map and additional SCNLight objects added to the scene.)By default, the emissive propertys contents object is a black color, causing the property to have no visible effect. Setting the emissive propertys contents to any solid color adds a uniform color to the material independent of lighting. To create a selective glow effect, set the propertys contents to an image or other texture-mapped content whose glowing areas use bright colors and whose other areas use darker colors. In the darker-colored portions of the emissive map (and portions with reduced opacity), the other visual properties of the material contribute to its appearance under scene lighting.Figure 1 shows a material (with a texture for its diffuse property) before and after providing an emissive map image.Figure 1 Adding an emissive map to a materialAdding an emissive map to a material
	     * @see https://developer.apple.com/reference/scenekit/scnmaterial/1462527-emission
	     */

	  }, {
	    key: 'emission',
	    get: function get() {
	      return this._emission;
	    }

	    /**
	     * An object that determines the opacity of each point in a material.
	     * @type {SCNMaterialProperty}
	     * @desc Use this property to selectively make parts of a material appear transparent. You can uniformly adjust the opacity of a material using its transparency property, or of all the content attached to a node using the nodes opacity property.By default, the transparent propertys contents object is a fully opaque black color, causing the property to have no visible effect. Setting the transparent propertys contents to any solid color uniformly fades the opacity of the material based on that colors opacity value. To make parts of a material appear transparent, set the propertys contents to an image or other texture-mapped content whose alpha channel defines areas of full or partial opacity.Figure 1 shows a semitransparent material before and after providing a texture image for its transparent property. (To make the transparency effect more visible, a blue sphere is shown behind the transparent material.)Figure 1 Adding a transparent texture to a materialThe transparencyMode property controls how SceneKit interprets color information from the transparent propertys contents.Adding a transparent texture to a material
	     * @see https://developer.apple.com/reference/scenekit/scnmaterial/1462583-transparent
	     */

	  }, {
	    key: 'transparent',
	    get: function get() {
	      return this._transparent;
	    }

	    /**
	     * An object that provides color values that are multiplied with pixels in a material after all other shading is complete.
	     * @type {SCNMaterialProperty}
	     * @desc After combining a materials other visual properties with lighting and other information about a scene, Scene kit multiplies the color of each rendered pixel by the color this property provides. You can use this property to darken or tint a surface independent of the effects of lighting and other properties, or to add precomputed lighting to a scene via a shadow map.By default, the multiply propertys contents object is a white color, causing the property to have no visible effect.Figure 1 shows a material (with textures for its diffuse and emission properties) before and after setting the multiply propertys contents to a solid color. Notice that the multiply color modulates even the bright areas added by the emissive map.Figure 1 Adding a multiply color to a materialAdding a multiply color to a material
	     * @see https://developer.apple.com/reference/scenekit/scnmaterial/1462575-multiply
	     */

	  }, {
	    key: 'multiply',
	    get: function get() {
	      return this._multiply;
	    }

	    /**
	     * An object that provides color values to be multiplied with the ambient light affecting the material.
	     * @type {SCNMaterialProperty}
	     * @desc Use this property to assign an ambient occlusion texture map to a surface. This property has no effect if there is no ambient light in the scene. If this property is not nil, SceneKit ignores the ambient property.When using physically-based shading (see physicallyBased), ambient occlusion approximates large-scale surface details that obscure global illumination.
	     * @see https://developer.apple.com/reference/scenekit/scnmaterial/1462579-ambientocclusion
	     */

	  }, {
	    key: 'ambientOcclusion',
	    get: function get() {
	      return this._ambientOcclusion;
	    }

	    /**
	     * An object that provides color values representing the global illumination of the surface.
	     * @type {SCNMaterialProperty}
	     * @desc Self-illumination applies to all materials, but is especially useful for those using physically-based shading (see physicallyBased). Physically-based materials work best with environment-based lighting (see the SCNScene property lightingEnvironment), but for some materials it can be useful to let a surface itself define part of its lightingfor example, an object whose position obscures it from the sky that provides the main lighting environment. When you assign contents to this property, they override the environmental lighting contribution to diffuse shading, but environmental lighting still contributes to specular effects.
	     * @see https://developer.apple.com/reference/scenekit/scnmaterial/1462524-selfillumination
	     */

	  }, {
	    key: 'selfIllumination',
	    get: function get() {
	      return this._selfIllumination;
	    }

	    /**
	     * An object that provides color values to determine how metallic the materials surface appears.
	     * @type {SCNMaterialProperty}
	     * @desc This property measures only the total intensity of color values; texture contents are best defined in grayscale.This property generally approximates aspects of a physical surfacesuch as index of refraction, tendency to produce sharp reflections, and tendency to produce Fresnel reflections at grazing anglesthat together produce an overall metallic or nonmetallic (also called dielectric) appearance. Lower values (darker colors) cause the material to appear more like a dielectric surface. Higher values (brighter colors) cause the surface to appear more metallic.This property applies only when the materials lightingModel value is physicallyBased.
	     * @see https://developer.apple.com/reference/scenekit/scnmaterial/1640554-metalness
	     */

	  }, {
	    key: 'metalness',
	    get: function get() {
	      return this._metalness;
	    }

	    /**
	     * An object that provides color values to determine the apparent smoothness of the surface.
	     * @type {SCNMaterialProperty}
	     * @desc This property measures only the total intensity of color values; texture contents are best defined in grayscale.This property approximates the level of microscopic detailfor example tiny bumps and cracksin a surface. By approximating these microfacets as a single term, this property helps produce lighting calculations that resemble the energy-conserving laws of real-world physics, resulting in more realistic variation between matte and shiny surfaces. Lower values (darker colors) cause the material to appear shiny, with well-defined specular highlights. Higher values (brighter colors) cause specular highlights to spread out and the diffuse color of the material to become more retroreflective.This property applies only when the materials lightingModel value is physicallyBased.
	     * @see https://developer.apple.com/reference/scenekit/scnmaterial/1640555-roughness
	     */

	  }, {
	    key: 'roughness',
	    get: function get() {
	      return this._roughness;
	    }
	  }, {
	    key: 'animationKeys',
	    get: function get() {
	      var keys = [];
	      var _iteratorNormalCompletion = true;
	      var _didIteratorError = false;
	      var _iteratorError = undefined;

	      try {
	        for (var _iterator = this._animations.keys()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	          var key = _step.value;

	          keys.push(key);
	        }
	      } catch (err) {
	        _didIteratorError = true;
	        _iteratorError = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion && _iterator.return) {
	            _iterator.return();
	          }
	        } finally {
	          if (_didIteratorError) {
	            throw _iteratorError;
	          }
	        }
	      }

	      return keys;
	    }
	  }], [{
	    key: 'LightingModel',
	    get: function get() {
	      return _LightingModel;
	    }
	  }]);

	  return SCNMaterial;
	}(_NSObject3.default);

	exports.default = SCNMaterial;

/***/ },
/* 76 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _NSObject2 = __webpack_require__(2);

	var _NSObject3 = _interopRequireDefault(_NSObject2);

	var _SCNAnimatable = __webpack_require__(66);

	var _SCNAnimatable2 = _interopRequireDefault(_SCNAnimatable);

	var _SCNFilterMode = __webpack_require__(77);

	var _SCNFilterMode2 = _interopRequireDefault(_SCNFilterMode);

	var _SCNMatrix = __webpack_require__(46);

	var _SCNMatrix2 = _interopRequireDefault(_SCNMatrix);

	var _SCNMatrix4MakeTranslation = __webpack_require__(78);

	var _SCNMatrix4MakeTranslation2 = _interopRequireDefault(_SCNMatrix4MakeTranslation);

	var _SCNOrderedDictionary = __webpack_require__(79);

	var _SCNOrderedDictionary2 = _interopRequireDefault(_SCNOrderedDictionary);

	var _SCNTransaction = __webpack_require__(80);

	var _SCNTransaction2 = _interopRequireDefault(_SCNTransaction);

	var _SCNWrapMode = __webpack_require__(81);

	var _SCNWrapMode2 = _interopRequireDefault(_SCNWrapMode);

	var _SKColor = __webpack_require__(11);

	var _SKColor2 = _interopRequireDefault(_SKColor);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * A container for the color or texture of one of a materials visual properties. 
	 * @access public
	 * @extends {NSObject}
	 * @implements {SCNAnimatable}
	 * @see https://developer.apple.com/reference/scenekit/scnmaterialproperty
	 */
	var SCNMaterialProperty = function (_NSObject) {
	  _inherits(SCNMaterialProperty, _NSObject);

	  _createClass(SCNMaterialProperty, null, [{
	    key: '_propTypes',
	    get: function get() {
	      return {
	        color: ['NSColor', '_contents'],
	        image: ['NSMutableDictionary', function (obj, dict, key, coder) {
	          var path = '';
	          if (typeof dict.path !== 'undefined') {
	            //path = coder._directoryPath + dict.path
	            path = dict.path;
	          } else if (typeof dict.URL !== 'undefined') {
	            path = dict.URL;
	          }
	          obj._loadContentsImage(path, coder._directoryPath);
	        }],
	        float: ['float', function (obj, value) {
	          obj._contents = new _SKColor2.default(value, value, value, 1.0);
	        }],
	        intensity: 'float',
	        // contentsTransform
	        wrapS: 'integer',
	        wrapT: 'integer',
	        minificationFilter: 'integer',
	        magnificationFilter: 'integer',
	        mipFilter: 'integer',
	        maxAnisotropy: 'float',
	        mappingChannel: 'integer',
	        borderColor: 'plist',

	        propertyType: ['integer', null],
	        parent: ['SCNMaterial', '_parent'],
	        isCommonProfileProperty: ['boolean', null]
	      };
	    }

	    // Creating a Material Property

	    /**
	     * Creates a new material property object with the specified contents.
	     * @access public
	     * @constructor
	     * @param {Object} contents - The visual contents of the material propertya color, image, or source of animated content. For details, see the discussion of the  contents property.
	     * @desc Newly created SCNMaterial objects contain SCNMaterialProperty instances for all of their visual properties. To change a materials visual properties, you modify those instances rather than creating new material property objects.You create new SCNMaterialProperty instances to provide textures for use with custom GLSL shadersfor details, see SCNShadable.
	     * @see https://developer.apple.com/reference/scenekit/scnmaterialproperty/1395386-init
	     */

	  }]);

	  function SCNMaterialProperty() {
	    var contents = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

	    _classCallCheck(this, SCNMaterialProperty);

	    // Working with Material Property Contents

	    /**
	     * The visual contents of the material propertya color, image, or source of animated content. Animatable.
	     * @access private
	     * @type {?Object}
	     * @see https://developer.apple.com/reference/scenekit/scnmaterialproperty/1395372-contents
	     */
	    var _this = _possibleConstructorReturn(this, (SCNMaterialProperty.__proto__ || Object.getPrototypeOf(SCNMaterialProperty)).call(this));

	    _this._contents = contents;

	    /**
	     * A number between 0.0 and 1.0 that modulates the effect of the material property. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnmaterialproperty/1395407-intensity
	     */
	    _this.intensity = 0;

	    // Configuring Texture Mapping Attributes

	    /**
	     * The transformation applied to the material propertys visual contents. Animatable.
	     * @type {SCNMatrix4}
	     * @see https://developer.apple.com/reference/scenekit/scnmaterialproperty/1395388-contentstransform
	     */
	    _this.contentsTransform = (0, _SCNMatrix4MakeTranslation2.default)(0, 0, 0);

	    /**
	     * The wrapping behavior for the S texture coordinate.
	     * @type {SCNWrapMode}
	     * @see https://developer.apple.com/reference/scenekit/scnmaterialproperty/1395384-wraps
	     */
	    _this.wrapS = _SCNWrapMode2.default.clamp;

	    /**
	     * The wrapping behavior for the T texture coordinate.
	     * @type {SCNWrapMode}
	     * @see https://developer.apple.com/reference/scenekit/scnmaterialproperty/1395382-wrapt
	     */
	    _this.wrapT = _SCNWrapMode2.default.clamp;

	    /**
	     * Texture filtering for rendering the material propertys image contents at a size smaller than that of the original image.
	     * @type {SCNFilterMode}
	     * @see https://developer.apple.com/reference/scenekit/scnmaterialproperty/1395390-minificationfilter
	     */
	    _this.minificationFilter = _SCNFilterMode2.default.linear;

	    /**
	     * Texture filtering for rendering the material propertys image contents at a size larger than that of the original image.
	     * @type {SCNFilterMode}
	     * @see https://developer.apple.com/reference/scenekit/scnmaterialproperty/1395378-magnificationfilter
	     */
	    _this.magnificationFilter = _SCNFilterMode2.default.linear;

	    /**
	     * Texture filtering for using mipmaps to render the material propertys image contents at a size smaller than that of the original image.
	     * @type {SCNFilterMode}
	     * @see https://developer.apple.com/reference/scenekit/scnmaterialproperty/1395398-mipfilter
	     */
	    _this.mipFilter = _SCNFilterMode2.default.nearest;

	    /**
	     * The amount of anisotropic texture filtering to be used when rendering the material propertys image contents.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnmaterialproperty/1395402-maxanisotropy
	     */
	    _this.maxAnisotropy = 0;

	    /**
	     * The source of texture coordinates for mapping the material propertys image contents.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnmaterialproperty/1395405-mappingchannel
	     */
	    _this.mappingChannel = 0;

	    /**
	     * A color used to fill in areas of a materials surface not covered by the material propertys image contents.
	     * @type {?Object}
	     * @deprecated
	     * @see https://developer.apple.com/reference/scenekit/scnmaterialproperty/1395376-bordercolor
	     */
	    _this.borderColor = null;

	    /**
	     * @access private
	     * @type {SCNMaterial}
	     */
	    _this._parent = null;

	    ///////////////////
	    // SCNAnimatable //
	    ///////////////////

	    /**
	     * @access private
	     * @type {Map}
	     */
	    _this._animations = new _SCNOrderedDictionary2.default();

	    _this.__presentation = null;
	    return _this;
	  }

	  _createClass(SCNMaterialProperty, [{
	    key: '_createPresentation',
	    value: function _createPresentation() {
	      if (this.__presentation === null) {
	        this.__presentation = this.copy();
	      }
	    }
	  }, {
	    key: '_copyPresentation',
	    value: function _copyPresentation() {
	      // TODO: copy other properties
	      this.__presentation._contents = this._contents;
	    }
	  }, {
	    key: 'copy',


	    /**
	     *
	     * @access public
	     * @returns {SCNMaterialProperty} -
	     */
	    value: function copy() {
	      var p = new SCNMaterialProperty();
	      p._contents = this._contents; // TODO: copy
	      p.intensity = this.intensity;
	      p.contentsTransform = this.contentsTransform; // TODO: copy
	      p.wrapS = this.wrapS;
	      p.wrapT = this.wrapT;
	      p.minificationFilter = this.minificationFilter;
	      p.magnicifactionFilter = this.maginicifactionFilter;
	      p.mipFilter = this.mipFilter;
	      p.maxAnisotropy = this.maxAnisotropy;
	      p.mappingChannel = this.mappingChannel;
	      p.borderColor = this.borderColor; // TODO: copy
	      //p._parent
	      //p._animations
	      //p._presentation

	      return p;
	    }
	  }, {
	    key: 'valueForKeyPath',
	    value: function valueForKeyPath(keyPath) {
	      var target = this.__presentation ? this.__presentation : this;

	      // TODO: add other keys
	      if (keyPath === 'contents') {
	        return target._contents;
	      }

	      return _get(SCNMaterialProperty.prototype.__proto__ || Object.getPrototypeOf(SCNMaterialProperty.prototype), 'valueForKeyPath', this).call(this, keyPath);
	    }
	  }, {
	    key: 'setValueForKeyPath',
	    value: function setValueForKeyPath(value, keyPath) {
	      var target = this.__presentation ? this.__presentation : this;

	      // TODO: add other keys
	      if (keyPath === 'contents') {
	        target._contents = value;
	      } else {
	        _get(SCNMaterialProperty.prototype.__proto__ || Object.getPrototypeOf(SCNMaterialProperty.prototype), 'setValueForKeyPath', this).call(this, value, keyPath);
	      }
	    }

	    /**
	     * The visual contents of the material propertya color, image, or source of animated content. Animatable.
	     * @type {?Object}
	     * @see https://developer.apple.com/reference/scenekit/scnmaterialproperty/1395372-contents
	     */

	  }, {
	    key: 'addAnimationForKey',


	    ///////////////////
	    // SCNAnimatable //
	    ///////////////////

	    // Managing Animations

	    /**
	     * Required. Adds an animation object for the specified key.
	     * @access public
	     * @param {CAAnimation} animation - The animation object to be added.
	     * @param {?string} key - An string identifying the animation for later retrieval. You may pass nil if you dont need to reference the animation later.
	     * @returns {void}
	     * @desc Newly added animations begin executing after the current run loop cycle ends.SceneKit does not define any requirements for the contents of the key parameterit need only be unique among the keys for other animations you add. If you add an animation with an existing key, this method overwrites the existing animation.
	     * @see https://developer.apple.com/reference/scenekit/scnanimatable/1523386-addanimation
	     */
	    value: function addAnimationForKey(animation, key) {
	      console.log('SCNMaterialProperty addAnimationForKey');
	      if (typeof key === 'undefined' || key === null) {
	        key = Symbol();
	      }
	      var anim = animation.copy();
	      // FIXME: use current frame time
	      anim._animationStartTime = Date.now() * 0.001;
	      anim._prevTime = anim._animationStartTime - 0.0000001;

	      this._animations.set(key, anim);
	    }

	    /**
	     * Required. Returns the animation with the specified key.
	     * @access public
	     * @param {string} key - A string identifying a previously added animation.
	     * @returns {?CAAnimation} - 
	     * @desc Attempting to modify any properties of the returned object results in undefined behavior.
	     * @see https://developer.apple.com/reference/scenekit/scnanimatable/1524020-animation
	     */

	  }, {
	    key: 'animationForKey',
	    value: function animationForKey(key) {
	      return this._animations.get(key);
	    }

	    /**
	     * Required. Removes all the animations currently attached to the object.
	     * @access public
	     * @returns {void}
	     * @see https://developer.apple.com/reference/scenekit/scnanimatable/1522762-removeallanimations
	     */

	  }, {
	    key: 'removeAllAnimations',
	    value: function removeAllAnimations() {
	      this._animations.clear();
	    }

	    /**
	     * Required. Removes the animation attached to the object with the specified key.
	     * @access public
	     * @param {string} key - A string identifying an attached animation to remove.
	     * @returns {void}
	     * @see https://developer.apple.com/reference/scenekit/scnanimatable/1522880-removeanimation
	     */

	  }, {
	    key: 'removeAnimationForKey',
	    value: function removeAnimationForKey(key) {
	      this._animations.delete(key);
	      // TODO: reset values
	    }

	    /**
	     * Required. Removes the animation attached to the object with the specified key, smoothly transitioning out of the animations effect.
	     * @access public
	     * @param {string} key - A string identifying an attached animation to remove.
	     * @param {number} duration - The duration for transitioning out of the animations effect before it is removed.
	     * @returns {void}
	     * @desc Use this method to create smooth transitions between the effects of multiple animations. For example, the geometry loaded from a scene file for a game character may have associated animations for player actions such as walking and jumping. When the player lands from a jump, you remove the jump animation so the character continues walking. If you use the removeAnimation(forKey:) method to remove the jump animation, SceneKit abruptly switches from the current frame of the jump animation to the current frame of the walk animation. If you use the removeAnimation(forKey:fadeOutDuration:) method instead, SceneKit plays both animations at once during that duration and interpolates vertex positions from one animation to the other, creating a smooth transition.
	     * @see https://developer.apple.com/reference/scenekit/scnanimatable/1522841-removeanimation
	     */

	  }, {
	    key: 'removeAnimationForKeyFadeOutDuration',
	    value: function removeAnimationForKeyFadeOutDuration(key, duration) {}

	    /**
	     * Required. An array containing the keys of all animations currently attached to the object.
	     * @type {string[]}
	     * @desc This array contains all keys for which animations are attached to the object, or is empty if there are no attached animations. The ordering of animation keys in the array is arbitrary.
	     * @see https://developer.apple.com/reference/scenekit/scnanimatable/1523610-animationkeys
	     */

	  }, {
	    key: 'pauseAnimationForKey',


	    // Pausing and Resuming Animations

	    /**
	     * Required. Pauses the animation attached to the object with the specified key.
	     * @access public
	     * @param {string} key - A string identifying an attached animation.
	     * @returns {void}
	     * @desc This method has no effect if no animation is attached to the object with the specified key.
	     * @see https://developer.apple.com/reference/scenekit/scnanimatable/1523592-pauseanimation
	     */
	    value: function pauseAnimationForKey(key) {}

	    /**
	     * Required. Resumes a previously paused animation attached to the object with the specified key.
	     * @access public
	     * @param {string} key - A string identifying an attached animation.
	     * @returns {void}
	     * @desc This method has no effect if no animation is attached to the object with the specified key or if the specified animation is not currently paused.
	     * @see https://developer.apple.com/reference/scenekit/scnanimatable/1523332-resumeanimation
	     */

	  }, {
	    key: 'resumeAnimationForKey',
	    value: function resumeAnimationForKey(key) {}

	    /**
	     * Required. Returns a Boolean value indicating whether the animation attached to the object with the specified key is paused.
	     * @access public
	     * @param {string} key - A string identifying an attached animation.
	     * @returns {boolean} - 
	     * @see https://developer.apple.com/reference/scenekit/scnanimatable/1523703-isanimationpaused
	     */

	  }, {
	    key: 'isAnimationPausedForKey',
	    value: function isAnimationPausedForKey(key) {
	      return false;
	    }

	    // Instance Methods

	    /**
	     * Required. 
	     * @access public
	     * @param {number} speed - 
	     * @param {string} key - 
	     * @returns {void}
	     * @see https://developer.apple.com/reference/scenekit/scnanimatable/1778343-setanimationspeed
	     */

	  }, {
	    key: 'setAnimationSpeedForKey',
	    value: function setAnimationSpeedForKey(speed, key) {}

	    /**
	     * @access private
	     * @param {WebGLContext} gl -
	     * @returns {number} -
	     */

	  }, {
	    key: '_wrapSFor',
	    value: function _wrapSFor(gl) {
	      switch (this.wrapS) {
	        case _SCNWrapMode2.default.clamp:
	          return gl.CLAMP_TO_EDGE; // FIXME: do not apply the texture out of 0-1
	        case _SCNWrapMode2.default.repeat:
	          return gl.REPEAT;
	        case _SCNWrapMode2.default.clampToBorder:
	          return gl.CLAMP_TO_EDGE;
	        case _SCNWrapMode2.default.mirror:
	          return gl.MIRRORED_REPEAT;
	        default:
	          throw new Error('unknown wrapS: ' + this.wrapS);
	      }
	    }

	    /**
	     * @access private
	     * @param {WebGLContext} gl -
	     * @returns {number} -
	     */

	  }, {
	    key: '_wrapTFor',
	    value: function _wrapTFor(gl) {
	      switch (this.wrapT) {
	        case _SCNWrapMode2.default.clamp:
	          return gl.CLAMP_TO_EDGE; // FIXME: do not apply the texture out of 0-1
	        case _SCNWrapMode2.default.repeat:
	          return gl.REPEAT;
	        case _SCNWrapMode2.default.clampToBorder:
	          return gl.CLAMP_TO_EDGE;
	        case _SCNWrapMode2.default.mirror:
	          return gl.MIRRORED_REPEAT;
	        default:
	          throw new Error('unknown wrapT: ' + this.wrapT);
	      }
	    }

	    /**
	     * @access private
	     * @param {WebGLContext} gl -
	     * @returns {number} -
	     */

	  }, {
	    key: '_minificationFilterFor',
	    value: function _minificationFilterFor(gl) {
	      switch (this.minificationFilter) {
	        case _SCNFilterMode2.default.none:
	        case _SCNFilterMode2.default.linear:
	          {
	            switch (this.mipFilter) {
	              case _SCNFilterMode2.default.none:
	                return gl.LINEAR;
	              case _SCNFilterMode2.default.nearest:
	                return gl.LINEAR_MIPMAP_NEAREST;
	              case _SCNFilterMode2.default.linear:
	                return gl.LINEAR_MIPMAP_LINEAR;
	              default:
	                throw new Error('unknown mipmapFilter: ' + this.mipmapFilter);
	            }
	          }
	        case _SCNFilterMode2.default.nearest:
	          {
	            switch (this.mipFilter) {
	              case _SCNFilterMode2.default.none:
	                return gl.NEAREST;
	              case _SCNFilterMode2.default.nearest:
	                return gl.NEAREST_MIPMAP_NEAREST;
	              case _SCNFilterMode2.default.linear:
	                return gl.NEAREST_MIPMAP_LINEAR;
	              default:
	                throw new Error('unknown mipmapFilter: ' + this.mipmapFilter);
	            }
	          }
	        default:
	          throw new Error('unknown minificationFilter: ' + this.minificationFilter);
	      }
	    }

	    /**
	     * @access private
	     * @param {WebGLContext} gl -
	     * @returns {number} -
	     */

	  }, {
	    key: '_magnificationFilterFor',
	    value: function _magnificationFilterFor(gl) {
	      switch (this.magnificationFilter) {
	        case _SCNFilterMode2.default.none:
	          return gl.LINEAR; // default value
	        case _SCNFilterMode2.default.nearest:
	          return gl.NEAREST;
	        case _SCNFilterMode2.default.linear:
	          return gl.LINEAR;
	        default:
	          throw new Error('unknown magnificationFilter: ' + this.magnificationFilter);
	      }
	    }

	    /**
	     * @access private
	     * @param {string} path -
	     * @param {string} dirPath -
	     * @returns {Image} -
	     */

	  }, {
	    key: '_loadContentsImage',
	    value: function _loadContentsImage(path, dirPath) {
	      var _this2 = this;

	      console.log('image.path: ' + path);
	      var image = new Image();
	      if (path.indexOf('file:///') === 0) {
	        var paths = path.slice(8).split('/');
	        var pathCount = 1;
	        var _path = dirPath + paths.slice(-pathCount).join('/');
	        //console.warn(`image loading: ${_path}`)
	        image.onload = function () {
	          //console.info(`image ${image.src} onload`)
	          _this2._contents = image;
	        };
	        image.onerror = function () {
	          //console.warn('image.onerror')
	          pathCount += 1;
	          if (pathCount > paths.length) {
	            //console.error(`image ${path} load error.`)
	            throw new Error('image ' + path + ' load error.');
	          } else {
	            // retry
	            _path = dirPath + paths.slice(-pathCount).join('/');
	            image.src = _path;
	          }
	        };
	        image.src = _path;
	      } else {
	        console.info('image loading: ' + path);
	        image.onload = function () {
	          console.warn('http image ' + image.src + ' onload');
	          _this2._contents = image;
	        };
	        image.onerror = function () {
	          console.warn('http image ' + path + ' load error.');
	        };
	        image.src = dirPath + path;
	      }
	      return image;
	    }

	    /**
	     * @access public
	     * @returns {Float32Array} -
	     */

	  }, {
	    key: 'float32Array',
	    value: function float32Array() {
	      var target = this.__presentation ? this.__presentation : this;
	      if (target._contents instanceof _SKColor2.default) {
	        return target._contents.float32Array();
	      }
	      return new Float32Array([1, 1, 1, 1]);
	    }
	  }, {
	    key: '_presentation',
	    get: function get() {
	      if (this.__presentation === null) {
	        return null;
	      }
	      return this.__presentation;
	    }
	  }, {
	    key: 'contents',
	    get: function get() {
	      return this._contents;
	    },
	    set: function set(newValue) {
	      var oldValue = this._contents;
	      this._contents = newValue;
	      _SCNTransaction2.default._addChange(this, 'contents', oldValue, newValue);
	    }
	  }, {
	    key: 'animationKeys',
	    get: function get() {
	      var keys = [];
	      var _iteratorNormalCompletion = true;
	      var _didIteratorError = false;
	      var _iteratorError = undefined;

	      try {
	        for (var _iterator = this._animations.keys()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	          var key = _step.value;

	          keys.push(key);
	        }
	      } catch (err) {
	        _didIteratorError = true;
	        _iteratorError = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion && _iterator.return) {
	            _iterator.return();
	          }
	        } finally {
	          if (_didIteratorError) {
	            throw _iteratorError;
	          }
	        }
	      }

	      return keys;
	    }
	  }]);

	  return SCNMaterialProperty;
	}(_NSObject3.default);

	exports.default = SCNMaterialProperty;

/***/ },
/* 77 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * Texture filtering modes, used by the the minificationFilter, magnificationFilter, and mipFilter properties.
	 * @typedef {Object} SCNFilterMode
	 * @property {number} none - No texture filtering is applied.
	 * @property {number} nearest - Texture filtering returns the color from only one texel, whose location is nearest to the coordinates being sampled.
	 * @property {number} linear - Texture filtering sample texels from the neighborhood of the coordinates being sampled and linearly interpolates their colors.
	 * @see https://developer.apple.com/reference/scenekit/scnfiltermode
	 */

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var SCNFilterMode = {
	  none: 0,
	  nearest: 1,
	  linear: 2
	};

	exports.default = SCNFilterMode;

/***/ },
/* 78 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _SCNMatrix = __webpack_require__(46);

	var _SCNMatrix2 = _interopRequireDefault(_SCNMatrix);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Returns a matrix describing a translation transformation.
	 * @access public
	 * @param {number} tx - 
	 * @param {number} ty - 
	 * @param {number} tz - 
	 * @returns {SCNMatrix4} - 
	 * @see https://developer.apple.com/reference/scenekit/1409679-scnmatrix4maketranslation
	 */
	var SCNMatrix4MakeTranslation = function SCNMatrix4MakeTranslation(tx, ty, tz) {
	  return new _SCNMatrix2.default(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, tx, ty, tz, 1);
	};

	exports.default = SCNMatrix4MakeTranslation;

/***/ },
/* 79 */
/***/ function(module, exports) {

	'use strict';

	/**
	 *
	 * @access public
	 * @extends {NSDictionary}
	 */

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var SCNOrderedDictionary = function () {
	  _createClass(SCNOrderedDictionary, null, [{
	    key: 'initWithCoder',

	    /**
	     * @access public
	     * @param {NSCoder} coder -
	     * @returns {Object} -
	     */
	    value: function initWithCoder(coder) {
	      var dict = new SCNOrderedDictionary();
	      if (typeof coder._refObj['NS.objects'] !== 'undefined') {
	        var keys = coder._refObj['NS.keys'];
	        var objects = coder._refObj['NS.objects'];
	        if (!Array.isArray(keys)) {
	          throw new Error('NS.keys must be Array');
	        }
	        if (!Array.isArray(objects)) {
	          throw new Error('NS.objects must be Array');
	        }
	        if (keys.length !== objects.length) {
	          throw new Error('NS.keys.length !== NS.objects.length');
	        }

	        var keyCoder = coder.copy();
	        keyCoder._refObj = keys;

	        var objCoder = coder.copy();
	        objCoder._refObj = objects;

	        for (var i = 0; i < keys.length; i++) {
	          var key = keyCoder.decodeObjectForKey(i);
	          var obj = objCoder.decodeObjectForKey(i);
	          dict._keys.push(key);
	          dict._values.push(obj);
	        }
	      } else {
	        for (var _i = 0;; _i++) {
	          var objKey = 'NS.object.' + _i;
	          var keyKey = 'NS.key.' + _i;
	          if (typeof coder._refObj[objKey] === 'undefined') {
	            break;
	          }
	          var _key = coder.decodeObjectForKey(keyKey);
	          var _obj = coder.decodeObjectForKey(objKey);
	          dict._keys.push(_key);
	          dict._values.push(_obj);
	        }
	      }

	      return dict;
	    }
	  }]);

	  function SCNOrderedDictionary() {
	    _classCallCheck(this, SCNOrderedDictionary);

	    this._keys = [];
	    this._values = [];
	  }

	  _createClass(SCNOrderedDictionary, [{
	    key: 'copy',
	    value: function copy() {
	      var dict = new SCNOrderedDictionary();
	      dict._keys = this._keys.slice(0);
	      dict._values = this._values.slice(0);
	      return dict;
	    }
	  }, {
	    key: 'keys',
	    value: function keys() {
	      return this._keys.slice(0);
	    }
	  }, {
	    key: 'dictionary',
	    value: function dictionary() {
	      var dict = {};
	      var len = this._keys.length;
	      for (var i = 0; i < len; i++) {
	        dict[this._keys[i]] = this._values[i];
	      }
	      return dict;
	    }
	  }, {
	    key: 'allValues',
	    value: function allValues() {
	      return this._values.slice(0);
	    }
	  }, {
	    key: 'allKeys',
	    value: function allKeys() {
	      return this.keys();
	    }
	  }, {
	    key: 'count',
	    value: function count() {
	      return this._keys.length;
	    }
	  }, {
	    key: 'removeAllObjects',
	    value: function removeAllObjects() {
	      this._keys = [];
	      this._values = [];
	    }
	  }, {
	    key: 'removeObjectForKey',
	    value: function removeObjectForKey(key) {
	      var index = this._keys.indexOf(key);
	      if (index < 0) {
	        return;
	      }
	      this._keys.splice(index, 1);
	      this._values.splice(index, 1);
	    }
	  }, {
	    key: 'objectForKey',
	    value: function objectForKey(key) {
	      var index = this._keys.indexOf(key);
	      if (index < 0) {
	        return null;
	      }
	      return this._values[index];
	    }
	  }, {
	    key: 'setObjectForKey',
	    value: function setObjectForKey(object, key) {
	      var index = this._keys.indexOf(key);
	      if (index < 0) {
	        index = this._keys.length;
	        this._keys[index] = key;
	      }
	      this._values[index] = object;
	    }
	  }, {
	    key: 'valueForKey',
	    value: function valueForKey(key) {
	      return this.objectForKey(key);
	    }
	  }, {
	    key: 'setValueForKey',
	    value: function setValueForKey(value, key) {
	      this.setObjectForKey(value, key);
	    }

	    // extension for JavaScript

	  }, {
	    key: 'set',
	    value: function set(key, object) {
	      this.setObjectForKey(object, key);
	    }
	  }, {
	    key: 'get',
	    value: function get(key) {
	      return this.objectForKey(key);
	    }
	  }, {
	    key: 'clear',
	    value: function clear() {
	      this.removeAllObjects();
	    }
	  }, {
	    key: 'delete',
	    value: function _delete(key) {
	      this.removeObjectForKey(key);
	    }
	  }, {
	    key: 'forEach',
	    value: function forEach(func) {
	      var len = this._keys.length;
	      for (var i = 0; i < len; i++) {
	        func(this._values[i], this._keys[i]);
	      }
	    }
	  }]);

	  return SCNOrderedDictionary;
	}();

	exports.default = SCNOrderedDictionary;

/***/ },
/* 80 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _NSObject2 = __webpack_require__(2);

	var _NSObject3 = _interopRequireDefault(_NSObject2);

	var _CAMediaTimingFunction = __webpack_require__(51);

	var _CAMediaTimingFunction2 = _interopRequireDefault(_CAMediaTimingFunction);

	var _CABasicAnimation = __webpack_require__(55);

	var _CABasicAnimation2 = _interopRequireDefault(_CABasicAnimation);

	var _SCNAnimationEvent = __webpack_require__(53);

	var _SCNAnimationEvent2 = _interopRequireDefault(_SCNAnimationEvent);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var _transactions = [];
	var _immediateMode = true;

	var _Transaction = function _Transaction() {
	  _classCallCheck(this, _Transaction);

	  /**
	   * @type {Object}
	   */
	  this._animations = [];

	  /**
	   * @type {number}
	   */
	  this._animationDuration = 0.0;

	  /**
	   * @type {?CAMediaTimingFunction}
	   */
	  this._animationTimingFunction = null;

	  /**
	   * @type {boolean}
	   */
	  this._disableActions = false;

	  /**
	   * @type {?function}
	   */
	  this._completionBlock = null;

	  /**
	   * @type {Map<string, Object>}
	   */
	  this._values = new Map();
	};

	var _automaticTransaction = new _Transaction();

	/**
	 * The SCNTransaction class defines SceneKits mechanism for batching scene graph modifications into atomic updates. You use SCNTransaction class methods to control the animation that results from changing animatable properties in the scene graph and to combine sets of changes into nested transactions.
	 * @access public
	 * @extends {NSObject}
	 * @see https://developer.apple.com/reference/scenekit/scntransaction
	 */

	var SCNTransaction = function (_NSObject) {
	  _inherits(SCNTransaction, _NSObject);

	  /**
	   * constructor
	   * @access public
	   * @constructor
	   */
	  function SCNTransaction() {
	    _classCallCheck(this, SCNTransaction);

	    var _this = _possibleConstructorReturn(this, (SCNTransaction.__proto__ || Object.getPrototypeOf(SCNTransaction)).call(this));

	    throw new Error('do not create an instance of SCNTransaction');
	    return _this;
	  }

	  // Creating and Committing Transactions

	  /**
	   * Begins a new transaction for the current thread.
	   * @access public
	   * @returns {void}
	   * @desc The new transaction is nested within the threads current transaction, if there is one.The first time you modify the scene graph during a pass through the run loop, SceneKit automatically creates a transaction and makes it the current transaction. (SceneKit commits that transaction when the next iteration of the run loops begins.) If you call this method to create a custom transaction before modifying the scene graph, your custom transaction becomes the current transaction.
	   * @see https://developer.apple.com/reference/scenekit/scntransaction/1522820-begin
	   */


	  _createClass(SCNTransaction, null, [{
	    key: 'begin',
	    value: function begin() {
	      var newTransaction = new _Transaction();
	      newTransaction._disableActions = this._currentTransaction._disabledActions;
	      _transactions.push(newTransaction);
	    }

	    /**
	     * Commits all changes made during the current transaction.
	     * @access public
	     * @returns {void}
	     * @desc If there is no current transaction, this method has no effect.
	     * @see https://developer.apple.com/reference/scenekit/scntransaction/1523436-commit
	     */

	  }, {
	    key: 'commit',
	    value: function commit() {
	      var transaction = _transactions.pop();
	      if (transaction) {
	        this._apply(transaction);
	      }
	    }

	    /**
	     * Applies all changes from the current automatic transaction.
	     * @access public
	     * @returns {void}
	     * @desc SceneKit automatically calls this method at the end of each pass through the run loop, regardless of the run loop mode. If your app does not have a run loop, you must call this method explicitly.If the current transaction has any nested transactions that are still animating, SceneKit waits to commit the current transactions changes until those transactions complete.NoteIf possible, avoid calling flush() explicitly. By allowing flush() to execute during the run loop, your app achieves better performance, atomic screen updates are preserved, and transactions and animations that work from transaction to transaction continue to function.
	     * @see https://developer.apple.com/reference/scenekit/scntransaction/1522860-flush
	     */

	  }, {
	    key: 'flush',
	    value: function flush() {
	      // TODO: wait nested transactions
	      this._apply(_automaticTransaction);
	    }
	  }, {
	    key: '_apply',
	    value: function _apply(transaction) {
	      if (transaction._disableActions || transaction._animationDuration === 0) {
	        //transaction._animations.forEach((anim) => {
	        //  anim.target.setValueForKeyPath(anim.newValue, anim.keyPath)
	        //})
	        if (transaction._completionBlock) {
	          transaction._completionBlock();
	        }
	      } else {
	        var promises = [];
	        transaction._animations.forEach(function (anim) {
	          var promise = new Promise(function (resolve, reject) {
	            var animation = new _CABasicAnimation2.default(anim.keyPath);
	            animation.fromValue = anim.diff;
	            animation.timingFunction = transaction._animationTimingFunction;
	            animation.duration = transaction._animationDuration;
	            animation.isAdditive = true;
	            animation.isRemovedOnCompletion = true;
	            animation.delegate = {
	              animationDidStop: function animationDidStop(_anim, _finished) {
	                if (_finished) {
	                  console.log('animation completed: ' + anim.keyPath);
	                  //anim.target.setValueForKeyPath(anim.newValue, anim.keyPath)
	                  resolve(anim, animation);
	                }
	              }
	            };
	            anim.target.addAnimationForKey(animation, null);
	          });
	          promises.push(promise);
	        });
	        Promise.all(promises).then(function () {
	          if (transaction._completionBlock) {
	            transaction._completionBlock();
	          }
	        });
	      }
	    }

	    // Overriding Animation Duration and Timing

	    /**
	     * Returns the duration, in seconds, of all animations within the current transaction.
	     * @type {number}
	     * @desc The default duration is zero for transactions automatically created by SceneKit, and 0.25 for animations you create using the begin() method.
	     * @see https://developer.apple.com/reference/scenekit/scntransaction/1523888-animationduration
	     */

	  }, {
	    key: 'lock',


	    // Managing Concurrency

	    /**
	     * Attempts to acquire a recursive spinlock to ensure the validity of values you retrieve during the transaction.
	     * @access public
	     * @returns {void}
	     * @desc SceneKits data model is thread-safe in that it ensures that internal data structures will not be corrupted by concurrent attempts to modify their contents from multiple threads. However, this model does not guarantee the validity of values you read from scene graph objects after returning them.For example, consider the following operation:_node.position = SCNVector3Make(_node.position.x, _node.position.y + 10, _node.position.z);
	    The intent of this line is to move a node by ten units. But if another thread modifies the nodes position property concurrently, the new position value could be unexpected. If your app modifies the scene graph from multiple threads, use a transaction lock to ensure that your modifications take effect as intended.[SCNTransaction lock];
	    _node.position = SCNVector3Make(_node.position.x, _node.position.y + 10, _node.position.z);
	    [SCNTransaction unlock];
	    If another thread currently holds a lock on the transaction, calling lock() has no effect._node.position = SCNVector3Make(_node.position.x, _node.position.y + 10, _node.position.z);
	    [SCNTransaction lock];
	    _node.position = SCNVector3Make(_node.position.x, _node.position.y + 10, _node.position.z);
	    [SCNTransaction unlock];
	      * @see https://developer.apple.com/reference/scenekit/scntransaction/1523078-lock
	     */
	    value: function lock() {
	      throw new Error('lock() is not implemented');
	    }

	    /**
	     * Relinquishes a previously acquired transaction lock.
	     * @access public
	     * @returns {void}
	     * @desc See the lock() method for more details on transaction locking.
	     * @see https://developer.apple.com/reference/scenekit/scntransaction/1523166-unlock
	     */

	  }, {
	    key: 'unlock',
	    value: function unlock() {
	      throw new Error('unlock() is not implemented');
	    }

	    // Getting and Setting Transaction Properties

	    /**
	     * Associates an arbitrary object with the current transaction using the specified key.
	     * @access public
	     * @param {?Object} value - 
	     * @param {string} key - A unique string identifying the object for later retrieval.
	     * @returns {void}
	     * @desc Nested transactions have nested data scope. Setting a value for a key associates it with the current transaction (or innermost nested transaction) only, and reading the value for a key searches through nested transactions (starting from the innermost).
	     * @see https://developer.apple.com/reference/scenekit/scntransaction/1524124-setvalue
	     */

	  }, {
	    key: 'setValueForKey',
	    value: function setValueForKey(value, key) {
	      this._currentTransaction._values.set(key, value);
	    }

	    /**
	     * Returns the object previously associated with the current transaction using the specified key.
	     * @access public
	     * @param {string} key - The unique string identifying an object previously associated with the transaction.
	     * @returns {?Object} - 
	     * @desc Nested transactions have nested data scope. Setting a value for a key associates it with the current transaction (or innermost nested transaction) only, but reading the value for a key searches through nested transactions (starting from the innermost).
	     * @see https://developer.apple.com/reference/scenekit/scntransaction/1523919-value
	     */

	  }, {
	    key: 'valueForKey',
	    value: function valueForKey(key) {
	      for (var i = _transactions.length - 1; i >= 0; i--) {
	        var value = _transactions[i]._values.get(key);
	        if (typeof value !== 'undefined') {
	          return value;
	        }
	      }
	      return _automaticTransaction._values.get(key);
	    }

	    /**
	     * @access private
	     * @returns {_Transaction} -
	     */

	  }, {
	    key: '_addChange',
	    value: function _addChange(target, keyPath, oldValue, newValue) {
	      if (this._immediateMode) {
	        //target.setValueForKeyPath(newValue, keyPath)
	      } else {
	        var diff = null;
	        if (typeof newValue === 'number') {
	          diff = oldValue - newValue;
	        } else if (typeof newValue.sub !== 'undefined') {
	          diff = oldValue.sub(newValue);
	        } else {
	          throw new Error('keyPath ' + keyPath + ' does not have sub function');
	        }
	        this._currentTransaction._animations.push({
	          target: target,
	          keyPath: keyPath,
	          diff: diff,
	          oldValue: oldValue,
	          newValue: newValue
	        });
	      }
	    }

	    /**
	     * @access public
	     * @type {boolean}
	     */

	  }, {
	    key: 'animationDuration',
	    get: function get() {
	      return this._currentTransaction._animationDuration;
	    }

	    /**
	     * Returns the duration, in seconds, of all animations within the current transaction.
	     * @type {number}
	     * @desc The default duration is zero for transactions automatically created by SceneKit, and 0.25 for animations you create using the begin() method.
	     * @see https://developer.apple.com/reference/scenekit/scntransaction/1523888-animationduration
	     */
	    ,
	    set: function set(newValue) {
	      this._currentTransaction._animationDuration = newValue;
	    }

	    /**
	     * Returns the timing function that SceneKit uses for all animations within this transaction group. 
	     * @type {?CAMediaTimingFunction}
	     * @desc Media timing functions, also known as animation curves, define the relationship between the elapsed time of an animation and its effect on a property. For example, the kCAMediaTimingFunctionEaseInEaseOut function creates an effect that begins slowly, speeds up, and then finishes slowly.
	     * @see https://developer.apple.com/reference/scenekit/scntransaction/1522614-animationtimingfunction
	     */

	  }, {
	    key: 'animationTimingFunction',
	    get: function get() {
	      return this._currentTransaction._animationTimingFunction;
	    }

	    /**
	     * Returns the timing function that SceneKit uses for all animations within this transaction group. 
	     * @type {?CAMediaTimingFunction}
	     * @desc Media timing functions, also known as animation curves, define the relationship between the elapsed time of an animation and its effect on a property. For example, the kCAMediaTimingFunctionEaseInEaseOut function creates an effect that begins slowly, speeds up, and then finishes slowly.
	     * @see https://developer.apple.com/reference/scenekit/scntransaction/1522614-animationtimingfunction
	     */
	    ,
	    set: function set(newValue) {
	      this._currentTransaction._animationTimingFunction = newValue;
	    }

	    // Temporarily Disabling Property Animations

	    /**
	     * Returns a Boolean value indicating whether changes to animatable properties during the transaction are implicitly animated.
	     * @type {boolean}
	     * @desc By default (when this property is false), any changes to animatable properties of objects in the scene graph implicitly create animations. (These animations may not be visible unless you use the animationDuration property to set a nonzero duration for the transaction.) Set this property to true to disable implicit animation during the transaction.Disabling animation applies to all property changes in the current transaction and any nested transactions within it. However, you can use this property again within a nested transaction to enable implicit animation for that transaction.
	     * @see https://developer.apple.com/reference/scenekit/scntransaction/1524238-disableactions
	     */

	  }, {
	    key: 'disableActions',
	    get: function get() {
	      return this._currentTransaction._disableActions;
	    }

	    /**
	     * Returns a Boolean value indicating whether changes to animatable properties during the transaction are implicitly animated.
	     * @type {boolean}
	     * @desc By default (when this property is false), any changes to animatable properties of objects in the scene graph implicitly create animations. (These animations may not be visible unless you use the animationDuration property to set a nonzero duration for the transaction.) Set this property to true to disable implicit animation during the transaction.Disabling animation applies to all property changes in the current transaction and any nested transactions within it. However, you can use this property again within a nested transaction to enable implicit animation for that transaction.
	     * @see https://developer.apple.com/reference/scenekit/scntransaction/1524238-disableactions
	     */
	    ,
	    set: function set(newValue) {
	      this._currentTransaction._disableActions = newValue;
	    }

	    // Getting and Setting Completion Block Objects

	    /**
	     * Returns the block previously associated with the current transaction.
	     * @type {?function(): void}
	     * @desc See setCompletionBlock(_:) for a description of the role of the completion block object.
	     * @see https://developer.apple.com/reference/scenekit/scntransaction/1523660-completionblock
	     */

	  }, {
	    key: 'completionBlock',
	    get: function get() {
	      return this._currentTransaction._completionBlock;
	    }

	    /**
	     * Returns the block previously associated with the current transaction.
	     * @type {?function(): void}
	     * @desc See setCompletionBlock(_:) for a description of the role of the completion block object.
	     * @see https://developer.apple.com/reference/scenekit/scntransaction/1523660-completionblock
	     */
	    ,
	    set: function set(newValue) {
	      this._currentTransaction._completionBlock = newValue;
	    }
	  }, {
	    key: '_currentTransaction',
	    get: function get() {
	      if (_transactions.length > 0) {
	        return _transactions[_transactions.length - 1];
	      }
	      return _automaticTransaction;
	    }
	  }, {
	    key: 'immediateMode',
	    get: function get() {
	      if (_transactions.length > 0) {
	        return false;
	      }
	      return _immediateMode;
	    }

	    /**
	     * @access public
	     * @type {boolean}
	     */
	    ,
	    set: function set(newValue) {
	      _immediateMode = newValue;
	    }
	  }]);

	  return SCNTransaction;
	}(_NSObject3.default);

	exports.default = SCNTransaction;

/***/ },
/* 81 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * Modes to apply to texture wrapping, used by the wrapT and wrapS properties.
	 * @typedef {Object} SCNWrapMode
	 * @property {number} clamp - Texture coordinates are clamped to the range from 0.0 to 1.0, inclusive.
	 * @property {number} repeat - Texture sampling uses only the fractional part of texture coordinates, passing through the range from 0.0 to (but not including) 1.0.
	 * @property {number} clampToBorder - Texture sampling uses texture colors for coordinates in the range from 0.0 to 1.0 (inclusive) and the material propertys borderColor value otherwise.
	 * @property {number} mirror - Texture sampling of texture coordinates outside range from 0.0 to 1.0 should behave as if the range reverses before repeating.
	 * @see https://developer.apple.com/reference/scenekit/scnwrapmode
	 */

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var SCNWrapMode = {
	  clamp: 1,
	  repeat: 2,
	  clampToBorder: 3,
	  mirror: 4
	};

	exports.default = SCNWrapMode;

/***/ },
/* 82 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * The modes SceneKit uses to calculate the opacity of pixels rendered with a material, used by the transparencyMode property.
	 * @typedef {Object} SCNTransparencyMode
	 * @property {number} aOne - SceneKit derives transparency information from the alpha channel of colors. The value 1.0 is opaque.
	 * @property {number} rgbZero - SceneKit derives transparency information from the luminance of colors. The value 0.0 is opaque.
	 * @see https://developer.apple.com/reference/scenekit/scntransparencymode
	 */

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var SCNTransparencyMode = {
	  aOne: 0,
	  rgbZero: 1
	};

	exports.default = SCNTransparencyMode;

/***/ },
/* 83 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * Modes that describe how SceneKit blends source colors rendered using a material with destination colors already in a rendering target, used by the blendMode property.
	 * @typedef {Object} SCNBlendMode
	 * @property {number} alpha - Blend by multiplying source and destination color values by their corresponding alpha values.
	 * @property {number} add - Blend by adding the source color to the destination color.
	 * @property {number} subtract - Blend by subtracting the source color from the destination color.
	 * @property {number} multiply - Blend by multiplying the source color with the background color.
	 * @property {number} screen - Blend by multiplying the inverse of the source color with the inverse of the destination color.
	 * @property {number} replace - Blend by replacing the destination color with the source color, ignoring alpha.
	 * @see https://developer.apple.com/reference/scenekit/scnblendmode
	 */

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var SCNBlendMode = {
	  alpha: 0,
	  add: 1,
	  subtract: 2,
	  multiply: 3,
	  screen: 4,
	  replace: 5
	};

	exports.default = SCNBlendMode;

/***/ },
/* 84 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _NSObject2 = __webpack_require__(2);

	var _NSObject3 = _interopRequireDefault(_NSObject2);

	var _SCNAnimatable = __webpack_require__(66);

	var _SCNAnimatable2 = _interopRequireDefault(_SCNAnimatable);

	var _SCNTechniqueSupport = __webpack_require__(85);

	var _SCNTechniqueSupport2 = _interopRequireDefault(_SCNTechniqueSupport);

	var _SCNMaterialProperty = __webpack_require__(76);

	var _SCNMaterialProperty2 = _interopRequireDefault(_SCNMaterialProperty);

	var _SCNMatrix = __webpack_require__(46);

	var _SCNMatrix2 = _interopRequireDefault(_SCNMatrix);

	var _CGSize = __webpack_require__(9);

	var _CGSize2 = _interopRequireDefault(_CGSize);

	var _SKColor = __webpack_require__(11);

	var _SKColor2 = _interopRequireDefault(_SKColor);

	var _SCNShadowMode = __webpack_require__(136);

	var _SCNShadowMode2 = _interopRequireDefault(_SCNShadowMode);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var _LightType = {
	  IES: 'ies',
	  ambient: 'ambient',
	  directional: 'directional',
	  omni: 'omni',
	  probe: 'probe',
	  spot: 'spot'
	};

	/**
	 * A light source that can be attached to a node to illuminate the scene.
	 * @access public
	 * @extends {NSObject}
	 * @implements {SCNAnimatable}
	 * @implements {SCNTechniqueSupport}
	 * @see https://developer.apple.com/reference/scenekit/scnlight
	 */

	var SCNLight = function (_NSObject) {
	  _inherits(SCNLight, _NSObject);

	  _createClass(SCNLight, null, [{
	    key: '_propTypes',
	    get: function get() {
	      return {
	        type: 'string',
	        color: 'plist',
	        temperature: 'float',
	        intensity: 'float',
	        name: 'string',
	        attenuationStartDistance: 'float',
	        attenuationEndDistance: 'float',
	        attenuationFalloffExponent: 'float',
	        spotInnerAngle: 'float',
	        spotOuterAngle: 'float',
	        gobo: ['SCNMaterialProperty', '_gobo'],
	        castsShadow: 'boolean',
	        shadowRadius: 'float',
	        shadowColor: 'plist',
	        shadowMapSize: 'CGSize',
	        shadowSampleCount: 'integer',
	        shadowMode: 'integer',
	        shadowBias: 'float',
	        orthographicScale: 'float',
	        zFar: 'float',
	        zNear: 'float',
	        lightCategoryBitMask: ['integer', 'categoryBitMask'],

	        entityID: ['string', '_entityID'],
	        version: ['float', null],
	        spotFallOffExponent: ['float', null],
	        usesDeferredShadows: ['boolean', null],
	        usesModulatedMode: ['boolean', null],
	        shouldBakeIndirectLighting: ['boolean', null],
	        shouldBakeDirectLighting: ['boolean', null],
	        baked: ['boolean', null],
	        goboProjectShadows: ['boolean', null],
	        shadowSampleCount2: ['integer', null]
	      };
	    }

	    /**
	     * constructor
	     * @access public
	     * @returns {void}
	     */

	  }]);

	  function SCNLight() {
	    _classCallCheck(this, SCNLight);

	    // Modifying a Lights Appearance

	    /**
	     * A constant identifying the general behavior of the light.
	     * @type {SCNLight.LightType}
	     * @see https://developer.apple.com/reference/scenekit/scnlight/1522919-type
	     */
	    var _this = _possibleConstructorReturn(this, (SCNLight.__proto__ || Object.getPrototypeOf(SCNLight)).call(this));

	    _this.type = _LightType.omni;

	    /**
	     * The color of the light. Animatable.
	     * @type {SKColor}
	     * @see https://developer.apple.com/reference/scenekit/scnlight/1523627-color
	     */
	    _this.color = new _SKColor2.default(1, 1, 1, 1);

	    /**
	     * The color temperature, in degrees Kelvin, of the light source. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnlight/1640545-temperature
	     */
	    _this.temperature = 6500.0;

	    /**
	     * The luminous flux, in lumens, or total brightness of the light. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnlight/1640548-intensity
	     */
	    _this.intensity = 1000.0;

	    // Managing Light Attributes

	    /**
	     * A name associated with the light.
	     * @type {?string}
	     * @see https://developer.apple.com/reference/scenekit/scnlight/1522839-name
	     */
	    _this.name = null;

	    // Managing Light Attenuation

	    /**
	     * The distance from the light at which its intensity begins to diminish. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnlight/1524223-attenuationstartdistance
	     */
	    _this.attenuationStartDistance = 0;

	    /**
	     * The distance from the light at which its intensity is completely diminished. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnlight/1524140-attenuationenddistance
	     */
	    _this.attenuationEndDistance = 0;

	    /**
	     * The transition curve for the lights intensity between its attenuation start and end distances. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnlight/1522879-attenuationfalloffexponent
	     */
	    _this.attenuationFalloffExponent = 0;

	    // Managing Spotlight Extent

	    /**
	     * The angle, in degrees, of the area fully lit by a spotlight. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnlight/1522797-spotinnerangle
	     */
	    _this.spotInnerAngle = 0;

	    /**
	     * The angle, in degrees, of the area partially lit by a spotlight. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnlight/1523382-spotouterangle
	     */
	    _this.spotOuterAngle = 45.0;

	    _this._gobo = new _SCNMaterialProperty2.default();

	    // Managing Shadows Cast by the Light

	    /**
	     * A Boolean value that determines whether the light casts shadows.
	     * @type {boolean}
	     * @see https://developer.apple.com/reference/scenekit/scnlight/1523816-castsshadow
	     */
	    _this.castsShadow = false;

	    /**
	     * A number that specifies the amount of blurring around the edges of shadows cast by the light. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnlight/1523724-shadowradius
	     */
	    _this.shadowRadius = 3.0;

	    /**
	     * The color of shadows cast by the light. Animatable.
	     * @type {SKColor}
	     * @see https://developer.apple.com/reference/scenekit/scnlight/1522864-shadowcolor
	     */
	    _this.shadowColor = new _SKColor2.default(0, 0, 0, 1);

	    /**
	     * The size of the shadow map image that SceneKit renders when creating shadows.
	     * @type {CGSize}
	     * @see https://developer.apple.com/reference/scenekit/scnlight/1524127-shadowmapsize
	     */
	    _this.shadowMapSize = new _CGSize2.default(0, 0);

	    /**
	     * The number of samples from the shadow map that SceneKit uses to render each pixel.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnlight/1523300-shadowsamplecount
	     */
	    _this.shadowSampleCount = 0;

	    /**
	     * The mode SceneKit uses to render shadows.
	     * @type {SCNShadowMode}
	     * @see https://developer.apple.com/reference/scenekit/scnlight/1522847-shadowmode
	     */
	    _this.shadowMode = null;

	    /**
	     * The amount of correction to apply to the shadow to prevent rendering artifacts.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnlight/1522849-shadowbias
	     */
	    _this.shadowBias = 1.0;

	    /**
	     * The orthographic scale SceneKit uses when rendering the shadow map for a directional light.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnlight/1523951-orthographicscale
	     */
	    _this.orthographicScale = 1.0;

	    /**
	     * The maximum distance between the light and a visible surface for casting shadows.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnlight/1522845-zfar
	     */
	    _this.zFar = 100.0;

	    /**
	     * The minimum distance between the light and a visible surface for casting shadows. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnlight/1522630-znear
	     */
	    _this.zNear = 1.0;

	    // Choosing Nodes to be Illuminated by the Light

	    /**
	     * A mask that defines which categories this light belongs to.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnlight/1523669-categorybitmask
	     */
	    _this.categoryBitMask = -1;

	    // Managing Photometric Lights

	    /**
	     * The URL for a file that contains photometry data describing the intended appearance of the light.
	     * @type {?string}
	     * @see https://developer.apple.com/reference/scenekit/scnlight/1640546-iesprofileurl
	     */
	    _this.iesProfileURL = null;

	    /**
	     * @access private
	     * @type {?string}
	     */
	    _this._entityID = null;

	    _this._context = null;
	    _this._shadowFrameBuffer = null;
	    _this._shadowDepthBuffer = null;
	    _this._shadowDepthTexture = null;
	    _this._projectionTransform = null;
	    return _this;
	  }

	  // Creating a Light

	  /**
	   * Creates a light from the specified Model I/O light object.
	   * @access public
	   * @param {MDLLight} mdlLight - A Model I/O light object.
	   * @returns {void}
	   * @desc The Model I/O framework provides universal support for import, export, description, and processing of several 3D asset file formats and related resources. (For details, see Model I/O.) The MDLLight class is a generic description of a light source in a scene, supporting a superset of the attributes described by the SCNLight class.
	   * @see https://developer.apple.com/reference/scenekit/scnlight/1419849-init
	   */


	  _createClass(SCNLight, [{
	    key: 'init',
	    value: function init(mdlLight) {}

	    // Managing Light Attributes

	    /**
	     * Returns the value of a lighting attribute.
	     * @deprecated
	     * @access public
	     * @param {string} key - A constant specifying a lighting attribute. See Lighting Attribute Keys for available keys and their possible values.
	     * @returns {?Object} - 
	     * @desc A lights type property determines its set of available attributes.You can also get the values of lighting attributes using Key-value coding. The key path for each lighting attribute is listed in Lighting Attribute Keys.
	     * @see https://developer.apple.com/reference/scenekit/scnlight/1523345-attribute
	     */

	  }, {
	    key: 'attributeForKey',
	    value: function attributeForKey(key) {
	      return null;
	    }

	    /**
	     * Sets the value for a lighting attribute.
	     * @deprecated
	     * @access public
	     * @param {?Object} attribute - The value for the lighting attribute.
	     * @param {string} key - A constant specifying a lighting attribute. See Lighting Attribute Keys for available keys and their possible values.
	     * @returns {void}
	     * @desc A lights type property determines its set of available attributes.You can also set or animate changes to the values of lighting attributes using Key-value coding. The key path for each lighting attribute is listed in Lighting Attribute Keys.
	     * @see https://developer.apple.com/reference/scenekit/scnlight/1523148-setattribute
	     */

	  }, {
	    key: 'setAttributeForKey',
	    value: function setAttributeForKey(attribute, key) {}

	    // Managing Spotlight Extent
	    /**
	     * An image or other visual content affecting the shape and color of a lights illuminated area.
	     * @type {?SCNMaterialProperty}
	     * @desc In photographic and stage lighting terminology, a gobo (also known as a flag or cookie) is a stencil, gel, or other object placed just in front of a light source, shaping or coloring the beam of light.You alter the appearance of a spotlight by changing the contents property of the object permanently assigned to this property. As with other material properties, you can use a color or image, or a Core Animation layer containing animated content, as a lighting gobo.This property applies only to lights whose type property is spot.
	     * @see https://developer.apple.com/reference/scenekit/scnlight/1523524-gobo
	     */

	  }, {
	    key: '_getDepthBufferForContext',
	    value: function _getDepthBufferForContext(context) {
	      if (this._shadowFrameBuffer && this._context === context) {
	        return this._shadowFrameBuffer;
	      }
	      this._context = context;

	      var gl = context;
	      var width = this._shadowMapWidth;
	      var height = this._shadowMapHeight;
	      this._shadowFrameBuffer = gl.createFramebuffer();
	      this._shadowDepthBuffer = gl.createRenderbuffer();
	      gl.bindFramebuffer(gl.FRAMEBUFFER, this._shadowFrameBuffer);

	      gl.bindRenderbuffer(gl.RENDERBUFFER, this._shadowDepthBuffer);
	      gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, width, height);
	      gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, this._shadowDepthBuffer);

	      this._shadowDepthTexture = gl.createTexture();
	      gl.bindTexture(gl.TEXTURE_2D, this._shadowDepthTexture);
	      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
	      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
	      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
	      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
	      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
	      gl.generateMipmap(gl.TEXTURE_2D);

	      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this._shadowDepthTexture, 0);
	      gl.drawBuffers([gl.COLOR_ATTACHMENT0]);

	      gl.bindRenderbuffer(gl.RENDERBUFFER, null);
	      gl.bindFramebuffer(gl.FRAMEBUFFER, null);

	      return this._shadowFrameBuffer;
	    }

	    /**
	     * @access private
	     * @param {CGRect} viewRect -
	     * @returns {void}
	     */

	  }, {
	    key: '_updateProjectionTransform',
	    value: function _updateProjectionTransform() {
	      var m = new _SCNMatrix2.default();
	      var left = 0;
	      var right = this._shadowMapWidth;
	      var top = 0;
	      var bottom = this._shadowMapHeight;
	      var aspect = this._shadowMapWidth / this._shadowMapHeight;

	      if (this.type === _LightType.directional) {
	        // orthographic
	        // FIXME: use orthographicScale, adjust x/y scale automatically
	        //m.m11 = 2 / (right - left)
	        m.m11 = 0.2;
	        //m.m11 = 2 / (right - left)
	        m.m12 = 0;
	        m.m13 = 0;
	        m.m14 = 0;
	        m.m21 = 0;
	        //m.m22 = 2 / (top - bottom)
	        m.m22 = 0.2;
	        m.m23 = 0;
	        m.m24 = 0;
	        m.m31 = 0;
	        m.m32 = 0;
	        m.m33 = -2 / (this.zFar - this.zNear);
	        //m.m33 = -1 / (this.zFar - this.zNear)
	        m.m34 = 0;
	        m.m41 = 0;
	        m.m42 = 0;
	        m.m43 = -(this.zFar + this.zNear) / (this.zFar - this.zNear);
	        //m.m43 = -this.zFar / (this.zFar - this.zNear)
	        m.m44 = 1;
	      } else {
	        // perspective
	        var m11 = 1;
	        var m22 = 1;
	        if (this.yFov <= 0 && this.xFov <= 0) {
	          var cot = 1.0 / Math.tan(Math.PI / 6.0);
	          m11 = cot / aspect;
	          m22 = cot;
	        } else if (this.yFov <= 0) {
	          var _cot = 1.0 / Math.tan(this.xFov * Math.PI / 360.0);
	          m11 = _cot;
	          m22 = _cot * aspect;
	        } else if (this.xFov <= 0) {
	          var _cot2 = 1.0 / Math.tan(this.yFov * Math.PI / 360.0);
	          m11 = _cot2 / aspect;
	          m22 = _cot2;
	        } else {
	          // FIXME: compare xFov to yFov
	          var _cot3 = 1.0 / Math.tan(this.yFov * Math.PI / 360.0);
	          m11 = _cot3 / aspect;
	          m22 = _cot3;
	        }

	        m.m11 = m11;
	        m.m12 = 0;
	        m.m13 = 0;
	        m.m14 = 0;
	        m.m21 = 0;
	        m.m22 = m22;
	        m.m23 = 0;
	        m.m24 = 0;
	        m.m31 = 0;
	        m.m32 = 0;
	        m.m33 = -(this.zFar + this.zNear) / (this.zFar - this.zNear);
	        m.m34 = -1;
	        m.m41 = 0;
	        m.m42 = 0;
	        m.m43 = -2 * this.zFar * this.zNear / (this.zFar - this.zNear);
	        m.m44 = 0;
	      }
	      this._projectionTransform = m;
	    }
	  }, {
	    key: 'gobo',
	    get: function get() {
	      return this._gobo;
	    }

	    // Structures
	    /**
	     * @type {Object} LightType
	     * @property {string} IES A light source whose shape, direction, and intensity of illumination is determined by a photometric profile.
	     * @property {string} ambient A light that illuminates all objects in the scene from all directions.
	     * @property {string} directional A light source with a uniform direction and constant intensity.
	     * @property {string} omni An omnidirectional light, also known as a point light. 
	     * @property {string} probe A sample of the environment around a point in a scene to be used in environment-based lighting.
	     * @property {string} spot A light source that illuminates a cone-shaped area.
	     * @see https://developer.apple.com/reference/scenekit/scnlight.lighttype
	     */

	  }, {
	    key: '_shadowMapWidth',
	    get: function get() {
	      if (this.shadowMapSize.width > 0) {
	        return this.shadowMapSize.width;
	      }
	      // FIXME: adjust shadowMapSize
	      return 2048;
	    }
	  }, {
	    key: '_shadowMapHeight',
	    get: function get() {
	      if (this.shadowMapSize.height > 0) {
	        return this.shadowMapSize.height;
	      }
	      // FIXME: adjust shadowMapSize
	      return 2048;
	    }
	  }], [{
	    key: 'LightType',
	    get: function get() {
	      return _LightType;
	    }
	  }]);

	  return SCNLight;
	}(_NSObject3.default);

	exports.default = SCNLight;

/***/ },
/* 85 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _SCNTechnique = __webpack_require__(86);

	var _SCNTechnique2 = _interopRequireDefault(_SCNTechnique);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	/**
	 * The common interface for SceneKit objects that support multipass rendering using SCNTechnique objects.
	 * @interface
	 * @see https://developer.apple.com/reference/scenekit/scntechniquesupport
	 */
	var SCNTechniqueSupport = function () {
	  function SCNTechniqueSupport() {
	    _classCallCheck(this, SCNTechniqueSupport);
	  }

	  _createClass(SCNTechniqueSupport, [{
	    key: 'init',


	    /**
	     * constructor
	     * @access public
	     * @returns {void}
	     */
	    value: function init() {

	      // Specifying a Technique

	      /**
	       * Required. The technique SceneKit uses when rendering the object.
	       * @type {?SCNTechnique}
	       * @see https://developer.apple.com/reference/scenekit/scntechniquesupport/1520496-technique
	       */
	      this.technique = null;
	    }
	  }]);

	  return SCNTechniqueSupport;
	}();

	exports.default = SCNTechniqueSupport;

/***/ },
/* 86 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _NSObject2 = __webpack_require__(2);

	var _NSObject3 = _interopRequireDefault(_NSObject2);

	var _SCNAnimatable = __webpack_require__(66);

	var _SCNAnimatable2 = _interopRequireDefault(_SCNAnimatable);

	var _SCNBindingBlock = __webpack_require__(87);

	var _SCNBindingBlock2 = _interopRequireDefault(_SCNBindingBlock);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * A specification for augmenting or postprocessing SceneKit's rendering of a scene using additional drawing passes with custom Metal or OpenGL shaders.
	 * @access public
	 * @extends {NSObject}
	 * @implements {SCNAnimatable}
	 * @see https://developer.apple.com/reference/scenekit/scntechnique
	 */
	var SCNTechnique = function (_NSObject) {
	  _inherits(SCNTechnique, _NSObject);

	  function SCNTechnique() {
	    _classCallCheck(this, SCNTechnique);

	    return _possibleConstructorReturn(this, (SCNTechnique.__proto__ || Object.getPrototypeOf(SCNTechnique)).apply(this, arguments));
	  }

	  _createClass(SCNTechnique, [{
	    key: 'init',


	    // Creating a Technique

	    /**
	     * Creates a technique from a technique definition dictionary.,
	     * @access public
	     * @param {Map<string, Object>} dictionary - A dictionary defining the series of rendering passes that comprise the technique.
	     * @returns {void}
	     * @desc See the class overview for details of a technique definition dictionary.
	     * @see https://developer.apple.com/reference/scenekit/scntechnique/1520494-init
	     */
	    value: function init(dictionary) {

	      // Retrieving a Techniques Definition

	      this._dictionaryRepresentation = null;
	    }

	    // Combining Techniques

	    /**
	     * Creates a new rendering technique that combines a series of techniques.
	     * @access public
	     * @param {SCNTechnique[]} techniques - An array of SCNTechnique objects.
	     * @returns {void}
	     * @desc The new technique applies the effects of the techniques in the order specified in the techniques array. Each output of a technique in the array becomes an input to the next technique in the array.
	     * @see https://developer.apple.com/reference/scenekit/scntechnique/1520497-init
	     */

	  }, {
	    key: 'initBySequencingTechniques',
	    value: function initBySequencingTechniques(techniques) {

	      // Retrieving a Techniques Definition

	      this._dictionaryRepresentation = null;
	    }

	    // Retrieving a Techniques Definition
	    /**
	     * The dictionary defining the rendering technique.
	     * @type {Map<string, Object>}
	     * @desc Read this property when you want to save a property list file containing the definition of a technique.See the class overview for details of a technique definition dictionary.
	     * @see https://developer.apple.com/reference/scenekit/scntechnique/1520492-dictionaryrepresentation
	     */

	  }, {
	    key: 'handleBindingOfSymbolUsing',


	    // Handling Parameters for a Techniques Shader Programs

	    /**
	     * Specifies a block to be called before rendering using programs with the specified GLSL uniform variable or attribute name.
	     * @access public
	     * @param {string} symbol - A GLSL uniform variable or attribute name used in one of the techniques shader programs.
	     * @param {?SCNBindingBlock} [block = null] - A block that SceneKit calls.
	     * @returns {void}
	     * @desc This method associates a block for handling setup of an attribute or uniform variable in the shader programs associated with the technique. SceneKit calls your block before any performing any rendering passes that use that symbol. In the block, you can execute any OpenGL commands or other code necessary for preparing your custom shader.NoteYou must associate a handler block with a technique before assigning that technique to a SceneKit object. The result of calling this method on a technique currently in use is undefined.Use this method when you need to update a value in a shader program every time SceneKit renders a frame. To set a value infrequently, or only once, use the setObject(_:forKeyedSubscript:) or setValue(_:forKey:) method instead.If you associate a block with a symbol using this method, SceneKit ignores values set using the setObject(_:forKeyedSubscript:) method.
	     * @see https://developer.apple.com/reference/scenekit/scntechnique/1520490-handlebinding
	     */
	    value: function handleBindingOfSymbolUsing(symbol) {
	      var block = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
	    }

	    /**
	     * Sets a value for the specified shader  variable or attribute name, using subscript syntax.
	     * @access public
	     * @param {?Object} obj - An object containing a new value for the shader symbol.
	     * @param {NSCopying} key - A shader variable or attribute name used in one of the techniques shader programs.
	     * @returns {void}
	     * @desc The value parameter should be an object appropriate to the type of the shader symbol being set. For example, use an NSNumber object to set the value of a float uniform variable, or use an NSValue object containing an SCNVector3 structure to set the value of a GLSL vec3 uniform variable or a Metal float3 variable.Use this method when you need to set a value infrequently or only once. To update a shader value every time SceneKit renders a frame, use the handleBinding(ofSymbol:using:) method instead.If you use the handleBinding(ofSymbol:using:) method to associate a handler block for a symbol, SceneKit ignores values set for the symbol using the setObject(_:forKeyedSubscript:) method.
	     * @see https://developer.apple.com/reference/scenekit/scntechnique/1520495-setobject
	     */

	  }, {
	    key: 'setObjectForKeyedSubscript',
	    value: function setObjectForKeyedSubscript(obj, key) {}
	  }, {
	    key: 'dictionaryRepresentation',
	    get: function get() {
	      return this._dictionaryRepresentation;
	    }
	  }]);

	  return SCNTechnique;
	}(_NSObject3.default);

	exports.default = SCNTechnique;

/***/ },
/* 87 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _SCNNode = __webpack_require__(65);

	var _SCNNode2 = _interopRequireDefault(_SCNNode);

	var _SCNRenderer = __webpack_require__(88);

	var _SCNRenderer2 = _interopRequireDefault(_SCNRenderer);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * The signature for a block called for binding or unbinding a GLSL symbol in a custom program.
	 * @type {function(programID: number, location: number, renderedNode: ?SCNNode, renderer: SCNRenderer): void}
	 * @param {number} programID - The OpenGL program identifier for the current SCNProgram instance, as used by OpenGL functions such as glValidateProgram.
	 * @param {number} location - The OpenGL location index for the symbol to be bound or unbound, as used by OpenGL functions such as glUniform.
	 * @param {?SCNNode} renderedNode - The SCNNode object being rendered.
	 * @param {SCNRenderer} renderer - The SCNRenderer object responsible for rendering.
	 * @returns {void}
	 * @desc Call handleBinding(ofSymbol:handler:) or handleUnbinding(ofSymbol:handler:) to associate a handler block with a GLSL symbol for a SceneKit geometry or material.
	 * @see https://developer.apple.com/reference/scenekit/scnbindingblock
	 */
	var SCNBindingBlock = function SCNBindingBlock(programID, location, renderedNode, renderer) {};

	exports.default = SCNBindingBlock;

/***/ },
/* 88 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _CGPoint = __webpack_require__(7);

	var _CGPoint2 = _interopRequireDefault(_CGPoint);

	var _CGRect = __webpack_require__(8);

	var _CGRect2 = _interopRequireDefault(_CGRect);

	var _CGSize = __webpack_require__(9);

	var _CGSize2 = _interopRequireDefault(_CGSize);

	var _NSObject2 = __webpack_require__(2);

	var _NSObject3 = _interopRequireDefault(_NSObject2);

	var _SCNSceneRenderer = __webpack_require__(89);

	var _SCNSceneRenderer2 = _interopRequireDefault(_SCNSceneRenderer);

	var _SCNTechniqueSupport = __webpack_require__(85);

	var _SCNTechniqueSupport2 = _interopRequireDefault(_SCNTechniqueSupport);

	var _SCNScene = __webpack_require__(90);

	var _SCNScene2 = _interopRequireDefault(_SCNScene);

	var _SCNAntialiasingMode = __webpack_require__(124);

	var _SCNAntialiasingMode2 = _interopRequireDefault(_SCNAntialiasingMode);

	var _SCNMatrix = __webpack_require__(46);

	var _SCNMatrix2 = _interopRequireDefault(_SCNMatrix);

	var _SCNMatrix4MakeTranslation = __webpack_require__(78);

	var _SCNMatrix4MakeTranslation2 = _interopRequireDefault(_SCNMatrix4MakeTranslation);

	var _SCNNode = __webpack_require__(65);

	var _SCNNode2 = _interopRequireDefault(_SCNNode);

	var _SCNProgram = __webpack_require__(125);

	var _SCNProgram2 = _interopRequireDefault(_SCNProgram);

	var _SCNPhysicsWorld = __webpack_require__(99);

	var _SCNPhysicsWorld2 = _interopRequireDefault(_SCNPhysicsWorld);

	var _SCNCamera = __webpack_require__(130);

	var _SCNCamera2 = _interopRequireDefault(_SCNCamera);

	var _SCNLight = __webpack_require__(84);

	var _SCNLight2 = _interopRequireDefault(_SCNLight);

	var _SCNVector = __webpack_require__(44);

	var _SCNVector2 = _interopRequireDefault(_SCNVector);

	var _SCNVector3 = __webpack_require__(45);

	var _SCNVector4 = _interopRequireDefault(_SCNVector3);

	var _SCNGeometryPrimitiveType = __webpack_require__(73);

	var _SCNGeometryPrimitiveType2 = _interopRequireDefault(_SCNGeometryPrimitiveType);

	var _SCNGeometrySource = __webpack_require__(71);

	var _SCNGeometrySource2 = _interopRequireDefault(_SCNGeometrySource);

	var _SCNHitTestOption = __webpack_require__(122);

	var _SCNHitTestOption2 = _interopRequireDefault(_SCNHitTestOption);

	var _SCNHitTestResult = __webpack_require__(106);

	var _SCNHitTestResult2 = _interopRequireDefault(_SCNHitTestResult);

	var _SKColor = __webpack_require__(11);

	var _SKColor2 = _interopRequireDefault(_SKColor);

	var _SKSpriteNode = __webpack_require__(131);

	var _SKSpriteNode2 = _interopRequireDefault(_SKSpriteNode);

	var _SKTexture = __webpack_require__(134);

	var _SKTexture2 = _interopRequireDefault(_SKTexture);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * @access private
	 * @type {string}
	 */
	var _defaultVertexShader = '#version 300 es\n  precision mediump float;\n\n  #define NUM_AMBIENT_LIGHTS __NUM_AMBIENT_LIGHTS__\n  #define NUM_DIRECTIONAL_LIGHTS __NUM_DIRECTIONAL_LIGHTS__\n  #define NUM_DIRECTIONAL_SHADOW_LIGHTS __NUM_DIRECTIONAL_SHADOW_LIGHTS__\n  #define NUM_OMNI_LIGHTS __NUM_OMNI_LIGHTS__\n  #define NUM_SPOT_LIGHTS __NUM_SPOT_LIGHTS__\n  #define NUM_IES_LIGHTS __NUM_IES_LIGHTS__\n  #define NUM_PROBE_LIGHTS __NUM_PROBE_LIGHTS__\n  #define USE_SHADER_MODIFIER_GEOMETRY __USE_SHADER_MODIFIER_GEOMETRY__\n\n  layout (std140) uniform cameraUniform {\n    vec4 position;\n    mat4 viewTransform;\n    mat4 viewProjectionTransform;\n  } camera;\n\n  layout (std140) uniform materialUniform {\n    vec4 ambient;\n    vec4 diffuse;\n    vec4 specular;\n    vec4 emission;\n    float shininess;\n    float fresnelExponent;\n  } material;\n\n  struct AmbientLight {\n    vec4 color;\n  };\n\n  struct DirectionalLight {\n    vec4 color;\n    vec4 direction; // should use vec4; vec3 might cause problem for the layout\n  };\n\n  struct DirectionalShadowLight {\n    vec4 color;\n    vec4 direction; // should use vec4; vec3 might cause problem for the layout\n    vec4 shadowColor;\n    mat4 viewProjectionTransform;\n    mat4 shadowProjectionTransform;\n  };\n\n  struct OmniLight {\n    vec4 color;\n    vec4 position; // should use vec4; vec3 might cause problem for the layout\n  };\n\n  struct SpotLight {\n    // TODO: implement\n    vec4 color;\n  };\n\n  struct IESLight {\n    // TODO: implement\n    vec4 color;\n  };\n\n  struct ProbeLight {\n    // TODO: implement\n    vec4 color;\n  };\n\n  layout (std140) uniform lightUniform {\n    __LIGHT_DEFINITION__\n  } light;\n  __VS_LIGHT_VARS__\n\n  layout (std140) uniform fogUniform {\n    vec4 color;\n    float startDistance;\n    float endDistance;\n    float densityExponent;\n  } fog;\n\n  #define kSCNTexcoordCount 2\n  struct SCNShaderGeometry {\n    vec3 position;\n    vec3 normal;\n    vec4 tangent;\n    vec4 color;\n    vec2 texcoords[kSCNTexcoordCount];\n  };\n\n  uniform float u_time;\n  //uniform mat3x4[255] skinningJoints;\n  uniform vec4[765] skinningJoints;\n  uniform int numSkinningJoints;\n\n  in vec3 position;\n  in vec3 normal;\n  in vec3 tangent;\n  in vec4 color;\n  in vec2 texcoord0;\n  in vec2 texcoord1;\n  in vec4 boneIndices;\n  in vec4 boneWeights;\n\n  out vec3 v_position;\n  out vec3 v_normal;\n  out vec3 v_tangent;\n  out vec3 v_bitangent;\n  out vec2 v_texcoord0;\n  out vec2 v_texcoord1;\n  out vec4 v_color;\n  out vec3 v_eye;\n  out float v_fogFactor;\n\n  #if USE_SHADER_MODIFIER_GEOMETRY\n  void shaderModifierGeometry(inout SCNShaderGeometry _geometry) {\n    __SHADER_MODIFIER_GEOMETRY__\n  }\n  #endif\n\n  void main() {\n    SCNShaderGeometry _geometry;\n    _geometry.position = position;\n    _geometry.normal = normal;\n    _geometry.tangent = vec4(tangent, 1.0);\n    _geometry.color = color;\n    _geometry.texcoords[0] = texcoord0;\n    _geometry.texcoords[1] = texcoord1;\n    \n    #if USE_SHADER_MODIFIER_GEOMETRY\n      shaderModifierGeometry(_geometry);\n    #endif\n\n    vec3 pos = vec3(0, 0, 0);\n    vec3 nom = vec3(0, 0, 0);\n    vec3 tng = vec3(0, 0, 0);\n    vec4 col = _geometry.color;\n\n    if(numSkinningJoints > 0){\n      for(int i=0; i<numSkinningJoints; i++){\n        float weight = boneWeights[i];\n        if(int(boneIndices[i]) < 0){\n          continue;\n        }\n        int idx = int(boneIndices[i]) * 3;\n        mat4 jointMatrix = transpose(mat4(skinningJoints[idx],\n                                          skinningJoints[idx+1],\n                                          skinningJoints[idx+2],\n                                          vec4(0, 0, 0, 1)));\n        pos += (jointMatrix * vec4(_geometry.position, 1.0)).xyz * weight;\n        nom += (mat3(jointMatrix) * _geometry.normal) * weight;\n        tng += (mat3(jointMatrix) * _geometry.tangent.xyz) * weight;\n      }\n    }else{\n      mat4 jointMatrix = transpose(mat4(skinningJoints[0],\n                                        skinningJoints[1],\n                                        skinningJoints[2],\n                                        vec4(0, 0, 0, 1)));\n      pos = (jointMatrix * vec4(_geometry.position, 1.0)).xyz;\n      nom = mat3(jointMatrix) * _geometry.normal;\n      tng = mat3(jointMatrix) * _geometry.tangent.xyz;\n    }\n    v_position = pos;\n    v_normal = normalize(nom);\n    v_tangent = normalize(tng);\n    v_bitangent = cross(v_tangent, v_normal);\n\n    vec3 viewVec = camera.position.xyz - pos;\n    v_eye = viewVec;\n\n    v_color = material.emission;\n    int numLights = 0;\n\n    __VS_LIGHTING__\n\n    float distance = length(viewVec);\n    v_fogFactor = clamp((distance - fog.startDistance) / (fog.endDistance - fog.startDistance), 0.0, 1.0);\n\n    v_texcoord0 = _geometry.texcoords[0];\n    v_texcoord1 = _geometry.texcoords[1];\n    gl_Position = camera.viewProjectionTransform * vec4(pos, 1.0);\n  }\n';

	var _vsAmbient = '\n  for(int i=0; i<NUM_AMBIENT_LIGHTS; i++){\n    v_color += light.ambient[i].color * material.ambient;\n  }\n';

	var _vsDirectional = '\n  for(int i=0; i<NUM_DIRECTIONAL_LIGHTS; i++){\n    v_light[numLights + i] = -light.directional[i].direction.xyz;\n  }\n  numLights += NUM_DIRECTIONAL_LIGHTS;\n';

	var _vsDirectionalShadow = '\n  for(int i=0; i<NUM_DIRECTIONAL_SHADOW_LIGHTS; i++){\n    v_light[numLights + i] = -light.directionalShadow[i].direction.xyz;\n    v_directionalShadowDepth[i] = light.directionalShadow[i].viewProjectionTransform * vec4(pos, 1.0);\n    v_directionalShadowTexcoord[i] = light.directionalShadow[i].shadowProjectionTransform * vec4(pos, 1.0);\n  }\n  numLights += NUM_DIRECTIONAL_SHADOW_LIGHTS;\n';

	var _vsOmni = '\n  for(int i=0; i<NUM_OMNI_LIGHTS; i++){\n    v_light[numLights + i] = light.omni[i].position.xyz - pos;\n  }\n  numLights += NUM_OMNI_LIGHTS;\n';

	var _vsSpot = '\n  for(int i=0; i<NUM_SPOT_LIGHTS; i++){\n    v_light[numLights + i] = light.spot[i].position.xyz - pos;\n  }\n  numLights += NUM_SPOT_LIGHTS;\n';

	var _vsIES = '';
	var _vsProbe = '';

	var _cameraLoc = 0;
	var _materialLoc = 1;
	var _lightLoc = 2;
	var _fogLoc = 3;

	/**
	 * @access private
	 * @type {string}
	 */
	var _defaultFragmentShader = '#version 300 es\n  precision mediump float;\n  precision highp sampler2DShadow;\n\n  uniform bool[8] textureFlags;\n  #define TEXTURE_EMISSION_INDEX 0\n  #define TEXTURE_AMBIENT_INDEX 1\n  #define TEXTURE_DIFFUSE_INDEX 2\n  #define TEXTURE_SPECULAR_INDEX 3\n  #define TEXTURE_REFLECTIVE_INDEX 4\n  #define TEXTURE_TRANSPARENT_INDEX 5\n  #define TEXTURE_MULTIPLY_INDEX 6\n  #define TEXTURE_NORMAL_INDEX 7\n\n  uniform bool selfIllumination;\n\n  uniform sampler2D u_emissionTexture;\n  uniform sampler2D u_ambientTexture;\n  uniform sampler2D u_diffuseTexture;\n  uniform sampler2D u_specularTexture;\n  uniform samplerCube u_reflectiveTexture;\n  uniform sampler2D u_transparentTexture;\n  uniform sampler2D u_multiplyTexture;\n  uniform sampler2D u_normalTexture;\n\n  #define NUM_AMBIENT_LIGHTS __NUM_AMBIENT_LIGHTS__\n  #define NUM_DIRECTIONAL_LIGHTS __NUM_DIRECTIONAL_LIGHTS__\n  #define NUM_DIRECTIONAL_SHADOW_LIGHTS __NUM_DIRECTIONAL_SHADOW_LIGHTS__\n  #define NUM_OMNI_LIGHTS __NUM_OMNI_LIGHTS__\n  #define NUM_SPOT_LIGHTS __NUM_SPOT_LIGHTS__\n  #define NUM_IES_LIGHTS __NUM_IES_LIGHTS__\n  #define NUM_PROBE_LIGHTS __NUM_PROBE_LIGHTS__\n  #define USE_SHADER_MODIFIER_SURFACE __USE_SHADER_MODIFIER_SURFACE__\n  #define USE_SHADER_MODIFIER_FRAGMENT __USE_SHADER_MODIFIER_FRAGMENT__\n\n  layout (std140) uniform materialUniform {\n    vec4 ambient;\n    vec4 diffuse;\n    vec4 specular;\n    vec4 emission;\n    float shininess;\n    float fresnelExponent;\n  } material;\n\n  struct AmbientLight {\n    vec4 color;\n  };\n\n  struct DirectionalLight {\n    vec4 color;\n    vec4 direction; // should use vec4; vec3 might cause problem for the layout\n  };\n\n  struct DirectionalShadowLight {\n    vec4 color;\n    vec4 direction; // should use vec4; vec3 might cause problem for the layout\n    vec4 shadowColor;\n    mat4 viewProjectionTransform;\n    mat4 shadowProjectionTransform;\n  };\n\n  struct OmniLight {\n    vec4 color;\n    vec4 position; // should use vec4; vec3 might cause problem for the layout\n  };\n\n  struct ProbeLight {\n    // TODO: implement\n    vec4 color;\n  };\n\n  struct SpotLight {\n    // TODO: implement\n    vec4 color;\n  };\n\n  layout (std140) uniform lightUniform {\n    __LIGHT_DEFINITION__\n  } light;\n  __FS_LIGHT_VARS__\n\n  layout (std140) uniform fogUniform {\n    vec4 color;\n    float startDistance;\n    float endDistance;\n    float densityExponent;\n  } fog;\n\n  struct SCNShaderSurface {\n    vec3 view;\n    vec3 position;\n    vec3 normal;\n    vec3 tangent;\n    vec3 bitangent;\n    vec4 ambient;\n    vec2 ambientTexcoord;\n    vec4 diffuse;\n    vec2 diffuseTexcoord;\n    vec4 specular;\n    vec2 specularTexcoord;\n    vec4 emission;\n    vec2 emissionTexcoord;\n    vec4 multiply;\n    vec2 multiplyTexcoord;\n    vec4 transparent;\n    vec2 transparentTexcoord;\n    vec4 reflective;\n    float shininess;\n    float fresnel;\n  } _surface;\n\n  struct SCNShaderOutput {\n    vec4 color;\n  } _output;\n\n  in vec3 v_position;\n  in vec3 v_normal;\n  in vec2 v_texcoord0;\n  in vec2 v_texcoord1;\n  in vec4 v_color;\n  in vec3 v_eye;\n  in vec3 v_tangent;\n  in vec3 v_bitangent;\n  in float v_fogFactor;\n\n  out vec4 outColor;\n\n  #if USE_SHADER_MODIFIER_SURFACE\n  void shaderModifierSurface() {\n    __SHADER_MODIFIER_SURFACE__\n  }\n  #endif\n\n  #if USE_SHADER_MODIFIER_FRAGMENT\n  void shaderModifierFragment() {\n    __SHADER_MODIFIER_FRAGMENT__\n  }\n  #endif\n\n  float convDepth(vec4 color) {\n    const float rMask = 1.0;\n    const float gMask = 1.0 / 255.0;\n    const float bMask = 1.0 / (255.0 * 255.0);\n    const float aMask = 1.0 / (255.0 * 255.0 * 255.0);\n    float depth = dot(color, vec4(rMask, gMask, bMask, aMask));\n    return depth * 2.0 - 1.0;\n  }\n\n  void main() {\n    _output.color = v_color;\n\n    //vec3 viewVec = normalize(v_eye);\n    //vec3 nom = normalize(v_normal);\n    _surface.view = normalize(v_eye);\n    _surface.position = v_position;\n    _surface.normal = normalize(v_normal);\n    _surface.tangent = normalize(v_tangent);\n    _surface.bitangent = normalize(v_bitangent);\n\n    // normal texture\n    if(textureFlags[TEXTURE_NORMAL_INDEX]){\n      mat3 tsInv = mat3(_surface.tangent, _surface.bitangent, _surface.normal);\n      vec3 color = normalize(texture(u_normalTexture, v_texcoord0).rgb * 2.0 - 1.0); // FIXME: check mappingChannel to decide which texture you use.\n      _surface.normal = normalize(tsInv * color);\n    }\n\n    #if USE_SHADER_MODIFIER_SURFACE\n      shaderModifierSurface();\n    #endif\n\n    // emission texture\n    if(textureFlags[TEXTURE_EMISSION_INDEX]){\n      if(selfIllumination){\n        vec4 color = texture(u_emissionTexture, v_texcoord1); // FIXME: check mappingChannel to decide which texture you use.\n        _output.color += color;\n      }else{\n        vec4 color = texture(u_emissionTexture, v_texcoord0);\n        _output.color = color * _output.color;\n      }\n    }\n\n    int numLights = 0;\n\n    vec4 specularColor;\n    if(textureFlags[TEXTURE_SPECULAR_INDEX]){\n      vec4 color = texture(u_specularTexture, v_texcoord0);\n      specularColor = color;\n    }else{\n      specularColor = material.specular;\n    }\n      \n    _output.color.a = material.diffuse.a;\n    __FS_LIGHTING__\n    \n    // diffuse texture\n    if(textureFlags[TEXTURE_DIFFUSE_INDEX]){\n      vec4 color = texture(u_diffuseTexture, v_texcoord0);\n      _output.color = color * _output.color;\n    }\n\n    // fresnel reflection\n    if(textureFlags[TEXTURE_REFLECTIVE_INDEX]){\n      vec3 r = reflect(_surface.view, _surface.normal);\n      //float f0 = 0.0; // TODO: calculate f0\n      //float fresnel = f0 + (1.0 - f0) * pow(1.0 - clamp(dot(viewVec, nom), 0.0, 1.0), material.fresnelExponent);\n      float fresnel = 0.4 * pow(1.0 - clamp(dot(_surface.view, _surface.normal), 0.0, 1.0), material.fresnelExponent);\n      _output.color += texture(u_reflectiveTexture, r) * fresnel;\n    }\n\n    float fogFactor = pow(v_fogFactor, fog.densityExponent);\n    _output.color = mix(_output.color, fog.color, fogFactor);\n\n    // DEBUG\n    //if(textureFlags[TEXTURE_NORMAL_INDEX]){\n    //  mat3 tsInv = mat3(normalize(v_tangent), normalize(v_bitangent), nom);\n    //  vec3 color = normalize(texture(u_normalTexture, v_texcoord0).rgb * 2.0 - 1.0); // FIXME: check mappingChannel to decide which texture you use.\n    //  outColor.rgb = (normalize(tsInv * color) + 1.0) * 0.5;\n    //}\n\n    #if USE_SHADER_MODIFIER_FRAGMENT\n      shaderModifierFragment();\n    #endif\n\n    outColor = _output.color;\n  }\n';

	var _fsAmbient = '\n';

	var _fsDirectional = '\n  for(int i=0; i<NUM_DIRECTIONAL_LIGHTS; i++){\n    // diffuse\n    vec3 lightVec = normalize(v_light[numLights + i]);\n    float diffuse = clamp(dot(lightVec, _surface.normal), 0.0f, 1.0f);\n    _output.color.rgb += light.directional[i].color.rgb * material.diffuse.rgb * diffuse;\n\n    // specular\n    if(diffuse > 0.0f){\n      vec3 halfVec = normalize(lightVec + _surface.view);\n      float specular = pow(dot(halfVec, _surface.normal), material.shininess);\n      //outColor.rgb += material.specular.rgb * specular;\n      _output.color.rgb += specularColor.rgb * specular;\n    }\n  }\n  numLights += NUM_DIRECTIONAL_LIGHTS;\n';

	var _fsDirectionalShadow = '\n  float shadow = convDepth(texture(u_shadowMapTexture__I__, v_directionalShadowTexcoord[__I__].xy / v_directionalShadowTexcoord[__I__].w));\n  if(v_directionalShadowDepth[__I__].z / v_directionalShadowDepth[__I__].w - 0.0001 > shadow){\n    _output.color.rgb += material.diffuse.rgb * light.directionalShadow[__I__].shadowColor.rgb;\n  }else{\n    // diffuse\n    vec3 lightVec = normalize(v_light[numLights]);\n    float diffuse = clamp(dot(lightVec, _surface.normal), 0.0f, 1.0f);\n    _output.color.rgb += light.directionalShadow[__I__].color.rgb * material.diffuse.rgb * diffuse;\n\n    // specular\n    if(diffuse > 0.0f){\n      vec3 halfVec = normalize(lightVec + _surface.view);\n      float specular = pow(dot(halfVec, _surface.normal), material.shininess);\n      //outColor.rgb += material.specular.rgb * specular;\n      _output.color.rgb += specularColor.rgb * specular;\n    }\n  }\n\n  numLights += 1;\n';

	var _fsOmni = '\n  for(int i=0; i<NUM_OMNI_LIGHTS; i++){\n    // diffuse\n    vec3 lightVec = normalize(v_light[numLights + i]);\n    float diffuse = clamp(dot(lightVec, _surface.normal), 0.0f, 1.0f);\n    _output.color.rgb += light.omni[i].color.rgb * material.diffuse.rgb * diffuse;\n\n    // specular\n    if(diffuse > 0.0f){\n      vec3 halfVec = normalize(lightVec + _surface.view);\n      float specular = pow(dot(halfVec, _surface.normal), material.shininess);\n      //outColor.rgb += material.specular.rgb * specular; // TODO: get the light color of specular\n      _output.color.rgb += specularColor.rgb * specular;\n    }\n  }\n  numLights += NUM_OMNI_LIGHTS;\n';

	var _fsSpot = '\n  // TODO: implement\n';

	var _fsIES = '';
	var _fsProbe = '';

	var _defaultCameraDistance = 15;

	/**
	 * @access private
	 * @type {string}
	 */
	var _defaultParticleVertexShader = '#version 300 es\n  precision mediump float;\n\n  uniform mat4 modelTransform;\n  uniform mat4 viewTransform;\n  uniform mat4 projectionTransform;\n  uniform int orientationMode;\n  uniform float stretchFactor;\n\n  in vec3 position;\n  in vec3 velocity;\n  in vec4 rotation;\n  in vec4 color;\n  in float size;\n  //in float life;\n  in vec2 corner;\n\n  out vec2 v_texcoord;\n  out vec4 v_color;\n\n  void main() {\n    vec4 pos = viewTransform * vec4(position, 1.0);\n    vec3 d;\n\n    if(stretchFactor > 0.0){\n      vec4 v = viewTransform * vec4(velocity, 0.0) * stretchFactor;\n      if(corner.y > 0.0){\n        pos.xyz += v.xyz;\n      }\n      vec2 cy = normalize(v.xy);\n      vec2 cx = vec2(-cy.y, cy.x);\n      d = vec3(cx * corner.x + cy * corner.y, 0) * size;\n    }else{\n      float sinAngle = sin(rotation.w);\n      float cosAngle = cos(rotation.w);\n      float tcos = 1.0 - cosAngle;\n\n      d = vec3(\n          corner.x * (rotation.x * rotation.x * tcos + cosAngle)\n        + corner.y * (rotation.x * rotation.y * tcos - rotation.z * sinAngle),\n          corner.x * (rotation.y * rotation.x * tcos + rotation.z * sinAngle)\n        + corner.y * (rotation.y * rotation.y * tcos + cosAngle),\n          corner.x * (rotation.z * rotation.x * tcos - rotation.y * sinAngle)\n        + corner.y * (rotation.z * rotation.y * tcos + rotation.x * sinAngle)) * size * 0.5;\n      if(orientationMode == 2){\n        // orientation: free\n        d = mat3(viewTransform) * mat3(modelTransform) * d;\n      }\n    }\n    pos.xyz += d;\n\n    v_color = color;\n    v_texcoord = corner * vec2(0.5, -0.5) + 0.5;\n    gl_Position = projectionTransform * pos;\n  }\n';

	/**
	 * @access private
	 * @type {string}
	 */
	var _defaultParticleFragmentShader = '#version 300 es\n  precision mediump float;\n\n  uniform sampler2D particleTexture;\n\n  in vec2 v_texcoord;\n  in vec4 v_color;\n\n  out vec4 outColor;\n\n  void main() {\n    vec4 texColor = texture(particleTexture, v_texcoord);\n    texColor.rgb *= texColor.a;\n    outColor = v_color * texColor;\n  }\n';

	/**
	 * @access private
	 * @type {string}
	 */
	var _defaultHitTestVertexShader = '#version 300 es\n  precision mediump float;\n\n  uniform mat4 viewProjectionTransform;\n  uniform vec4[765] skinningJoints;\n  uniform int numSkinningJoints;\n\n  in vec3 position;\n  in vec3 normal;\n  in vec4 boneIndices;\n  in vec4 boneWeights;\n  \n  out vec3 v_normal;\n  out vec3 v_position;\n\n  void main() {\n    vec3 pos = vec3(0, 0, 0);\n    vec3 nom = vec3(0, 0, 0);\n    if(numSkinningJoints > 0){\n      for(int i=0; i<numSkinningJoints; i++){\n        float weight = boneWeights[i];\n        if(int(boneIndices[i]) < 0){\n          continue;\n        }\n        int idx = int(boneIndices[i]) * 3;\n        mat4 jointMatrix = transpose(mat4(skinningJoints[idx],\n                                          skinningJoints[idx+1],\n                                          skinningJoints[idx+2],\n                                          vec4(0, 0, 0, 1)));\n        pos += (jointMatrix * vec4(position, 1.0)).xyz * weight;\n        nom += (mat3(jointMatrix) * normal) * weight;\n      }\n    }else{\n      mat4 jointMatrix = transpose(mat4(skinningJoints[0],\n                                        skinningJoints[1],\n                                        skinningJoints[2],\n                                        vec4(0, 0, 0, 1)));\n      pos = (jointMatrix * vec4(position, 1.0)).xyz;\n      nom = mat3(jointMatrix) * normal;\n    }\n    //v_position = pos;\n    v_normal = nom;\n\n    gl_Position = viewProjectionTransform * vec4(pos, 1.0);\n    v_position = gl_Position.xyz / gl_Position.w;\n  }\n';

	/**
	 * @access private
	 * @type {string}
	 */
	var _defaultHitTestFragmentShader = '#version 300 es\n  precision mediump float;\n\n  uniform int objectID;\n  uniform int geometryID;\n\n  in vec3 v_normal;\n  in vec3 v_position;\n\n  layout(location = 0) out vec4 out_objectID;\n  layout(location = 1) out vec4 out_faceID;\n  layout(location = 2) out vec4 out_position;\n  layout(location = 3) out vec4 out_normal;\n\n  void main() {\n    out_objectID = vec4(\n      float(objectID >> 8) / 255.0,\n      float(objectID & 0xFF) / 255.0,\n      float(geometryID >> 8) / 255.0,\n      float(geometryID & 0xFF) / 255.0\n    );\n    //out_faceID = vec4(\n    //  (gl_PrimitiveID >> 24) / 255.0,\n    //  ((gl_PrimitiveID >> 16) & 0xFF) / 255.0,\n    //  ((gl_PrimitiveID >> 8) & 0xFF) / 255.0,\n    //  (gl_PrimitiveID & 0xFF) / 255.0\n    //);\n    out_faceID = vec4(0, 0, 0, 0); // TODO: implement\n    vec3 n = normalize(v_normal);\n    out_normal = vec4((n.x + 1.0) * 0.5, (n.y + 1.0) * 0.5, (n.z + 1.0) * 0.5, 0);\n    out_position = vec4((v_position.x + 1.0) * 0.5, (v_position.y + 1.0) * 0.5, (v_position.z + 1.0) * 0.5, 0);\n  }\n';

	/**
	 * @access private
	 * @type {string}
	 */
	var _defaultShadowVertexShader = '#version 300 es\n  precision mediump float;\n\n  uniform mat4 viewProjectionTransform;\n  uniform vec4[765] skinningJoints;\n  uniform int numSkinningJoints;\n\n  in vec3 position;\n  //in vec3 normal;\n  in vec4 boneIndices;\n  in vec4 boneWeights;\n\n  out vec3 v_position;\n\n  void main() {\n    vec3 pos = vec3(0, 0, 0);\n    if(numSkinningJoints > 0){\n      for(int i=0; i<numSkinningJoints; i++){\n        float weight = boneWeights[i];\n        if(int(boneIndices[i]) < 0){\n          continue;\n        }\n        int idx = int(boneIndices[i]) * 3;\n        mat4 jointMatrix = transpose(mat4(skinningJoints[idx],\n                                          skinningJoints[idx+1],\n                                          skinningJoints[idx+2],\n                                          vec4(0, 0, 0, 1)));\n        pos += (jointMatrix * vec4(position, 1.0)).xyz * weight;\n      }\n    }else{\n      mat4 jointMatrix = transpose(mat4(skinningJoints[0],\n                                        skinningJoints[1],\n                                        skinningJoints[2],\n                                        vec4(0, 0, 0, 1)));\n      pos = (jointMatrix * vec4(position, 1.0)).xyz;\n    }\n    //v_position = pos;\n\n    gl_Position = viewProjectionTransform * vec4(pos, 1.0);\n    v_position = gl_Position.xyz / gl_Position.w;\n  }\n';

	/**
	 * @access private
	 * @type {string}
	 */
	var _defaultShadowFragmentShader = '#version 300 es\n  precision mediump float;\n\n  in vec3 v_position;\n\n  layout(location = 0) out vec4 out_depth;\n  //layout(location = 0) out float out_depth;\n\n  void main() {\n    float r = (v_position.z + 1.0) * 0.5;\n    float g = fract(r * 255.0);\n    float b = fract(g * 255.0);\n    float a = fract(b * 255.0);\n    float coef = 1.0 / 255.0;\n\n    r -= g * coef;\n    g -= b * coef;\n    b -= a * coef;\n    out_depth = vec4(r, g, b, a);\n    //out_depth = v_position.z;\n  }\n';

	/**
	 * A renderer for displaying SceneKit scene in an an existing Metal workflow or OpenGL context. 
	 * @access public
	 * @extends {NSObject}
	 * @implements {SCNSceneRenderer}
	 * @implements {SCNTechniqueSupport}
	 * @see https://developer.apple.com/reference/scenekit/scnrenderer
	 */

	var SCNRenderer = function (_NSObject) {
	  _inherits(SCNRenderer, _NSObject);

	  // Creating a Renderer

	  /**
	   * Creates a renderer with the specified Metal device.
	   * @access public
	   * @constructor
	   * @param {?MTLDevice} device - A Metal device.
	   * @param {?Map<AnyHashable, Object>} [options = null] - An optional dictionary for future extensions.
	   * @desc Use this initializer to create a SceneKit renderer that draws into the rendering targets your app already uses to draw other content. For the device parameter, pass the MTLDevice object your app uses for drawing. Then, to tell SceneKit to render your content, call the SCNRenderer method, providing a command buffer and render pass descriptor for SceneKit to use in its rendering.
	   * @see https://developer.apple.com/reference/scenekit/scnrenderer/1518404-init
	   */
	  function SCNRenderer(device) {
	    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

	    _classCallCheck(this, SCNRenderer);

	    // Specifying a Scene

	    /**
	     * The scene to be rendered.
	     * @type {?SCNScene}
	     * @see https://developer.apple.com/reference/scenekit/scnrenderer/1518400-scene
	     */
	    var _this = _possibleConstructorReturn(this, (SCNRenderer.__proto__ || Object.getPrototypeOf(SCNRenderer)).call(this));

	    _this.scene = null;

	    // Managing Animation Timing

	    _this._nextFrameTime = 0;

	    /**
	     * context to draw frame
	     * @type {WebGLRenderingContext}
	     */
	    _this._context = null;

	    /**
	     *
	     * @access private
	     * @type {SKColor}
	     */
	    _this._backgroundColor = null;

	    //////////////////////
	    // SCNSceneRenderer //
	    //////////////////////

	    // Managing Scene Display

	    /**
	     * Required. The node from which the scenes contents are viewed for rendering.
	     * @access private
	     * @type {?SCNNode}
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1523982-pointofview
	     */
	    _this._pointOfView = null;

	    /**
	     * Required. A Boolean value that determines whether SceneKit automatically adds lights to a scene.
	     * @type {boolean}
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1523812-autoenablesdefaultlighting
	     */
	    _this.autoenablesDefaultLighting = false;

	    /**
	     * Required. A Boolean value that determines whether SceneKit applies jittering to reduce aliasing artifacts.
	     * @type {boolean}
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1524026-isjitteringenabled
	     */
	    _this.isJitteringEnabled = false;

	    /**
	     * Required. A Boolean value that determines whether SceneKit displays rendering performance statistics in an accessory view.
	     * @type {boolean}
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1522763-showsstatistics
	     */
	    _this.showsStatistics = false;

	    /**
	     * Required. Options for drawing overlay content in a scene that can aid debugging.
	     * @type {SCNDebugOptions}
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1523281-debugoptions
	     */
	    _this.debugOptions = null;

	    _this._renderingAPI = null;

	    // Managing Scene Animation Timing

	    /**
	     * Required. The current scene time.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1522680-scenetime
	     */
	    _this.sceneTime = 0;

	    /**
	     * current time in seconds
	     * @access private
	     * @type {number}
	     */
	    _this._time = 0;

	    /**
	     * Required. A Boolean value that determines whether the scene is playing.
	     * @type {boolean}
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1523401-isplaying
	     */
	    _this.isPlaying = false;

	    /**
	     * Required. A Boolean value that determines whether SceneKit restarts the scene time after all animations in the scene have played.
	     * @type {boolean}
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1522878-loops
	     */
	    _this.loops = false;

	    // Participating in the Scene Rendering Process

	    /**
	     * Required. A delegate object that receives messages about SceneKits rendering process.
	     * @type {?SCNSceneRendererDelegate}
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1522671-delegate
	     */
	    _this.delegate = null;

	    // Customizing Scene Rendering with Metal

	    _this._currentRenderCommandEncoder = null;
	    _this._device = null;
	    _this._commandQueue = null;
	    _this._colorPixelFormat = null;
	    _this._depthPixelFormat = null;
	    _this._stencilPixelFormat = null;

	    // Rendering Sprite Kit Content over a Scene

	    /**
	     * Required. A Sprite Kit scene to be rendered on top of the SceneKit content.
	     * @type {?SKScene}
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1524051-overlayskscene
	     */
	    _this.overlaySKScene = null;

	    // Working With Positional Audio

	    /**
	     * Required. The node representing the listeners position in the scene for use with positional audio effects.
	     * @type {?SCNNode}
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1523747-audiolistener
	     */
	    //this.audioListener = null
	    //this._audioEnvironmentNode = null
	    //this._audioEngine = null

	    // Instance Properties

	    /**
	     * Required. 
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1522854-currenttime
	     */
	    _this.currentTime = 0;

	    /**
	     * @access private
	     * @type {SCNProgram}
	     */
	    _this.__defaultProgram = null;

	    /**
	     * @access private
	     * @type {SCNProgram}
	     */
	    _this.__defaultParticleProgram = null;

	    /**
	     * @access private
	     * @type {SCNProgram}
	     */
	    _this.__defaultHitTestProgram = null;

	    /**
	     * @access private
	     * @type {SCNProgram}
	     */
	    _this.__defaultShadowProgram = null;

	    _this._location = new Map();

	    _this._defaultCameraPosNode = new _SCNNode2.default();
	    _this._defaultCameraRotNode = new _SCNNode2.default();
	    _this._defaultCameraNode = new _SCNNode2.default();
	    _this._defaultCameraNode.name = 'kSCNFreeViewCameraName';

	    var camera = new _SCNCamera2.default();
	    camera.name = 'kSCNFreeViewCameraNameCamera';
	    _this._defaultCameraNode.camera = camera;
	    _this._defaultCameraNode.position = new _SCNVector2.default(0, 0, _defaultCameraDistance);
	    _this._defaultCameraNode._presentation = _this._defaultCameraNode.copy();

	    _this._defaultCameraPosNode.addChildNode(_this._defaultCameraRotNode);
	    _this._defaultCameraPosNode._presentation = _this._defaultCameraPosNode.copy();
	    _this._defaultCameraRotNode.addChildNode(_this._defaultCameraNode);
	    _this._defaultCameraRotNode._presentation = _this._defaultCameraRotNode.copy();

	    _this._defaultLightNode = new _SCNNode2.default();
	    var light = new _SCNLight2.default();
	    light.color = _SKColor2.default.white;
	    light.type = _SCNLight2.default.LightType.omni;
	    light.position = new _SCNVector2.default(0, 10, 10);
	    _this._defaultLightNode.light = light;
	    _this._defaultLightNode._presentation = _this._defaultLightNode.copy();

	    /**
	     * @access private
	     * @type {CGRect}
	     */
	    _this._viewRect = new _CGRect2.default(new _CGPoint2.default(0, 0), new _CGSize2.default(0, 0));

	    /**
	     * The background color of the view.
	     * @type {SKColor}
	     */
	    _this._backgroundColor = _SKColor2.default.white;

	    /**
	     * @access private
	     * @type {WebGLTexture}
	     */
	    _this.__dummyTexture = null;

	    /**
	     * @access private
	     * @type {Object}
	     */
	    _this._lightNodes = {};

	    /**
	     * @access private
	     * @type {Object}
	     */
	    _this._numLights = {};

	    /**
	     * @access private
	     * @type {WebGLBuffer}
	     */
	    _this._cameraBuffer = null;

	    /**
	     * @access private
	     * @type {WebGLBuffer}
	     */
	    _this._lightBuffer = null;

	    /**
	     * @access private
	     * @type {WebGLBuffer}
	     */
	    _this._fogBuffer = null;

	    ////////////////////////////
	    // Hit Test
	    ////////////////////////////

	    /**
	     * @access private
	     * @type {WebGLFramebuffer}
	     */
	    _this._hitFrameBuffer = null;

	    /**
	     * @access private
	     * @type {WebGLRenderbuffer}
	     */
	    _this._hitDepthBuffer = null;

	    /**
	     * @access private
	     * @type {WebGLTexture}
	     */
	    _this._hitObjectIDTexture = null;

	    /**
	     * @access private
	     * @type {WebGLTexture}
	     */
	    _this._hitFaceIDTexture = null;

	    /**
	     * @access private
	     * @type {WebGLTexture}
	     */
	    _this._hitPositionTexture = null;

	    /**
	     * @access private
	     * @type {WebGLTexture}
	     */
	    _this._hitNormalTexture = null;

	    /**
	     * @access private
	     * @type {SCNProgram}
	     */
	    _this._currentProgram = null;
	    return _this;
	  }

	  /**
	   * Creates a renderer with the specified Metal device.
	   * @access public
	   * @param {?MTLDevice} device - A Metal device.
	   * @param {?Map<AnyHashable, Object>} [options = null] - An optional dictionary for future extensions.
	   * @returns {void}
	   * @desc Use this initializer to create a SceneKit renderer that draws into the rendering targets your app already uses to draw other content. For the device parameter, pass the MTLDevice object your app uses for drawing. Then, to tell SceneKit to render your content, call the SCNRenderer method, providing a command buffer and render pass descriptor for SceneKit to use in its rendering.
	   * @see https://developer.apple.com/reference/scenekit/scnrenderer/1518404-init
	   */


	  _createClass(SCNRenderer, [{
	    key: 'init',
	    value: function init(device) {
	      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
	    }

	    // Managing Animation Timing

	    /**
	     * The timestamp for the next frame to be rendered.
	     * @type {number}
	     * @desc If the renderers scene has any attached actions or animations, use this property to determine how long your app should wait before telling the renderer to draw another frame. If this propertys value matches that of the renderers currentTime property, the scene contains a continuous animationschedule your next render at whatever time best maintains your apps performance. If the value is infinite, the scene has no running actions or animations.
	     * @see https://developer.apple.com/reference/scenekit/scnrenderer/1518410-nextframetime
	     */

	  }, {
	    key: 'renderAtTimePassDescriptor',


	    // Rendering a Scene Using Metal

	    /**
	     * Renders the scenes contents at the specified system time in the specified Metal command buffer.
	     * @access public
	     * @param {number} time - The timestamp, in seconds, at which to render the scene.
	     * @param {CGRect} viewport - The pixel dimensions in which to render.
	     * @param {MTLCommandBuffer} commandBuffer - The Metal command buffer in which SceneKit should schedule rendering commands.
	     * @param {MTLRenderPassDescriptor} renderPassDescriptor - The Metal render pass descriptor describing the rendering target.
	     * @returns {void}
	     * @desc This method can be used only with an SCNRenderer object created with the SCNRenderer initializer. Call this method to tell SceneKit to draw the renderers scene into the render target described by the renderPassDescriptor parameter, by encoding render commands into the commandBuffer parameter.When you call this method, SceneKit updates its hierarchy of presentation nodes based on the specified timestamp, and then draws the scene using the specified Metal objects. NoteBy default, the playback timing of actions and animations in a scene is based on the system time, not the scene time. Before using this method to control the playback of animations, set the usesSceneTimeBase property of each animation to true, or specify the playUsingSceneTimeBase option when loading a scene file that contains animations.
	     * @see https://developer.apple.com/reference/scenekit/scnrenderer/1518401-render
	     */
	    value: function renderAtTimePassDescriptor(time, viewport, commandBuffer, renderPassDescriptor) {}

	    // Rendering a Scene Using OpenGL

	    /**
	     * Renders the scenes contents in the renderers OpenGL context.
	     * @deprecated
	     * @access public
	     * @returns {void}
	     * @desc This method can be used only with an SCNRenderer object created with the SCNRenderer initializer. Call this method to tell SceneKit to draw the renderers scene into the OpenGL context you created the renderer with.When you call this method, SceneKit updates its hierarchy of presentation nodes based on the current system time, and then draws the scene.
	     * @see https://developer.apple.com/reference/scenekit/scnrenderer/1518403-render
	     */

	  }, {
	    key: 'render',
	    value: function render() {
	      var _this2 = this;

	      if (this.context === null) {
	        console.error('SCNRenderer.render(): context is null');
	        return;
	      }
	      if (this.scene === null) {
	        console.error('SCNRenderer.render(): scene is null');
	        return;
	      }

	      this._lightNodes = this._createLightNodeArray(); // createLightNodeArray must be called before getting program

	      var gl = this.context;
	      var program = this._defaultProgram._glProgram;

	      gl.clearColor(this._backgroundColor.r, this._backgroundColor.g, this._backgroundColor.b, this._backgroundColor.a);
	      gl.clearDepth(1.0);
	      gl.clearStencil(0);
	      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);

	      gl.useProgram(program);

	      gl.depthFunc(gl.LEQUAL);
	      gl.depthMask(true);
	      gl.enable(gl.BLEND);
	      gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

	      //////////////////////////
	      // Camera
	      //////////////////////////
	      if (this._cameraBuffer === null) {
	        this._initializeCameraBuffer(program);
	      }
	      var cameraData = [];
	      var cameraNode = this._getCameraNode();
	      cameraNode._updateWorldTransform();
	      var cameraPNode = cameraNode.presentation;
	      var camera = cameraPNode.camera;
	      camera._updateProjectionTransform(this._viewRect);

	      cameraData.push.apply(cameraData, _toConsumableArray(cameraPNode.worldTransform.getTranslation().floatArray()).concat([0]));
	      cameraData.push.apply(cameraData, _toConsumableArray(cameraPNode.viewTransform.floatArray()));
	      cameraData.push.apply(cameraData, _toConsumableArray(cameraPNode.viewProjectionTransform.floatArray()));
	      gl.bindBuffer(gl.UNIFORM_BUFFER, this._cameraBuffer);
	      gl.bufferData(gl.UNIFORM_BUFFER, new Float32Array(cameraData), gl.DYNAMIC_DRAW);
	      gl.bindBuffer(gl.UNIFORM_BUFFER, null);

	      //console.log('cameraNode.worldPosition: ' + cameraPNode.worldTransform.getTranslation().float32Array())
	      //console.log('viewTransform: ' + cameraPNode.viewTransform.float32Array())
	      //console.log('projectionTransform: ' + cameraNode.camera.projectionTransform.float32Array())
	      //console.log('viewProjectionTransform: ' + cameraNode.viewProjectionTransform.float32Array())

	      //////////////////////////
	      // Fog
	      //////////////////////////
	      if (this._fogBuffer === null) {
	        this._initializeFogBuffer(program);
	      }
	      var fogData = [];
	      if (this.scene.fogColor !== null && this.scene.fogEndDistance !== 0) {
	        fogData.push.apply(fogData, _toConsumableArray(this.scene.fogColor.floatArray()).concat([this.scene.fogStartDistance, this.scene.fogEndDistance, this.scene.fogDensityExponent, 0]));
	      } else {
	        fogData.push(0, 0, 0, 0, camera.zFar * 2, camera.zFar * 2 + 1, 1, 0);
	      }
	      gl.bindBuffer(gl.UNIFORM_BUFFER, this._fogBuffer);
	      gl.bufferData(gl.UNIFORM_BUFFER, new Float32Array(fogData), gl.DYNAMIC_DRAW);
	      gl.bindBuffer(gl.UNIFORM_BUFFER, null);

	      //////////////////////////
	      // Lights
	      //////////////////////////
	      if (this._lightBuffer === null) {
	        this._initializeLightBuffer(program);
	      }
	      var lights = this._lightNodes;
	      var lightData = [];
	      lights.ambient.forEach(function (node) {
	        lightData.push.apply(lightData, _toConsumableArray(node.presentation.light.color.float32Array()));
	      });
	      lights.directional.forEach(function (node) {
	        var direction = new _SCNVector2.default(0, 0, -1).rotateWithQuaternion(node.presentation._worldOrientation);
	        lightData.push.apply(lightData, _toConsumableArray(node.presentation.light.color.float32Array()).concat(_toConsumableArray(direction.float32Array()), [0]));
	      });
	      lights.directionalShadow.forEach(function (node) {
	        var direction = new _SCNVector2.default(0, 0, -1).rotateWithQuaternion(node.presentation._worldOrientation);
	        node.presentation.light._updateProjectionTransform();
	        lightData.push.apply(lightData, _toConsumableArray(node.presentation.light.color.float32Array()).concat(_toConsumableArray(direction.float32Array()), [0], _toConsumableArray(node.presentation.light.shadowColor.float32Array()), _toConsumableArray(node.presentation.lightViewProjectionTransform.float32Array()), _toConsumableArray(node.presentation.shadowProjectionTransform.float32Array())));
	      });
	      lights.omni.forEach(function (node) {
	        lightData.push.apply(lightData, _toConsumableArray(node.presentation.light.color.float32Array()).concat(_toConsumableArray(node.presentation._worldTranslation.float32Array()), [0]));
	      });
	      lights.probe.forEach(function (node) {
	        lightData.push.apply(lightData, _toConsumableArray(node.presentation.light.color.float32Array()));
	      });
	      lights.spot.forEach(function (node) {
	        lightData.push.apply(lightData, _toConsumableArray(node.presentation.light.color.float32Array()));
	      });

	      gl.bindBuffer(gl.UNIFORM_BUFFER, this._lightBuffer);
	      gl.bufferData(gl.UNIFORM_BUFFER, new Float32Array(lightData), gl.DYNAMIC_DRAW);
	      gl.bindBuffer(gl.UNIFORM_BUFFER, null);

	      //////////////////////////
	      // Background (SkyBox)
	      //////////////////////////
	      if (this.scene.background._contents !== null) {
	        var skyBox = this.scene._skyBox;
	        skyBox.position = cameraPNode._worldTranslation;
	        var scale = camera.zFar * 1.154;
	        skyBox.scale = new _SCNVector2.default(scale, scale, scale);
	        skyBox._updateWorldTransform();

	        // disable fog
	        var disabledFogData = fogData.slice(0);
	        disabledFogData[4] = camera.zFar * 2.0; // startDistance
	        disabledFogData[5] = camera.zFar * 2.1; // endDistance
	        disabledFogData[6] = 1.0; // densityExponent
	        gl.bindBuffer(gl.UNIFORM_BUFFER, this._fogBuffer);
	        gl.bufferData(gl.UNIFORM_BUFFER, new Float32Array(disabledFogData), gl.DYNAMIC_DRAW);
	        gl.bindBuffer(gl.UNIFORM_BUFFER, null);

	        this._renderNode(skyBox);

	        // enable fog
	        gl.bindBuffer(gl.UNIFORM_BUFFER, this._fogBuffer);
	        gl.bufferData(gl.UNIFORM_BUFFER, new Float32Array(fogData), gl.DYNAMIC_DRAW);
	        gl.bindBuffer(gl.UNIFORM_BUFFER, null);
	      }

	      //////////////////////////
	      // Shadow
	      //////////////////////////
	      gl.useProgram(this._defaultShadowProgram._glProgram);
	      gl.enable(gl.DEPTH_TEST);
	      gl.depthMask(true);
	      gl.depthFunc(gl.LEQUAL);
	      gl.clearDepth(1.0);
	      gl.clearColor(1.0, 1.0, 1.0, 1.0);
	      gl.disable(gl.BLEND);
	      var shadowRenderingArray = this._createShadowNodeArray();

	      var _iteratorNormalCompletion = true;
	      var _didIteratorError = false;
	      var _iteratorError = undefined;

	      try {
	        for (var _iterator = Object.keys(lights)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	          var key = _step.value;
	          var _iteratorNormalCompletion3 = true;
	          var _didIteratorError3 = false;
	          var _iteratorError3 = undefined;

	          try {
	            for (var _iterator3 = lights[key][Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
	              var lightNode = _step3.value;

	              this._renderNodesShadowOfLight(shadowRenderingArray, lightNode);
	            }
	          } catch (err) {
	            _didIteratorError3 = true;
	            _iteratorError3 = err;
	          } finally {
	            try {
	              if (!_iteratorNormalCompletion3 && _iterator3.return) {
	                _iterator3.return();
	              }
	            } finally {
	              if (_didIteratorError3) {
	                throw _iteratorError3;
	              }
	            }
	          }
	        }
	      } catch (err) {
	        _didIteratorError = true;
	        _iteratorError = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion && _iterator.return) {
	            _iterator.return();
	          }
	        } finally {
	          if (_didIteratorError) {
	            throw _iteratorError;
	          }
	        }
	      }

	      this._setViewPort(); // reset viewport size
	      gl.useProgram(program);
	      for (var i = 0; i < lights.directionalShadow.length; i++) {
	        var node = lights.directionalShadow[i];
	        var symbol = 'TEXTURE' + (i + 8);
	        gl.activeTexture(gl[symbol]);
	        gl.bindTexture(gl.TEXTURE_2D, node.presentation.light._shadowDepthTexture);
	      }

	      //////////////////////////
	      // Nodes
	      //////////////////////////
	      var renderingArray = this._createRenderingNodeArray();
	      renderingArray.forEach(function (node) {
	        _this2._renderNode(node);
	      });

	      var particleProgram = this._defaultParticleProgram._glProgram;
	      gl.useProgram(particleProgram);
	      gl.depthMask(false);
	      gl.enable(gl.BLEND);
	      gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
	      gl.uniformMatrix4fv(gl.getUniformLocation(particleProgram, 'viewTransform'), false, cameraPNode.viewTransform.float32Array());
	      gl.uniformMatrix4fv(gl.getUniformLocation(particleProgram, 'projectionTransform'), false, cameraPNode.projectionTransform.float32Array());

	      //////////////////////////
	      // Particles
	      //////////////////////////
	      if (this.scene._particleSystems !== null) {
	        var _iteratorNormalCompletion2 = true;
	        var _didIteratorError2 = false;
	        var _iteratorError2 = undefined;

	        try {
	          for (var _iterator2 = this.scene._particleSystems[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
	            var system = _step2.value;

	            this._renderParticleSystem(system);
	          }
	        } catch (err) {
	          _didIteratorError2 = true;
	          _iteratorError2 = err;
	        } finally {
	          try {
	            if (!_iteratorNormalCompletion2 && _iterator2.return) {
	              _iterator2.return();
	            }
	          } finally {
	            if (_didIteratorError2) {
	              throw _iteratorError2;
	            }
	          }
	        }
	      }
	      var particleArray = this._createParticleNodeArray();
	      particleArray.forEach(function (node) {
	        _this2._renderParticle(node);
	      });

	      //////////////////////////
	      // 2D Overlay
	      //////////////////////////
	      this._renderOverlaySKScene();

	      // DEBUG: show shadow map
	      //this._showShadowMapOfLight(lights.directionalShadow[0])

	      gl.flush();
	    }
	  }, {
	    key: '_renderOverlaySKScene',
	    value: function _renderOverlaySKScene() {
	      if (this.overlaySKScene === null) {
	        return;
	      }
	      var gl = this.context;
	      gl.clearDepth(-1);
	      gl.clearStencil(0);
	      gl.depthMask(true);
	      gl.enable(gl.DEPTH_TEST);
	      gl.disable(gl.CULL_FACE);
	      gl.depthFunc(gl.GEQUAL);
	      gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
	      gl.clear(gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);

	      var skNodes = this._createSKNodeArray();
	      var _iteratorNormalCompletion4 = true;
	      var _didIteratorError4 = false;
	      var _iteratorError4 = undefined;

	      try {
	        for (var _iterator4 = skNodes[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
	          var node = _step4.value;

	          this._renderSKNode(node);
	        }
	      } catch (err) {
	        _didIteratorError4 = true;
	        _iteratorError4 = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion4 && _iterator4.return) {
	            _iterator4.return();
	          }
	        } finally {
	          if (_didIteratorError4) {
	            throw _iteratorError4;
	          }
	        }
	      }
	    }

	    /**
	     * @access private
	     * @returns {SCNNode} -
	     */

	  }, {
	    key: '_getCameraNode',
	    value: function _getCameraNode() {
	      var cameraNode = this._pointOfView;
	      if (cameraNode === null) {
	        cameraNode = this._searchCameraNode();
	        this._pointOfView = cameraNode;
	        if (cameraNode === null) {
	          cameraNode = this._defaultCameraNode;
	        }
	      }
	      if (cameraNode === this._defaultCameraNode) {
	        this._defaultCameraPosNode._updateWorldTransform();
	      }
	      return cameraNode;
	    }

	    /**
	     *
	     * @access private
	     * @returns {SCNNode[]} -
	     */

	  }, {
	    key: '_createShadowNodeArray',
	    value: function _createShadowNodeArray() {
	      var arr = [this.scene._rootNode];
	      var targetNodes = [];
	      while (arr.length > 0) {
	        var node = arr.shift();
	        if (node.presentation !== null && node.presentation.geometry !== null && node.presentation.castsShadow && node.presentation.opacity > 0 && !node.presentation.isHidden) {
	          targetNodes.push(node);
	        }
	        arr.push.apply(arr, _toConsumableArray(node.childNodes));
	      }

	      return targetNodes;
	    }

	    /**
	     *
	     * @access private
	     * @returns {SCNNode[]} -
	     */

	  }, {
	    key: '_createRenderingNodeArray',
	    value: function _createRenderingNodeArray() {
	      var arr = [this.scene._rootNode];
	      var targetNodes = [];
	      while (arr.length > 0) {
	        var node = arr.shift();
	        if (node.presentation !== null && node.presentation.geometry !== null) {
	          targetNodes.push(node);
	        }
	        arr.push.apply(arr, _toConsumableArray(node.childNodes));
	      }
	      targetNodes.sort(function (a, b) {
	        return a.renderingOrder - b.renderingOrder;
	      });

	      return targetNodes;
	    }

	    /**
	     *
	     * @access private
	     * @returns {SCNNode[]} -
	     */

	  }, {
	    key: '_createParticleNodeArray',
	    value: function _createParticleNodeArray() {
	      var arr = [this.scene._rootNode];
	      var targetNodes = [];
	      while (arr.length > 0) {
	        var node = arr.shift();
	        if (node.presentation !== null && node.presentation.particleSystems !== null) {
	          targetNodes.push(node);
	        }
	        arr.push.apply(arr, _toConsumableArray(node.childNodes));
	      }
	      targetNodes.sort(function (a, b) {
	        return a.renderingOrder - b.renderingOrder;
	      });

	      return targetNodes;
	    }

	    /**
	     *
	     * @access private
	     * @returns {SCNNode[]} -
	     */

	  }, {
	    key: '_createLightNodeArray',
	    value: function _createLightNodeArray() {
	      var targetNodes = {
	        ies: [],
	        ambient: [],
	        directional: [],
	        omni: [],
	        probe: [],
	        spot: [],

	        directionalShadow: []
	      };

	      var arr = [this.scene.rootNode];
	      var numLights = 0;
	      while (arr.length > 0) {
	        var node = arr.shift();
	        if (node.presentation !== null && node.presentation.light !== null) {
	          if (node.presentation.light.type === 'directional' && node.presentation.light.castsShadow) {
	            targetNodes['directionalShadow'].push(node);
	          } else {
	            targetNodes[node.presentation.light.type].push(node);
	          }
	          if (node.presentation.light.type !== _SCNLight2.default.LightType.ambient) {
	            numLights += 1;
	          }
	        }
	        arr.push.apply(arr, _toConsumableArray(node.childNodes));
	      }
	      if (this.autoenablesDefaultLighting && numLights === 0) {
	        targetNodes[this._defaultLightNode.light.type].push(this._defaultLightNode);
	      }

	      return targetNodes;
	    }

	    /**
	     *
	     * @access private
	     * @returns {SCNNode[]} -
	     */

	  }, {
	    key: '_createRenderingPhysicsNodeArray',
	    value: function _createRenderingPhysicsNodeArray() {
	      var arr = [this.scene._rootNode];
	      var targetNodes = [];
	      while (arr.length > 0) {
	        var node = arr.shift();
	        if (node.presentation !== null && node.presentation.physicsBody !== null) {
	          targetNodes.push(node);
	        }
	        arr.push.apply(arr, _toConsumableArray(node.childNodes));
	      }
	      targetNodes.sort(function (a, b) {
	        return a.renderingOrder - b.renderingOrder;
	      });

	      return targetNodes;
	    }

	    /**
	     *
	     * @access private
	     * @param {SCNNode} node -
	     * @param {SCNNode} lightNode -
	     * @returns {void}
	     */

	  }, {
	    key: '_renderNodesShadowOfLight',
	    value: function _renderNodesShadowOfLight(nodes, lightNode) {
	      var lp = lightNode.presentation;
	      var light = lp.light;
	      if (!lp.castsShadow) {
	        return;
	      }
	      this._setViewPort(light._shadowMapWidth, light._shadowMapHeight);
	      var gl = this.context;
	      var program = this._defaultShadowProgram._glProgram;
	      gl.bindFramebuffer(gl.FRAMEBUFFER, light._getDepthBufferForContext(gl));
	      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
	      //gl.clear(gl.DEPTH_BUFFER_BIT)

	      gl.uniformMatrix4fv(gl.getUniformLocation(program, 'viewProjectionTransform'), false, lp.lightViewProjectionTransform.float32Array());

	      var _iteratorNormalCompletion5 = true;
	      var _didIteratorError5 = false;
	      var _iteratorError5 = undefined;

	      try {
	        for (var _iterator5 = nodes[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
	          var node = _step5.value;

	          var geometry = node.presentation.geometry;
	          if (geometry._shadowVAO === null) {
	            this._initializeShadowVAO(node, program);
	          }

	          if (node.morpher !== null) {
	            //this._updateVAO(node)
	          }

	          if (node.presentation.skinner !== null) {
	            gl.uniform1i(gl.getUniformLocation(program, 'numSkinningJoints'), node.presentation.skinner.numSkinningJoints);
	            gl.uniform4fv(gl.getUniformLocation(program, 'skinningJoints'), node.presentation.skinner.float32Array());
	          } else {
	            gl.uniform1i(gl.getUniformLocation(program, 'numSkinningJoints'), 0);
	            gl.uniform4fv(gl.getUniformLocation(program, 'skinningJoints'), node.presentation._worldTransform.float32Array3x4f());
	          }

	          var geometryCount = geometry.geometryElements.length;
	          if (geometryCount === 0) {
	            throw new Error('geometryCount: 0');
	          }
	          for (var i = 0; i < geometryCount; i++) {
	            var vao = geometry._shadowVAO[i];
	            var element = geometry.geometryElements[i];

	            gl.bindVertexArray(vao);
	            // FIXME: use bufferData instead of bindBufferBase

	            var shape = null;
	            switch (element.primitiveType) {
	              case _SCNGeometryPrimitiveType2.default.triangles:
	                shape = gl.TRIANGLES;
	                break;
	              case _SCNGeometryPrimitiveType2.default.triangleStrip:
	                shape = gl.TRIANGLE_STRIP;
	                break;
	              case _SCNGeometryPrimitiveType2.default.line:
	                shape = gl.LINES;
	                break;
	              case _SCNGeometryPrimitiveType2.default.point:
	                shape = gl.POINTS;
	                break;
	              case _SCNGeometryPrimitiveType2.default.polygon:
	                shape = gl.TRIANGLE_FAN;
	                break;
	              default:
	                throw new Error('unsupported primitiveType: ' + element.primitiveType);
	            }

	            var size = null;
	            switch (element.bytesPerIndex) {
	              case 1:
	                size = gl.UNSIGNED_BYTE;
	                break;
	              case 2:
	                size = gl.UNSIGNED_SHORT;
	                break;
	              case 4:
	                size = gl.UNSIGNED_INT;
	                break;
	              default:
	                throw new Error('unsupported index size: ' + element.bytesPerIndex);
	            }

	            gl.drawElements(shape, element._glData.length, size, 0);
	          }
	        }
	      } catch (err) {
	        _didIteratorError5 = true;
	        _iteratorError5 = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion5 && _iterator5.return) {
	            _iterator5.return();
	          }
	        } finally {
	          if (_didIteratorError5) {
	            throw _iteratorError5;
	          }
	        }
	      }

	      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
	    }

	    /**
	     *
	     * @access private
	     * @param {SCNNode} node -
	     * @returns {void}
	     */

	  }, {
	    key: '_renderNode',
	    value: function _renderNode(node) {
	      if (node.presentation.isHidden || node.presentation.opacity <= 0) {
	        return;
	      }
	      var gl = this.context;
	      var geometry = node.presentation.geometry;
	      var scnProgram = this._getProgramForGeometry(geometry);
	      var program = scnProgram._glProgram;
	      //gl.useProgram(program)
	      this._switchProgram(scnProgram);

	      if (geometry._vertexArrayObjects === null) {
	        this._initializeVAO(node, program);
	        this._initializeUBO(node, program); // FIXME: program should have UBO, not node.
	      }

	      if (node.morpher !== null) {
	        this._updateVAO(node);
	      }

	      var uniformTime = gl.getUniformLocation(program, 'u_time');
	      if (uniformTime) {
	        // this._time might be too large.
	        var time = this._time % 100000.0;
	        gl.uniform1f(uniformTime, time);
	      }

	      if (node.presentation.skinner !== null) {
	        gl.uniform1i(gl.getUniformLocation(program, 'numSkinningJoints'), node.presentation.skinner.numSkinningJoints);
	        gl.uniform4fv(gl.getUniformLocation(program, 'skinningJoints'), node.presentation.skinner.float32Array());
	      } else {
	        gl.uniform1i(gl.getUniformLocation(program, 'numSkinningJoints'), 0);
	        gl.uniform4fv(gl.getUniformLocation(program, 'skinningJoints'), node.presentation._worldTransform.float32Array3x4f());
	      }

	      var geometryCount = geometry.geometryElements.length;
	      if (geometryCount === 0) {
	        throw new Error('geometryCount: 0');
	      }
	      for (var i = 0; i < geometryCount; i++) {
	        var vao = geometry._vertexArrayObjects[i];
	        var element = geometry.geometryElements[i];

	        gl.bindVertexArray(vao);
	        // FIXME: use bufferData instead of bindBufferBase
	        gl.bindBufferBase(gl.UNIFORM_BUFFER, _materialLoc, geometry._materialBuffer);

	        geometry._bufferMaterialData(gl, program, i, node.presentation.opacity);

	        var shape = null;
	        switch (element.primitiveType) {
	          case _SCNGeometryPrimitiveType2.default.triangles:
	            shape = gl.TRIANGLES;
	            break;
	          case _SCNGeometryPrimitiveType2.default.triangleStrip:
	            shape = gl.TRIANGLE_STRIP;
	            break;
	          case _SCNGeometryPrimitiveType2.default.line:
	            shape = gl.LINES;
	            break;
	          case _SCNGeometryPrimitiveType2.default.point:
	            shape = gl.POINTS;
	            break;
	          case _SCNGeometryPrimitiveType2.default.polygon:
	            shape = gl.TRIANGLE_FAN;
	            break;
	          default:
	            throw new Error('unsupported primitiveType: ' + element.primitiveType);
	        }

	        var size = null;
	        switch (element.bytesPerIndex) {
	          case 1:
	            size = gl.UNSIGNED_BYTE;
	            break;
	          case 2:
	            size = gl.UNSIGNED_SHORT;
	            break;
	          case 4:
	            size = gl.UNSIGNED_INT;
	            break;
	          default:
	            throw new Error('unsupported index size: ' + element.bytesPerIndex);
	        }

	        gl.drawElements(shape, element._glData.length, size, 0);
	      }
	    }

	    /**
	     *
	     * @access private
	     * @param {SCNNode} node -
	     * @returns {void}
	     */

	  }, {
	    key: '_renderParticle',
	    value: function _renderParticle(node) {
	      var _this3 = this;

	      if (node.presentation.isHidden) {
	        return;
	      }

	      var systems = node.presentation.particleSystems;
	      systems.forEach(function (system) {
	        _this3._renderParticleSystem(system, node);
	      });
	    }

	    /**
	     *
	     * @access private
	     * @param {SCNParticleSystem} system - 
	     * @returns {void}
	     */

	  }, {
	    key: '_renderParticleSystem',
	    value: function _renderParticleSystem(system) {
	      var node = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

	      //this.currentTime
	      var gl = this.context;
	      var program = this._defaultParticleProgram._glProgram;
	      if (system._program !== null) {
	        program = system._program._glProgram;
	      }
	      gl.useProgram(program);
	      //this._switchProgram(program)
	      gl.disable(gl.CULL_FACE);

	      if (system._vertexBuffer === null) {
	        system._initializeVAO(gl, program);
	      }
	      gl.bindVertexArray(system._vertexArray);

	      system._bufferMaterialData(gl, program);
	      if (node) {
	        gl.uniformMatrix4fv(gl.getUniformLocation(program, 'modelTransform'), false, node._worldTransform.float32Array());
	      } else {
	        var m = (0, _SCNMatrix4MakeTranslation2.default)(0, 0, 0);
	        gl.uniformMatrix4fv(gl.getUniformLocation(program, 'modelTransform'), false, m.float32Array());
	      }

	      gl.drawElements(gl.TRIANGLES, system._particles.length * 6, system._glIndexSize, 0);
	    }

	    /**
	     *
	     * @access private
	     * @param {SCNNode} node -
	     * @param {number} objectID -
	     * @param {Map} options -
	     * @returns {void}
	     */

	  }, {
	    key: '_renderNodeForHitTest',
	    value: function _renderNodeForHitTest(node, objectID, options) {
	      var gl = this.context;
	      var geometry = node.presentation.geometry;
	      var program = this._defaultHitTestProgram._glProgram;

	      if (geometry._vertexArrayObjects === null) {
	        // geometry is not ready
	        return;
	      }
	      if (geometry._hitTestVAO === null) {
	        this._initializeHitTestVAO(node, program);
	      }

	      gl.uniform1i(gl.getUniformLocation(program, 'objectID'), objectID);

	      if (node.presentation.skinner !== null) {
	        gl.uniform1i(gl.getUniformLocation(program, 'numSkinningJoints'), node.presentation.skinner.numSkinningJoints);
	        gl.uniform4fv(gl.getUniformLocation(program, 'skinningJoints'), node.presentation.skinner.float32Array());
	      } else {
	        gl.uniform1i(gl.getUniformLocation(program, 'numSkinningJoints'), 0);
	        gl.uniform4fv(gl.getUniformLocation(program, 'skinningJoints'), node.presentation._worldTransform.float32Array3x4f());
	      }

	      var geometryCount = geometry.geometryElements.length;
	      if (geometryCount === 0) {
	        throw new Error('geometryCount: 0');
	      }
	      for (var i = 0; i < geometryCount; i++) {
	        var vao = geometry._hitTestVAO[i];
	        var element = geometry.geometryElements[i];

	        gl.bindVertexArray(vao);
	        gl.uniform1i(gl.getUniformLocation(program, 'geometryID'), i);

	        var shape = null;
	        switch (element.primitiveType) {
	          case _SCNGeometryPrimitiveType2.default.triangles:
	            shape = gl.TRIANGLES;
	            break;
	          case _SCNGeometryPrimitiveType2.default.triangleStrip:
	            shape = gl.TRIANGLE_STRIP;
	            break;
	          case _SCNGeometryPrimitiveType2.default.line:
	            shape = gl.LINES;
	            break;
	          case _SCNGeometryPrimitiveType2.default.point:
	            shape = gl.POINTS;
	            break;
	          case _SCNGeometryPrimitiveType2.default.polygon:
	            shape = gl.TRIANGLE_FAN;
	            break;
	          default:
	            throw new Error('unsupported primitiveType: ' + element.primitiveType);
	        }

	        var size = null;
	        switch (element.bytesPerIndex) {
	          case 1:
	            size = gl.UNSIGNED_BYTE;
	            break;
	          case 2:
	            size = gl.UNSIGNED_SHORT;
	            break;
	          case 4:
	            size = gl.UNSIGNED_INT;
	            break;
	          default:
	            throw new Error('unsupported index size: ' + element.bytesPerIndex);
	        }

	        //console.log(`hitTest drawElements: length: ${element._glData.length}`)
	        gl.drawElements(shape, element._glData.length, size, 0);
	      }
	    }

	    /**
	     *
	     * @access private
	     * @param {SCNNode} node -
	     * @param {number} objectID -
	     * @param {Map} options -
	     * @returns {void}
	     */

	  }, {
	    key: '_renderPhysicsNodeForHitTest',
	    value: function _renderPhysicsNodeForHitTest(node, objectID, options) {
	      var gl = this.context;
	      var p = node.presentation;
	      var body = p.physicsBody;
	      var geometry = body.physicsShape._sourceGeometry;
	      var program = this._defaultHitTestProgram._glProgram;

	      if (geometry._vertexBuffer === null) {
	        // should I copy the geometry?
	        geometry._createVertexBuffer(gl, node, false, geometry);
	      }
	      if (geometry._hitTestVAO === null) {
	        this._initializeHitTestVAO(node, program, true);
	      }

	      gl.uniform1i(gl.getUniformLocation(program, 'objectID'), objectID);

	      if (node.presentation.skinner !== null) {
	        gl.uniform1i(gl.getUniformLocation(program, 'numSkinningJoints'), node.presentation.skinner.numSkinningJoints);
	        gl.uniform4fv(gl.getUniformLocation(program, 'skinningJoints'), node.presentation.skinner.float32Array());
	      } else {
	        gl.uniform1i(gl.getUniformLocation(program, 'numSkinningJoints'), 0);
	        gl.uniform4fv(gl.getUniformLocation(program, 'skinningJoints'), node.presentation._worldTransform.float32Array3x4f());
	      }

	      var geometryCount = geometry.geometryElements.length;
	      if (geometryCount === 0) {
	        throw new Error('geometryCount: 0');
	      }
	      for (var i = 0; i < geometryCount; i++) {
	        var vao = geometry._hitTestVAO[i];
	        var element = geometry.geometryElements[i];

	        gl.bindVertexArray(vao);
	        gl.uniform1i(gl.getUniformLocation(program, 'geometryID'), i);

	        var shape = null;
	        switch (element.primitiveType) {
	          case _SCNGeometryPrimitiveType2.default.triangles:
	            shape = gl.TRIANGLES;
	            break;
	          case _SCNGeometryPrimitiveType2.default.triangleStrip:
	            shape = gl.TRIANGLE_STRIP;
	            break;
	          case _SCNGeometryPrimitiveType2.default.line:
	            shape = gl.LINES;
	            break;
	          case _SCNGeometryPrimitiveType2.default.point:
	            shape = gl.POINTS;
	            break;
	          case _SCNGeometryPrimitiveType2.default.polygon:
	            shape = gl.TRIANGLE_FAN;
	            break;
	          default:
	            throw new Error('unsupported primitiveType: ' + element.primitiveType);
	        }

	        var size = null;
	        switch (element.bytesPerIndex) {
	          case 1:
	            size = gl.UNSIGNED_BYTE;
	            break;
	          case 2:
	            size = gl.UNSIGNED_SHORT;
	            break;
	          case 4:
	            size = gl.UNSIGNED_INT;
	            break;
	          default:
	            throw new Error('unsupported index size: ' + element.bytesPerIndex);
	        }

	        gl.drawElements(shape, element._glData.length, size, 0);
	      }
	    }

	    /**
	     *
	     * @access private
	     * @returns {SKNode[]} -
	     */

	  }, {
	    key: '_createSKNodeArray',
	    value: function _createSKNodeArray() {
	      if (this.overlaySKScene === null) {
	        return [];
	      }

	      var arr = [this.overlaySKScene];
	      var targetNodes = [];
	      while (arr.length > 0) {
	        var node = arr.shift();
	        targetNodes.push(node);
	        arr.push.apply(arr, _toConsumableArray(node.children));
	      }
	      //targetNodes.sort((a, b) => { return a.renderingOrder - b.renderingOrder })

	      return targetNodes;
	    }

	    /**
	     *
	     * @access private
	     * @param {SKNode} node -
	     * @returns {void}
	     */

	  }, {
	    key: '_renderSKNode',
	    value: function _renderSKNode(node) {
	      node._render(this.context, this._viewRect);
	    }

	    /**
	     * Renders the scenes contents at the specified system time in the renderers OpenGL context.
	     * @access public
	     * @param {number} time - The timestamp, in seconds, at which to render the scene.
	     * @returns {void}
	     * @desc This method can be used only with an SCNRenderer object created with the SCNRenderer initializer. Call this method to tell SceneKit to draw the renderers scene into the OpenGL context you created the renderer with.When you call this method, SceneKit updates its hierarchy of presentation nodes based on the specified timestamp, and then draws the scene.NoteBy default, the playback timing of actions and animations in a scene is based on the system time, not the scene time. Before using this method to control the playback of animations, set the usesSceneTimeBase property of each animation to true, or specify the playUsingSceneTimeBase option when loading a scene file that contains animations.
	     * @see https://developer.apple.com/reference/scenekit/scnrenderer/1518402-render
	     */

	  }, {
	    key: 'renderAtTime',
	    value: function renderAtTime(time) {}

	    // Capturing a Snapshot

	    /**
	     * Creates an image by drawing the renderers content at the specified system time.
	     * @access public
	     * @param {number} time - The timestamp, in seconds, at which to render the scene.
	     * @param {CGSize} size - The size, in pixels, of the image to create.
	     * @param {SCNAntialiasingMode} antialiasingMode - The antialiasing mode to use for the image output.
	     * @returns {Image} - 
	     * @desc When you call this method, SceneKit updates its hierarchy of presentation nodes based on the specified timestamp, and then draws the scene into a new image object of the specified size.
	     * @see https://developer.apple.com/reference/scenekit/scnrenderer/1641767-snapshot
	     */

	  }, {
	    key: 'snapshotAtTimeWith',
	    value: function snapshotAtTimeWith(time, size, antialiasingMode) {
	      return null;
	    }

	    // Instance Methods

	    /**
	     * 
	     * @access public
	     * @param {SCNNode[]} lightProbes - 
	     * @param {number} time - 
	     * @returns {void}
	     * @see https://developer.apple.com/reference/scenekit/scnrenderer/2097153-updateprobes
	     */

	  }, {
	    key: 'updateProbesAtTime',
	    value: function updateProbesAtTime(lightProbes, time) {}

	    //////////////////////
	    // SCNSceneRenderer //
	    //////////////////////

	    // Presenting a Scene

	    /**
	     * Required. Displays the specified scene with an animated transition.
	     * @access public
	     * @param {SCNScene} scene - The new scene to be displayed.
	     * @param {SKTransition} transition - An object that specifies the duration and style of the animated transition.
	     * @param {?SCNNode} pointOfView - The node to use as the pointOfView property when displaying the new scene.
	     * @param {?function(): void} [completionHandler = null] - A block that SceneKit calls after the transition animation has completed.This block takes no parameters and has no return value.
	     * @returns {void}
	     * @desc Use this method to change the scene displayed in a SceneKit view (or other renderer) with an animated transition. For details on transition styles, see SKTransition.
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1523028-present
	     */

	  }, {
	    key: 'presentWithIncomingPointOfView',
	    value: function presentWithIncomingPointOfView(scene, transition, pointOfView) {
	      var completionHandler = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
	    }

	    // Managing Scene Display

	    /**
	     * Required. The node from which the scenes contents are viewed for rendering.
	     * @type {?SCNNode}
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1523982-pointofview
	     */

	  }, {
	    key: 'prepareShouldAbortBlock',


	    // Preloading Renderer Resources

	    /**
	     * Required. Prepares a SceneKit object for rendering.
	     * @access public
	     * @param {Object} object - An SCNScene, SCNNode, SCNGeometry, or SCNMaterial instance.
	     * @param {?function(): boolean} [block = null] - A block that SceneKit calls periodically while preparing the object. The block takes no parameters.Your block should return false to tell SceneKit to continue preparing the object, or true to cancel preparation.Pass nil for this parameter if you do not need an opportunity to cancel preparing the object.
	     * @returns {boolean} - 
	     * @desc By default, SceneKit lazily loads resources onto the GPU for rendering. This approach uses memory and GPU bandwidth efficiently, but can lead to stutters in an otherwise smooth frame rate when you add large amounts of new content to an animated scene. To avoid such issues, use this method to prepare content for drawing before adding it to the scene. You can call this method on a secondary thread to prepare content asynchronously. SceneKit prepares all content associated with the object parameter you provide. If you provide an SCNMaterial object, SceneKit loads any texture images assigned to its material properties. If you provide an SCNGeometry object, SceneKit loads all materials attached to the geometry, as well as its vertex data. If you provide an SCNNode or SCNScene object, SceneKit loads all geometries and materials associated with the node and all its child nodes, or with the entire node hierarchy of the scene.You can use the block parameter to cancel preparation if content is no longer needed. For example, in a game you might use this method to preload areas of the game world the player is soon to enter, but if the player character dies before entering those areas, you can return true from the block to cancel preloading.You can observe the progress of this operation with the Progress class. For details, see Progress.
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1522798-prepare
	     */
	    value: function prepareShouldAbortBlock(object) {
	      var block = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

	      return false;
	    }

	    /**
	     * Required. Prepares the specified SceneKit objects for rendering, using a background thread.
	     * @access public
	     * @param {Object[]} objects - An array of containing one or more SCNScene, SCNNode, SCNGeometry, or SCNMaterial instances.
	     * @param {?function(arg1: boolean): void} [completionHandler = null] - A block that SceneKit calls when object preparation fails or completes.The block takes the following parameter:successtrue if all content was successfully prepared for rendering; otherwise, false.
	     * @returns {void}
	     * @desc By default, SceneKit lazily loads resources onto the GPU for rendering. This approach uses memory and GPU bandwidth efficiently, but can lead to stutters in an otherwise smooth frame rate when you add large amounts of new content to an animated scene. To avoid such issues, use this method to prepare content for drawing before adding it to the scene. SceneKit uses a secondary thread to prepare content asynchronously.SceneKit prepares all content associated with the objects you provide. If you provide an SCNMaterial object, SceneKit loads any texture images assigned to its material properties. If you provide an SCNGeometry object, SceneKit loads all materials attached to the geometry, as well as its vertex data. If you provide an SCNNode or SCNScene object, SceneKit loads all geometries and materials associated with the node and all its child nodes, or with the entire node hierarchy of the scene.You can observe the progress of this operation with the Progress class. For details, see Progress.
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1523375-prepare
	     */

	  }, {
	    key: 'prepare',
	    value: function prepare(objects) {
	      var completionHandler = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
	    }

	    // Working With Projected Scene Contents

	    /**
	     * Required. Searches the renderers scene for objects corresponding to a point in the rendered image.
	     * @access public
	     * @param {CGPoint} point - 
	     * @param {?Map<SCNHitTestOption, Object>} [options = null] - A dictionary of options affecting the search. See Hit Testing Options Keys for acceptable values.
	     * @returns {SCNHitTestResult[]} - 
	     * @desc A 2D point in the rendered screen coordinate space can refer to any point along a line segment in the 3D scene coordinate space. Hit-testing is the process of finding elements of a scene located along this line segment. For example, you can use this method to find the geometry corresponding to a click event in a SceneKit view.
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1522929-hittest
	     */

	  }, {
	    key: 'hitTest',
	    value: function hitTest(point) {
	      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

	      if (this.scene === null) {
	        return [];
	      }
	      var _options = new Map();
	      if (options instanceof Map) {
	        _options = options;
	      } else if (Array.isArray(options)) {
	        _options = new Map(options);
	      }

	      var cameraNode = this._getCameraNode();
	      cameraNode.camera._updateProjectionTransform(this._viewRect);
	      var from = new _SCNVector2.default(point.x, point.y, 0);
	      var to = new _SCNVector2.default(point.x, point.y, 1.0);

	      var useGPU = true;
	      if (!useGPU) {
	        return this._hitTestByCPU(cameraNode.viewProjectionTransform, from, to, _options);
	      }
	      return this._hitTestByGPU(cameraNode.viewProjectionTransform, from, to, _options);
	    }
	  }, {
	    key: '_initializeHitFrameBuffer',
	    value: function _initializeHitFrameBuffer() {
	      var gl = this.context;
	      var width = this._viewRect.size.width;
	      var height = this._viewRect.size.height;
	      this._hitFrameBuffer = gl.createFramebuffer();
	      this._hitDepthBuffer = gl.createRenderbuffer();
	      gl.bindFramebuffer(gl.FRAMEBUFFER, this._hitFrameBuffer);
	      gl.bindRenderbuffer(gl.RENDERBUFFER, this._hitDepthBuffer);
	      gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, width, height);

	      this._hitObjectIDTexture = gl.createTexture();
	      gl.bindTexture(gl.TEXTURE_2D, this._hitObjectIDTexture);
	      // texImage2D(target, level, internalformat, width, height, border, format, type, source)
	      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);

	      this._hitFaceIDTexture = gl.createTexture();
	      gl.bindTexture(gl.TEXTURE_2D, this._hitFaceIDTexture);
	      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);

	      this._hitPositionTexture = gl.createTexture();
	      gl.bindTexture(gl.TEXTURE_2D, this._hitPositionTexture);
	      //gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, width, height, 0, gl.RGB, gl.UNSIGNED_BYTE, null)
	      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);

	      this._hitNormalTexture = gl.createTexture();
	      gl.bindTexture(gl.TEXTURE_2D, this._hitNormalTexture);
	      //gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, width, height, 0, gl.RGB, gl.UNSIGNED_BYTE, null)
	      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);

	      //gl.framebufferRenderbuffer(target, attachment, renderbuffertarget, renderbuffer)
	      gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, this._hitDepthBuffer);
	      //gl.framebufferTexture2D(target, attachment, textarget, texture, level)
	      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this._hitObjectIDTexture, 0);
	      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT1, gl.TEXTURE_2D, this._hitFaceIDTexture, 0);
	      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT2, gl.TEXTURE_2D, this._hitPositionTexture, 0);
	      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT3, gl.TEXTURE_2D, this._hitNormalTexture, 0);
	      gl.drawBuffers([gl.COLOR_ATTACHMENT0, gl.COLOR_ATTACHMENT1, gl.COLOR_ATTACHMENT2, gl.COLOR_ATTACHMENT3]);

	      gl.bindRenderbuffer(gl.RENDERBUFFER, null);
	      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
	    }

	    /**
	     * @access private
	     * @param {SCNMatrix4} viewProjectionMatrix -
	     * @param {SCNVector3} from -
	     * @param {SCNVector3} to -
	     * @param {Object} options -
	     * @returns {SCNHitTestResult[]} -
	     */

	  }, {
	    key: '_hitTestByCPU',
	    value: function _hitTestByCPU(viewProjectionMatrix, from, to, options) {
	      var result = [];

	      var invVp = viewProjectionMatrix.invert();
	      var rayFrom = from.transform(invVp);
	      var rayTo = to.transform(invVp);
	      //console.log(`rayFrom: ${rayFrom.float32Array()}`)
	      //console.log(`rayTo  : ${rayTo.float32Array()}`)

	      var rayVec = rayTo.sub(rayFrom);
	      var renderingArray = this._createRenderingNodeArray();
	      //console.log(`renderingArray.length: ${renderingArray.length}`)

	      var categoryBitMask = options.get(_SCNHitTestOption2.default.categoryBitMask);
	      if (typeof categoryBitMask === 'undefined') {
	        categoryBitMask = -1;
	      }

	      var _iteratorNormalCompletion6 = true;
	      var _didIteratorError6 = false;
	      var _iteratorError6 = undefined;

	      try {
	        for (var _iterator6 = renderingArray[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
	          var node = _step6.value;

	          if (node.categoryBitMask & categoryBitMask) {
	            result.push.apply(result, _toConsumableArray(this._nodeHitTestByCPU(node, rayFrom, rayVec)));
	          }
	        }
	      } catch (err) {
	        _didIteratorError6 = true;
	        _iteratorError6 = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion6 && _iterator6.return) {
	            _iterator6.return();
	          }
	        } finally {
	          if (_didIteratorError6) {
	            throw _iteratorError6;
	          }
	        }
	      }

	      return result;
	    }

	    /**
	     * @access private
	     * @param {SCNMatrix4} viewProjectionTransform -
	     * @param {SCNVector3} rayFrom -
	     * @param {SCNVector3} rayTo -
	     * @param {Map} options -
	     * @returns {SCNHitTestResult[]} -
	     */

	  }, {
	    key: '_hitTestByGPU',
	    value: function _hitTestByGPU(viewProjectionTransform, from, to, options) {
	      var result = [];
	      var gl = this._context;

	      if (this._hitFrameBuffer === null) {
	        this._initializeHitFrameBuffer();
	      }
	      var hitTestProgram = this._defaultHitTestProgram._glProgram;
	      gl.useProgram(hitTestProgram);
	      gl.bindFramebuffer(gl.FRAMEBUFFER, this._hitFrameBuffer);

	      gl.depthMask(true);
	      gl.depthFunc(gl.LEQUAL);
	      gl.enable(gl.SCISSOR_TEST);
	      gl.disable(gl.BLEND);
	      gl.clearColor(0, 0, 0, 0);
	      gl.clearDepth(1.0);
	      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

	      var x = (from.x + 1.0) * 0.5 * this._viewRect.size.width;
	      var y = (from.y + 1.0) * 0.5 * this._viewRect.size.height;
	      var sx = x - 1;
	      var sy = y - 1;
	      if (sx < 0) {
	        sx = 0;
	      } else if (sx + 3 > this._viewRect.size.width) {
	        sx = this._viewRect.size.width - 3;
	      }
	      if (sy < 0) {
	        sy = 0;
	      } else if (sy + 3 > this._viewRect.size.height) {
	        sy = this._viewRect.size.width - 3;
	      }

	      gl.scissor(sx, sy, 3, 3);
	      gl.uniformMatrix4fv(gl.getUniformLocation(hitTestProgram, 'viewProjectionTransform'), false, viewProjectionTransform.float32Array());
	      var backFaceCulling = options.get(_SCNHitTestOption2.default.backFaceCulling);
	      if (typeof backFaceCulling === 'undefined') {
	        backFaceCulling = true;
	      }
	      if (backFaceCulling) {
	        gl.enable(gl.CULL_FACE);
	        gl.cullFace(gl.BACK);
	      } else {
	        gl.disable(gl.CULL_FACE);
	      }

	      var categoryBitMask = options.get(_SCNHitTestOption2.default.categoryBitMask);
	      if (typeof categoryBitMask === 'undefined') {
	        categoryBitMask = -1;
	      }
	      var ignoreHiddenNodes = options.get(_SCNHitTestOption2.default.ignoreHiddenNodes);
	      if (typeof ignoreHiddenNodes === 'undefined') {
	        ignoreHiddenNodes = true;
	      }

	      var renderingArray = this._createRenderingNodeArray();
	      var len = renderingArray.length;
	      for (var i = 0; i < len; i++) {
	        var node = renderingArray[i];
	        if ((node.categoryBitMask & categoryBitMask) === 0) {
	          continue;
	        }
	        if (ignoreHiddenNodes && node.isHidden) {
	          continue;
	        }
	        this._renderNodeForHitTest(node, i + 100, options);
	      }

	      var objectIDBuf = new Uint8Array(4);
	      gl.readBuffer(gl.COLOR_ATTACHMENT0);
	      gl.readPixels(x, y, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, objectIDBuf, 0);
	      var objectID = objectIDBuf[0] * 256 + objectIDBuf[1];
	      var geometryIndex = objectIDBuf[2] * 256 + objectIDBuf[3];

	      var faceIDBuf = new Uint8Array(4);
	      gl.readBuffer(gl.COLOR_ATTACHMENT1);
	      gl.readPixels(x, y, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, faceIDBuf, 0);
	      var faceIndex = faceIDBuf[0] * 16777216 + faceIDBuf[1] * 65536 + faceIDBuf[2] * 256 + faceIDBuf[3];

	      var positionBuf = new Uint8Array(4);
	      gl.readBuffer(gl.COLOR_ATTACHMENT2);
	      gl.readPixels(x, y, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, positionBuf, 0);
	      var screenPos = new _SCNVector2.default(positionBuf[0] / 127.5 - 1.0, positionBuf[1] / 127.5 - 1.0, positionBuf[2] / 127.5 - 1.0);
	      var position = screenPos.transform(viewProjectionTransform.invert());

	      var normalBuf = new Uint8Array(4);
	      gl.readBuffer(gl.COLOR_ATTACHMENT3);
	      gl.readPixels(x, y, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, normalBuf, 0);
	      var normal = new _SCNVector2.default(normalBuf[0] / 127.5 - 1.0, normalBuf[1] / 127.5 - 1.0, normalBuf[2] / 127.5 - 1.0);

	      //console.log('***** Hit Result *****')
	      //console.log(`objectID: ${objectID}`)
	      //console.log(`geometryIndex: ${geometryIndex}`)
	      //console.log(`faceIndex: ${faceIndex}`)
	      //console.log(`position: ${position.floatArray()}`)
	      //console.log(`normal: ${normal.floatArray()}`)
	      //console.log('**********************')

	      if (objectID >= 100) {
	        var r = new _SCNHitTestResult2.default();
	        var _node = renderingArray[objectID - 100];
	        var worldInv = _node.presentation._worldTransform.invert();
	        r._node = _node;
	        r._geometryIndex = geometryIndex;
	        r._faceIndex = faceIndex;
	        r._worldCoordinates = position;
	        r._worldNormal = normal;
	        r._modelTransform = _node.presentation._worldTransform;
	        r._localCoordinates = position.transform(worldInv);
	        r._localNormal = normal.transform(worldInv);

	        result.push(r);
	      }

	      gl.disable(gl.SCISSOR_TEST);
	      gl.bindFramebuffer(gl.FRAMEBUFFER, null);

	      return result;
	    }

	    /**
	     * @access private
	     * @param {SCNMatrix4} viewProjectionTransform -
	     * @param {SCNVector3} rayFrom -
	     * @param {SCNVector3} rayTo -
	     * @param {Map} options -
	     * @returns {SCNHitTestResult[]} -
	     */

	  }, {
	    key: '_physicsHitTestByGPU',
	    value: function _physicsHitTestByGPU(viewProjectionTransform, from, to, options) {
	      var result = [];
	      var gl = this._context;

	      if (this._hitFrameBuffer === null) {
	        this._initializeHitFrameBuffer();
	      }
	      var hitTestProgram = this._defaultHitTestProgram._glProgram;
	      gl.useProgram(hitTestProgram);
	      gl.bindFramebuffer(gl.FRAMEBUFFER, this._hitFrameBuffer);

	      gl.depthMask(true);
	      gl.depthFunc(gl.LEQUAL);
	      gl.enable(gl.SCISSOR_TEST);
	      gl.disable(gl.BLEND);
	      gl.clearColor(0, 0, 0, 0);
	      gl.clearDepth(1.0);
	      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

	      var x = (from.x + 1.0) * 0.5 * this._viewRect.size.width;
	      var y = (from.y + 1.0) * 0.5 * this._viewRect.size.height;
	      var sx = x - 1;
	      var sy = y - 1;
	      if (sx < 0) {
	        sx = 0;
	      } else if (sx + 3 > this._viewRect.size.width) {
	        sx = this._viewRect.size.width - 3;
	      }
	      if (sy < 0) {
	        sy = 0;
	      } else if (sy + 3 > this._viewRect.size.height) {
	        sy = this._viewRect.size.width - 3;
	      }

	      gl.scissor(sx, sy, 3, 3);
	      gl.uniformMatrix4fv(gl.getUniformLocation(hitTestProgram, 'viewProjectionTransform'), false, viewProjectionTransform.float32Array());
	      var backFaceCulling = options.get(_SCNPhysicsWorld2.default.TestOption.backfaceCulling);
	      if (typeof backFaceCulling === 'undefined') {
	        backFaceCulling = true;
	      }
	      if (backFaceCulling) {
	        gl.enable(gl.CULL_FACE);
	        gl.cullFace(gl.BACK);
	      } else {
	        gl.disable(gl.CULL_FACE);
	      }

	      var collisionBitMask = options.get(_SCNPhysicsWorld2.default.TestOption.collisionBitMask);
	      if (typeof collisionBitMask === 'undefined') {
	        collisionBitMask = -1;
	      }

	      var searchMode = options.get(_SCNPhysicsWorld2.default.TestOption.searchMode);
	      if (typeof searchMode === 'undefined') {
	        searchMode = _SCNPhysicsWorld2.default.TestSearchMode.closest;
	      }

	      var renderingArray = this._createRenderingPhysicsNodeArray();
	      var len = renderingArray.length;
	      for (var i = 0; i < len; i++) {
	        var node = renderingArray[i];
	        var body = node.physicsBody;
	        if ((body.categoryBitMask & collisionBitMask) === 0) {
	          continue;
	        }
	        this._renderPhysicsNodeForHitTest(node, i + 100, options);
	      }

	      var objectIDBuf = new Uint8Array(4);
	      gl.readBuffer(gl.COLOR_ATTACHMENT0);
	      gl.readPixels(x, y, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, objectIDBuf, 0);
	      var objectID = objectIDBuf[0] * 256 + objectIDBuf[1];
	      var geometryIndex = objectIDBuf[2] * 256 + objectIDBuf[3];

	      var faceIDBuf = new Uint8Array(4);
	      gl.readBuffer(gl.COLOR_ATTACHMENT1);
	      gl.readPixels(x, y, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, faceIDBuf, 0);
	      var faceIndex = faceIDBuf[0] * 16777216 + faceIDBuf[1] * 65536 + faceIDBuf[2] * 256 + faceIDBuf[3];

	      var positionBuf = new Uint8Array(4);
	      gl.readBuffer(gl.COLOR_ATTACHMENT2);
	      gl.readPixels(x, y, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, positionBuf, 0);
	      var screenPos = new _SCNVector2.default(positionBuf[0] / 127.5 - 1.0, positionBuf[1] / 127.5 - 1.0, positionBuf[2] / 127.5 - 1.0);
	      var position = screenPos.transform(viewProjectionTransform.invert());

	      var normalBuf = new Uint8Array(4);
	      gl.readBuffer(gl.COLOR_ATTACHMENT3);
	      gl.readPixels(x, y, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, normalBuf, 0);
	      var normal = new _SCNVector2.default(normalBuf[0] / 127.5 - 1.0, normalBuf[1] / 127.5 - 1.0, normalBuf[2] / 127.5 - 1.0);

	      //console.log('***** Hit Result *****')
	      //console.log(`objectID: ${objectID}`)
	      //console.log(`geometryIndex: ${geometryIndex}`)
	      //console.log(`faceIndex: ${faceIndex}`)
	      //console.log(`from: ${from.floatArray()}`)
	      //console.log(`to: ${to.floatArray()}`)
	      //console.log(`positionBuf: ${positionBuf[0]}, ${positionBuf[1]}, ${positionBuf[2]}`)
	      //console.log(`sPos: ${screenPos.floatArray()}`)
	      //console.log(`position: ${position.floatArray()}`)
	      //console.log(`normal: ${normal.floatArray()}`)
	      //console.log('**********************')

	      if (objectID >= 100) {
	        var r = new _SCNHitTestResult2.default();
	        var _node2 = renderingArray[objectID - 100];
	        var worldInv = _node2.presentation._worldTransform.invert();
	        r._node = _node2;
	        r._geometryIndex = geometryIndex;
	        r._faceIndex = faceIndex;
	        r._worldCoordinates = position;
	        r._worldNormal = normal;
	        r._modelTransform = _node2.presentation._worldTransform;
	        r._localCoordinates = position.transform(worldInv);
	        r._localNormal = normal.transform(worldInv);

	        result.push(r);
	      }

	      gl.disable(gl.SCISSOR_TEST);
	      gl.bindFramebuffer(gl.FRAMEBUFFER, null);

	      return result;
	    }

	    /**
	     * Required. Returns a Boolean value indicating whether a node might be visible from a specified point of view.
	     * @access public
	     * @param {SCNNode} node - The node whose visibility is to be tested.
	     * @param {SCNNode} pointOfView - A node defining a point of view, as used by the pointOfView property.
	     * @returns {boolean} - 
	     * @desc Any node containing a camera or spotlight may serve as a point of view (see the pointOfView property for details). Such a node defines a viewing frustuma portion of the scenes coordinate space, shaped like a truncated pyramid, that encloses all points visible from that point of view.Use this method to test whether a node lies within the viewing frustum defined by another node (which may or may not be the scene renderers current pointOfView node). For example, in a game scene containing multiple camera nodes, you could use this method to determine which camera is currently best for viewing a moving player character.Note that this method does not perform occlusion testing. That is, it returns true if the tested node lies within the specified viewing frustum regardless of whether that nodes contents are obscured by other geometry.
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1522647-isnode
	     */

	  }, {
	    key: 'isNodeInsideFrustumOf',
	    value: function isNodeInsideFrustumOf(node, pointOfView) {
	      return false;
	    }

	    /**
	     * Required. Returns all nodes that might be visible from a specified point of view.
	     * @access public
	     * @param {SCNNode} pointOfView - A node defining a point of view, as used by the pointOfView property.
	     * @returns {SCNNode[]} - 
	     * @desc Any node containing a camera or spotlight may serve as a point of view (see the pointOfView property for details). Such a node defines a viewing frustuma portion of the scenes coordinate space, shaped like a truncated pyramid, that encloses all points visible from that point of view.Use this method find all nodes whose content lies within the viewing frustum defined by another node (which may or may not be the scene renderers current pointOfView node).Note that this method does not perform occlusion testing. That is, the returned array includes any node that lies within the specified viewing frustum regardless of whether that nodes contents are obscured by other geometry.
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1522942-nodesinsidefrustum
	     */

	  }, {
	    key: 'nodesInsideFrustumOf',
	    value: function nodesInsideFrustumOf(pointOfView) {
	      return null;
	    }

	    /**
	     * Required. Projects a point from the 3D world coordinate system of the scene to the 2D pixel coordinate system of the renderer.
	     * @access public
	     * @param {SCNVector3} point - A point in the world coordinate system of the renderers scene.
	     * @returns {SCNVector3} - 
	     * @desc The z-coordinate of the returned point describes the depth of the projected point relative to the near and far clipping planes of the renderers viewing frustum (defined by its pointOfView node). Projecting a point on the near clipping plane returns a point whose z-coordinate is 0.0; projecting a point on the far clipping plane returns a point whose z-coordinate is 1.0.
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1524089-projectpoint
	     */

	  }, {
	    key: 'projectPoint',
	    value: function projectPoint(point) {
	      return null;
	    }

	    /**
	     * Required. Unprojects a point from the 2D pixel coordinate system of the renderer to the 3D world coordinate system of the scene.
	     * @access public
	     * @param {SCNVector3} point - A point in the screen-space (view, layer, or GPU viewport) coordinate system of the scene renderer.
	     * @returns {SCNVector3} - 
	     * @desc The z-coordinate of the point parameter describes the depth at which to unproject the point relative to the near and far clipping planes of the renderers viewing frustum (defined by its pointOfView node). Unprojecting a point whose z-coordinate is 0.0 returns a point on the near clipping plane; unprojecting a point whose z-coordinate is 1.0 returns a point on the far clipping plane.A 2D point in the rendered screen coordinate space can refer to any point along a line segment in the 3D scene coordinate space. To test for scene contents along this linefor example, to find the geometry corresponding to the location of a click event in a viewuse the hitTest(_:options:) method.
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1522631-unprojectpoint
	     */

	  }, {
	    key: 'unprojectPoint',
	    value: function unprojectPoint(point) {
	      return null;
	    }

	    // Customizing Scene Rendering with Metal
	    /**
	     * Required. The Metal render command encoder in use for the current SceneKit rendering pass.
	     * @type {?MTLRenderCommandEncoder}
	     * @desc Use this render command encoder to encode additional rendering commands before or after SceneKit draws its own content.This property is valid only during the SceneKit rendering loopthat is, within one of the methods defined in the SCNSceneRendererDelegate protocol. Accessing this property at any other time returns nil.
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1522609-currentrendercommandencoder
	     */

	  }, {
	    key: '_setContext',
	    value: function _setContext(context) {
	      this._context = context;
	      this._createDummyTexture();
	    }

	    // Working With Positional Audio

	    /**
	     * Required. The 3D audio mixing node SceneKit uses for positional audio effects.
	     * @type {AVAudioEnvironmentNode}
	     * @desc SceneKit uses this audio node to spatialize sounds from SCNAudioPlayer objects attached to nodes in the scene. You can use this object in conjunction with the audioEngine property to rearrange the audio graph to add other, non-spatialized audio sources or mix in audio processing effects.
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1523582-audioenvironmentnode
	     */

	  }, {
	    key: '_getProgramForGeometry',


	    /**
	     * @access private
	     * @param {SCNGeometry} geometry -
	     * @returns {SCNProgram} -
	     */
	    value: function _getProgramForGeometry(geometry) {
	      if (geometry.program !== null) {
	        //return geometry.program._glProgram
	        return geometry.program;
	      }
	      if (geometry._shadableHelper === null) {
	        //return this._defaultProgram._glProgram
	        return this._defaultProgram;
	      }

	      var gl = this.context;
	      var p = new _SCNProgram2.default();
	      p._glProgram = gl.createProgram();

	      var vsText = this._vertexShaderForGeometry(geometry);
	      var fsText = this._fragmentShaderForGeometry(geometry);

	      // initialize vertex shader
	      var vertexShader = gl.createShader(gl.VERTEX_SHADER);
	      gl.shaderSource(vertexShader, vsText);
	      gl.compileShader(vertexShader);
	      if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
	        var info = gl.getShaderInfoLog(vertexShader);
	        throw new Error('vertex shader compile error: ' + info);
	      }
	      p.vertexShader = vertexShader;

	      // initialize fragment shader
	      var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
	      gl.shaderSource(fragmentShader, fsText);
	      gl.compileShader(fragmentShader);
	      if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
	        var _info = gl.getShaderInfoLog(fragmentShader);
	        throw new Error('fragment shader compile error: ' + _info);
	      }
	      p.fragmentShader = fragmentShader;

	      gl.attachShader(p._glProgram, vertexShader);
	      gl.attachShader(p._glProgram, fragmentShader);

	      // link program object
	      gl.linkProgram(p._glProgram);
	      if (!gl.getProgramParameter(p._glProgram, gl.LINK_STATUS)) {
	        var _info2 = gl.getProgramInfoLog(p._glProgram);
	        throw new Error('program link error: ' + _info2);
	      }

	      geometry.program = p;

	      return p;
	    }
	  }, {
	    key: '_switchProgram',
	    value: function _switchProgram(program) {
	      if (this._currentProgram === program) {
	        return;
	      }

	      var gl = this.context;
	      gl.useProgram(program._glProgram);

	      // set dummy textures
	      program._setDummyTextureForContext(gl);

	      // set shadow textures
	      var lights = this._lightNodes;
	      for (var i = 0; i < lights.directionalShadow.length; i++) {
	        var node = lights.directionalShadow[i];
	        var symbol = 'TEXTURE' + (i + 8);
	        gl.activeTexture(gl[symbol]);
	        gl.bindTexture(gl.TEXTURE_2D, node.presentation.light._shadowDepthTexture);
	      }

	      // bind buffers
	      var cameraIndex = gl.getUniformBlockIndex(program._glProgram, 'cameraUniform');
	      gl.uniformBlockBinding(program._glProgram, cameraIndex, _cameraLoc);
	      gl.bindBufferBase(gl.UNIFORM_BUFFER, _cameraLoc, this._cameraBuffer);
	      var fogIndex = gl.getUniformBlockIndex(program._glProgram, 'fogUniform');
	      gl.uniformBlockBinding(program._glProgram, fogIndex, _fogLoc);
	      gl.bindBufferBase(gl.UNIFORM_BUFFER, _fogLoc, this._fogBuffer);
	      var lightIndex = gl.getUniformBlockIndex(program._glProgram, 'lightUniform');
	      gl.uniformBlockBinding(program._glProgram, lightIndex, _lightLoc);
	      gl.bindBufferBase(gl.UNIFORM_BUFFER, _lightLoc, this._lightBuffer);

	      this._currentProgram = program;
	    }

	    /**
	     * @access private
	     * @type {SCNProgram}
	     */

	  }, {
	    key: '_programForGeometry',


	    /**
	     * @access private
	     * @param {SCNGeometry} geometry -
	     * @returns {SCNProgram} -
	     */
	    value: function _programForGeometry(geometry) {}

	    /**
	     * @access private
	     * @returns {string} -
	     */

	  }, {
	    key: '_vertexShaderForGeometry',


	    /**
	     * @access private
	     * @param {SCNGeometry} geometry -
	     * @returns {string} -
	     */
	    value: function _vertexShaderForGeometry(geometry) {
	      return this._replaceTexts(_defaultVertexShader, geometry);
	    }

	    /**
	     * @access private
	     * @returns {string} -
	     */

	  }, {
	    key: '_fragmentShaderForGeometry',


	    /**
	     * @access private
	     * @param {SCNGeometry} geometry -
	     * @returns {string} -
	     */
	    value: function _fragmentShaderForGeometry(geometry) {
	      return this._replaceTexts(_defaultFragmentShader, geometry);
	    }

	    /**
	     * @access private
	     * @param {string} text -
	     * @param {SCNGeometry} geometry -
	     * @returns {string} -
	     */

	  }, {
	    key: '_replaceTexts',
	    value: function _replaceTexts(text, geometry) {
	      var vars = new Map();
	      var numAmbient = this._numLights[_SCNLight2.default.LightType.ambient];
	      var numDirectional = this._numLights[_SCNLight2.default.LightType.directional];
	      var numDirectionalShadow = this._numLights['directionalShadow'];
	      var numOmni = this._numLights[_SCNLight2.default.LightType.omni];
	      var numSpot = this._numLights[_SCNLight2.default.LightType.spot];
	      var numIES = this._numLights[_SCNLight2.default.LightType.IES];
	      var numProbe = this._numLights[_SCNLight2.default.LightType.probe];

	      vars.set('__NUM_AMBIENT_LIGHTS__', numAmbient);
	      vars.set('__NUM_DIRECTIONAL_LIGHTS__', numDirectional);
	      vars.set('__NUM_DIRECTIONAL_SHADOW_LIGHTS__', numDirectionalShadow);
	      vars.set('__NUM_OMNI_LIGHTS__', numOmni);
	      vars.set('__NUM_SPOT_LIGHTS__', numSpot);
	      vars.set('__NUM_IES_LIGHTS__', numIES);
	      vars.set('__NUM_PROBE_LIGHTS__', numProbe);

	      vars.set('__USE_SHADER_MODIFIER_GEOMETRY__', 0);
	      vars.set('__SHADER_MODIFIER_GEOMETRY__', '');
	      vars.set('__USE_SHADER_MODIFIER_SURFACE__', 0);
	      vars.set('__SHADER_MODIFIER_SURFACE__', '');
	      vars.set('__USE_SHADER_MODIFIER_FRAGMENT__', 0);
	      vars.set('__SHADER_MODIFIER_FRAGMENT__', '');

	      if (geometry && geometry._shadableHelper && geometry._shadableHelper._shaderModifiers) {
	        var modifiers = geometry._shadableHelper._shaderModifiers;
	        if (modifiers.SCNShaderModifierEntryPointGeometry) {
	          vars.set('__USE_SHADER_MODIFIER_GEOMETRY__', 1);
	          vars.set('__SHADER_MODIFIER_GEOMETRY__', modifiers.SCNShaderModifierEntryPointGeometry);
	        }
	        if (modifiers.SCNShaderModifierEntryPointSurface) {
	          vars.set('__USE_SHADER_MODIFIER_SURFACE__', 1);
	          vars.set('__SHADER_MODIFIER_SURFACE__', modifiers.SCNShaderModifierEntryPointSurface);
	        }
	        if (modifiers.SCNShaderModifierEntryPointFragment) {
	          vars.set('__USE_SHADER_MODIFIER_FRAGMENT__', 1);
	          vars.set('__SHADER_MODIFIER_FRAGMENT__', modifiers.SCNShaderModifierEntryPointFragment);
	        }
	      }

	      var lightDefinition = '';
	      var vsLighting = '';
	      var fsLighting = '';
	      if (numAmbient > 0) {
	        lightDefinition += 'AmbientLight ambient[NUM_AMBIENT_LIGHTS]; ';
	        vsLighting += _vsAmbient;
	        fsLighting += _fsAmbient;
	      }
	      if (numDirectional > 0) {
	        lightDefinition += 'DirectionalLight directional[NUM_DIRECTIONAL_LIGHTS]; ';
	        vsLighting += _vsDirectional;
	        fsLighting += _fsDirectional;
	      }
	      if (numDirectionalShadow > 0) {
	        lightDefinition += 'DirectionalShadowLight directionalShadow[NUM_DIRECTIONAL_SHADOW_LIGHTS]; ';
	        vsLighting += _vsDirectionalShadow;
	        for (var i = 0; i < numDirectionalShadow; i++) {
	          var fsDSText = _fsDirectionalShadow.replace(new RegExp('__I__', 'g'), i);
	          fsLighting += fsDSText;
	        }
	      }
	      if (numOmni > 0) {
	        lightDefinition += 'OmniLight omni[NUM_OMNI_LIGHTS]; ';
	        vsLighting += _vsOmni;
	        fsLighting += _fsOmni;
	      }
	      if (numSpot > 0) {
	        lightDefinition += 'OmniLight spot[NUM_OMNI_LIGHTS]; ';
	        vsLighting += _vsSpot;
	        fsLighting += _fsSpot;
	      }
	      if (numIES > 0) {
	        lightDefinition += 'IESLight ies[NUM_IES_LIGHTS]; ';
	        vsLighting += _vsIES;
	        fsLighting += _fsIES;
	      }
	      if (numProbe > 0) {
	        lightDefinition += 'ProbeLight probe[NUM_PROBE_LIGHTS]; ';
	        vsLighting += _vsProbe;
	        fsLighting += _fsProbe;
	      }
	      vars.set('__LIGHT_DEFINITION__', lightDefinition);
	      vars.set('__VS_LIGHTING__', vsLighting);
	      vars.set('__FS_LIGHTING__', fsLighting);

	      if (numDirectional + numDirectionalShadow + numOmni + numSpot > 0) {
	        var v = 'vec3 v_light[NUM_DIRECTIONAL_LIGHTS + NUM_DIRECTIONAL_SHADOW_LIGHTS + NUM_OMNI_LIGHTS + NUM_SPOT_LIGHTS]; ';
	        var vs = 'out ' + v;
	        var fs = 'in ' + v;
	        if (numDirectionalShadow > 0) {
	          vs += 'out vec4 v_directionalShadowDepth[NUM_DIRECTIONAL_SHADOW_LIGHTS]; ';
	          vs += 'out vec4 v_directionalShadowTexcoord[NUM_DIRECTIONAL_SHADOW_LIGHTS]; ';
	          fs += 'in vec4 v_directionalShadowDepth[NUM_DIRECTIONAL_SHADOW_LIGHTS]; ';
	          fs += 'in vec4 v_directionalShadowTexcoord[NUM_DIRECTIONAL_SHADOW_LIGHTS]; ';
	          for (var _i = 0; _i < numDirectionalShadow; _i++) {
	            //fs += 'uniform sampler2DShadow u_shadowMapTexture' + i + '; '
	            fs += 'uniform sampler2D u_shadowMapTexture' + _i + '; ';
	          }
	        }

	        vars.set('__VS_LIGHT_VARS__', vs);
	        vars.set('__FS_LIGHT_VARS__', fs);
	      } else {
	        vars.set('__VS_LIGHT_VARS__', '');
	        vars.set('__FS_LIGHT_VARS__', '');
	      }

	      var result = text;
	      vars.forEach(function (value, key) {
	        var rex = new RegExp(key, 'g');
	        result = result.replace(rex, value);
	      });

	      return result;
	    }
	  }, {
	    key: '_initializeVAO',
	    value: function _initializeVAO(node, program) {
	      var gl = this.context;
	      var geometry = node.presentation.geometry;
	      var baseGeometry = node.geometry;

	      // prepare vertex array data
	      //const vertexBuffer = geometry._createVertexBuffer(gl, baseGeometry)
	      var vertexBuffer = geometry._createVertexBuffer(gl, node);
	      // TODO: retain attribute locations
	      var positionLoc = gl.getAttribLocation(program, 'position');
	      var normalLoc = gl.getAttribLocation(program, 'normal');
	      var tangentLoc = gl.getAttribLocation(program, 'tangent');
	      var colorLoc = gl.getAttribLocation(program, 'color');
	      var texcoord0Loc = gl.getAttribLocation(program, 'texcoord0');
	      var texcoord1Loc = gl.getAttribLocation(program, 'texcoord1');
	      var boneIndicesLoc = gl.getAttribLocation(program, 'boneIndices');
	      var boneWeightsLoc = gl.getAttribLocation(program, 'boneWeights');

	      geometry._vertexArrayObjects = [];
	      var elementCount = node.presentation.geometry.geometryElements.length;
	      for (var i = 0; i < elementCount; i++) {
	        var element = node.presentation.geometry.geometryElements[i];
	        var material = node.presentation.geometry.materials[i];
	        var vao = gl.createVertexArray();
	        gl.bindVertexArray(vao);

	        // initialize vertex buffer
	        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);

	        gl.bindAttribLocation(program, positionLoc, 'position');
	        gl.bindAttribLocation(program, normalLoc, 'normal');
	        gl.bindAttribLocation(program, tangentLoc, 'tangent');
	        gl.bindAttribLocation(program, colorLoc, 'color');
	        gl.bindAttribLocation(program, texcoord0Loc, 'texcoord0');
	        gl.bindAttribLocation(program, texcoord1Loc, 'texcoord1');
	        gl.bindAttribLocation(program, boneIndicesLoc, 'boneIndices');
	        gl.bindAttribLocation(program, boneWeightsLoc, 'boneWeights');

	        // vertexAttribPointer(ulong idx, long size, ulong type, bool norm, long stride, ulong offset)

	        // position
	        var posSrc = geometry.getGeometrySourcesForSemantic(_SCNGeometrySource2.default.Semantic.vertex)[0];
	        if (posSrc) {
	          gl.enableVertexAttribArray(positionLoc);
	          gl.vertexAttribPointer(positionLoc, posSrc.componentsPerVector, gl.FLOAT, false, posSrc.dataStride, posSrc.dataOffset);
	        } else {
	          gl.disableVertexAttribArray(positionLoc);
	        }

	        // normal
	        var nrmSrc = geometry.getGeometrySourcesForSemantic(_SCNGeometrySource2.default.Semantic.normal)[0];
	        if (nrmSrc) {
	          gl.enableVertexAttribArray(normalLoc);
	          gl.vertexAttribPointer(normalLoc, nrmSrc.componentsPerVector, gl.FLOAT, false, nrmSrc.dataStride, nrmSrc.dataOffset);
	        } else {
	          gl.disableVertexAttribArray(normalLoc);
	        }

	        // tangent
	        var tanSrc = geometry.getGeometrySourcesForSemantic(_SCNGeometrySource2.default.Semantic.tangent)[0];
	        if (tanSrc) {
	          gl.enableVertexAttribArray(tangentLoc);
	          gl.vertexAttribPointer(tangentLoc, tanSrc.componentsPerVector, gl.FLOAT, false, tanSrc.dataStride, tanSrc.dataOffset);
	        } else {
	          gl.disableVertexAttribArray(tangentLoc);
	        }

	        // color
	        var colorSrc = geometry.getGeometrySourcesForSemantic(_SCNGeometrySource2.default.Semantic.color)[0];
	        if (colorSrc) {
	          gl.enableVertexAttribArray(colorLoc);
	          gl.vertexAttribPointer(colorLoc, colorSrc.componentsPerVector, gl.FLOAT, false, colorSrc.dataStride, colorSrc.dataOffset);
	        } else {
	          gl.disableVertexAttribArray(colorLoc);
	        }

	        // texcoord0
	        var tex0Src = geometry.getGeometrySourcesForSemantic(_SCNGeometrySource2.default.Semantic.texcoord)[0];
	        if (tex0Src) {
	          //console.log(`texSrc: ${texcoordLoc}, ${texSrc.componentsPerVector}, ${texSrc.dataStride}, ${texSrc.dataOffset}`)
	          gl.enableVertexAttribArray(texcoord0Loc);
	          gl.vertexAttribPointer(texcoord0Loc, tex0Src.componentsPerVector, gl.FLOAT, false, tex0Src.dataStride, tex0Src.dataOffset);
	        } else {
	          gl.disableVertexAttribArray(texcoord0Loc);
	        }

	        // texcoord1
	        var tex1Src = geometry.getGeometrySourcesForSemantic(_SCNGeometrySource2.default.Semantic.texcoord)[1];
	        if (tex1Src) {
	          gl.enableVertexAttribArray(texcoord1Loc);
	          gl.vertexAttribPointer(texcoord1Loc, tex1Src.componentsPerVector, gl.FLOAT, false, tex1Src.dataStride, tex1Src.dataOffset);
	        } else {
	          gl.disableVertexAttribArray(texcoord1Loc);
	        }

	        // boneIndices
	        var indSrc = node.skinner ? node.skinner._boneIndices : null;
	        if (indSrc) {
	          //console.log(`indSrc: ${boneIndicesLoc}, ${indSrc.componentsPerVector}, ${indSrc.dataStride}, ${indSrc.dataOffset}`)
	          gl.enableVertexAttribArray(boneIndicesLoc);
	          gl.vertexAttribPointer(boneIndicesLoc, indSrc.componentsPerVector, gl.FLOAT, false, indSrc.dataStride, indSrc.dataOffset);
	        } else {
	          gl.disableVertexAttribArray(boneIndicesLoc);
	        }

	        // boneWeights
	        var wgtSrc = node.skinner ? node.skinner._boneWeights : null;
	        if (wgtSrc) {
	          //console.log(`wgtSrc: ${boneWeightsLoc}, ${wgtSrc.componentsPerVector}, ${wgtSrc.dataStride}, ${wgtSrc.dataOffset}`)
	          gl.enableVertexAttribArray(boneWeightsLoc);
	          gl.vertexAttribPointer(boneWeightsLoc, wgtSrc.componentsPerVector, gl.FLOAT, false, wgtSrc.dataStride, wgtSrc.dataOffset);
	        } else {
	          gl.disableVertexAttribArray(boneWeightsLoc);
	        }

	        // FIXME: use setting
	        gl.disable(gl.CULL_FACE);

	        // initialize index buffer
	        // FIXME: check geometrySource semantic
	        var indexBuffer = element._createBuffer(gl);
	        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);

	        geometry._vertexArrayObjects.push(vao);
	      }
	    }
	  }, {
	    key: '_initializeShadowVAO',
	    value: function _initializeShadowVAO(node, program) {
	      var gl = this.context;
	      var geometry = node.presentation.geometry;
	      var baseGeometry = node.geometry;

	      // prepare vertex array data
	      var vertexBuffer = geometry._createVertexBuffer(gl, node);
	      // TODO: retain attribute locations
	      var positionLoc = gl.getAttribLocation(program, 'position');
	      var boneIndicesLoc = gl.getAttribLocation(program, 'boneIndices');
	      var boneWeightsLoc = gl.getAttribLocation(program, 'boneWeights');

	      geometry._shadowVAO = [];
	      var elementCount = node.presentation.geometry.geometryElements.length;
	      for (var i = 0; i < elementCount; i++) {
	        var element = node.presentation.geometry.geometryElements[i];
	        var material = node.presentation.geometry.materials[i];
	        var shadowVAO = gl.createVertexArray();
	        gl.bindVertexArray(shadowVAO);

	        // initialize vertex buffer
	        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);

	        gl.bindAttribLocation(program, positionLoc, 'position');
	        gl.bindAttribLocation(program, boneIndicesLoc, 'boneIndices');
	        gl.bindAttribLocation(program, boneWeightsLoc, 'boneWeights');

	        // vertexAttribPointer(ulong idx, long size, ulong type, bool norm, long stride, ulong offset)

	        // position
	        var posSrc = geometry.getGeometrySourcesForSemantic(_SCNGeometrySource2.default.Semantic.vertex)[0];
	        if (posSrc) {
	          gl.enableVertexAttribArray(positionLoc);
	          gl.vertexAttribPointer(positionLoc, posSrc.componentsPerVector, gl.FLOAT, false, posSrc.dataStride, posSrc.dataOffset);
	        } else {
	          gl.disableVertexAttribArray(positionLoc);
	        }

	        // boneIndices
	        var indSrc = node.skinner ? node.skinner._boneIndices : null;
	        if (indSrc) {
	          gl.enableVertexAttribArray(boneIndicesLoc);
	          gl.vertexAttribPointer(boneIndicesLoc, indSrc.componentsPerVector, gl.FLOAT, false, indSrc.dataStride, indSrc.dataOffset);
	        } else {
	          gl.disableVertexAttribArray(boneIndicesLoc);
	        }

	        // boneWeights
	        var wgtSrc = node.skinner ? node.skinner._boneWeights : null;
	        if (wgtSrc) {
	          gl.enableVertexAttribArray(boneWeightsLoc);
	          gl.vertexAttribPointer(boneWeightsLoc, wgtSrc.componentsPerVector, gl.FLOAT, false, wgtSrc.dataStride, wgtSrc.dataOffset);
	        } else {
	          gl.disableVertexAttribArray(boneWeightsLoc);
	        }

	        // FIXME: use setting
	        gl.disable(gl.CULL_FACE);

	        // initialize index buffer
	        // FIXME: check geometrySource semantic
	        var indexBuffer = element._createBuffer(gl);
	        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);

	        geometry._shadowVAO.push(shadowVAO);
	      }
	    }
	  }, {
	    key: '_initializeHitTestVAO',
	    value: function _initializeHitTestVAO(node, program) {
	      var physics = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

	      var gl = this.context;
	      var geometry = physics ? node.physicsBody.physicsShape._sourceGeometry : node.presentation.geometry;
	      var baseGeometry = physics ? geometry : node.geometry;

	      // TODO: retain attribute locations
	      var positionLoc = gl.getAttribLocation(program, 'position');
	      var normalLoc = gl.getAttribLocation(program, 'normal');
	      var boneIndicesLoc = gl.getAttribLocation(program, 'boneIndices');
	      var boneWeightsLoc = gl.getAttribLocation(program, 'boneWeights');

	      geometry._hitTestVAO = [];
	      var elementCount = geometry.geometryElements.length;
	      for (var i = 0; i < elementCount; i++) {
	        var element = geometry.geometryElements[i];
	        var vao = gl.createVertexArray();
	        gl.bindVertexArray(vao);

	        gl.bindBuffer(gl.ARRAY_BUFFER, geometry._vertexBuffer);

	        gl.bindAttribLocation(program, positionLoc, 'position');
	        gl.bindAttribLocation(program, normalLoc, 'normal');
	        gl.bindAttribLocation(program, boneIndicesLoc, 'boneIndices');
	        gl.bindAttribLocation(program, boneWeightsLoc, 'boneWeights');

	        // vertexAttribPointer(ulong idx, long size, ulong type, bool norm, long stride, ulong offset)

	        // position
	        var posSrc = geometry.getGeometrySourcesForSemantic(_SCNGeometrySource2.default.Semantic.vertex)[0];
	        if (posSrc) {
	          gl.enableVertexAttribArray(positionLoc);
	          gl.vertexAttribPointer(positionLoc, posSrc.componentsPerVector, gl.FLOAT, false, posSrc.dataStride, posSrc.dataOffset);
	        } else {
	          gl.disableVertexAttribArray(positionLoc);
	        }

	        // normal
	        var nrmSrc = geometry.getGeometrySourcesForSemantic(_SCNGeometrySource2.default.Semantic.normal)[0];
	        if (nrmSrc) {
	          gl.enableVertexAttribArray(normalLoc);
	          gl.vertexAttribPointer(normalLoc, nrmSrc.componentsPerVector, gl.FLOAT, false, nrmSrc.dataStride, nrmSrc.dataOffset);
	        } else {
	          gl.disableVertexAttribArray(normalLoc);
	        }

	        // boneIndices
	        var indSrc = node.skinner ? node.skinner._boneIndices : null;
	        if (indSrc) {
	          gl.enableVertexAttribArray(boneIndicesLoc);
	          gl.vertexAttribPointer(boneIndicesLoc, indSrc.componentsPerVector, gl.FLOAT, false, indSrc.dataStride, indSrc.dataOffset);
	        } else {
	          gl.disableVertexAttribArray(boneIndicesLoc);
	        }

	        // boneWeights
	        var wgtSrc = node.skinner ? node.skinner._boneWeights : null;
	        if (wgtSrc) {
	          gl.enableVertexAttribArray(boneWeightsLoc);
	          gl.vertexAttribPointer(boneWeightsLoc, wgtSrc.componentsPerVector, gl.FLOAT, false, wgtSrc.dataStride, wgtSrc.dataOffset);
	        } else {
	          gl.disableVertexAttribArray(boneWeightsLoc);
	        }

	        // initialize index buffer
	        // FIXME: check geometrySource semantic
	        var indexBuffer = element._createBuffer(gl);
	        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, element._buffer);

	        geometry._hitTestVAO.push(vao);
	      }
	    }
	  }, {
	    key: '_initializeCameraBuffer',
	    value: function _initializeCameraBuffer(program) {
	      var gl = this.context;

	      var cameraIndex = gl.getUniformBlockIndex(program, 'cameraUniform');

	      this._cameraBuffer = gl.createBuffer();
	      gl.uniformBlockBinding(program, cameraIndex, _cameraLoc);
	      gl.bindBufferBase(gl.UNIFORM_BUFFER, _cameraLoc, this._cameraBuffer);
	    }
	  }, {
	    key: '_initializeFogBuffer',
	    value: function _initializeFogBuffer(program) {
	      var gl = this.context;

	      var fogIndex = gl.getUniformBlockIndex(program, 'fogUniform');

	      this._fogBuffer = gl.createBuffer();
	      gl.uniformBlockBinding(program, fogIndex, _fogLoc);
	      gl.bindBufferBase(gl.UNIFORM_BUFFER, _fogLoc, this._fogBuffer);
	    }
	  }, {
	    key: '_initializeLightBuffer',
	    value: function _initializeLightBuffer(program) {
	      var gl = this.context;

	      var lightIndex = gl.getUniformBlockIndex(program, 'lightUniform');

	      this._lightBuffer = gl.createBuffer();
	      gl.uniformBlockBinding(program, lightIndex, _lightLoc);
	      gl.bindBufferBase(gl.UNIFORM_BUFFER, _lightLoc, this._lightBuffer);

	      for (var i = 0; i < this._lightNodes.directionalShadow.length; i++) {
	        var node = this._lightNodes.directionalShadow[i];
	        var symbol = 'TEXTURE' + (i + 8);
	        var name = 'u_shadowMapTexture' + i;

	        gl.uniform1i(gl.getUniformLocation(program, name), i + 8);
	        gl.activeTexture(gl[symbol]);
	        gl.bindTexture(gl.TEXTURE_2D, node.presentation.light._shadowDepthTexture);
	      }
	    }
	  }, {
	    key: '_initializeUBO',
	    value: function _initializeUBO(node, program) {
	      var gl = this.context;
	      var geometry = node.presentation.geometry;

	      var materialIndex = gl.getUniformBlockIndex(program, 'materialUniform');
	      geometry._materialBuffer = gl.createBuffer();
	      gl.uniformBlockBinding(program, materialIndex, _materialLoc);
	      gl.bindBufferBase(gl.UNIFORM_BUFFER, _materialLoc, geometry._materialBuffer);
	    }
	  }, {
	    key: '_updateVAO',
	    value: function _updateVAO(node) {
	      var gl = this.context;
	      var geometry = node.presentation.geometry;
	      var baseGeometry = node.geometry;

	      geometry._updateVertexBuffer(gl, baseGeometry);
	    }
	  }, {
	    key: '_createDummyTexture',
	    value: function _createDummyTexture() {
	      var gl = this.context;

	      var canvas = document.createElement('canvas');
	      canvas.width = 1;
	      canvas.height = 1;
	      var context = canvas.getContext('2d');
	      context.fillStyle = 'rgba(255, 255, 255, 1.0)';
	      context.fillRect(0, 0, 1, 1);

	      this.__dummyTexture = gl.createTexture();

	      gl.bindTexture(gl.TEXTURE_2D, this.__dummyTexture);
	      // texImage2D(target, level, internalformat, width, height, border, format, type, source)
	      // Safari complains that 'source' is not ArrayBufferView type, but WebGL2 should accept HTMLCanvasElement.
	      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, canvas);
	      gl.bindTexture(gl.TEXTURE_2D, null);
	    }

	    /**
	     * @access private
	     * @param {SCNProgram} program -
	     * @returns {void}
	     */
	    //_setDummyTextureAsDefault(program) {
	    //  const gl = this.context
	    //  const p = program

	    //  const texNames = [
	    //    gl.TEXTURE0,
	    //    gl.TEXTURE1,
	    //    gl.TEXTURE2,
	    //    gl.TEXTURE3,
	    //    gl.TEXTURE4,
	    //    gl.TEXTURE5,
	    //    gl.TEXTURE6,
	    //    gl.TEXTURE7
	    //  ]
	    //  const texSymbols = [
	    //    'u_emissionTexture',
	    //    'u_ambientTexture',
	    //    'u_diffuseTexture',
	    //    'u_specularTexture',
	    //    'u_reflectiveTexture',
	    //    'u_transparentTexture',
	    //    'u_multiplyTexture',
	    //    'u_normalTexture'
	    //  ]
	    //  for(let i=0; i<texNames.length; i++){
	    //    const texName = texNames[i]
	    //    const symbol = texSymbols[i]
	    //    gl.uniform1i(gl.getUniformLocation(p._glProgram, symbol), i)
	    //    gl.activeTexture(texName)
	    //    gl.bindTexture(gl.TEXTURE_2D, this.__dummyTexture)
	    //  }
	    //}

	  }, {
	    key: '_switchToDefaultCamera',
	    value: function _switchToDefaultCamera() {
	      if (this._pointOfView === null) {
	        this._defaultCameraPosNode.position = new _SCNVector2.default(0, 0, 0);
	        this._defaultCameraRotNode.rotation = new _SCNVector4.default(0, 0, 0, 0);
	        this._defaultCameraNode.position = new _SCNVector2.default(0, 0, _defaultCameraDistance);
	      } else if (this._pointOfView !== this._defaultCameraNode) {
	        var rot = this.pointOfView.presentation._worldRotation;
	        var rotMat = _SCNMatrix2.default.matrixWithRotation(rot);
	        var pos = this.pointOfView.presentation._worldTranslation;

	        this._defaultCameraPosNode.position = new _SCNVector2.default(0, 0, -_defaultCameraDistance).rotate(rotMat).add(pos);
	        this._defaultCameraRotNode.rotation = rot;
	        this._defaultCameraNode.position = new _SCNVector2.default(0, 0, _defaultCameraDistance);
	        console.log('pov defined: pov.pos: ' + this._pointOfView._worldTranslation.float32Array());
	        console.log('pov defined: node.pos: ' + this._defaultCameraNode._worldTranslation.float32Array());
	      }
	      this._pointOfView = this._defaultCameraNode;
	    }
	  }, {
	    key: '_setDefaultCameraOrientation',
	    value: function _setDefaultCameraOrientation(orientation) {
	      this._defaultCameraRotNode.orientation = orientation;
	    }
	  }, {
	    key: '_searchCameraNode',
	    value: function _searchCameraNode() {
	      var nodes = [this.scene._rootNode];
	      var node = nodes.shift();
	      while (node) {
	        if (node.camera !== null) {
	          return node;
	        }
	        nodes.push.apply(nodes, _toConsumableArray(node._childNodes));
	        node = nodes.shift();
	      }
	      return null;
	    }

	    /**
	     * @access private
	     * @returns {SCNVector3} -
	     */

	  }, {
	    key: '_getCameraPosition',
	    value: function _getCameraPosition() {
	      if (this._pointOfView === this._defaultCameraNode) {
	        return this._defaultCameraPosNode.position;
	      } else if (this._pointOfView === null) {
	        return new _SCNVector2.default(0, 0, 0);
	      }
	      var rot = this._getCameraOrientation();
	      var rotMat = _SCNMatrix2.default.matrixWithRotation(rot);
	      var pos = this._pointOfView.presentation._worldTranslation;
	      return pos.add(new _SCNVector2.default(0, 0, -_defaultCameraDistance).rotate(rotMat));
	    }

	    /**
	     * @access private
	     * @returns {SCNVector4} -
	     */

	  }, {
	    key: '_getCameraOrientation',
	    value: function _getCameraOrientation() {
	      if (this._pointOfView === this._defaultCameraNode) {
	        return this._defaultCameraRotNode.presentation.orientation;
	      } else if (this._pointOfView === null) {
	        return new _SCNVector4.default(0, 0, 0, 0);
	      }
	      return this._pointOfView.presentation._worldOrientation;
	    }

	    /**
	     * @access private
	     * @returns {number} -
	     */

	  }, {
	    key: '_getCameraDistance',
	    value: function _getCameraDistance() {
	      if (this._pointOfView === this._defaultCameraNode) {
	        return this._defaultCameraNode.presentation.position.z;
	      }
	      return _defaultCameraDistance;
	    }

	    /**
	     * @access private
	     * @returns {boolean} - true if the number of lights is changed.
	     */

	  }, {
	    key: '_numLightsChanged',
	    value: function _numLightsChanged() {
	      var changed = false;
	      var types = [].concat(_toConsumableArray(Object.values(_SCNLight2.default.LightType)), ['directionalShadow']);
	      var _iteratorNormalCompletion7 = true;
	      var _didIteratorError7 = false;
	      var _iteratorError7 = undefined;

	      try {
	        for (var _iterator7 = types[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
	          var type = _step7.value;

	          var num = this._lightNodes[type].length;
	          if (num !== this._numLights[type]) {
	            changed = true;
	            this._numLights[type] = num;
	          }
	        }
	      } catch (err) {
	        _didIteratorError7 = true;
	        _iteratorError7 = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion7 && _iterator7.return) {
	            _iterator7.return();
	          }
	        } finally {
	          if (_didIteratorError7) {
	            throw _iteratorError7;
	          }
	        }
	      }

	      return changed;
	    }

	    /**
	     * @access private
	     * @param {SCNNode} node -
	     * @param {SCNVector3} rayPoint - 
	     * @param {SCNVector3} rayVec -
	     * @returns {SCNHitTestResult[]} -
	     */

	  }, {
	    key: '_nodeHitTestByCPU',
	    value: function _nodeHitTestByCPU(node, rayPoint, rayVec) {
	      var result = [];
	      var geometry = node.presentation.geometry;
	      var invRay = rayVec.mul(-1);

	      console.log('rayPoint: ' + rayPoint.float32Array());
	      console.log('rayVec: ' + rayVec.float32Array());

	      //if(node.morpher !== null){
	      //  this._updateVAO(node)
	      //}

	      // TODO: test the bounding box/sphere first for performance

	      var source = geometry.getGeometrySourcesForSemantic(_SCNGeometrySource2.default.Semantic.vertex)[0];
	      var sourceLen = source.vectorCount;
	      var sourceData = [];
	      var modelTransform = node.presentation._worldTransform;
	      var skinningJoints = [];
	      if (node.presentation.skinner) {
	        var skinner = node.presentation.skinner;
	        var numBones = skinner._bones.length;
	        for (var i = 0; i < numBones; i++) {
	          var bone = skinner._bones[i];
	          var mat = skinner._boneInverseBindTransforms[i].mult(bone._presentation._worldTransform);
	          skinningJoints.push(mat);
	        }
	        for (var _i2 = 0; _i2 < sourceLen; _i2++) {
	          var weights = skinner._boneWeights._vectorAt(_i2);
	          var indices = skinner._boneIndices._vectorAt(_i2);
	          var _mat = new _SCNMatrix2.default();
	          for (var j = 0; j < skinner.numSkinningJoints; j++) {
	            _mat.add(skinningJoints[indices[j]].mul(weights[j]));
	          }
	          sourceData.push(source._scnVectorAt(_i2).transform(_mat));
	        }
	      } else {
	        for (var _i3 = 0; _i3 < sourceLen; _i3++) {
	          sourceData.push(source._scnVectorAt(_i3).transform(modelTransform));
	        }
	      }

	      var geometryCount = geometry.geometryElements.length;
	      for (var _i4 = 0; _i4 < geometryCount; _i4++) {
	        console.log('geometry element ' + _i4);
	        var element = geometry.geometryElements[_i4];
	        switch (element.primitiveType) {
	          case _SCNGeometryPrimitiveType2.default.line:
	            console.warn('hitTest for line is not implemented');
	            continue;
	          case _SCNGeometryPrimitiveType2.default.point:
	            console.warn('hitTest for point is not implemented');
	            continue;
	        }

	        var elementData = element._glData;
	        var len = element.primitiveCount;
	        console.log('primitiveCount: ' + len);
	        // TODO: check cull settings
	        for (var pi = 0; pi < len; pi++) {
	          var _indices = element._indexAt(pi);

	          var v0 = sourceData[_indices[0]];
	          var v1 = sourceData[_indices[1]];
	          var v2 = sourceData[_indices[2]];

	          var e1 = v1.sub(v0);
	          var e2 = v2.sub(v0);

	          var denom = this._det(e1, e2, invRay);
	          if (denom <= 0) {
	            continue;
	          }
	          denom = 1.0 / denom;

	          var d = rayPoint.sub(v0);
	          var u = this._det(d, e2, invRay) * denom;
	          if (u < 0 || u > 1) {
	            continue;
	          }

	          var v = this._det(e1, d, invRay) * denom;
	          if (v < 0 || v > 1) {
	            continue;
	          }

	          var t = this._det(e1, e2, d) * denom;
	          if (t < 0) {
	            continue;
	          }

	          // Hit!
	          console.log('Hit! ' + _i4 + ': ' + pi);
	          var hitPoint = rayPoint.add(rayVec.mul(t));
	          var invModel = modelTransform.invert();

	          var res = new _SCNHitTestResult2.default();
	          res._node = node;
	          res._geometryIndex = _i4;
	          res._faceIndex = pi;
	          res._worldCoordinates = hitPoint;
	          res._localCoordinates = hitPoint.transform(invModel);
	          var nom = e1.cross(e2);
	          res._worldNormal = nom.normalize();
	          res._localNormal = nom.transform(invModel);
	          res._modelTransform = modelTransform;
	          res._boneNode = null; // it should be array... what should I put here?
	          result.push(res);
	        }
	      }

	      return result;
	    }

	    /**
	     * @access private
	     * @type {SCNProgram}
	     */

	  }, {
	    key: '_setDummyParticleTextureAsDefault',
	    value: function _setDummyParticleTextureAsDefault() {
	      var gl = this.context;
	      var p = this._defaultParticleProgram;

	      var texNames = [gl.TEXTURE0
	      //gl.TEXTURE1
	      ];
	      var texSymbols = ['particleTexture'
	      //'colorTexture'
	      ];
	      for (var i = 0; i < texNames.length; i++) {
	        var texName = texNames[i];
	        var symbol = texSymbols[i];
	        gl.uniform1i(gl.getUniformLocation(p._glProgram, symbol), i);
	        gl.activeTexture(texName);
	        gl.bindTexture(gl.TEXTURE_2D, this.__dummyTexture);
	      }
	    }

	    /**
	     * @access private
	     * @type {SCNProgram}
	     */

	  }, {
	    key: '_showShadowMapOfLight',


	    // for debug
	    value: function _showShadowMapOfLight(lightNode) {
	      var gl = this.context;
	      var p = lightNode.presentation;
	      var light = p.light;
	      if (!this.__debugShadowMapSprite) {
	        var node = new _SKSpriteNode2.default();
	        node.size = new _CGSize2.default(100, 100);
	        node.anchorPoint = new _CGPoint2.default(0.0, 0.0);
	        var texture = new _SKTexture2.default();
	        texture._glTexture = light._shadowDepthTexture;
	        texture._image = {
	          naturalWidth: 100,
	          naturalHeight: 100
	        };
	        node._texture = texture;
	        node.__presentation = node.copy();
	        node.__presentation._isPresentationInstance = true;
	        node.position = new _CGPoint2.default(100, 100);
	        node._updateWorldTransform();

	        this.__debugShadowMapSprite = node;
	      }
	      gl.clearDepth(-1);
	      gl.clearStencil(0);
	      gl.depthMask(true);
	      gl.enable(gl.DEPTH_TEST);
	      gl.disable(gl.CULL_FACE);
	      gl.depthFunc(gl.GEQUAL);
	      gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
	      gl.clear(gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);

	      this._renderSKNode(this.__debugShadowMapSprite);
	    }
	  }, {
	    key: '_setViewPort',
	    value: function _setViewPort() {
	      var width = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
	      var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

	      var w = width;
	      var h = height;
	      if (w === null || h === null) {
	        w = this._viewRect.size.width;
	        h = this._viewRect.size.height;
	      }
	      this.context.viewport(0, 0, w, h);
	    }

	    /**
	     * calculate a determinant of 3x3 matrix from 3 vectors.
	     * @access private
	     * @param {SCNVector3} v1 -
	     * @param {SCNVector3} v2 -
	     * @param {SCNVector3} v3 -
	     * @returns {number} -
	     */

	  }, {
	    key: '_det',
	    value: function _det(v1, v2, v3) {
	      return v1.x * v2.y * v3.z + v1.y * v2.z * v3.x + v1.z * v2.x * v3.y - v1.x * v2.z * v3.y - v1.y * v2.x * v3.z - v1.z * v2.y * v3.x;
	    }
	  }, {
	    key: 'nextFrameTime',
	    get: function get() {
	      return this._nextFrameTime;
	    }
	  }, {
	    key: 'pointOfView',
	    get: function get() {
	      return this._getCameraNode();
	    }

	    /**
	     * Required. The node from which the scenes contents are viewed for rendering.
	     * @type {?SCNNode}
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1523982-pointofview
	     */
	    ,
	    set: function set(newValue) {
	      this._pointOfView = newValue;
	    }

	    /**
	     * Required. The graphics technology SceneKit uses to render the scene.
	     * @type {SCNRenderingAPI}
	     * @desc You choose a graphics technology when initializing a scene renderer:When initializing a SCNView object, use the init(frame:options:) initializer and the preferredRenderingAPI key. Alternatively, create a view in Interface Builder and use the Rendering API control in the inspector. During initialization, the view will attempt to use the preferred API, but will fall back to a different API if the preferred one is not supported on the current hardware.To create a SCNRenderer object that renders into your own OpenGL contect, use the init(context:options:) initializer. To create a renderer for use in your own Metal workflow, use the init(device:options:) initializer.The rendering technology used by a SCNLayer object is determined by Core Animation.After initializing a renderer, this property reflects the rendering technology in use.
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1522616-renderingapi
	     */

	  }, {
	    key: 'renderingAPI',
	    get: function get() {
	      return this._renderingAPI;
	    }
	  }, {
	    key: 'currentRenderCommandEncoder',
	    get: function get() {
	      return this._currentRenderCommandEncoder;
	    }

	    /**
	     * Required. The Metal device this renderer uses for rendering.
	     * @type {?MTLDevice}
	     * @desc Use this property to create or look up other Metal resources that use the same device as your SceneKit renderer.NoteThis property is valid only for scene renderers whose renderingAPI value is metal. You create a SceneKit view that renders using Metal with the preferredRenderingAPI initialization option or in Interface Builder, or an SCNRenderer that uses Metal with the init(device:options:) method. For OpenGL-based scene renderers, this propertys value is always nil.
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1523935-device
	     */

	  }, {
	    key: 'device',
	    get: function get() {
	      return this._device;
	    }

	    /**
	     * Required. The Metal command queue this renderer uses for rendering.
	     * @type {?MTLCommandQueue}
	     * @desc Use this property to schedule additional command buffers for the Metal device to execute as part of the render cycle. For example, you can use a compute command encoder to modify the vertex data in a Metal buffer for use by a SCNGeometrySource object.NoteThis property is valid only for scene renderers whose renderingAPI value is metal. You create a SceneKit view that renders using Metal with the preferredRenderingAPI initialization option or in Interface Builder, or an SCNRenderer that uses Metal with the init(device:options:) method. For OpenGL-based scene renderers, this propertys value is always nil.
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1523974-commandqueue
	     */

	  }, {
	    key: 'commandQueue',
	    get: function get() {
	      return this._commandQueue;
	    }

	    /**
	     * Required. The Metal pixel format for the renderers color output.
	     * @type {MTLPixelFormat}
	     * @desc Use this property, along with the depthPixelFormat and stencilPixelFormat properties, if you perform custom drawing with Metal (see the SCNSceneRendererDelegate and SCNNodeRendererDelegate classes) and need to create a new MTLRenderPipelineState object to change the GPU state as part of your rendering.NoteThis property is valid only for scene renderers whose renderingAPI value is metal. You create a SceneKit view that renders using Metal with the preferredRenderingAPI initialization option or in Interface Builder, or an SCNRenderer that uses Metal with the init(device:options:) method. For OpenGL-based scene renderers, this propertys value is always nil.
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1523701-colorpixelformat
	     */

	  }, {
	    key: 'colorPixelFormat',
	    get: function get() {
	      return this._colorPixelFormat;
	    }

	    /**
	     * Required. The Metal pixel format for the renderers depth buffer.
	     * @type {MTLPixelFormat}
	     * @desc Use this property, along with the colorPixelFormat and stencilPixelFormat properties, if you perform custom drawing with Metal (see the SCNSceneRendererDelegate and SCNNodeRendererDelegate classes) and need to create a new MTLRenderPipelineState object to change the GPU state as part of your rendering.NoteThis property is valid only for scene renderers whose renderingAPI value is metal. You create a SceneKit view that renders using Metal with the preferredRenderingAPI initialization option or in Interface Builder, or an SCNRenderer that uses Metal with the init(device:options:) method. For OpenGL-based scene renderers, this propertys value is always nil.
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1523780-depthpixelformat
	     */

	  }, {
	    key: 'depthPixelFormat',
	    get: function get() {
	      return this._depthPixelFormat;
	    }

	    /**
	     * Required. The Metal pixel format for the renderers stencil buffer.
	     * @type {MTLPixelFormat}
	     * @desc Use this property, along with the depthPixelFormat and colorPixelFormat properties, if you perform custom drawing with Metal (see the SCNSceneRendererDelegate and SCNNodeRendererDelegate classes) and need to create a new MTLRenderPipelineState object to change the GPU state as part of your rendering.NoteThis property is valid only for scene renderers whose renderingAPI value is metal. You create a SceneKit view that renders using Metal with the preferredRenderingAPI initialization option or in Interface Builder, or an SCNRenderer that uses Metal with the init(device:options:) method. For OpenGL-based scene renderers, this propertys value is always nil.
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1523315-stencilpixelformat
	     */

	  }, {
	    key: 'stencilPixelFormat',
	    get: function get() {
	      return this._stencilPixelFormat;
	    }

	    // Customizing Scene Rendering with OpenGL

	    /**
	     * Required. The OpenGL rendering context that SceneKit uses for rendering the scene.
	     * @type {?Object}
	     * @desc In macOS, the value of this property is a Core OpenGL cglContextObj object.In iOS, the value of this property is an EAGLContext object.
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1522840-context
	     */

	  }, {
	    key: 'context',
	    get: function get() {
	      return this._context;
	    }
	  }, {
	    key: 'audioEnvironmentNode',
	    get: function get() {
	      return this._audioEnvironmentNode;
	    }

	    /**
	     * Required. The audio engine SceneKit uses for playing scene sounds.
	     * @type {AVAudioEngine}
	     * @desc SceneKit uses this audio engine to play sounds from SCNAudioPlayer objects attached to nodes in the scene. You can use this object directly to add other sound sources not related to scene contents, or to add other sound processing nodes or mixing nodes to the audio engine. To identify the node SceneKit uses for spatializing scene sounds when connecting other nodes, use the audioEnvironmentNode property.
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1522686-audioengine
	     */

	  }, {
	    key: 'audioEngine',
	    get: function get() {
	      return this._audioEngine;
	    }
	  }, {
	    key: '_defaultProgram',
	    get: function get() {
	      var numLightsChanged = this._numLightsChanged();
	      if (this.__defaultProgram !== null && !numLightsChanged) {
	        return this.__defaultProgram;
	      }

	      var gl = this.context;
	      if (this.__defaultProgram === null) {
	        this.__defaultProgram = new _SCNProgram2.default();
	        this.__defaultProgram._glProgram = gl.createProgram();
	      }
	      var p = this.__defaultProgram;
	      var vsText = this._defaultVertexShader;
	      var fsText = this._defaultFragmentShader;

	      // initialize vertex shader
	      var vertexShader = gl.createShader(gl.VERTEX_SHADER);
	      gl.shaderSource(vertexShader, vsText);
	      gl.compileShader(vertexShader);
	      if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
	        var info = gl.getShaderInfoLog(vertexShader);
	        throw new Error('vertex shader compile error: ' + info);
	      }
	      this.__defaultProgram.vertexShader = vertexShader;

	      // initialize fragment shader
	      var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
	      gl.shaderSource(fragmentShader, fsText);
	      gl.compileShader(fragmentShader);
	      if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
	        var _info3 = gl.getShaderInfoLog(fragmentShader);
	        throw new Error('fragment shader compile error: ' + _info3);
	      }
	      this.__defaultProgram.fragmentShader = fragmentShader;

	      gl.attachShader(p._glProgram, vertexShader);
	      gl.attachShader(p._glProgram, fragmentShader);

	      // link program object
	      gl.linkProgram(p._glProgram);
	      if (!gl.getProgramParameter(p._glProgram, gl.LINK_STATUS)) {
	        var _info4 = gl.getProgramInfoLog(p._glProgram);
	        throw new Error('program link error: ' + _info4);
	      }

	      //gl.useProgram(p._glProgram)
	      this._switchProgram(p);

	      gl.enable(gl.DEPTH_TEST);
	      gl.depthFunc(gl.LEQUAL);
	      gl.enable(gl.BLEND);
	      gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
	      gl.enable(gl.CULL_FACE);
	      gl.cullFace(gl.BACK);

	      // set default textures to prevent warnings
	      //this._setDummyTextureAsDefault(p)

	      return this.__defaultProgram;
	    }
	  }, {
	    key: '_defaultVertexShader',
	    get: function get() {
	      return this._replaceTexts(_defaultVertexShader);
	    }
	  }, {
	    key: '_defaultFragmentShader',
	    get: function get() {
	      return this._replaceTexts(_defaultFragmentShader);
	    }
	  }, {
	    key: '_dummyTexture',
	    get: function get() {
	      return this.__dummyTexture;
	    }
	  }, {
	    key: '_defaultParticleProgram',
	    get: function get() {
	      if (this.__defaultParticleProgram !== null) {
	        return this.__defaultParticleProgram;
	      }
	      var gl = this.context;
	      if (this.__defaultParticleProgram === null) {
	        this.__defaultParticleProgram = new _SCNProgram2.default();
	        this.__defaultParticleProgram._glProgram = gl.createProgram();
	      }
	      var p = this.__defaultParticleProgram;
	      var vsText = _defaultParticleVertexShader;
	      var fsText = _defaultParticleFragmentShader;

	      // initialize vertex shader
	      var vertexShader = gl.createShader(gl.VERTEX_SHADER);
	      gl.shaderSource(vertexShader, vsText);
	      gl.compileShader(vertexShader);
	      if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
	        var info = gl.getShaderInfoLog(vertexShader);
	        throw new Error('particle vertex shader compile error: ' + info);
	      }

	      // initialize fragment shader
	      var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
	      gl.shaderSource(fragmentShader, fsText);
	      gl.compileShader(fragmentShader);
	      if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
	        var _info5 = gl.getShaderInfoLog(fragmentShader);
	        throw new Error('particle fragment shader compile error: ' + _info5);
	      }

	      gl.attachShader(p._glProgram, vertexShader);
	      gl.attachShader(p._glProgram, fragmentShader);

	      // link program object
	      gl.linkProgram(p._glProgram);
	      if (!gl.getProgramParameter(p._glProgram, gl.LINK_STATUS)) {
	        var _info6 = gl.getProgramInfoLog(p._glProgram);
	        throw new Error('program link error: ' + _info6);
	      }

	      gl.useProgram(p._glProgram);
	      //gl.clearColor(1, 1, 1, 1)
	      //gl.clearDepth(1.0)
	      //gl.clearStencil(0)

	      gl.enable(gl.DEPTH_TEST);
	      gl.depthFunc(gl.LEQUAL);
	      gl.enable(gl.BLEND);
	      gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
	      gl.enable(gl.CULL_FACE);
	      gl.cullFace(gl.BACK);

	      // set default textures to prevent warnings
	      this._setDummyParticleTextureAsDefault();

	      return this.__defaultParticleProgram;
	    }

	    /**
	     * @access private
	     * @type {SCNProgram}
	     */

	  }, {
	    key: '_defaultShadowProgram',
	    get: function get() {
	      if (this.__defaultShadowProgram !== null) {
	        return this.__defaultShadowProgram;
	      }
	      var gl = this.context;
	      if (this.__defaultShadowProgram === null) {
	        this.__defaultShadowProgram = new _SCNProgram2.default();
	        this.__defaultShadowProgram._glProgram = gl.createProgram();
	      }
	      var p = this.__defaultShadowProgram;
	      var vsText = _defaultShadowVertexShader;
	      var fsText = _defaultShadowFragmentShader;

	      // initialize vertex shader
	      var vertexShader = gl.createShader(gl.VERTEX_SHADER);
	      gl.shaderSource(vertexShader, vsText);
	      gl.compileShader(vertexShader);
	      if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
	        var info = gl.getShaderInfoLog(vertexShader);
	        throw new Error('particle vertex shader compile error: ' + info);
	      }

	      // initialize fragment shader
	      var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
	      gl.shaderSource(fragmentShader, fsText);
	      gl.compileShader(fragmentShader);
	      if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
	        var _info7 = gl.getShaderInfoLog(fragmentShader);
	        throw new Error('particle fragment shader compile error: ' + _info7);
	      }

	      gl.attachShader(p._glProgram, vertexShader);
	      gl.attachShader(p._glProgram, fragmentShader);

	      // link program object
	      gl.linkProgram(p._glProgram);
	      if (!gl.getProgramParameter(p._glProgram, gl.LINK_STATUS)) {
	        var _info8 = gl.getProgramInfoLog(p._glProgram);
	        throw new Error('program link error: ' + _info8);
	      }

	      gl.useProgram(p._glProgram);
	      //gl.clearColor(1, 1, 1, 1)
	      //gl.clearDepth(1.0)
	      //gl.clearStencil(0)

	      gl.enable(gl.DEPTH_TEST);
	      gl.depthFunc(gl.LEQUAL);
	      //gl.enable(gl.BLEND)
	      gl.disable(gl.BLEND);
	      //gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA)
	      gl.enable(gl.CULL_FACE);
	      gl.cullFace(gl.BACK);

	      return this.__defaultShadowProgram;
	    }
	  }, {
	    key: '_defaultHitTestProgram',
	    get: function get() {
	      if (this.__defaultHitTestProgram !== null) {
	        return this.__defaultHitTestProgram;
	      }
	      var gl = this.context;
	      if (this.__defaultHitTestProgram === null) {
	        this.__defaultHitTestProgram = new _SCNProgram2.default();
	        this.__defaultHitTestProgram._glProgram = gl.createProgram();
	      }
	      var p = this.__defaultHitTestProgram;
	      var vsText = _defaultHitTestVertexShader;
	      var fsText = _defaultHitTestFragmentShader;

	      // initialize vertex shader
	      var vertexShader = gl.createShader(gl.VERTEX_SHADER);
	      gl.shaderSource(vertexShader, vsText);
	      gl.compileShader(vertexShader);
	      if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
	        var info = gl.getShaderInfoLog(vertexShader);
	        throw new Error('hitTest vertex shader compile error: ' + info);
	      }

	      // initialize fragment shader
	      var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
	      gl.shaderSource(fragmentShader, fsText);
	      gl.compileShader(fragmentShader);
	      if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
	        var _info9 = gl.getShaderInfoLog(fragmentShader);
	        throw new Error('hitTest fragment shader compile error: ' + _info9);
	      }

	      gl.attachShader(p._glProgram, vertexShader);
	      gl.attachShader(p._glProgram, fragmentShader);

	      // link program object
	      gl.linkProgram(p._glProgram);
	      if (!gl.getProgramParameter(p._glProgram, gl.LINK_STATUS)) {
	        var _info10 = gl.getProgramInfoLog(p._glProgram);
	        throw new Error('program link error: ' + _info10);
	      }

	      gl.useProgram(p._glProgram);
	      //gl.clearColor(1, 1, 1, 1)
	      //gl.clearDepth(1.0)
	      //gl.clearStencil(0)

	      gl.enable(gl.DEPTH_TEST);
	      gl.depthFunc(gl.LEQUAL);
	      gl.enable(gl.BLEND);
	      gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
	      gl.enable(gl.CULL_FACE);
	      gl.cullFace(gl.BACK);

	      //this._setDummyHitTestTextureAsDefault()

	      return this.__defaultHitTestProgram;
	    }
	  }]);

	  return SCNRenderer;
	}(_NSObject3.default);

	exports.default = SCNRenderer;

/***/ },
/* 89 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _SCNScene = __webpack_require__(90);

	var _SCNScene2 = _interopRequireDefault(_SCNScene);

	var _SCNNode = __webpack_require__(65);

	var _SCNNode2 = _interopRequireDefault(_SCNNode);

	var _SCNDebugOptions = __webpack_require__(120);

	var _SCNDebugOptions2 = _interopRequireDefault(_SCNDebugOptions);

	var _SCNRenderingAPI = __webpack_require__(121);

	var _SCNRenderingAPI2 = _interopRequireDefault(_SCNRenderingAPI);

	var _SCNHitTestResult = __webpack_require__(106);

	var _SCNHitTestResult2 = _interopRequireDefault(_SCNHitTestResult);

	var _CGPoint = __webpack_require__(7);

	var _CGPoint2 = _interopRequireDefault(_CGPoint);

	var _SCNHitTestOption = __webpack_require__(122);

	var _SCNHitTestOption2 = _interopRequireDefault(_SCNHitTestOption);

	var _SCNVector = __webpack_require__(44);

	var _SCNVector2 = _interopRequireDefault(_SCNVector);

	var _SCNSceneRendererDelegate = __webpack_require__(123);

	var _SCNSceneRendererDelegate2 = _interopRequireDefault(_SCNSceneRendererDelegate);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	/**
	 * Methods and properties common to the SCNView, SCNLayer and SCNRenderer classes.
	 * @interface
	 * @see https://developer.apple.com/reference/scenekit/scnscenerenderer
	 */
	var SCNSceneRenderer = function () {
	  /**
	   * constructor
	   * @access public
	   * @returns {void}
	   */
	  function SCNSceneRenderer() {
	    _classCallCheck(this, SCNSceneRenderer);

	    // Presenting a Scene

	    /**
	     * Required. The scene to be displayed.
	     * @type {?SCNScene}
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1523956-scene
	     */
	    this.scene = null;

	    // Managing Scene Display

	    /**
	     * Required. The node from which the scenes contents are viewed for rendering.
	     * @type {?SCNNode}
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1523982-pointofview
	     */
	    this.pointOfView = null;

	    /**
	     * Required. A Boolean value that determines whether SceneKit automatically adds lights to a scene.
	     * @type {boolean}
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1523812-autoenablesdefaultlighting
	     */
	    this.autoenablesDefaultLighting = false;

	    /**
	     * Required. A Boolean value that determines whether SceneKit applies jittering to reduce aliasing artifacts.
	     * @type {boolean}
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1524026-isjitteringenabled
	     */
	    this.isJitteringEnabled = false;

	    /**
	     * Required. A Boolean value that determines whether SceneKit displays rendering performance statistics in an accessory view.
	     * @type {boolean}
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1522763-showsstatistics
	     */
	    this.showsStatistics = false;

	    /**
	     * Required. Options for drawing overlay content in a scene that can aid debugging.
	     * @type {SCNDebugOptions}
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1523281-debugoptions
	     */
	    this.debugOptions = null;

	    this._renderingAPI = null;

	    // Managing Scene Animation Timing

	    /**
	     * Required. The current scene time.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1522680-scenetime
	     */
	    this.sceneTime = 0;

	    /**
	     * Required. A Boolean value that determines whether the scene is playing.
	     * @type {boolean}
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1523401-isplaying
	     */
	    this.isPlaying = false;

	    /**
	     * Required. A Boolean value that determines whether SceneKit restarts the scene time after all animations in the scene have played.
	     * @type {boolean}
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1522878-loops
	     */
	    this.loops = false;

	    // Participating in the Scene Rendering Process

	    /**
	     * Required. A delegate object that receives messages about SceneKits rendering process.
	     * @type {?SCNSceneRendererDelegate}
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1522671-delegate
	     */
	    this.delegate = null;

	    // Customizing Scene Rendering with Metal

	    this._currentRenderCommandEncoder = null;
	    this._device = null;
	    this._commandQueue = null;
	    this._colorPixelFormat = null;
	    this._depthPixelFormat = null;
	    this._stencilPixelFormat = null;

	    // Customizing Scene Rendering with OpenGL

	    this._context = null;

	    // Rendering Sprite Kit Content over a Scene

	    /**
	     * Required. A Sprite Kit scene to be rendered on top of the SceneKit content.
	     * @type {?SKScene}
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1524051-overlayskscene
	     */
	    this.overlaySKScene = null;

	    // Working With Positional Audio

	    /**
	     * Required. The node representing the listeners position in the scene for use with positional audio effects.
	     * @type {?SCNNode}
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1523747-audiolistener
	     */
	    this.audioListener = null;

	    this._audioEnvironmentNode = null;
	    this._audioEngine = null;

	    // Instance Properties

	    /**
	     * Required. 
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1522854-currenttime
	     */
	    this.currentTime = 0;
	  }

	  // Presenting a Scene

	  /**
	   * Required. Displays the specified scene with an animated transition.
	   * @access public
	   * @param {SCNScene} scene - The new scene to be displayed.
	   * @param {SKTransition} transition - An object that specifies the duration and style of the animated transition.
	   * @param {?SCNNode} pointOfView - The node to use as the pointOfView property when displaying the new scene.
	   * @param {?function(): void} [completionHandler = null] - A block that SceneKit calls after the transition animation has completed.This block takes no parameters and has no return value.
	   * @returns {void}
	   * @desc Use this method to change the scene displayed in a SceneKit view (or other renderer) with an animated transition. For details on transition styles, see SKTransition.
	   * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1523028-present
	   */


	  _createClass(SCNSceneRenderer, [{
	    key: 'presentWithIncomingPointOfView',
	    value: function presentWithIncomingPointOfView(scene, transition, pointOfView) {
	      var completionHandler = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
	    }

	    // Managing Scene Display
	    /**
	     * Required. The graphics technology SceneKit uses to render the scene.
	     * @type {SCNRenderingAPI}
	     * @desc You choose a graphics technology when initializing a scene renderer:When initializing a SCNView object, use the init(frame:options:) initializer and the preferredRenderingAPI key. Alternatively, create a view in Interface Builder and use the Rendering API control in the inspector. During initialization, the view will attempt to use the preferred API, but will fall back to a different API if the preferred one is not supported on the current hardware.To create a SCNRenderer object that renders into your own OpenGL contect, use the init(context:options:) initializer. To create a renderer for use in your own Metal workflow, use the init(device:options:) initializer.The rendering technology used by a SCNLayer object is determined by Core Animation.After initializing a renderer, this property reflects the rendering technology in use.
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1522616-renderingapi
	     */

	  }, {
	    key: 'prepareShouldAbortBlock',


	    // Preloading Renderer Resources

	    /**
	     * Required. Prepares a SceneKit object for rendering.
	     * @access public
	     * @param {Object} object - An SCNScene, SCNNode, SCNGeometry, or SCNMaterial instance.
	     * @param {?function(): boolean} [block = null] - A block that SceneKit calls periodically while preparing the object. The block takes no parameters.Your block should return false to tell SceneKit to continue preparing the object, or true to cancel preparation.Pass nil for this parameter if you do not need an opportunity to cancel preparing the object.
	     * @returns {boolean} - 
	     * @desc By default, SceneKit lazily loads resources onto the GPU for rendering. This approach uses memory and GPU bandwidth efficiently, but can lead to stutters in an otherwise smooth frame rate when you add large amounts of new content to an animated scene. To avoid such issues, use this method to prepare content for drawing before adding it to the scene. You can call this method on a secondary thread to prepare content asynchronously. SceneKit prepares all content associated with the object parameter you provide. If you provide an SCNMaterial object, SceneKit loads any texture images assigned to its material properties. If you provide an SCNGeometry object, SceneKit loads all materials attached to the geometry, as well as its vertex data. If you provide an SCNNode or SCNScene object, SceneKit loads all geometries and materials associated with the node and all its child nodes, or with the entire node hierarchy of the scene.You can use the block parameter to cancel preparation if content is no longer needed. For example, in a game you might use this method to preload areas of the game world the player is soon to enter, but if the player character dies before entering those areas, you can return true from the block to cancel preloading.You can observe the progress of this operation with the Progress class. For details, see Progress.
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1522798-prepare
	     */
	    value: function prepareShouldAbortBlock(object) {
	      var block = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

	      return false;
	    }

	    /**
	     * Required. Prepares the specified SceneKit objects for rendering, using a background thread.
	     * @access public
	     * @param {Object[]} objects - An array of containing one or more SCNScene, SCNNode, SCNGeometry, or SCNMaterial instances.
	     * @param {?function(arg1: boolean): void} [completionHandler = null] - A block that SceneKit calls when object preparation fails or completes.The block takes the following parameter:successtrue if all content was successfully prepared for rendering; otherwise, false.
	     * @returns {void}
	     * @desc By default, SceneKit lazily loads resources onto the GPU for rendering. This approach uses memory and GPU bandwidth efficiently, but can lead to stutters in an otherwise smooth frame rate when you add large amounts of new content to an animated scene. To avoid such issues, use this method to prepare content for drawing before adding it to the scene. SceneKit uses a secondary thread to prepare content asynchronously.SceneKit prepares all content associated with the objects you provide. If you provide an SCNMaterial object, SceneKit loads any texture images assigned to its material properties. If you provide an SCNGeometry object, SceneKit loads all materials attached to the geometry, as well as its vertex data. If you provide an SCNNode or SCNScene object, SceneKit loads all geometries and materials associated with the node and all its child nodes, or with the entire node hierarchy of the scene.You can observe the progress of this operation with the Progress class. For details, see Progress.
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1523375-prepare
	     */

	  }, {
	    key: 'prepare',
	    value: function prepare(objects) {
	      var completionHandler = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
	    }

	    // Working With Projected Scene Contents

	    /**
	     * Required. Searches the renderers scene for objects corresponding to a point in the rendered image.
	     * @access public
	     * @param {CGPoint} point - 
	     * @param {?Map<SCNHitTestOption, Object>} [options = null] - A dictionary of options affecting the search. See Hit Testing Options Keys for acceptable values.
	     * @returns {SCNHitTestResult[]} - 
	     * @desc A 2D point in the rendered screen coordinate space can refer to any point along a line segment in the 3D scene coordinate space. Hit-testing is the process of finding elements of a scene located along this line segment. For example, you can use this method to find the geometry corresponding to a click event in a SceneKit view.
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1522929-hittest
	     */

	  }, {
	    key: 'hitTest',
	    value: function hitTest(point) {
	      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

	      return null;
	    }

	    /**
	     * Required. Returns a Boolean value indicating whether a node might be visible from a specified point of view.
	     * @access public
	     * @param {SCNNode} node - The node whose visibility is to be tested.
	     * @param {SCNNode} pointOfView - A node defining a point of view, as used by the pointOfView property.
	     * @returns {boolean} - 
	     * @desc Any node containing a camera or spotlight may serve as a point of view (see the pointOfView property for details). Such a node defines a viewing frustuma portion of the scenes coordinate space, shaped like a truncated pyramid, that encloses all points visible from that point of view.Use this method to test whether a node lies within the viewing frustum defined by another node (which may or may not be the scene renderers current pointOfView node). For example, in a game scene containing multiple camera nodes, you could use this method to determine which camera is currently best for viewing a moving player character.Note that this method does not perform occlusion testing. That is, it returns true if the tested node lies within the specified viewing frustum regardless of whether that nodes contents are obscured by other geometry.
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1522647-isnode
	     */

	  }, {
	    key: 'isNodeInsideFrustumOf',
	    value: function isNodeInsideFrustumOf(node, pointOfView) {
	      return false;
	    }

	    /**
	     * Required. Returns all nodes that might be visible from a specified point of view.
	     * @access public
	     * @param {SCNNode} pointOfView - A node defining a point of view, as used by the pointOfView property.
	     * @returns {SCNNode[]} - 
	     * @desc Any node containing a camera or spotlight may serve as a point of view (see the pointOfView property for details). Such a node defines a viewing frustuma portion of the scenes coordinate space, shaped like a truncated pyramid, that encloses all points visible from that point of view.Use this method find all nodes whose content lies within the viewing frustum defined by another node (which may or may not be the scene renderers current pointOfView node).Note that this method does not perform occlusion testing. That is, the returned array includes any node that lies within the specified viewing frustum regardless of whether that nodes contents are obscured by other geometry.
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1522942-nodesinsidefrustum
	     */

	  }, {
	    key: 'nodesInsideFrustumOf',
	    value: function nodesInsideFrustumOf(pointOfView) {
	      return null;
	    }

	    /**
	     * Required. Projects a point from the 3D world coordinate system of the scene to the 2D pixel coordinate system of the renderer.
	     * @access public
	     * @param {SCNVector3} point - A point in the world coordinate system of the renderers scene.
	     * @returns {SCNVector3} - 
	     * @desc The z-coordinate of the returned point describes the depth of the projected point relative to the near and far clipping planes of the renderers viewing frustum (defined by its pointOfView node). Projecting a point on the near clipping plane returns a point whose z-coordinate is 0.0; projecting a point on the far clipping plane returns a point whose z-coordinate is 1.0.
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1524089-projectpoint
	     */

	  }, {
	    key: 'projectPoint',
	    value: function projectPoint(point) {
	      return null;
	    }

	    /**
	     * Required. Unprojects a point from the 2D pixel coordinate system of the renderer to the 3D world coordinate system of the scene.
	     * @access public
	     * @param {SCNVector3} point - A point in the screen-space (view, layer, or GPU viewport) coordinate system of the scene renderer.
	     * @returns {SCNVector3} - 
	     * @desc The z-coordinate of the point parameter describes the depth at which to unproject the point relative to the near and far clipping planes of the renderers viewing frustum (defined by its pointOfView node). Unprojecting a point whose z-coordinate is 0.0 returns a point on the near clipping plane; unprojecting a point whose z-coordinate is 1.0 returns a point on the far clipping plane.A 2D point in the rendered screen coordinate space can refer to any point along a line segment in the 3D scene coordinate space. To test for scene contents along this linefor example, to find the geometry corresponding to the location of a click event in a viewuse the hitTest(_:options:) method.
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1522631-unprojectpoint
	     */

	  }, {
	    key: 'unprojectPoint',
	    value: function unprojectPoint(point) {
	      return null;
	    }

	    // Customizing Scene Rendering with Metal
	    /**
	     * Required. The Metal render command encoder in use for the current SceneKit rendering pass.
	     * @type {?MTLRenderCommandEncoder}
	     * @desc Use this render command encoder to encode additional rendering commands before or after SceneKit draws its own content.This property is valid only during the SceneKit rendering loopthat is, within one of the methods defined in the SCNSceneRendererDelegate protocol. Accessing this property at any other time returns nil.
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1522609-currentrendercommandencoder
	     */

	  }, {
	    key: 'renderingAPI',
	    get: function get() {
	      return this._renderingAPI;
	    }
	  }, {
	    key: 'currentRenderCommandEncoder',
	    get: function get() {
	      return this._currentRenderCommandEncoder;
	    }

	    /**
	     * Required. The Metal device this renderer uses for rendering.
	     * @type {?MTLDevice}
	     * @desc Use this property to create or look up other Metal resources that use the same device as your SceneKit renderer.NoteThis property is valid only for scene renderers whose renderingAPI value is metal. You create a SceneKit view that renders using Metal with the preferredRenderingAPI initialization option or in Interface Builder, or an SCNRenderer that uses Metal with the init(device:options:) method. For OpenGL-based scene renderers, this propertys value is always nil.
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1523935-device
	     */

	  }, {
	    key: 'device',
	    get: function get() {
	      return this._device;
	    }

	    /**
	     * Required. The Metal command queue this renderer uses for rendering.
	     * @type {?MTLCommandQueue}
	     * @desc Use this property to schedule additional command buffers for the Metal device to execute as part of the render cycle. For example, you can use a compute command encoder to modify the vertex data in a Metal buffer for use by a SCNGeometrySource object.NoteThis property is valid only for scene renderers whose renderingAPI value is metal. You create a SceneKit view that renders using Metal with the preferredRenderingAPI initialization option or in Interface Builder, or an SCNRenderer that uses Metal with the init(device:options:) method. For OpenGL-based scene renderers, this propertys value is always nil.
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1523974-commandqueue
	     */

	  }, {
	    key: 'commandQueue',
	    get: function get() {
	      return this._commandQueue;
	    }

	    /**
	     * Required. The Metal pixel format for the renderers color output.
	     * @type {MTLPixelFormat}
	     * @desc Use this property, along with the depthPixelFormat and stencilPixelFormat properties, if you perform custom drawing with Metal (see the SCNSceneRendererDelegate and SCNNodeRendererDelegate classes) and need to create a new MTLRenderPipelineState object to change the GPU state as part of your rendering.NoteThis property is valid only for scene renderers whose renderingAPI value is metal. You create a SceneKit view that renders using Metal with the preferredRenderingAPI initialization option or in Interface Builder, or an SCNRenderer that uses Metal with the init(device:options:) method. For OpenGL-based scene renderers, this propertys value is always nil.
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1523701-colorpixelformat
	     */

	  }, {
	    key: 'colorPixelFormat',
	    get: function get() {
	      return this._colorPixelFormat;
	    }

	    /**
	     * Required. The Metal pixel format for the renderers depth buffer.
	     * @type {MTLPixelFormat}
	     * @desc Use this property, along with the colorPixelFormat and stencilPixelFormat properties, if you perform custom drawing with Metal (see the SCNSceneRendererDelegate and SCNNodeRendererDelegate classes) and need to create a new MTLRenderPipelineState object to change the GPU state as part of your rendering.NoteThis property is valid only for scene renderers whose renderingAPI value is metal. You create a SceneKit view that renders using Metal with the preferredRenderingAPI initialization option or in Interface Builder, or an SCNRenderer that uses Metal with the init(device:options:) method. For OpenGL-based scene renderers, this propertys value is always nil.
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1523780-depthpixelformat
	     */

	  }, {
	    key: 'depthPixelFormat',
	    get: function get() {
	      return this._depthPixelFormat;
	    }

	    /**
	     * Required. The Metal pixel format for the renderers stencil buffer.
	     * @type {MTLPixelFormat}
	     * @desc Use this property, along with the depthPixelFormat and colorPixelFormat properties, if you perform custom drawing with Metal (see the SCNSceneRendererDelegate and SCNNodeRendererDelegate classes) and need to create a new MTLRenderPipelineState object to change the GPU state as part of your rendering.NoteThis property is valid only for scene renderers whose renderingAPI value is metal. You create a SceneKit view that renders using Metal with the preferredRenderingAPI initialization option or in Interface Builder, or an SCNRenderer that uses Metal with the init(device:options:) method. For OpenGL-based scene renderers, this propertys value is always nil.
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1523315-stencilpixelformat
	     */

	  }, {
	    key: 'stencilPixelFormat',
	    get: function get() {
	      return this._stencilPixelFormat;
	    }

	    // Customizing Scene Rendering with OpenGL
	    /**
	     * Required. The OpenGL rendering context that SceneKit uses for rendering the scene.
	     * @type {?Object}
	     * @desc In macOS, the value of this property is a Core OpenGL cglContextObj object.In iOS, the value of this property is an EAGLContext object.
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1522840-context
	     */

	  }, {
	    key: 'context',
	    get: function get() {
	      return this._context;
	    }

	    // Working With Positional Audio

	    /**
	     * Required. The 3D audio mixing node SceneKit uses for positional audio effects.
	     * @type {AVAudioEnvironmentNode}
	     * @desc SceneKit uses this audio node to spatialize sounds from SCNAudioPlayer objects attached to nodes in the scene. You can use this object in conjunction with the audioEngine property to rearrange the audio graph to add other, non-spatialized audio sources or mix in audio processing effects.
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1523582-audioenvironmentnode
	     */

	  }, {
	    key: 'audioEnvironmentNode',
	    get: function get() {
	      return this._audioEnvironmentNode;
	    }

	    /**
	     * Required. The audio engine SceneKit uses for playing scene sounds.
	     * @type {AVAudioEngine}
	     * @desc SceneKit uses this audio engine to play sounds from SCNAudioPlayer objects attached to nodes in the scene. You can use this object directly to add other sound sources not related to scene contents, or to add other sound processing nodes or mixing nodes to the audio engine. To identify the node SceneKit uses for spatializing scene sounds when connecting other nodes, use the audioEnvironmentNode property.
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1522686-audioengine
	     */

	  }, {
	    key: 'audioEngine',
	    get: function get() {
	      return this._audioEngine;
	    }
	  }]);

	  return SCNSceneRenderer;
	}();

	exports.default = SCNSceneRenderer;

/***/ },
/* 90 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _NSObject2 = __webpack_require__(2);

	var _NSObject3 = _interopRequireDefault(_NSObject2);

	var _SKColor = __webpack_require__(11);

	var _SKColor2 = _interopRequireDefault(_SKColor);

	var _SCNNode = __webpack_require__(65);

	var _SCNNode2 = _interopRequireDefault(_SCNNode);

	var _SCNMaterial = __webpack_require__(75);

	var _SCNMaterial2 = _interopRequireDefault(_SCNMaterial);

	var _SCNBox = __webpack_require__(91);

	var _SCNBox2 = _interopRequireDefault(_SCNBox);

	var _SCNMaterialProperty = __webpack_require__(76);

	var _SCNMaterialProperty2 = _interopRequireDefault(_SCNMaterialProperty);

	var _SCNGeometrySource = __webpack_require__(71);

	var _SCNGeometrySource2 = _interopRequireDefault(_SCNGeometrySource);

	var _SCNSceneExportDelegate = __webpack_require__(92);

	var _SCNSceneExportDelegate2 = _interopRequireDefault(_SCNSceneExportDelegate);

	var _SCNSceneExportProgressHandler = __webpack_require__(93);

	var _SCNSceneExportProgressHandler2 = _interopRequireDefault(_SCNSceneExportProgressHandler);

	var _SCNSceneSource = __webpack_require__(94);

	var _SCNSceneSource2 = _interopRequireDefault(_SCNSceneSource);

	var _SCNPhysicsWorld = __webpack_require__(99);

	var _SCNPhysicsWorld2 = _interopRequireDefault(_SCNPhysicsWorld);

	var _SCNParticleSystem = __webpack_require__(107);

	var _SCNParticleSystem2 = _interopRequireDefault(_SCNParticleSystem);

	var _SCNMatrix = __webpack_require__(46);

	var _SCNMatrix2 = _interopRequireDefault(_SCNMatrix);

	var _BinaryRequest2 = __webpack_require__(97);

	var _BinaryRequest3 = _interopRequireDefault(_BinaryRequest2);

	var _File2 = __webpack_require__(34);

	var _File3 = _interopRequireDefault(_File2);

	var _FileReader2 = __webpack_require__(35);

	var _FileReader3 = _interopRequireDefault(_FileReader2);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var _Attribute = {
	  endTime: 'kSceneEndTimeAttributeKey',
	  frameRate: 'kSceneFrameRateAttributeKey',
	  startTime: 'kSceneStartTimeAttributeKey',
	  upAxis: 'kSceneUpAxisAttributeKey'
	};

	/**
	 * A scene grapha hierarchy of nodes with attached geometries, lights, cameras and other attributes that together form a displayable 3D scene.
	 * @access public
	 * @extends {NSObject}
	 * @see https://developer.apple.com/reference/scenekit/scnscene
	 */

	var SCNScene = function (_NSObject) {
	  _inherits(SCNScene, _NSObject);

	  _createClass(SCNScene, null, [{
	    key: '_propTypes',
	    get: function get() {
	      return {
	        paused: ['boolean', 'isPaused'],
	        rootNode: ['SCNNode', '_rootNode'],
	        upAxis: ['SCNVector3', null],
	        physicsWorld: ['SCNPhysicsWorld', function (obj, value) {
	          obj._physicsWorld = value;
	          obj._physicsWorld._scene = obj;
	        }],
	        background: ['SCNMaterialProperty', function (obj, value) {
	          obj._skyBox.geometry.firstMaterial._emission = value;
	          obj._skyBox.geometry.firstMaterial._emission._createPresentation();
	        }],
	        startTime: ['double', null],
	        endTime: ['double', null],
	        frameRate: ['double', null],
	        fogDensityExponent: 'double',
	        fogStartDistance: 'double',
	        fogEndDistance: 'double',
	        fogColor: 'plist',
	        version: ['float', null],
	        environment: ['SCNMaterialProperty', '_lightingEnvironment']
	      };
	    }

	    /**
	     * Loads a scene from the specified URL.
	     * @access public
	     * @constructor
	     * @param {string} url - The URL to the scene file to load.
	     * @param {?Map<SCNSceneSource.LoadingOption, Object>} [options = null] - A dictionary of options affecting scene loading, or nil for default options. For available keys, see Scene Loading Options.
	     * @param {function} onload -
	     * @param {function} onerror -
	     * @throws {Error}
	     * @desc This method provides a convenient way to load a complete scene from a file at an arbitrary URL. For more detailed options or to load only part of a files scene graph, use the SCNSceneSource class.Handling Errors in Swift:
	    In Swift, this method returns a nonoptional result and is marked with the throws keyword to indicate that it throws an error in cases of failure.
	    You call this method in a try expression and handle any errors in the catch clauses of a do statement, as described in Error Handling in The Swift Programming Language (Swift 3.1) and Error Handling in Using Swift with Cocoa and Objective-C (Swift 3.1).
	      * @see https://developer.apple.com/reference/scenekit/scnscene/1522660-init
	     */

	  }]);

	  function SCNScene(url) {
	    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
	    var onload = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
	    var onerror = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

	    _classCallCheck(this, SCNScene);

	    // Managing Animated Effects in a Scene

	    /**
	     * A Boolean value that determines whether to run actions, animations, particle systems, and physics simulations in the scene graph.
	     * @type {boolean}
	     * @see https://developer.apple.com/reference/scenekit/scnscene/1523604-ispaused
	     */
	    var _this = _possibleConstructorReturn(this, (SCNScene.__proto__ || Object.getPrototypeOf(SCNScene)).call(this));

	    _this.isPaused = false;

	    // Accessing Scene Contents

	    _this._rootNode = new _SCNNode2.default();
	    _this._lightingEnvironment = null;

	    // Adding Fog to a Scene

	    /**
	     * The distance from a point of view at which the scenes contents begin to be obscured by fog. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnscene/1522790-fogstartdistance
	     */
	    _this.fogStartDistance = 0;

	    /**
	     * The distance from a point of view at which the scenes contents are completely obscured by fog. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnscene/1523836-fogenddistance
	     */
	    _this.fogEndDistance = 0;

	    /**
	     * The transition curve for the fogs intensity between its start and end distances. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnscene/1523776-fogdensityexponent
	     */
	    _this.fogDensityExponent = 0;

	    /**
	     * The color of the fog effect to be rendered with the scene. Animatable.
	     * @type {Object}
	     * @see https://developer.apple.com/reference/scenekit/scnscene/1522774-fogcolor
	     */
	    _this.fogColor = null;

	    // Working With Physics in the Scene

	    _this._physicsWorld = new _SCNPhysicsWorld2.default();
	    _this._physicsWorld._scene = _this;

	    // Working with Particle Systems in the Scene

	    _this._particleSystems = null;
	    _this._particleSystemsTransform = null;

	    if (typeof url !== 'undefined') {
	      _this._loadSceneWithURL(url, options).then(function (scene) {
	        _this._copyValue(scene);
	        if (onload) {
	          onload(_this);
	        }
	      }).catch(function (error) {
	        if (onerror) {
	          onerror(error);
	        }
	      });
	    }

	    var skyBoxGeometry = new _SCNBox2.default();
	    var material = new _SCNMaterial2.default();
	    material._diffuse._contents = _SKColor2.default.black;
	    material._ambient._contents = _SKColor2.default.black;
	    material._emission._contents = null;
	    material.isDoubleSided = true;

	    skyBoxGeometry.firstMaterial = material;
	    var texSrc = skyBoxGeometry.getGeometrySourcesForSemantic(_SCNGeometrySource2.default.Semantic.texcoord)[0];
	    var margin = 0.001;
	    var w0 = 0.0;
	    var w1 = 1.0 / 6.0;
	    var w2 = 2.0 / 6.0;
	    var w3 = 3.0 / 6.0;
	    var w4 = 4.0 / 6.0;
	    var w5 = 5.0 / 6.0;
	    var w6 = 1.0;
	    var data = [w5 - margin, 1, w5 - margin, 0, w4 + margin, 1, w4 + margin, 0, w2 - margin, 1, w2 - margin, 0, w1 + margin, 1, w1 + margin, 0, w6 - margin, 1, w6 - margin, 0, w5 + margin, 1, w5 + margin, 0, w1 - margin, 1, w1 - margin, 0, w0 + margin, 1, w0 + margin, 0, w3 - margin, 1, w3 - margin, 0, w2 + margin, 1, w2 + margin, 0, w4 - margin, 1, w4 - margin, 0, w3 + margin, 1, w3 + margin, 0];
	    var dataIndex = 0;
	    var srcIndex = 6;
	    for (var i = 0; i < 24; i++) {
	      texSrc._data[srcIndex + 0] = data[dataIndex + 0];
	      texSrc._data[srcIndex + 1] = data[dataIndex + 1];
	      srcIndex += 8;
	      dataIndex += 2;
	    }
	    _this._skyBox = new _SCNNode2.default(skyBoxGeometry);
	    _this._skyBox._presentation = _this._skyBox;
	    return _this;
	  }

	  _createClass(SCNScene, [{
	    key: '_copyValue',
	    value: function _copyValue(src) {
	      this.isPaused = src.isPaused;
	      this._rootNode = src._rootNode;
	      //this._background = src._background
	      this._skyBox.geometry = src._skyBox.geometry.copy();
	      this._lightingEnvironment = src._lightingEnvironment;
	      this.fogStartDistance = src.fogStartDistance;
	      this.fogEndDistance = src.fogEndDistance;
	      this.fogDensityExponent = src.fogDensityExponent;
	      this.fogColor = src.fogColor;
	      this._physicsWorld = src._physicsWorld; // TODO: copy SCNPhysicsWorld
	      this._particleSystems = src._particleSystems ? src._particleSystems.slice(0) : null;
	      this._particleSystemsTransform = src._particleSystemsTransform ? src._particleSystemsTransform.slice(0) : null;
	    }
	  }, {
	    key: '_loadSceneWithURL',
	    value: function _loadSceneWithURL(url, options) {
	      var _this2 = this;

	      var _options = options;
	      if (_options === null) {
	        _options = new Map();
	      }
	      if (typeof _options.get(_SCNSceneSource2.default.LoadingOption.assetDirectoryURLs) === 'undefined') {
	        var paths = url.split('/');
	        var name = paths.pop();
	        var directory = paths.join('/');

	        _options.set(_SCNSceneSource2.default.LoadingOption.assetDirectoryURLs, directory);
	      }

	      if (url instanceof _File3.default) {
	        return Promise(function (resolve, reject) {
	          var reader = new _FileReader3.default();
	          reader.onload = function () {
	            var scene = _this2._loadSceneWithData(reader.result, _options);
	            resolve(scene);
	          };
	          reader.onerror = function () {
	            reject(reader.error);
	          };
	          reader.readAsBinaryString(url);
	        });
	      } else {
	        return _BinaryRequest3.default.get(url).then(function (data) {
	          return _this2._loadSceneWithData(data, _options);
	        });
	      }
	    }
	  }, {
	    key: '_loadSceneWithData',
	    value: function _loadSceneWithData(data, options) {
	      var source = new _SCNSceneSource2.default(data, options);
	      return source.scene();
	    }

	    // Creating or Loading a Scene

	    /**
	     * Loads a scene from a file with the specified name in the apps main bundle.
	     * @access public
	     * @param {string} name - The name of a scene file in the app bundles resources directory.
	     * @returns {void}
	     * @desc This method provides a convenient way to load a complete scene from a file in the apps main bundle. Calling this method is equivalent to using the Bundle class to locate the scene file and passing the resulting URL to the init(url:options:) method, specifying no options and no error handling.For more detailed options or to load only part of a files scene graph, use the SCNSceneSource class.
	     * @see https://developer.apple.com/reference/scenekit/scnscene/1523355-init
	     */

	  }, {
	    key: 'attributeForKey',


	    // Managing Scene Attributes

	    /**
	     * Returns the scene attribute for the specified key.
	     * @access public
	     * @param {string} key - One of the constants described in Scene Attributes that identifies the attribute to be read.
	     * @returns {?Object} - 
	     * @see https://developer.apple.com/reference/scenekit/scnscene/1522858-attribute
	     */
	    value: function attributeForKey(key) {
	      return null;
	    }

	    /**
	     * Sets a scene attribute for the specified key.
	     * @access public
	     * @param {?Object} attribute - An object that specifies the value of the attribute to be written.
	     * @param {string} key - One of the constants described in Scene Attributes that identifies the attribute to be written.
	     * @returns {void}
	     * @see https://developer.apple.com/reference/scenekit/scnscene/1524229-setattribute
	     */

	  }, {
	    key: 'setAttributeForKey',
	    value: function setAttributeForKey(attribute, key) {}

	    // Exporting a Scene File

	    /**
	     * Exports the scene and its contents to a file at the specified URL.
	     * @access public
	     * @param {string} url - The URL to write the scene file to. This URL must use the file scheme.
	     * @param {?Map<string, Object>} [options = null] - A dictionary of options affecting scene loading, or nil for default options. For available keys, see Scene Loading Options.
	     * @param {?SCNSceneExportDelegate} delegate - A delegate object to customize export of external resources used by the scene. Pass nil for default export of external resources.
	     * @param {?SCNSceneExportProgressHandler} [progressHandler = null] - A block that SceneKit calls repeatedly to report progress of the export operation.
	     * @returns {boolean} - 
	     * @desc SceneKit creates and writes a file containing the scene graph in the Digital Asset Exchange (DAE) format. The format of the file created depends on OS version and on the filename extension you specify:In iOS 10.0, tvOS 10.0, watchOS 3.0, OS X v10.11, and later versions, specify the .scn extension to save a file in SceneKits native format. This format supports all features of SceneKit (including physics, constraints, and particle systems), and reading files in this format is faster than importing from other scene file formats.In macOS only, specify the .dae extension to export in Digital Asset Exchange (DAE) format for use by other apps. Exported DAE files do not contain scene elements specific to SceneKit, such as physics bodies and fields, constraints, and particle systems.If the scene references external resources, such as image files used in material properties, SceneKit exports these files to a nearby location and references their URLs in the exported scene file. To override SceneKits exporting of external resources, provide an object implementing the SCNSceneExportDelegate protocol in the delegate parameter.
	     * @see https://developer.apple.com/reference/scenekit/scnscene/1523577-write
	     */

	  }, {
	    key: 'writeTo',
	    value: function writeTo(url) {
	      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
	      var delegate = arguments[2];
	      var progressHandler = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

	      return false;
	    }

	    // Working With Physics in the Scene
	    /**
	     * The physics simulation associated with the scene.
	     * @type {SCNPhysicsWorld}
	     * @desc Every scene automatically creates a physics world object to simulate physics on nodes in the scene. You use this property to access the scenes global physics properties, such as gravity, and to manage physics interactions between nodes. To make a node in the scene participate in the physics simulation, use either or both of its physicsBody and physicsField properties.
	     * @see https://developer.apple.com/reference/scenekit/scnscene/1522643-physicsworld
	     */

	  }, {
	    key: 'addParticleSystem',


	    // Working with Particle Systems in the Scene

	    /**
	     * Attaches a particle system to the scene, using the specified transform.
	     * @access public
	     * @param {SCNParticleSystem} system - A particle system.
	     * @param {SCNMatrix4} transform - A transformation matrix that positions and orients the particle system relative to the world coordinate space of the scene.
	     * @returns {void}
	     * @desc A particle system directly attached to a scene is not related to the coordinate space of any node in the scene. To attach a particle system whose emitter location follows the movement of a node within the scene, use the corresponding SCNNode method.For details on particle systems, see SCNParticleSystem.
	     * @see https://developer.apple.com/reference/scenekit/scnscene/1523359-addparticlesystem
	     */
	    value: function addParticleSystem(system, transform) {
	      if (this._particleSystems === null) {
	        this._particleSystems = [];
	        this._particleSystemsTransform = [];
	      }
	      //system._startTime = Date.now() * 0.001
	      system.reset();
	      this._particleSystems.push(system);
	      this._particleSystemsTransform.push(transform);

	      if (this._particleSystems.length !== this._particleSystemsTransform.length) {
	        throw new Error('particleSystems array length inconsistency');
	      }
	    }

	    /**
	     * Removes a particle system attached to the scene.
	     * @access public
	     * @param {SCNParticleSystem} system - A particle system.
	     * @returns {void}
	     * @desc This method has no effect if the system parameter does not reference a particle system directly attached to the scene.
	     * @see https://developer.apple.com/reference/scenekit/scnscene/1523498-removeparticlesystem
	     */

	  }, {
	    key: 'removeParticleSystem',
	    value: function removeParticleSystem(system) {
	      if (this._particleSystems === null) {
	        return;
	      }
	      var index = this._particleSystems.indexOf(system);
	      if (index < 0) {
	        return;
	      }
	      this._particleSystems.splice(index, 1);
	      this._particleSystemsTransform.splice(index, 1);
	    }

	    /**
	     * Removes any particle systems directly attached to the scene.
	     * @access public
	     * @returns {void}
	     * @desc Calling this method does not remove particle systems attached to nodes within the scene.
	     * @see https://developer.apple.com/reference/scenekit/scnscene/1522786-removeallparticlesystems
	     */

	  }, {
	    key: 'removeAllParticleSystems',
	    value: function removeAllParticleSystems() {
	      this._particleSystems = [];
	      this._particleSystemsTransform = [];
	    }

	    /**
	     * The particle systems attached to the scene.
	     * @type {?SCNParticleSystem[]}
	     * @desc An array of SCNParticleSystem objects directly attached to the scene. This array does not include particle systems attached to nodes within the scene.For details on particle systems, see SCNParticleSystem.
	     * @see https://developer.apple.com/reference/scenekit/scnscene/1522787-particlesystems
	     */

	  }, {
	    key: 'rootNode',


	    // Accessing Scene Contents
	    /**
	     * The root node of the scene graph.
	     * @type {SCNNode}
	     * @desc All scene contentnodes, geometries and their materials, lights, cameras, and related objectsis organized in a node hierarchy with a single common root node.Some scene files created using external tools may describe node hierarchies containing multiple root nodes. When SceneKit imports such files, their separate root nodes will be made children of a new, unique root node.Each child nodes coordinate system is defined relative to the transformation of its parent node. You should not modify the transform property of the root node.
	     * @see https://developer.apple.com/reference/scenekit/scnscene/1524029-rootnode
	     */
	    get: function get() {
	      return this._rootNode;
	    }

	    /**
	     * A background to be rendered before the rest of the scene.
	     * @type {SCNMaterialProperty}
	     * @desc If the material propertys contents object is nil, SceneKit does not draw any background before drawing the rest of the scene. (If the scene is presented in an SCNView instance, the views background color is visible behind the contents of the scene.)If you specify a cube map texture for the material property (see the discussion of the contents property), SceneKit renders the background as a skybox.
	     * @see https://developer.apple.com/reference/scenekit/scnscene/1523665-background
	     */

	  }, {
	    key: 'background',
	    get: function get() {
	      return this._skyBox.geometry.firstMaterial._emission;
	    }

	    /**
	     * A cube map texture that depicts the environment surrounding the scenes contents, used for advanced lighting effects.
	     * @type {SCNMaterialProperty}
	     * @desc When rendering materials with the physicallyBased lighting model, SceneKit illuminates surfaces differently according to the environment that surrounds them. For example, with physically based shading, even a diffuse surface takes on some color from the sky above it and the ground below it.TipFor realistic results, reuse the same contents for both the lighting environment and the background property.For information about defining cube maps, see the discussion of the contents property.
	     * @see https://developer.apple.com/reference/scenekit/scnscene/1639532-lightingenvironment
	     */

	  }, {
	    key: 'lightingEnvironment',
	    get: function get() {
	      return this._lightingEnvironment;
	    }
	  }, {
	    key: 'physicsWorld',
	    get: function get() {
	      return this._physicsWorld;
	    }
	  }, {
	    key: 'particleSystems',
	    get: function get() {
	      return this._particleSystems.slice(0);
	    }

	    // Structures

	    /**
	     * @type {Object} Attribute
	     * @property {string} endTime A floating-point value (in an NSNumber object) for the end time of the scene.
	     * @property {string} frameRate A floating-point value (in an NSNumber object) for the frame rate of the scene.
	     * @property {string} startTime A floating-point value (in an NSNumber object) for the start time of the scene.
	     * @property {string} upAxis An SCNVector3 structure (in an NSValue object) specifying the orientation of the scene.
	     * @see https://developer.apple.com/reference/scenekit/scnscene.attribute
	     */

	  }], [{
	    key: 'sceneNamed',
	    value: function sceneNamed(name) {}

	    /**
	     * Loads a scene from a file with the specified name in a specific subdirectory of the apps main bundle.
	     * @access public
	     * @param {string} name - The name of a scene file in the app bundle.
	     * @param {?string} directory - The path to the subdirectory of the bundles resources directory containing the scene file.
	     * @param {?Map<SCNSceneSource.LoadingOption, Object>} [options = null] - A dictionary of options affecting scene loading, or nil for default options. For available keys, see Scene Loading Options.
	     * @returns {void}
	     * @desc This method provides a convenient way to load a complete scene from a file in the apps main bundle. Calling this method is equivalent to using the Bundle class to locate the scene file and passing the resulting URL to the init(url:options:) method.For more detailed options or to load only part of a files scene graph, use the SCNSceneSource class.
	     * @see https://developer.apple.com/reference/scenekit/scnscene/1522851-init
	     */

	  }, {
	    key: 'sceneNamedInDirectory',
	    value: function sceneNamedInDirectory(name, directory) {
	      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
	    }

	    /**
	     * Loads a scene from the specified URL.
	     * @access public
	     * @param {string} url - The URL to the scene file to load.
	     * @param {?Map<SCNSceneSource.LoadingOption, Object>} [options = null] - A dictionary of options affecting scene loading, or nil for default options. For available keys, see Scene Loading Options.
	     * @returns {SCNScene} -
	     * @throws {Error}
	     * @desc This method provides a convenient way to load a complete scene from a file at an arbitrary URL. For more detailed options or to load only part of a files scene graph, use the SCNSceneSource class.Handling Errors in Swift:
	    In Swift, this method returns a nonoptional result and is marked with the throws keyword to indicate that it throws an error in cases of failure.
	    You call this method in a try expression and handle any errors in the catch clauses of a do statement, as described in Error Handling in The Swift Programming Language (Swift 3.1) and Error Handling in Using Swift with Cocoa and Objective-C (Swift 3.1).
	      * @see https://developer.apple.com/reference/scenekit/scnscene/1522660-init
	     */

	  }, {
	    key: 'scene',
	    value: function scene(url) {
	      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

	      return new SCNScene(url, options);
	    }
	  }, {
	    key: 'Attribute',
	    get: function get() {
	      return _Attribute;
	    }
	  }]);

	  return SCNScene;
	}(_NSObject3.default);

	exports.default = SCNScene;

/***/ },
/* 91 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _SCNGeometry2 = __webpack_require__(68);

	var _SCNGeometry3 = _interopRequireDefault(_SCNGeometry2);

	var _SCNGeometrySource = __webpack_require__(71);

	var _SCNGeometrySource2 = _interopRequireDefault(_SCNGeometrySource);

	var _SCNGeometryElement = __webpack_require__(72);

	var _SCNGeometryElement2 = _interopRequireDefault(_SCNGeometryElement);

	var _SCNGeometryPrimitiveType = __webpack_require__(73);

	var _SCNGeometryPrimitiveType2 = _interopRequireDefault(_SCNGeometryPrimitiveType);

	var _SCNVector = __webpack_require__(44);

	var _SCNVector2 = _interopRequireDefault(_SCNVector);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/*global Ammo*/

	/**
	 * A six-sided polyhedron geometry whose faces are all rectangles, optionally with rounded edges and corners.
	 * @access public
	 * @extends {SCNGeometry}
	 * @see https://developer.apple.com/reference/scenekit/scnbox
	 */
	var SCNBox = function (_SCNGeometry) {
	  _inherits(SCNBox, _SCNGeometry);

	  _createClass(SCNBox, null, [{
	    key: '_propTypes',
	    get: function get() {
	      return {
	        $constructor: function $constructor(propNames, propValues) {
	          var box = new SCNBox(propValues.boxwidth, propValues.boxheight, propValues.boxlength, propValues.boxchamferRadius);
	          box.widthSegmentCount = propValues.boxwidthSegmentCount;
	          box.heightSegmentCount = propValues.boxheightSegmentCount;
	          box.lengthSegmentCount = propValues.boxlengthSegmentCount;
	          box.chamferSegmentCount = propValues.boxchamferSegmentCount;
	          // propValues.boxPrimitiveType
	          box.materials = propValues.materials;
	          box.subdivisionLevel = propValues.subdivisionLevel;

	          return box;
	        },
	        name: 'string',
	        boxwidth: ['float', null],
	        boxheight: ['float', null],
	        boxlength: ['float', null],
	        boxwidthSegmentCount: ['integer', null],
	        boxheightSegmentCount: ['integer', null],
	        boxlengthSegmentCount: ['integer', null],
	        boxchamferRadius: ['float', null],
	        boxchamferSegmentCount: ['integer', null],
	        boxprimitiveType: ['integer', null],
	        materials: ['NSArray', null],
	        subdivisionLevel: ['integer', null],
	        subdivisionSettings: ['bytes', null]
	      };
	    }

	    /**
	     * Creates a box geometry with the specified width, height, length, and chamfer radius.
	     * @access public
	     * @constructor
	     * @param {number} [width = 1.0] - The width of the box along the x-axis of its local coordinate space.
	     * @param {number} [height = 1.0] - The height of the box along the y-axis of its local coordinate space.
	     * @param {number} [length = 1.0] - The length of the box along the z-axis of its local coordinate space.
	     * @param {number} [chamferRadius = 0.0] - The radius of curvature for the edges and corners of the box.
	     * @desc The box is centered in its local coordinate system. For example, if you create a box whose width, height and length are all 10.0, it extends from -5.0 to 5.0 along in each of the x-, y-, and z-axes.
	     * @see https://developer.apple.com/reference/scenekit/scnbox/1522620-init
	     */

	  }]);

	  function SCNBox() {
	    var width = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1.0;
	    var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1.0;
	    var length = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1.0;
	    var chamferRadius = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0.0;

	    _classCallCheck(this, SCNBox);

	    // Adjusting a Boxs Dimensions

	    /**
	     * The extent of the box along its x-axis. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnbox/1523898-width
	     */
	    var _this = _possibleConstructorReturn(this, (SCNBox.__proto__ || Object.getPrototypeOf(SCNBox)).call(this, [], []));

	    _this.width = width;

	    /**
	     * The extent of the box along its y-axis. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnbox/1522901-height
	     */
	    _this.height = height;

	    /**
	     * The extent of the box along its z-axis. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnbox/1523514-length
	     */
	    _this.length = length;

	    // Configuring Box Properties

	    /**
	     * The number of subdivisions in each face of the box along its x-axis. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnbox/1523559-widthsegmentcount
	     */
	    _this.widthSegmentCount = 1;

	    /**
	     * The number of subdivisions in each face of the box along its y-axis. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnbox/1522869-heightsegmentcount
	     */
	    _this.heightSegmentCount = 1;

	    /**
	     * The number of subdivisions in each face of the box along its z-axis. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnbox/1523721-lengthsegmentcount
	     */
	    _this.lengthSegmentCount = 1;

	    // Adding Rounded Edges and Corners

	    /**
	     * The radius of curvature for the edges and corners of the box. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnbox/1523302-chamferradius
	     */
	    _this.chamferRadius = chamferRadius;

	    /**
	     * The number of line segments used to create each rounded edge of the box. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnbox/1522976-chamfersegmentcount
	     */
	    _this.chamferSegmentCount = 10;

	    _this._createGeometry();
	    return _this;
	  }

	  _createClass(SCNBox, [{
	    key: '_createGeometry',
	    value: function _createGeometry() {
	      var sourceData = [];
	      var indexData = [];

	      var left = -this.width * 0.5;
	      var right = this.width * 0.5;
	      var top = this.height * 0.5;
	      var bottom = -this.height * 0.5;
	      var front = this.length * 0.5;
	      var back = -this.length * 0.5;

	      // front
	      /*
	      this._createFace(sourceData, indexData,
	        new SCNVector3(left, bottom, front),
	        new SCNVector3(left, top, front),
	        new SCNVector3(right, bottom, front),
	        new SCNVector3(right, top, front),
	        this.heightSegmentCount,
	        this.widthSegmentCount)
	       // right
	      this._createFace(sourceData, indexData,
	        new SCNVector3(right, bottom, front),
	        new SCNVector3(right, top, front),
	        new SCNVector3(right, bottom, back),
	        new SCNVector3(right, top, back),
	        this.heightSegmentCount,
	        this.lengthSegmentCount)
	       // back
	      this._createFace(sourceData, indexData,
	        new SCNVector3(right, bottom, back),
	        new SCNVector3(right, top, back),
	        new SCNVector3(left, bottom, back),
	        new SCNVector3(left, top, back),
	        this.heightSegmentCount,
	        this.widthSegmentCount)
	       // left
	      this._createFace(sourceData, indexData,
	        new SCNVector3(left, bottom, back),
	        new SCNVector3(left, top, back),
	        new SCNVector3(left, bottom, front),
	        new SCNVector3(left, top, front),
	        this.heightSegmentCount,
	        this.lengthSegmentCount)
	       // top
	      this._createFace(sourceData, indexData,
	        new SCNVector3(left, top, front),
	        new SCNVector3(left, top, back),
	        new SCNVector3(right, top, front),
	        new SCNVector3(right, top, back),
	        this.lengthSegmentCount,
	        this.widthSegmentCount)
	       // bottom
	      this._createFace(sourceData, indexData,
	        new SCNVector3(left, bottom, back),
	        new SCNVector3(left, bottom, front),
	        new SCNVector3(right, bottom, back),
	        new SCNVector3(right, bottom, front),
	        this.lengthSegmentCount,
	        this.widthSegmentCount)
	      */

	      // front
	      sourceData.push(left, bottom, front); // position
	      sourceData.push(0, 0, 1); // normal
	      sourceData.push(0, 1); // texcoord
	      //sourceData.push(0, -1, -1, -1) // boneIndices
	      //sourceData.push(1, 0, 0, 0) // boneWeights

	      sourceData.push(left, top, front);
	      sourceData.push(0, 0, 1);
	      sourceData.push(0, 0);
	      //sourceData.push(0, -1, -1, -1)
	      //sourceData.push(1, 0, 0, 0)

	      sourceData.push(right, bottom, front);
	      sourceData.push(0, 0, 1);
	      sourceData.push(1, 1);
	      //sourceData.push(0, -1, -1, -1)
	      //sourceData.push(1, 0, 0, 0)

	      sourceData.push(right, top, front);
	      sourceData.push(0, 0, 1);
	      sourceData.push(1, 0);
	      //sourceData.push(0, -1, -1, -1)
	      //sourceData.push(1, 0, 0, 0)

	      indexData.push(0, 3, 1);
	      indexData.push(0, 2, 3);

	      // right
	      sourceData.push(right, bottom, front);
	      sourceData.push(1, 0, 0);
	      sourceData.push(0, 1);
	      //sourceData.push(0, -1, -1, -1)
	      //sourceData.push(1, 0, 0, 0)

	      sourceData.push(right, top, front);
	      sourceData.push(1, 0, 0);
	      sourceData.push(0, 0);
	      //sourceData.push(0, -1, -1, -1)
	      //sourceData.push(1, 0, 0, 0)

	      sourceData.push(right, bottom, back);
	      sourceData.push(1, 0, 0);
	      sourceData.push(1, 1);
	      //sourceData.push(0, -1, -1, -1)
	      //sourceData.push(1, 0, 0, 0)

	      sourceData.push(right, top, back);
	      sourceData.push(1, 0, 0);
	      sourceData.push(1, 0);
	      //sourceData.push(0, -1, -1, -1)
	      //sourceData.push(1, 0, 0, 0)

	      indexData.push(4, 7, 5);
	      indexData.push(4, 6, 7);

	      // back
	      sourceData.push(right, bottom, back);
	      sourceData.push(0, 0, -1);
	      sourceData.push(0, 1);
	      //sourceData.push(0, -1, -1, -1)
	      //sourceData.push(1, 0, 0, 0)

	      sourceData.push(right, top, back);
	      sourceData.push(0, 0, -1);
	      sourceData.push(0, 0);
	      //sourceData.push(0, -1, -1, -1)
	      //sourceData.push(1, 0, 0, 0)

	      sourceData.push(left, bottom, back);
	      sourceData.push(0, 0, -1);
	      sourceData.push(1, 1);
	      //sourceData.push(0, -1, -1, -1)
	      //sourceData.push(1, 0, 0, 0)

	      sourceData.push(left, top, back);
	      sourceData.push(0, 0, -1);
	      sourceData.push(1, 0);
	      //sourceData.push(0, -1, -1, -1)
	      //sourceData.push(1, 0, 0, 0)

	      indexData.push(8, 11, 9);
	      indexData.push(8, 10, 11);

	      // left
	      sourceData.push(left, bottom, back);
	      sourceData.push(-1, 0, 0);
	      sourceData.push(0, 1);
	      //sourceData.push(0, -1, -1, -1)
	      //sourceData.push(1, 0, 0, 0)

	      sourceData.push(left, top, back);
	      sourceData.push(-1, 0, 0);
	      sourceData.push(0, 0);
	      //sourceData.push(0, -1, -1, -1)
	      //sourceData.push(1, 0, 0, 0)

	      sourceData.push(left, bottom, front);
	      sourceData.push(-1, 0, 0);
	      sourceData.push(1, 1);
	      //sourceData.push(0, -1, -1, -1)
	      //sourceData.push(1, 0, 0, 0)

	      sourceData.push(left, top, front);
	      sourceData.push(-1, 0, 0);
	      sourceData.push(1, 0);
	      //sourceData.push(0, -1, -1, -1)
	      //sourceData.push(1, 0, 0, 0)

	      indexData.push(12, 15, 13);
	      indexData.push(12, 14, 15);

	      // top
	      sourceData.push(left, top, front);
	      sourceData.push(0, 1, 0);
	      sourceData.push(0, 1);
	      //sourceData.push(0, -1, -1, -1)
	      //sourceData.push(1, 0, 0, 0)

	      sourceData.push(left, top, back);
	      sourceData.push(0, 1, 0);
	      sourceData.push(0, 0);
	      //sourceData.push(0, -1, -1, -1)
	      //sourceData.push(1, 0, 0, 0)

	      sourceData.push(right, top, front);
	      sourceData.push(0, 1, 0);
	      sourceData.push(1, 1);
	      //sourceData.push(0, -1, -1, -1)
	      //sourceData.push(1, 0, 0, 0)

	      sourceData.push(right, top, back);
	      sourceData.push(0, 1, 0);
	      sourceData.push(1, 0);
	      //sourceData.push(0, -1, -1, -1)
	      //sourceData.push(1, 0, 0, 0)

	      indexData.push(16, 19, 17);
	      indexData.push(16, 18, 19);

	      // bottom
	      sourceData.push(left, bottom, back);
	      sourceData.push(0, -1, 0);
	      sourceData.push(0, 1);
	      //sourceData.push(0, -1, -1, -1)
	      //sourceData.push(1, 0, 0, 0)

	      sourceData.push(left, bottom, front);
	      sourceData.push(0, -1, 0);
	      sourceData.push(0, 0);
	      //sourceData.push(0, -1, -1, -1)
	      //sourceData.push(1, 0, 0, 0)

	      sourceData.push(right, bottom, back);
	      sourceData.push(0, -1, 0);
	      sourceData.push(1, 1);
	      //sourceData.push(0, -1, -1, -1)
	      //sourceData.push(1, 0, 0, 0)

	      sourceData.push(right, bottom, front);
	      sourceData.push(0, -1, 0);
	      sourceData.push(1, 0);
	      //sourceData.push(0, -1, -1, -1)
	      //sourceData.push(1, 0, 0, 0)

	      indexData.push(20, 23, 21);
	      indexData.push(20, 22, 23);

	      var vertexSource = new _SCNGeometrySource2.default(sourceData, // data
	      _SCNGeometrySource2.default.Semantic.vertex, // semantic
	      24, // vectorCount
	      true, // floatComponents
	      3, // componentsPerVector
	      4, // bytesPerComponent
	      0, // offset
	      32 // sride
	      );

	      var normalSource = new _SCNGeometrySource2.default(sourceData, // data
	      _SCNGeometrySource2.default.Semantic.normal, // semantic
	      24, // vectorCount
	      true, // floatComponents
	      3, // componentsPerVector
	      4, // bytesPerComponent
	      12, // offset
	      32 // stride
	      );

	      var texcoordSource = new _SCNGeometrySource2.default(sourceData, // data
	      _SCNGeometrySource2.default.Semantic.texcoord, // semantic
	      24, // vectorCount
	      true, // floatComponents
	      2, // componentsPerVector
	      4, // bytesPerComponent
	      24, // offset
	      32 // stride
	      );

	      var element = new _SCNGeometryElement2.default(indexData, _SCNGeometryPrimitiveType2.default.triangles);

	      this._geometryElements = [element];
	      this._geometrySources = [vertexSource, normalSource, texcoordSource];
	      this.boundingBox = {
	        min: new _SCNVector2.default(left, bottom, back),
	        max: new _SCNVector2.default(right, top, front)
	      };
	    }

	    /**
	     * @access private
	     * @param {number[]} sourceData -
	     * @param {number[]} indexData -
	     * @param {SCNVector3} v1 - position 1
	     * @param {SCNVector3} v2 - position 2
	     * @param {SCNVector3} v3 - position 3
	     * @param {SCNVector3} v4 - position 4
	     * @param {number} s1 - segmentCount 1
	     * @param {number} s2 - segmentCount 2
	     * @returns {void}
	     */

	  }, {
	    key: '_createFace',
	    value: function _createFace(sourceData, indexData, v1, v2, v3, v4, s1, s2) {}

	    /**
	     * @access private
	     * @returns {Ammo.btCollisionShape}
	     * @desc call Ammo.destroy(shape) after using it.
	     */

	  }, {
	    key: '_createBtCollisionShape',
	    value: function _createBtCollisionShape() {
	      //const size = new Ammo.btVector3(this.width * 0.5, this.height * 0.5, this.length * 0.5)
	      //const shape = new Ammo.btBoxShape(size)
	      //Ammo.destroy(size)
	      //return shape
	    }
	  }]);

	  return SCNBox;
	}(_SCNGeometry3.default);

	exports.default = SCNBox;

/***/ },
/* 92 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * Methods you can implement to participate in the process of exporting a scene to a file.
	 * @interface
	 * @see https://developer.apple.com/reference/scenekit/scnsceneexportdelegate
	 */

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var SCNSceneExportDelegate = function () {
	  function SCNSceneExportDelegate() {
	    _classCallCheck(this, SCNSceneExportDelegate);
	  }

	  _createClass(SCNSceneExportDelegate, [{
	    key: 'init',


	    /**
	     * constructor
	     * @access public
	     * @returns {void}
	     */
	    value: function init() {}

	    // Writing Image Attachments

	    /**
	     * Tells the delegate to export an image attached to a scene.
	     * @access public
	     * @param {Image} image - An image attached to the scene being exported.
	     * @param {string} documentURL - The URL the scene is being exported to.
	     * @param {?string} originalImageURL - The URL the image was originally loaded from, or nil if the image was not previously loaded from a URL.
	     * @returns {?string} - 
	     * @desc If you implement this method, Scene Kit calls it for each image (for example, a texture) attached to the scene. Your app can then save the image data in a location and format of your choice, returning a URL for the exported image file.If you do not provide a delegate when exporting a scene, or if your delegate returns nil from this method, Scene Kit exports the image in a default format to a default location.
	     * @see https://developer.apple.com/reference/scenekit/scnsceneexportdelegate/1524221-write
	     */

	  }, {
	    key: 'writeWithSceneDocumentURL',
	    value: function writeWithSceneDocumentURL(image, documentURL, originalImageURL) {
	      return null;
	    }
	  }]);

	  return SCNSceneExportDelegate;
	}();

	exports.default = SCNSceneExportDelegate;

/***/ },
/* 93 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * The signature for the block that SceneKit calls during scene export.
	 * @type {function(totalProgress: number, error: ?Error, stop: UnsafeMutablePointer<ObjCBool>): void}
	 * @param {number} totalProgress - A number between 0.0 and 1.0 that indicates the progress of the export operation, with 0.0 indicating that the operation has just begun and 1.0 indicating the operation has completed.
	 * @param {?Error} error - An error encountered during the export process, or nil if no errors have occurred.
	 * @param {UnsafeMutablePointer<ObjCBool>} stop - Set *stop to true inside the block to cancel export.
	 * @returns {void}
	 * @desc stopSet *stop to true inside the block to cancel export.
	 * @see https://developer.apple.com/reference/scenekit/scnsceneexportprogresshandler
	 */

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var SCNSceneExportProgressHandler = function SCNSceneExportProgressHandler(totalProgress, error, stop) {};

	exports.default = SCNSceneExportProgressHandler;

/***/ },
/* 94 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _NSKeyedUnarchiver = __webpack_require__(33);

	var _NSKeyedUnarchiver2 = _interopRequireDefault(_NSKeyedUnarchiver);

	var _NSObject2 = __webpack_require__(2);

	var _NSObject3 = _interopRequireDefault(_NSObject2);

	var _SCNScene = __webpack_require__(90);

	var _SCNScene2 = _interopRequireDefault(_SCNScene);

	var _SCNSceneSourceStatusHandler = __webpack_require__(95);

	var _SCNSceneSourceStatusHandler2 = _interopRequireDefault(_SCNSceneSourceStatusHandler);

	var _BinaryRequest2 = __webpack_require__(97);

	var _BinaryRequest3 = _interopRequireDefault(_BinaryRequest2);

	var _File2 = __webpack_require__(34);

	var _File3 = _interopRequireDefault(_File2);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var _AnimationImportPolicy = {
	  doNotPlay: 'keepSeparate',
	  play: 'playOnce',
	  playRepeatedly: 'playRepeatedly',
	  playUsingSceneTimeBase: 'playUsingSceneTime'
	};

	var _LoadingOption = {
	  animationImportPolicy: 'kSceneSourceAnimationLoadingMode',
	  assetDirectoryURLs: 'kSceneSourceAssetDirectoryURLs',
	  checkConsistency: 'kSceneSourceCheckConsistency',
	  convertToYUp: 'kSceneSourceConvertToYUpIfNeeded',
	  convertUnitsToMeters: 'kSceneSourceConvertToUnit',
	  createNormalsIfAbsent: 'kSceneSourceCreateNormalsIfAbsent',
	  flattenScene: 'kSceneSourceFlattenScene',
	  overrideAssetURLs: 'kSceneSourceOverrideAssetURLs',
	  preserveOriginalTopology: 'kSceneSourcePreserveOriginalTopology',
	  strictConformance: 'kSceneSourceStrictConformanceKey',
	  useSafeMode: 'kSceneSourceUseSafeMode'
	};

	/**
	 * Manages the data-reading tasks associated with loading scene contents from a file or data.
	 * @access public
	 * @extends {NSObject}
	 * @see https://developer.apple.com/reference/scenekit/scnscenesource
	 */

	var SCNSceneSource = function (_NSObject) {
	  _inherits(SCNSceneSource, _NSObject);

	  // Creating a Scene Source

	  /**
	   * Initializes a scene source for reading the scene graph contained in an NSData object.
	   * @access public
	   * @constructor
	   * @param {Blob} data - A data object containing a scene file in a format recognized by SceneKit.
	   * @param {?Map<SCNSceneSource.LoadingOption, Object>} [options = null] - A dictionary containing options that affect scene loading. See Scene Loading Options for available keys and values. Pass nil to use default options.
	   * @desc The data parameter of this method should contain the same data as directly read from a scene file (such as by using the NSData method dataWithContentsOfURL:). Use this method when you have the contents of a scene file but not the file itselffor example, if your app downloads scene files from the network.
	   * @see https://developer.apple.com/reference/scenekit/scnscenesource/1523500-init
	   */
	  function SCNSceneSource(data) {
	    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

	    _classCallCheck(this, SCNSceneSource);

	    // Getting Information about the Scene

	    var _this = _possibleConstructorReturn(this, (SCNSceneSource.__proto__ || Object.getPrototypeOf(SCNSceneSource)).call(this));

	    _this._url = null;
	    _this._options = options;
	    _this._data = data;
	    return _this;
	  }

	  /**
	   * @access public
	   * @param {Blob} data -
	   * @param {?Map<SCNSceneSource.LoadingOption, Object>} [options = null] -
	   * @returns {SCNSceneSource} -
	   */


	  _createClass(SCNSceneSource, [{
	    key: 'scene',


	    // Loading a Complete Scene

	    /**
	     * Loads the entire scene graph from the scene source and calls the specified block to provide progress information.
	     * @access public
	     * @param {?Map<SCNSceneSource.LoadingOption, Object>} [options = null] - A dictionary containing options that affect scene loading. See Scene Loading Options for available keys and values. Pass nil to use default options.
	     * @param {?SCNSceneSourceStatusHandler} [statusHandler = null] - An SCNSceneSourceStatusHandler block. SceneKit calls this block periodically to report progress while loading the scene.
	     * @returns {?SCNScene} - 
	     * @desc Use this method if you need to monitor progress while loading a scene from the scene source. For simpler scene loading, use the scene(options:) method or the SCNScene method init(url:options:).A scene source can contain objects that are not part of its scene graph. To obtain these objects, you must load them individually with the the entryWithIdentifier:withClass: or entries(passingTest:) method. For example, a scene file containing a game character could include several animations for the character geometry (such as running, jumping, and standing idle). Because you typically do not apply multiple animations at once, the scene file contains these animations without their being attached to the character geometry.
	     * @see https://developer.apple.com/reference/scenekit/scnscenesource/1522887-scene
	     */
	    value: function scene() {
	      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
	      var statusHandler = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

	      var _options = options;
	      if (!_options) {
	        if (this._options) {
	          _options = this._options;
	        }
	      }

	      var url = this._url;
	      var assetDirectoryURLs = _options.get(_LoadingOption.assetDirectoryURLs);
	      if (assetDirectoryURLs) {
	        var dir = assetDirectoryURLs;
	        if (Array.isArray(dir)) {
	          dir = dir[0];
	        }
	        url = dir + '/';
	        if (this._url) {
	          url += this._url.split('/').pop();
	        }
	      }

	      return _NSKeyedUnarchiver2.default.unarchiveObjectWithData(this._data, url);
	    }

	    // Loading and Inspecting Scene Elements

	    /**
	     * Returns the identifiers for all objects in the scene source of the specified class.
	     * @access public
	     * @param {Object} entryClass - The class of objects to find identifiers for.
	     * @returns {string[]} - 
	     * @desc SceneKit recognizes objects of the following classes in scene files:CAAnimationNSImageSCNCameraSCNGeometrySCNLightSCNMaterialSCNMorpherSCNNodeSCNSceneSCNSkinnerEach object in a scene file has an identifier that is unique for its class. These identifiers are determined by the software that created the scene filefor example, they may be descriptive names assigned by an artist using 3D authoring tools. For SceneKit classes with a name property (such as nodes and geometries), the name of an object loaded from a scene file is based on its identifier in the scene file.Use this method to enumerate all objects in a scene file of a specified class without loading the objects and their content. For example, the following code finds the identifiers for all animations stored in a scene source:NSArray *animations = [sceneSource identifiersOfEntriesWithClass:[CAAnimation class]];
	    NSArray *animations = [sceneSource identifiersOfEntriesWithClass:[CAAnimation class]];
	      * @see https://developer.apple.com/reference/scenekit/scnscenesource/1523656-identifiersofentries
	     */

	  }, {
	    key: 'identifiersOfEntriesWithClass',
	    value: function identifiersOfEntriesWithClass(entryClass) {
	      return null;
	    }

	    /**
	     * Loads and returns all objects in the scene source that pass the test in a given block.
	     * @access public
	     * @param {function(arg1: Object, arg2: string, arg3: UnsafeMutablePointer<ObjCBool>): boolean} predicate - The block to be applied to each object in the scene source.The block takes three parameters:entryThe object to be tested.identifierThe unique identifier of the object in the scene source.stopA reference to a Boolean value. Set *stop to true within the block to abort further processing of the scene sources contents.The block returns a Boolean value indicating whether the entry object passed the test and should be included in the methods returned array.
	     * @returns {Object[]} - 
	     * @desc SceneKit recognizes objects of the following classes in scene files:CAAnimationNSImageSCNCameraSCNGeometrySCNLightSCNMaterialSCNMorpherSCNNodeSCNSceneSCNSkinnerEach object in a scene file has an identifier that is unique for its class. These identifiers are determined by the software that created the scene filefor example, they may be descriptive names assigned by an artist using 3D authoring tools. For SceneKit classes with a name property (such as nodes and geometries), the name of an object loaded from a scene file is based on its identifier in the scene file.Use this method to selectively load objects from a scene source matching criteria you specify. For example, the following code loads from a scene file only the nodes that have attached geometry:NSArray *geometryNodes = [sceneSource entriesPassingTest:^BOOL(id entry, NSString *identifier, BOOL *stop) {
	      if ([entry isKindOfClass:[SCNNode class]]) {
	          SCNNode *node = (SCNNode *)entry;
	          return (node.geometry != nil);
	      } else {
	          return NO;
	      }
	    }];
	    NSArray *geometryNodes = [sceneSource entriesPassingTest:^BOOL(id entry, NSString *identifier, BOOL *stop) {
	      if ([entry isKindOfClass:[SCNNode class]]) {
	          SCNNode *node = (SCNNode *)entry;
	          return (node.geometry != nil);
	      } else {
	          return NO;
	      }
	    }];
	      * @see https://developer.apple.com/reference/scenekit/scnscenesource/1523055-entries
	     */

	  }, {
	    key: 'entriesPassingTest',
	    value: function entriesPassingTest(predicate) {
	      return null;
	    }

	    // Getting Information about the Scene

	    /**
	     * Returns metadata about the scene.
	     * @access public
	     * @param {string} key - A constant identifying a metadata property of the scene source. See Scene Source Properties for available keys and the formats of their values.
	     * @returns {?Object} - 
	     * @desc This method returns information about the scene that is defined in the file but is not directly referenced by the scene.
	     * @see https://developer.apple.com/reference/scenekit/scnscenesource/1523277-property
	     */

	  }, {
	    key: 'propertyForKey',
	    value: function propertyForKey(key) {
	      return null;
	    }
	    /**
	     * The URL identifying the file from which the scene source was created.
	     * @type {?string}
	     * @desc The value of this property is nil if the scene source was not created using the sceneSourceWithURL:options: or init(url:options:) method.
	     * @see https://developer.apple.com/reference/scenekit/scnscenesource/1524038-url
	     */

	  }, {
	    key: 'entryWithIdentifierWithClass',


	    // Instance Methods

	    /**
	     * 
	     * @access public
	     * @param {string} uid - 
	     * @param {T.Type} entryClass - 
	     * @returns {Object} - 
	     * @see https://developer.apple.com/reference/scenekit/scnscenesource/2805685-entrywithidentifier
	     */
	    value: function entryWithIdentifierWithClass(uid, entryClass) {
	      return null;
	    }

	    // Structures
	    /**
	     * @type {Object} AnimationImportPolicy
	     * @property {string} doNotPlay Animations are not loaded from the scene file.
	     * @property {string} play Animations loaded from the scene file are immediately added to the scene and played once.
	     * @property {string} playRepeatedly Animations loaded from the scene file are immediately added to the scene and played repeatedly.
	     * @property {string} playUsingSceneTimeBase Animations loaded from the scene file are immediately added to the scene and played according to the scenes sceneTime property.
	     * @see https://developer.apple.com/reference/scenekit/scnscenesource.animationimportpolicy
	     */

	  }, {
	    key: 'url',
	    get: function get() {
	      return this._url;
	    }
	    /**
	     * The data object from which the scene source loads scene content.
	     * @type {?Data}
	     * @desc If the scene source was created using the sceneSourceWithData:options: or init(data:options:) method, this propertys value is the data from which the scene source was created. If the scene source was created from a scene file using the the sceneSourceWithURL:options: or init(url:options:) method, this propertys value is the data loaded from that URL at the time the scene source was created.
	     * @see https://developer.apple.com/reference/scenekit/scnscenesource/1523061-data
	     */

	  }, {
	    key: 'data',
	    get: function get() {
	      return this._data;
	    }
	  }], [{
	    key: 'sceneSourceWithDataOptions',
	    value: function sceneSourceWithDataOptions(data, options) {
	      return new SCNSceneSource(data, options);
	    }

	    /**
	     * @access public
	     * @param {string|File} url -
	     * @param {?Map<SCNSceneSource.LoadingOption, Object>} [options = null] -
	     * @returns {Promise} -
	     */

	  }, {
	    key: 'sceneSourceWithURLOptions',
	    value: function sceneSourceWithURLOptions(url) {
	      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

	      var _options = options;
	      if (_options === null) {
	        _options = new Map();
	      }
	      if (typeof _options.get(_LoadingOption.assetDirectoryURLs) === 'undefined') {
	        var paths = url.split('/');
	        var name = paths.pop();
	        var directory = paths.join('/');

	        _options.set(_LoadingOption.assetDirectoryURLs, directory);
	      }

	      var promise = _BinaryRequest3.default.get(url).then(function (data) {
	        return new SCNSceneSource(data, _options);
	      });
	      return promise;
	    }
	  }, {
	    key: 'AnimationImportPolicy',
	    get: function get() {
	      return _AnimationImportPolicy;
	    }

	    /**
	     * @type {Object} LoadingOption
	     * @property {string} animationImportPolicy An option for controlling the playback of animations in a scene file.
	     * @property {string} assetDirectoryURLs Locations to use for resolving relative URLs to external resources.
	     * @property {string} checkConsistency An option to validate scene files while loading.
	     * @property {string} convertToYUp An option for whether to transform assets loaded from the scene file for use in a coordinate system where the y-axis points up.
	     * @property {string} convertUnitsToMeters An option for whether to automatically scale the scenes contents.
	     * @property {string} createNormalsIfAbsent An option for automatically generating surface normals if they are absent when loading geometry.
	     * @property {string} flattenScene An option for automatically merging portions of a scene graph during loading.
	     * @property {string} overrideAssetURLs An option to attempt loading external resources using their URLs as specified in a scene file.
	     * @property {string} preserveOriginalTopology 
	     * @property {string} strictConformance An option to interpret scene files exactly as specified by the scene file format.
	     * @property {string} useSafeMode An option to limit filesystem and network access for external resources referenced by a scene file.
	     * @see https://developer.apple.com/reference/scenekit/scnscenesource.loadingoption
	     */

	  }, {
	    key: 'LoadingOption',
	    get: function get() {
	      return _LoadingOption;
	    }
	  }]);

	  return SCNSceneSource;
	}(_NSObject3.default);

	exports.default = SCNSceneSource;

/***/ },
/* 95 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _SCNSceneSourceStatus = __webpack_require__(96);

	var _SCNSceneSourceStatus2 = _interopRequireDefault(_SCNSceneSourceStatus);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * The signature for the block that SceneKit calls periodically to report progress while loading a scene.
	 * @type {function(totalProgress: number, status: SCNSceneSourceStatus, error: ?Error, stopLoading: UnsafeMutablePointer<ObjCBool>): void}
	 * @param {number} totalProgress - A floating-point number between 0.0 and 1.0 indicating the overall progress of loading the scene. A value of 0.0 indicates that the loading process has just begun, and a value of 1.0 indicates that the process has completed.
	 * @param {SCNSceneSourceStatus} status - A constant identifying one of the distinct phases of SceneKits loading procedure. See SCNSceneSourceStatus for possible values.
	 * @param {?Error} error - An error object describing any error that has occurred during scene loading, or nil if no errors has been encountered.
	 * @param {UnsafeMutablePointer<ObjCBool>} stopLoading - A reference to a Boolean value. Set *stop to true within the block to abort further processing of the scene sources contents.
	 * @returns {void}
	 * @see https://developer.apple.com/reference/scenekit/scnscenesourcestatushandler
	 */
	var SCNSceneSourceStatusHandler = function SCNSceneSourceStatusHandler(totalProgress, status, error, stopLoading) {};

	exports.default = SCNSceneSourceStatusHandler;

/***/ },
/* 96 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * Constants identifying phases of SceneKits scene loading process, used in a SCNSceneSourceStatusHandler block.
	 * @typedef {Object} SCNSceneSourceStatus
	 * @property {number} error - An error occurred when SceneKit attempted to load the scene.
	 * @property {number} parsing - SceneKit has begun deserializing the source file.
	 * @property {number} validating - SceneKit has begun validating the scene files format.
	 * @property {number} processing - SceneKit has begun generating scene graph objects from the scene files contents.
	 * @property {number} complete - SceneKit has successfully finished loading the scene files contents.
	 * @see https://developer.apple.com/reference/scenekit/scnscenesourcestatus
	 */

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var SCNSceneSourceStatus = {
	  error: -1,
	  parsing: 4,
	  validating: 8,
	  processing: 12,
	  complete: 16
	};

	exports.default = SCNSceneSourceStatus;

/***/ },
/* 97 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.BinaryRequest = undefined;

	var _AjaxRequest2 = __webpack_require__(98);

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * BinaryRequest class
	 * @access public
	 */
	var BinaryRequest = exports.BinaryRequest = function (_AjaxRequest) {
	  _inherits(BinaryRequest, _AjaxRequest);

	  /**
	   * constructor
	   * @access public
	   * @constructor
	   */
	  function BinaryRequest() {
	    _classCallCheck(this, BinaryRequest);

	    var _this = _possibleConstructorReturn(this, (BinaryRequest.__proto__ || Object.getPrototypeOf(BinaryRequest)).call(this));

	    _this.defaultOptions.mimeType = 'text/plain; charset=x-user-defined';
	    return _this;
	  }

	  return BinaryRequest;
	}(_AjaxRequest2.AjaxRequest);

	exports.default = new BinaryRequest();

/***/ },
/* 98 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * AjaxRequest class
	 * @access public
	 */

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var AjaxRequest = exports.AjaxRequest = function () {
	  /**
	   * constructor
	   * @access public
	   * @constructor
	   */
	  function AjaxRequest() {
	    _classCallCheck(this, AjaxRequest);

	    this.defaultOptions = {
	      method: 'POST',
	      async: true,
	      data: null,
	      user: null,
	      password: null,
	      mimeType: null,
	      isJSONP: false,
	      responseType: null,
	      requestHeader: {}
	    };

	    this.jsonpScripts = [];
	    this.jsonpCallbackPrefix = 'jsonpCallback_';
	  }

	  _createClass(AjaxRequest, [{
	    key: 'get',
	    value: function get(url) {
	      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

	      options.method = 'GET';
	      return this.request(url, options);
	    }
	  }, {
	    key: 'post',
	    value: function post(url) {
	      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

	      options.method = 'POST';
	      return this.request(url, options);
	    }
	  }, {
	    key: 'jsonp',
	    value: function jsonp(url) {
	      var callbackParam = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'callback';
	      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

	      var requestURL = url;
	      var script = document.createElement('script');
	      var callbackFuncName = this._getNewFuncName(this.jsonpCallbackPrefix);

	      if (!options.data) {
	        options.data = {};
	      }
	      options.data[callbackParam] = callbackFuncName;

	      var queryArray = [];
	      options.data.forEach(function (key, value) {
	        queryArray.push(encodeURI(key) + '=' + encodeURI(value));
	      });
	      requestURL += '?' + queryArray.join('&');

	      var promise = new Promise(function (resolve, reject) {
	        window[callbackFuncName] = resolve;
	        script.addEventListener('error', reject);
	      }).catch(function (error) {
	        delete window[callbackFuncName];
	        document.head.removeChild(script);
	        return Promise.reject(error);
	      }).then(function (result) {
	        delete window[callbackFuncName];
	        document.head.removeChild(script);
	        return Promise.resolve(result);
	      });

	      script.src = requestURL;
	      document.head.appendChild(script);

	      return promise;
	    }
	  }, {
	    key: '_getNewFuncName',
	    value: function _getNewFuncName() {
	      var prefix = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';

	      // ESLint prefers for(;;) more than while(true)
	      for (;;) {
	        var funcName = prefix + Math.random().toString(16).slice(2);
	        if (typeof window[funcName] === 'undefined') {
	          return funcName;
	        }
	      }
	    }
	  }, {
	    key: 'request',
	    value: function request(url) {
	      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

	      var requestURL = url;
	      var method = typeof options.method === 'undefined' ? this.defaultOptions.method : options.method;
	      var async = typeof options.async === 'undefined' ? this.defaultOptions.async : options.async;
	      var data = this.defaultOptions.data;
	      var user = typeof options.user === 'undefined' ? this.defaultOptions.user : options.user;
	      var password = typeof options.password === 'undefined' ? this.defaultOptions.password : options.password;
	      var mimeType = typeof options.mimeType === 'undefined' ? this.defaultOptions.mimeType : options.mimeType;
	      var header = typeof options.requestHeader === 'undefined' ? this.defaultOptions.requestHeader : options.requestHeader;
	      var isJSONP = typeof options.isJSONP === 'undefined' ? this.defaultOptions.isJSONP : options.isJSONP;
	      var responseType = typeof options.responseType === 'undefined' ? this.defaultOptions.responseType : options.responseType;

	      if (method !== 'POST' && method !== 'GET') {
	        method = 'POST';
	      }

	      if (options.data) {
	        var dataArray = [];
	        if (options.data instanceof Map) {
	          options.data.forEach(function (key, value) {
	            dataArray.push(encodeURIComponent(key) + '=' + encodeURIComponent(value));
	          });
	        } else {
	          Object.keys(options.data).forEach(function (key) {
	            var value = options.data[key];
	            dataArray.push(encodeURIComponent(key) + '=' + encodeURIComponent(value));
	          });
	        }

	        if (method === 'POST') {
	          data = dataArray.join('&').replace(/%20/g, '+');
	        } else {
	          requestURL += '?' + dataArray.join('&').replace(/%20/g, '+');
	        }
	      }

	      if (method === 'POST' && typeof header['Content-Type'] === 'undefined') {
	        header['Content-Type'] = 'application/x-www-form-urlencoded';
	      }

	      return new Promise(function (resolve, reject) {
	        var xhr = new XMLHttpRequest();

	        if (mimeType) {
	          xhr.overrideMimeType(mimeType);
	        }
	        if (responseType) {
	          xhr.responseType = responseType;
	        }

	        if (user) {
	          xhr.open(method, url, async, user, password);
	        } else {
	          xhr.open(method, url, async);
	        }

	        if (header) {
	          for (var key in header) {
	            // Reflect is not yet implemented...
	            //if(Reflect.apply({}.hasOwnProperty, header, [key])){
	            if ({}.hasOwnProperty.call(header, key)) {
	              xhr.setRequestHeader(key, header[key]);
	            }
	          }
	        }

	        xhr.onload = function () {
	          if (xhr.readyState === 4 && xhr.status === 200) {
	            resolve(xhr.response);
	          } else {
	            reject(new Error(xhr.statusText));
	          }
	        };
	        xhr.onerror = function () {
	          reject(new Error(xhr.statusText));
	        };
	        xhr.send(data);
	      });
	    }
	  }]);

	  return AjaxRequest;
	}();

	exports.default = new AjaxRequest();

/***/ },
/* 99 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _NSObject2 = __webpack_require__(2);

	var _NSObject3 = _interopRequireDefault(_NSObject2);

	var _SCNVector = __webpack_require__(44);

	var _SCNVector2 = _interopRequireDefault(_SCNVector);

	var _SCNPhysicsBehavior = __webpack_require__(100);

	var _SCNPhysicsBehavior2 = _interopRequireDefault(_SCNPhysicsBehavior);

	var _SCNPhysicsContactDelegate = __webpack_require__(101);

	var _SCNPhysicsContactDelegate2 = _interopRequireDefault(_SCNPhysicsContactDelegate);

	var _SCNPhysicsContact = __webpack_require__(102);

	var _SCNPhysicsContact2 = _interopRequireDefault(_SCNPhysicsContact);

	var _SCNPhysicsBody = __webpack_require__(103);

	var _SCNPhysicsBody2 = _interopRequireDefault(_SCNPhysicsBody);

	var _SCNHitTestResult = __webpack_require__(106);

	var _SCNHitTestResult2 = _interopRequireDefault(_SCNHitTestResult);

	var _SCNPhysicsShape = __webpack_require__(105);

	var _SCNPhysicsShape2 = _interopRequireDefault(_SCNPhysicsShape);

	var _SCNMatrix = __webpack_require__(46);

	var _SCNMatrix2 = _interopRequireDefault(_SCNMatrix);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	//import _Ammo from '../third_party/ammo'
	/*global Ammo*/

	var _TestOption = {
	  backfaceCulling: 'backfaceCulling',
	  collisionBitMask: 'collisionBitMask',
	  searchMode: 'results'
	};

	var _TestSearchMode = {
	  all: 'all',
	  any: 'any',
	  closest: 'closest'
	};

	/**
	 * The global simulation of collisions, gravity, joints, and other physics effects in a scene.
	 * @access public
	 * @extends {NSObject}
	 * @see https://developer.apple.com/reference/scenekit/scnphysicsworld
	 */

	var SCNPhysicsWorld = function (_NSObject) {
	  _inherits(SCNPhysicsWorld, _NSObject);

	  _createClass(SCNPhysicsWorld, null, [{
	    key: '_propTypes',
	    get: function get() {
	      return {
	        gravity: 'SCNVector3',
	        speed: 'double',
	        timeStep: 'double',
	        scale: ['double', '_scale'],
	        // _allBehaviors
	        // contactDelegate
	        scene: ['SCNScene', '_scene']
	      };
	    }

	    /**
	     * constructor
	     * @access public
	     * @constructor
	     */

	  }]);

	  function SCNPhysicsWorld() {
	    _classCallCheck(this, SCNPhysicsWorld);

	    // Managing the Physics Simulation

	    /**
	     * A vector that specifies the gravitational acceleration applied to physics bodies in the physics world.
	     * @type {SCNVector3}
	     * @see https://developer.apple.com/reference/scenekit/scnphysicsworld/1512855-gravity
	     */
	    var _this = _possibleConstructorReturn(this, (SCNPhysicsWorld.__proto__ || Object.getPrototypeOf(SCNPhysicsWorld)).call(this));

	    _this.gravity = new _SCNVector2.default(0, 0, 0);

	    /**
	     * The rate at which the simulation executes.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnphysicsworld/1512851-speed
	     */
	    _this.speed = 0;

	    /**
	     * The time interval between updates to the physics simulation.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnphysicsworld/1512881-timestep
	     */
	    _this.timeStep = 0;

	    /**
	     * @access private
	     * @type {number}
	     */
	    _this._scale = 1.0;

	    // Registering Physics Behaviors

	    _this._allBehaviors = [];

	    // Detecting Contacts Between Physics Bodies

	    /**
	     * A delegate that is called when two physics bodies come in contact with each other.
	     * @type {?SCNPhysicsContactDelegate}
	     * @see https://developer.apple.com/reference/scenekit/scnphysicsworld/1512843-contactdelegate
	     */
	    _this.contactDelegate = null;

	    //const collisionConfiguration = new Ammo.btDefaultCollisionConfiguration()
	    //const dispatcher = new Ammo.btCollisionDispatcher(collisionConfiguration)
	    //const overlappingPairCache = new Ammo.btDbvtBroadphase()
	    //const solver = new Ammo.btSequentialImpulseConstraintSolver()
	    //this._world = new Ammo.btDiscreteDynamicsWorld(
	    //  dispatcher, overlappingPairCache, solver, collisionConfiguration
	    //)

	    _this._prevTime = null;

	    /**
	     * @access private
	     * @type {SCNScene}
	     */
	    _this._scene = null;

	    // for rayTest
	    _this._renderer = null;
	    return _this;
	  }

	  // Managing the Physics Simulation

	  /**
	   * Forces the physics engine to reevaluate possible collisions between physics bodies.
	   * @access public
	   * @returns {void}
	   * @desc By default, SceneKit checks for collisions between physics bodies only once per simulation step. If you directly change the positions of any physics bodies outside of a SCNPhysicsContactDelegate method, call the updateCollisionPairs() method before using any of the methods listed in Searching for Physics Bodies Detecting Contacts Between Physics Bodies.
	   * @see https://developer.apple.com/reference/scenekit/scnphysicsworld/1512877-updatecollisionpairs
	   */


	  _createClass(SCNPhysicsWorld, [{
	    key: 'updateCollisionPairs',
	    value: function updateCollisionPairs() {}

	    // Registering Physics Behaviors

	    /**
	     * Adds a behavior to the physics world.
	     * @access public
	     * @param {SCNPhysicsBehavior} behavior - The behavior to be added.
	     * @returns {void}
	     * @desc Physics behaviors constrain or modify the effects of the physics simulation on sets of physics bodies. For example, the SCNPhysicsHingeJoint behavior causes two bodies to move as if connected by a hinge that pivots around a specific axis, and the SCNPhysicsVehicle behavior causes a body to roll like a car or other wheeled vehicle.To use a behavior in your scene, follow these steps:Create SCNPhysicsBody objects and attach them to each node that participates in the behavior.Create and configure a behavior object joining the physics bodies. See SCNPhysicsBehavior for a list of behavior classes.Call addBehavior(_:) on your scenes physics world object to add the behavior to the physics simulation.
	     * @see https://developer.apple.com/reference/scenekit/scnphysicsworld/1512839-addbehavior
	     */

	  }, {
	    key: 'addBehavior',
	    value: function addBehavior(behavior) {
	      if (this._allBehaviors.indexOf(behavior) >= 0) {
	        return;
	      }
	      this._allBehaviors.push(behavior);
	    }

	    /**
	     * Removes a behavior from the physics world.
	     * @access public
	     * @param {SCNPhysicsBehavior} behavior - The behavior to be removed.
	     * @returns {void}
	     * @see https://developer.apple.com/reference/scenekit/scnphysicsworld/1512870-removebehavior
	     */

	  }, {
	    key: 'removeBehavior',
	    value: function removeBehavior(behavior) {
	      var index = this._allBehaviors.indexOf(behavior);
	      if (index < 0) {
	        return;
	      }
	      this._allBehaviors.splice(index, 1);
	    }

	    /**
	     * Removes all behaviors affecting bodies in the physics world.
	     * @access public
	     * @returns {void}
	     * @see https://developer.apple.com/reference/scenekit/scnphysicsworld/1512849-removeallbehaviors
	     */

	  }, {
	    key: 'removeAllBehaviors',
	    value: function removeAllBehaviors() {
	      this._allBehaviors = [];
	    }

	    /**
	     * The list of behaviors affecting bodies in the physics world.
	     * @type {SCNPhysicsBehavior[]}
	     * @desc 
	     * @see https://developer.apple.com/reference/scenekit/scnphysicsworld/1512853-allbehaviors
	     */

	  }, {
	    key: 'contactTestBetween',


	    // Detecting Contacts Between Physics Bodies

	    /**
	     * Checks for contacts between two physics bodies.
	     * @access public
	     * @param {SCNPhysicsBody} bodyA - The first body (to test for contact with the second).
	     * @param {SCNPhysicsBody} bodyB - The second body (to test for contact with the first).
	     * @param {?Map<SCNPhysicsWorld.TestOption, Object>} [options = null] - A dictionary of options affecting the test, or nil to use default options. For applicable keys and the possible values, see Physics Test Options Keys.
	     * @returns {SCNPhysicsContact[]} - 
	     * @desc SceneKit sends messages to the physics worlds contactDelegate object only when collisions occur between bodies whose collisionBitMask and categoryBitMask properties overlap, and only for collisions between certain types of bodies. (For details, see SCNPhysicsBodyType.) Use this method to directly test for contacts between any two bodies at a time of your choosing. For example, to implement a game where the player character can pick up an item, you might call this method when the player presses the pick up button to see if the player character is in contact with the item to be picked up.
	     * @see https://developer.apple.com/reference/scenekit/scnphysicsworld/1512875-contacttestbetween
	     */
	    value: function contactTestBetween(bodyA, bodyB) {
	      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

	      // FIXME: use physics library
	      if ((bodyA.categoryBitMask & bodyB.contactTestBitMask) === 0) {
	        return [];
	      }
	      var posA = bodyA._position;
	      var posB = bodyB._position;
	      var radA = bodyA._radius;
	      var radB = bodyB._radius;
	      var vec = posA.sub(posB);
	      var l = vec.length();
	      if (l > radA + radB) {
	        return [];
	      }
	      var contact = new _SCNPhysicsContact2.default();
	      contact._nodeA = bodyA._node;
	      contact._nodeB = bodyB._node;
	      contact._contactPoint = posA.add(vec.mul((radA - radB + l) * 0.5));
	      contact._contactNormal = vec.mul(-1).normalize();
	      contact._penetrationDistance = 0.000000001; // FIXME: implement
	      return [contact];
	    }

	    /**
	     * Checks for contacts between one physics body and any other bodies in the physics world.
	     * @access public
	     * @param {SCNPhysicsBody} body - The body to test for contact.
	     * @param {?Map<SCNPhysicsWorld.TestOption, Object>} [options = null] - A dictionary of options affecting the test, or nil to use default options. For applicable keys and the possible values, see Physics Test Options Keys.
	     * @returns {SCNPhysicsContact[]} - 
	     * @desc SceneKit sends messages to the physics worlds contactdelegate object only when collisions occur between bodies whose collisionBitMask and categoryBitMask properties overlap, and only for collisions between certain types of bodies. (For details, see SCNPhysicsBodyType.) Use this method to directly test for all contacts between one body and any other bodies at a time of your choosing. For example, to implement a game with a wall jump effect, you could call this method when the player presses the jump button to see if the player character is in contact with any walls.
	     * @see https://developer.apple.com/reference/scenekit/scnphysicsworld/1512841-contacttest
	     */

	  }, {
	    key: 'contactTestWith',
	    value: function contactTestWith(body) {
	      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

	      return [];
	    }

	    // Searching for Physics Bodies

	    /**
	     * Searches for physics bodies along a line segment between two points in the physics world.
	     * @access public
	     * @param {SCNVector3} origin - An endpoint of the line segment to search, specified in the scenes world coordinate system.
	     * @param {SCNVector3} dest - The other endpoint of the line segment to search, specified in the scenes world coordinate system.
	     * @param {?Map<SCNPhysicsWorld.TestOption, Object>} [options = null] - A dictionary of options affecting the test, or nil to use default options. For applicable keys and the possible values, see Physics Test Options Keys.
	     * @returns {SCNHitTestResult[]} - 
	     * @desc Use this method to implement concepts such as line of sight in your app. For example, in a game you might implement behavior for an enemy character by searching for physics bodies along a line between the enemy characters position and the player characters position, as illustrated below:// Options: Look only for the closest object along line of sight,
	    // and use the collision bitmask to avoid finding the enemy itself.
	    NSDictionary *options = @{ SCNPhysicsTestSearchModeKey : SCNPhysicsTestSearchModeClosest,
	                       SCNPhysicsTestCollisionBitMaskKey : @(kMyCategoryPlayer) };
	    NSArray *results = [physicsWorld rayTestWithSegmentFromPoint:enemy.position
	                                                       toPoint:player.position
	                                                       options:options];
	    if (results.firstObject.node == player) {
	      // Enemy can see player: begin pursuit.
	    } else {
	      // Enemy cannot see player: remain idle.
	    }
	    // Options: Look only for the closest object along line of sight,
	    // and use the collision bitmask to avoid finding the enemy itself.
	    NSDictionary *options = @{ SCNPhysicsTestSearchModeKey : SCNPhysicsTestSearchModeClosest,
	                       SCNPhysicsTestCollisionBitMaskKey : @(kMyCategoryPlayer) };
	    NSArray *results = [physicsWorld rayTestWithSegmentFromPoint:enemy.position
	                                                       toPoint:player.position
	                                                       options:options];
	    if (results.firstObject.node == player) {
	      // Enemy can see player: begin pursuit.
	    } else {
	      // Enemy cannot see player: remain idle.
	    }
	      * @see https://developer.apple.com/reference/scenekit/scnphysicsworld/1512857-raytestwithsegment
	     */

	  }, {
	    key: 'rayTestWithSegmentFromTo',
	    value: function rayTestWithSegmentFromTo(origin, dest) {
	      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

	      var opt = options;
	      if (Array.isArray(options)) {
	        opt = new Map(options);
	      }
	      var results = [];

	      var backfaceCulling = true;
	      var collisionBitMask = -1;
	      var searchMode = _TestSearchMode.any;
	      if (opt.has(_TestOption.backfaceCulling)) {
	        backfaceCulling = opt.get(_TestOption.backfaceCulling);
	      }
	      if (opt.has(_TestOption.collisionBitMask)) {
	        collisionBitMask = opt.get(_TestOption.collisionBitMask);
	      }
	      if (opt.has(_TestOption.searchMode)) {
	        searchMode = opt.get(_TestOption.searchMode);
	      }

	      //let originVec = origin._createBtVector3()
	      //let destVec = dest._createBtVector3()
	      //let rayCallback = null
	      //switch(searchMode){
	      //  case _TestSearchMode.all:
	      //    // TODO: implement
	      //    throw new Error('TestSearchMode.all not implemented')
	      //  case _TestSearchMode.any:
	      //    // TODO: implement
	      //    throw new Error('TestSearchMode.any not implemented')
	      //  case _TestSearchMode.closest:
	      //    rayCallback = new Ammo.ClosestRayResultCallback(originVec, destVec)
	      //    break
	      //  default:
	      //    throw new Error(`unknown search mode: ${searchMode}`)
	      //}

	      //this._world.rayTest(originVec, destVec, rayCallback)
	      //if(rayCallback.hasHit()){
	      //  const result = new SCNHitTestResult()
	      //  const body = Ammo.btRigidBody.prototype.upcast(rayCallback.get_m_collisionObject())
	      //  result._node = null
	      //  result._geometryIndex = 0
	      //  result._faceIndex = 0
	      //  result._worldCoordinates = new SCNVector3(rayCallback.get_m_hitPointWorld())
	      //  result._localCoordinates = null
	      //  result._worldNormal = new SCNVector3(rayCallback.get_m_hitNormalWorld())
	      //  result._localNormal = null
	      //  result._modelTransform = null
	      //  result._boneNode = null
	      //  results.push(result)
	      //}

	      //Ammo.destroy(originVec)
	      //Ammo.destroy(destVec)
	      //Ammo.destroy(rayCallback)

	      //return results
	      var viewProjectionTransform = this._createViewProjectionTransform(origin, dest);
	      var from = origin.transform(viewProjectionTransform);
	      var to = dest.transform(viewProjectionTransform);
	      //console.log('**** rayTestWithSegmentFromTo ****')
	      //console.log(`origin: ${origin.floatArray()}`)
	      //console.log(`dest: ${dest.floatArray()}`)
	      //console.log(`from: ${from.floatArray()}`)
	      //console.log(`to: ${to.floatArray()}`)

	      return this._renderer._physicsHitTestByGPU(viewProjectionTransform, from, to, opt);
	    }

	    /**
	     * @access private
	     * @param {SCNVector3} from -
	     * @param {SCNVector3} to -
	     + @returns {SCNMatrix4} -
	     */

	  }, {
	    key: '_createViewProjectionTransform',
	    value: function _createViewProjectionTransform(from, to) {
	      var vec = to.sub(from);
	      var len = vec.length();
	      var zNear = 1;
	      var zFar = zNear + len;
	      var proj = new _SCNMatrix2.default();
	      proj.m11 = 1;
	      proj.m22 = 1;
	      proj.m33 = -(zFar + zNear) / len;
	      proj.m34 = -1;
	      proj.m43 = -2 * zFar * zNear / len;
	      //proj.m44 = 0

	      var view = new _SCNMatrix2.default();
	      var up = new _SCNVector2.default(0, 1, 0);
	      if (vec.x === 0 && vec.z === 0) {
	        up.y = 0;
	        up.z = 1;
	      }
	      var f = vec.normalize();
	      var s = f.cross(up).normalize();
	      var u = s.cross(f).normalize();
	      view.m11 = s.x;
	      view.m21 = s.y;
	      view.m31 = s.z;
	      view.m12 = u.x;
	      view.m22 = u.y;
	      view.m32 = u.z;
	      view.m13 = -f.x;
	      view.m23 = -f.y;
	      view.m33 = -f.z;
	      view.m44 = 1;
	      var eye = from.sub(f.mul(zNear));
	      var t = eye.transform(view);
	      view.m41 = -t.x;
	      view.m42 = -t.y;
	      view.m43 = -t.z;

	      return view.mult(proj);
	    }

	    /**
	     * Searches for physics bodies in the space formed by moving a convex shape through the physics world.
	     * @access public
	     * @param {SCNPhysicsShape} shape - A physics shape. This shape must enclose a convex volume. For details on creating shapes that satisfy this requirement, see SCNPhysicsShape.
	     * @param {SCNMatrix4} from - A transform matrix representing the initial position and orientation of the shape.
	     * @param {SCNMatrix4} to - A transform matrix representing the final position and orientation of the shape.
	     * @param {?Map<SCNPhysicsWorld.TestOption, Object>} [options = null] - A dictionary of options affecting the test, or nil to use default options. For applicable keys and the possible values, see Physics Test Options Keys.
	     * @returns {SCNPhysicsContact[]} - 
	     * @desc Use this method when its important to plan for (or avoid) collisions ahead of the physics simulation. For example, in a game you might plan maneuvers for a flying character to fit through the gaps between static bodies in the physics world, as illustrated below:// Look for potential collisions along the spaceship's current path.
	    SCNMatrix4 current = spaceship.transform;
	    SCNMatrix4 upAhead = SCNMatrix4Translate(current, 0, 0, LOOK_AHEAD_DISTANCE);
	    NSArray *contacts = [physicsWorld convexSweepTestWithShape:spaceship.physicsBody.physicsShape
	                                               fromTransform:current
	                                                 toTransform:upAhead
	                                                     options:nil];
	    if (contacts.count == 0) {
	      // Flight path looks okay.
	    } else {
	      // Flight path will cause a collision: look for another way around.
	    }
	    // Look for potential collisions along the spaceship's current path.
	    SCNMatrix4 current = spaceship.transform;
	    SCNMatrix4 upAhead = SCNMatrix4Translate(current, 0, 0, LOOK_AHEAD_DISTANCE);
	    NSArray *contacts = [physicsWorld convexSweepTestWithShape:spaceship.physicsBody.physicsShape
	                                               fromTransform:current
	                                                 toTransform:upAhead
	                                                     options:nil];
	    if (contacts.count == 0) {
	      // Flight path looks okay.
	    } else {
	      // Flight path will cause a collision: look for another way around.
	    }
	      * @see https://developer.apple.com/reference/scenekit/scnphysicsworld/1512859-convexsweeptest
	     */

	  }, {
	    key: 'convexSweepTestWith',
	    value: function convexSweepTestWith(shape, from, to) {
	      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

	      return null;
	    }

	    // Structures
	    /**
	     * @type {Object} TestOption
	     * @property {string} backfaceCulling The key for choosing whether to ignore back-facing polygons in physics shapes when searching for contacts.
	     * @property {string} collisionBitMask The key for selecting which categories of physics bodies that SceneKit should test for contacts.
	     * @property {string} searchMode The key for selecting the number and order of contacts to be tested.
	     * @see https://developer.apple.com/reference/scenekit/scnphysicsworld.testoption
	     */

	  }, {
	    key: '_simulate',
	    value: function _simulate(time) {
	      // FIXME: use physics library
	      //this._world.stepSimulation(1.0/60.0, 0)

	      var objects = this._renderer._createRenderingPhysicsNodeArray();
	      var contacts = [];

	      //for(let i=0; i<objects.length-1; i++){
	      //  const bodyA = objects[i].presentation.physicsBody
	      //  for(let j=i+1; j<objects.length; j++){
	      //    const bodyB = objects[j].presentation.physicsBody

	      //    contacts.push(...this.contactTestBetween(bodyA, bodyB))
	      //  }
	      //}
	      for (var i = 0; i < objects.length; i++) {
	        var bodyA = objects[i].presentation.physicsBody;
	        for (var j = 0; j < objects.length; j++) {
	          if (i === j) {
	            continue;
	          }
	          var bodyB = objects[j].presentation.physicsBody;
	          contacts.push.apply(contacts, _toConsumableArray(this.contactTestBetween(bodyA, bodyB)));
	        }
	      }

	      if (this.contactDelegate) {
	        var _iteratorNormalCompletion = true;
	        var _didIteratorError = false;
	        var _iteratorError = undefined;

	        try {
	          for (var _iterator = contacts[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	            var contact = _step.value;

	            this.contactDelegate.physicsWorldDidBegin(this, contact);
	          }
	          // this.contactDelegate.physicsWorldDidUpdate
	          // this.contactDelegate.physicsWorldDidEnd
	        } catch (err) {
	          _didIteratorError = true;
	          _iteratorError = err;
	        } finally {
	          try {
	            if (!_iteratorNormalCompletion && _iterator.return) {
	              _iterator.return();
	            }
	          } finally {
	            if (_didIteratorError) {
	              throw _iteratorError;
	            }
	          }
	        }
	      }
	    }
	  }, {
	    key: 'allBehaviors',
	    get: function get() {
	      return this._allBehaviors.slice(0);
	    }
	  }], [{
	    key: 'TestOption',
	    get: function get() {
	      return _TestOption;
	    }
	    /**
	     * @type {Object} TestSearchMode
	     * @property {string} all Searches should return all contacts matching the search parameters.
	     * @property {string} any Searches should return only the first contact found regardless of its position relative to the search parameters.
	     * @property {string} closest Searches should return only the closest contact to the beginning of the search.
	     * @see https://developer.apple.com/reference/scenekit/scnphysicsworld.testsearchmode
	     */

	  }, {
	    key: 'TestSearchMode',
	    get: function get() {
	      return _TestSearchMode;
	    }
	  }]);

	  return SCNPhysicsWorld;
	}(_NSObject3.default);

	exports.default = SCNPhysicsWorld;

/***/ },
/* 100 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _NSObject2 = __webpack_require__(2);

	var _NSObject3 = _interopRequireDefault(_NSObject2);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * The abstract superclass for joints, vehicle simulations, and other high-level behaviors that incorporate multiple physics bodies.
	 * @access public
	 * @extends {NSObject}
	 * @see https://developer.apple.com/reference/scenekit/scnphysicsbehavior
	 */
	var SCNPhysicsBehavior = function (_NSObject) {
	  _inherits(SCNPhysicsBehavior, _NSObject);

	  function SCNPhysicsBehavior() {
	    _classCallCheck(this, SCNPhysicsBehavior);

	    return _possibleConstructorReturn(this, (SCNPhysicsBehavior.__proto__ || Object.getPrototypeOf(SCNPhysicsBehavior)).apply(this, arguments));
	  }

	  _createClass(SCNPhysicsBehavior, [{
	    key: 'init',


	    /**
	     * constructor
	     * @access public
	     * @returns {void}
	     */
	    value: function init() {}
	  }]);

	  return SCNPhysicsBehavior;
	}(_NSObject3.default);

	exports.default = SCNPhysicsBehavior;

/***/ },
/* 101 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _SCNPhysicsWorld = __webpack_require__(99);

	var _SCNPhysicsWorld2 = _interopRequireDefault(_SCNPhysicsWorld);

	var _SCNPhysicsContact = __webpack_require__(102);

	var _SCNPhysicsContact2 = _interopRequireDefault(_SCNPhysicsContact);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	/**
	 * Methods you can implement to respondwhen a contact or collision occurs between two physics bodies in a scene.
	 * @interface
	 * @see https://developer.apple.com/reference/scenekit/scnphysicscontactdelegate
	 */
	var SCNPhysicsContactDelegate = function () {
	  function SCNPhysicsContactDelegate() {
	    _classCallCheck(this, SCNPhysicsContactDelegate);
	  }

	  _createClass(SCNPhysicsContactDelegate, [{
	    key: 'init',


	    /**
	     * constructor
	     * @access public
	     * @returns {void}
	     */
	    value: function init() {}

	    // Responding to Contact Events

	    /**
	     * Tells the delegate that two bodies have come into contact.
	     * @access public
	     * @param {SCNPhysicsWorld} world - The physics world that is processing the contact.
	     * @param {SCNPhysicsContact} contact - An object that describes the contact.
	     * @returns {void}
	     * @see https://developer.apple.com/reference/scenekit/scnphysicscontactdelegate/1512835-physicsworld
	     */

	  }, {
	    key: 'physicsWorldDidBegin',
	    value: function physicsWorldDidBegin(world, contact) {}

	    /**
	     * Tells the delegate that new information is available about an ongoing contact.
	     * @access public
	     * @param {SCNPhysicsWorld} world - The physics world that is processing the contact.
	     * @param {SCNPhysicsContact} contact - An object that describes the contact.
	     * @returns {void}
	     * @desc SceneKit calls this method on each step of the physics simulation (see the timeStep property) if information about the contact changesfor example, if two bodies are sliding against one another.
	     * @see https://developer.apple.com/reference/scenekit/scnphysicscontactdelegate/1512865-physicsworld
	     */

	  }, {
	    key: 'physicsWorldDidUpdate',
	    value: function physicsWorldDidUpdate(world, contact) {}

	    /**
	     * Tells the delegate that a contact has ended.
	     * @access public
	     * @param {SCNPhysicsWorld} world - The physics world that is processing the contact.
	     * @param {SCNPhysicsContact} contact - An object that describes the contact.
	     * @returns {void}
	     * @see https://developer.apple.com/reference/scenekit/scnphysicscontactdelegate/1512883-physicsworld
	     */

	  }, {
	    key: 'physicsWorldDidEnd',
	    value: function physicsWorldDidEnd(world, contact) {}
	  }]);

	  return SCNPhysicsContactDelegate;
	}();

	exports.default = SCNPhysicsContactDelegate;

/***/ },
/* 102 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _NSObject2 = __webpack_require__(2);

	var _NSObject3 = _interopRequireDefault(_NSObject2);

	var _SCNNode = __webpack_require__(65);

	var _SCNNode2 = _interopRequireDefault(_SCNNode);

	var _SCNVector = __webpack_require__(44);

	var _SCNVector2 = _interopRequireDefault(_SCNVector);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * Detailed information about a contact between two physics bodies in a scenes physics simulation. 
	 * @access public
	 * @extends {NSObject}
	 * @see https://developer.apple.com/reference/scenekit/scnphysicscontact
	 */
	var SCNPhysicsContact = function (_NSObject) {
	  _inherits(SCNPhysicsContact, _NSObject);

	  /**
	   * constructor
	   * @access public
	   * @constructor
	   */
	  function SCNPhysicsContact() {
	    _classCallCheck(this, SCNPhysicsContact);

	    // Inspecting the Contact Properties

	    var _this = _possibleConstructorReturn(this, (SCNPhysicsContact.__proto__ || Object.getPrototypeOf(SCNPhysicsContact)).call(this));

	    _this._nodeA = null;
	    _this._nodeB = null;
	    _this._contactPoint = null;
	    _this._contactNormal = null;
	    _this._collisionImpulse = 0;
	    _this._penetrationDistance = 0;
	    return _this;
	  }

	  // Inspecting the Contact Properties

	  /**
	   * The node containing the first body in the contact.
	   * @type {SCNNode}
	   * @desc Use the nodes physicsBody property to examine physics characteristics of the node.
	   * @see https://developer.apple.com/reference/scenekit/scnphysicscontact/1523445-nodea
	   */


	  _createClass(SCNPhysicsContact, [{
	    key: 'nodeA',
	    get: function get() {
	      return this._nodeA;
	    }

	    /**
	     * The node containing the second body in the contact.
	     * @type {SCNNode}
	     * @desc Use the nodes physicsBody property to examine physics characteristics of the node.
	     * @see https://developer.apple.com/reference/scenekit/scnphysicscontact/1524232-nodeb
	     */

	  }, {
	    key: 'nodeB',
	    get: function get() {
	      return this._nodeB;
	    }

	    /**
	     * The contact point between the two physics bodies, in scene coordinates.
	     * @type {SCNVector3}
	     * @desc 
	     * @see https://developer.apple.com/reference/scenekit/scnphysicscontact/1523810-contactpoint
	     */

	  }, {
	    key: 'contactPoint',
	    get: function get() {
	      return this._contactPoint;
	    }

	    /**
	     * The normal vector at the contact point between the two physics bodies, in scene coordinates.
	     * @type {SCNVector3}
	     * @desc This vector tells you which direction the bodies were moving relative to one another at the time of the collision. For example, in a game you can examine this vector to have enemy characters take damage when struck from above by the player character but damage the player character instead when they collide side-to-side.
	     * @see https://developer.apple.com/reference/scenekit/scnphysicscontact/1522833-contactnormal
	     */

	  }, {
	    key: 'contactNormal',
	    get: function get() {
	      return this._contactNormal;
	    }

	    /**
	     * The force over time of the collision, in newton-seconds.
	     * @type {number}
	     * @desc This propertys value tells you how hard the bodies struck each other in a collision. For example, in a game you might allow a character to proceed unhindered after a minor collision, but take damage when struck with sufficient force.
	     * @see https://developer.apple.com/reference/scenekit/scnphysicscontact/1523944-collisionimpulse
	     */

	  }, {
	    key: 'collisionImpulse',
	    get: function get() {
	      return this._collisionImpulse;
	    }

	    /**
	     * The distance of overlap, in units of scene coordinate space, between the two physics bodies.
	     * @type {number}
	     * @desc 
	     * @see https://developer.apple.com/reference/scenekit/scnphysicscontact/1522870-penetrationdistance
	     */

	  }, {
	    key: 'penetrationDistance',
	    get: function get() {
	      return this._penetrationDistance;
	    }
	  }]);

	  return SCNPhysicsContact;
	}(_NSObject3.default);

	exports.default = SCNPhysicsContact;

/***/ },
/* 103 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _NSObject2 = __webpack_require__(2);

	var _NSObject3 = _interopRequireDefault(_NSObject2);

	var _SCNPhysicsBodyType = __webpack_require__(104);

	var _SCNPhysicsBodyType2 = _interopRequireDefault(_SCNPhysicsBodyType);

	var _SCNPhysicsShape = __webpack_require__(105);

	var _SCNPhysicsShape2 = _interopRequireDefault(_SCNPhysicsShape);

	var _SCNVector = __webpack_require__(44);

	var _SCNVector2 = _interopRequireDefault(_SCNVector);

	var _SCNVector3 = __webpack_require__(45);

	var _SCNVector4 = _interopRequireDefault(_SCNVector3);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/*global Ammo*/

	/**
	 * A set of physics simulation attributes attached to a scene graph node. 
	 * @access public
	 * @extends {NSObject}
	 * @see https://developer.apple.com/reference/scenekit/scnphysicsbody
	 */
	var SCNPhysicsBody = function (_NSObject) {
	  _inherits(SCNPhysicsBody, _NSObject);

	  _createClass(SCNPhysicsBody, null, [{
	    key: '_propTypes',
	    get: function get() {
	      return {
	        physicsShape: 'SCNPhysicsShape',
	        type: 'integer',
	        velocityFactor: 'SCNVector3',
	        angularVelocityFactor: 'SCNVector3',
	        ignoreGravity: ['boolean', function (obj, value) {
	          obj.isAffectedByGravity = !value;
	        }],
	        mass: 'float',
	        charge: 'float',
	        friction: 'float',
	        rollingFriction: 'float',
	        restitution: 'float',
	        damping: 'float',
	        angularDamping: 'float',
	        momentOfInertia: 'SCNVector3',
	        explicitMomentOfInertia: ['boolean', function (obj, value) {
	          obj.usesDefaultMomentOfInertia = !value;
	        }],
	        categoryBitMask: 'integer',
	        contactTestBitMask: 'integer',
	        collisionBitMask: 'integer',
	        velocity: 'SCNVector3',
	        angularVelocity: 'SCNVector4',
	        allowsResting: 'boolean',

	        isDefaultShape: ['boolean', null]
	      };
	    }

	    // Creating Physics Bodies

	    /**
	     * Creates a physics body with the specified type and shape.
	     * @access public
	     * @constructor
	     * @param {SCNPhysicsBodyType} type - A constant that determines how a body responds to forces and collisions. See SCNPhysicsBodyType.
	     * @param {?SCNPhysicsShape} shape - A physics shape defining the volume of the body for collision detection purposes.
	     * @desc For the body to participate in collision detection or respond to forces, you must attach it to the physicsBody property of an SCNNode object in a scene.If you pass nil for the shape parameter, SceneKit automatically creates a physics shape for the body when you attach it to a node, based on that nodes geometry property. To create a physics shape thats based on the geometries of a node and its hierarchy of children, or to control the level of detail in a physics shape, create the physics shape manually using an SCNPhysicsShape class method.NoteFor nodes containing custom geometry, the physics shape SceneKit automatically creates is a rough approximation of the geometry. This approximation, or convex hull, provides a compromise between accuracy and performance in collision detection. For the best collision detection performance, create an SCNPhysicsShape instance based on a basic geometry class (SCNBox, SCNSphere, SCNPyramid, SCNCone, SCNCylinder, or SCNCapsule).
	     * @see https://developer.apple.com/reference/scenekit/scnphysicsbody/1514797-init
	     */

	  }]);

	  function SCNPhysicsBody() {
	    var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _SCNPhysicsBodyType2.default.static;
	    var shape = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

	    _classCallCheck(this, SCNPhysicsBody);

	    // Defining How Forces Affect a Physics Body

	    /**
	     * An object that defines the solid volume of the physics body for use in collision detection.
	     * @type {?SCNPhysicsShape}
	     * @see https://developer.apple.com/reference/scenekit/scnphysicsbody/1514789-physicsshape
	     */
	    var _this = _possibleConstructorReturn(this, (SCNPhysicsBody.__proto__ || Object.getPrototypeOf(SCNPhysicsBody)).call(this));

	    _this.physicsShape = shape;

	    /**
	     * A constant that determines how the physics body responds to forces and collisions.
	     * @type {SCNPhysicsBodyType}
	     * @see https://developer.apple.com/reference/scenekit/scnphysicsbody/1514787-type
	     */
	    _this.type = type;

	    /**
	     * A multiplier affecting how SceneKit applies translations computed by the physics simulation to the node containing the physics body.
	     * @type {SCNVector3}
	     * @see https://developer.apple.com/reference/scenekit/scnphysicsbody/1514753-velocityfactor
	     */
	    _this.velocityFactor = new _SCNVector2.default(0, 0, 0);

	    /**
	     * A multiplier affecting how SceneKit applies rotations computed by the physics simulation to the node containing the physics body.
	     * @type {SCNVector3}
	     * @see https://developer.apple.com/reference/scenekit/scnphysicsbody/1514748-angularvelocityfactor
	     */
	    _this.angularVelocityFactor = new _SCNVector2.default(0, 0, 0);

	    /**
	     * A Boolean value that determines whether the constant gravity of a scene accelerates the body.
	     * @type {boolean}
	     * @see https://developer.apple.com/reference/scenekit/scnphysicsbody/1514738-isaffectedbygravity
	     */
	    _this.isAffectedByGravity = true;

	    // Defining a Bodys Physical Properties

	    /**
	     * The mass of the body, in kilograms.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnphysicsbody/1514755-mass
	     */
	    _this.mass = 0;

	    /**
	     * The electric charge of the body, in coulombs.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnphysicsbody/1514786-charge
	     */
	    _this.charge = 0;

	    /**
	     * The bodys resistance to sliding motion.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnphysicsbody/1514794-friction
	     */
	    _this.friction = 0;

	    /**
	     * The bodys resistance to rolling motion.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnphysicsbody/1514737-rollingfriction
	     */
	    _this.rollingFriction = 0;

	    /**
	     * A factor that determines how much kinetic energy the body loses or gains in collisions.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnphysicsbody/1514740-restitution
	     */
	    _this.restitution = 0;

	    /**
	     * A factor that reduces the bodys linear velocity.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnphysicsbody/1514763-damping
	     */
	    _this.damping = 0;

	    /**
	     * A factor that reduces the bodys angular velocity.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnphysicsbody/1514792-angulardamping
	     */
	    _this.angularDamping = 0;

	    /**
	     * The bodys moment of inertia, expressed in the local coordinate system of the node that contains the body.
	     * @type {SCNVector3}
	     * @see https://developer.apple.com/reference/scenekit/scnphysicsbody/1514777-momentofinertia
	     */
	    _this.momentOfInertia = new _SCNVector2.default(0, 0, 0);

	    /**
	     * A Boolean value that determines whether SceneKit automatically calculates the bodys moment of inertia or allows setting a custom value.
	     * @type {boolean}
	     * @see https://developer.apple.com/reference/scenekit/scnphysicsbody/1514761-usesdefaultmomentofinertia
	     */
	    _this.usesDefaultMomentOfInertia = true;

	    // Working with Contacts and Collisions

	    /**
	     * A mask that defines which categories this physics body belongs to.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnphysicsbody/1514768-categorybitmask
	     */
	    _this.categoryBitMask = 0;

	    /**
	     * A mask that defines which categories of bodies cause intersection notifications with this physics body.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnphysicsbody/1514746-contacttestbitmask
	     */
	    _this.contactTestBitMask = 0;

	    /**
	     * A mask that defines which categories of physics bodies can collide with this physics body.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnphysicsbody/1514772-collisionbitmask
	     */
	    _this.collisionBitMask = 0;

	    // Managing a Bodys Motion

	    /**
	     * A vector describing both the current speed (in meters per second) and direction of motion of the physics body.
	     * @type {SCNVector3}
	     * @see https://developer.apple.com/reference/scenekit/scnphysicsbody/1514757-velocity
	     */
	    _this.velocity = new _SCNVector2.default(0, 0, 0);

	    /**
	     * A vector describing both the current rotation axis and rotational speed (in radians per second) of the physics body.
	     * @type {SCNVector4}
	     * @see https://developer.apple.com/reference/scenekit/scnphysicsbody/1514770-angularvelocity
	     */
	    _this.angularVelocity = new _SCNVector4.default(0, 0, 0, 0);

	    /**
	     * A Boolean value that specifies whether SceneKit can automatically mark the physics body at rest.
	     * @type {boolean}
	     * @see https://developer.apple.com/reference/scenekit/scnphysicsbody/1514742-allowsresting
	     */
	    _this.allowsResting = false;

	    _this._isResting = false;

	    _this._node = null;
	    _this._btRigidBody = null;
	    _this._updateRigidBody();
	    return _this;
	  }

	  /**
	   * Creates a physics body that is unaffected by forces or collisions and that cannot move.
	   * @access public
	   * @returns {SCNPhysicsBody} - 
	   * @desc Use static bodies to construct fixtures in your scene that other bodies need to collide with but that do not themselves move, such as floors, walls, and terrain.For the body to participate in collision detection or respond to forces, you must attach it to the physicsBody property of an SCNNode object in a scene.SceneKit automatically creates a physics shape for the body when you attach it to a node, based on that nodes geometry property. To create a physics shape thats based on the geometries of a node and its hierarchy of children, or to control the level of detail in a physics shape, create the physics shape manually using an SCNPhysicsShape class method.NoteFor nodes containing custom geometry, the physics shape SceneKit automatically creates is a rough approximation of the geometry. This approximation, or convex hull, provides a compromise between accuracy and performance in collision detection. For the best collision detection performance, create an SCNPhysicsShape instance based on a basic geometry class (SCNBox, SCNSphere, SCNPyramid, SCNCone, SCNCylinder, or SCNCapsule).
	   * @see https://developer.apple.com/reference/scenekit/scnphysicsbody/1514791-static
	   */


	  _createClass(SCNPhysicsBody, [{
	    key: 'applyForceAsImpulse',


	    // Applying Forces, Impulses, and Torques

	    /**
	     * Applies a force or impulse to the body at its center of mass.
	     * @access public
	     * @param {SCNVector3} direction - The direction and magnitude of the force (in newtons) or of the impulse (in newton-seconds).
	     * @param {boolean} impulse - true to apply an instantaneous change in momentum; false to apply a force that affects the body at the end of the simulation step.
	     * @returns {void}
	     * @desc Applying a force or impulse to a body imparts a linear acceleration proportional to its mass.The impulse parameter determines how this method contributes to the physics simulation:If you specify true, SceneKit treats the direction parameter as an impulse, measured in newton-seconds, and accelerates the physics body immediately. Use this option to simulate instantaneous effects such as launching a projectile.If you specify false, SceneKit treats the direction parameter as a force, measured in newtons. At the end of each simulation step (by default, a step occurs once for each frame in the rendering loop), SceneKit sums all forces applied to the physics body during that step and accelerates the body according to the net effect of those forces. Use this option when you want to simulate continuous forces on the body by calling applyForce(_:asImpulse:) on each simulation step.NoteThe impulse parameter effectively changes the unit of magnitude. A value that results in a certain acceleration when applied continuously on each frame of the simulation results in much less acceleration if applied only during a single frame.As with all physical quantities in SceneKit, you need not use realistic force measurements in your appthe effects of the physics simulation depend on the relative differences between forces, not on their absolute values. You may use whatever values produce the behavior or gameplay youre looking for as long as you use them consistently.
	     * @see https://developer.apple.com/reference/scenekit/scnphysicsbody/1514801-applyforce
	     */
	    value: function applyForceAsImpulse(direction, impulse) {}

	    /**
	     * Applies a force or impulse to the body at a specific point.
	     * @access public
	     * @param {SCNVector3} direction - The direction and magnitude of the force (in newtons) or of the impulse (in newton-seconds).
	     * @param {SCNVector3} position - The point on the body where the force or impulse should be applied, in the local coordinate system of the SCNNode object containing the physics body.
	     * @param {boolean} impulse - true to apply an instantaneous change in momentum; false to apply a force that affects the body at the end of the simulation step.
	     * @returns {void}
	     * @desc Applying a force or impulse to a body at a position other than its center of mass may impart both linear and angular acceleration, depending on how the body is situated in the physics world and the other forces acting upon it.The impulse parameter determines how this method contributes to the physics simulation:If you specify true, SceneKit treats the direction parameter as an impulse, measured in newton-seconds, and accelerates the physics body immediately. Use this option to simulate instantaneous effects such as launching a projectile.If you specify false, SceneKit treats the direction parameter as a force, measured in newtons. At the end of each simulation step (by default, a step occurs once for each frame in the rendering loop), SceneKit sums all forces applied to the physics body during that step and accelerates the body according to the net effect of those forces. Use this option when you want to simulate continuous forces on the body by calling applyForce(_:at:asImpulse:) on each simulation step.NoteThe impulse parameter effectively changes the unit of magnitude. A value that results in a certain acceleration when applied continuously on each frame of the simulation results in much less acceleration if applied only during a single frame.As with all physical quantities in SceneKit, you need not use realistic force measurements in your appthe effects of the physics simulation depend on the relative differences between forces, not on their absolute values. You may use whatever values produce the behavior or gameplay youre looking for as long as you use them consistently.
	     * @see https://developer.apple.com/reference/scenekit/scnphysicsbody/1514750-applyforce
	     */

	  }, {
	    key: 'applyForceAtAsImpulse',
	    value: function applyForceAtAsImpulse(direction, position, impulse) {}

	    /**
	     * Applies a net torque or a change in angular momentum to the body.
	     * @access public
	     * @param {SCNVector4} torque - The direction and magnitude of the torque (in newton-meters) or of the change of angular momentum (in newton-meter-seconds), relative to the world coordinate space of the scene. 
	     * @param {boolean} impulse - true to apply an instantaneous change in angular momentum; false to apply a torque that affects the body at the end of the simulation step.
	     * @returns {void}
	     * @desc Applying a torque to a body changes its angular velocity by an amount related to its mass and shape, rotating it without affecting its linear acceleration. Each component of the torque vector relates to rotation about the corresponding axis in the local coordinate system of the SCNNode object containing the physics body. For example, applying a torque of {0.0, 0.0, 1.0} causes a node to spin counterclockwise around the world-space z-axis.The impulse parameter determines how this method contributes to the physics simulation:If you specify true, SceneKit treats the direction parameter as an instantaneous change in angular momentum, measured in newton-meter-seconds.If you specify false, SceneKit treats the direction parameter as a torque, measured in newton-meters. At the end of each simulation step (by default, a step occurs once for each frame in the rendering loop), SceneKit sums all forces and torques applied to the physics body during that step and accelerates the body according to the net effect of those forces and torques. Use this option when you want to simulate gradual acceleration by calling applyTorque(_:asImpulse:) on each simulation step.NoteThe impulse parameter effectively changes the unit of magnitude. A value that results in a certain acceleration when applied continuously on each frame of the simulation results in much less acceleration if applied only during a single frame.As with all physical quantities in SceneKit, you need not use realistic force and torque measurements in your appthe effects of the physics simulation depend on the relative differences between forces, not on their absolute values. You may use whatever values produce the behavior or gameplay youre looking for as long as you use them consistently.
	     * @see https://developer.apple.com/reference/scenekit/scnphysicsbody/1514752-applytorque
	     */

	  }, {
	    key: 'applyTorqueAsImpulse',
	    value: function applyTorqueAsImpulse(torque, impulse) {}

	    /**
	     * Cancels all continuous forces and torques acting on the physics body during the current simulation step.
	     * @access public
	     * @returns {void}
	     * @desc When you pass false for the impulse parameter in the applyForce(_:asImpulse:), applyForce(_:at:asImpulse:), or applyTorque(_:asImpulse:) method, SceneKit waits until the end of the current simulation step before applying its effect. At that time, SceneKit sums all forces and torques applied during that simulation step and changes the velocity or angular velocity of the body according to the net effect of those forces and torques.Call clearAllForces() to cancel any forces and torques previously applied during the current simulation step.
	     * @see https://developer.apple.com/reference/scenekit/scnphysicsbody/1514735-clearallforces
	     */

	  }, {
	    key: 'clearAllForces',
	    value: function clearAllForces() {}

	    // Managing a Bodys Motion
	    /**
	     * A Boolean value that indicates whether the physics body is at rest.
	     * @type {boolean}
	     * @desc This propertys default value is false, but SceneKits physics simulation may automatically set it to true if the body is not moving and not affected by any forces. A resting body does not participate in the simulation until another body collides with it or you change its position or velocity or apply a force to it.
	     * @see https://developer.apple.com/reference/scenekit/scnphysicsbody/1514795-isresting
	     */

	  }, {
	    key: 'resetTransform',


	    // Synchronizing a Physics Body with its Node

	    /**
	     * Updates the position and orientation of a body in the physics simulation to match that of the node to which the body is attached.
	     * @access public
	     * @returns {void}
	     * @desc If you change the position or orientation of a node with an attached static or dynamic physics body, call this method afterward to ensure that the physics simulation incorporates the change. You need not call this method for kinematic bodies.Note that dynamic and physics bodies are designed to be moved only by the physics simulation or not at all. You may use this method to move them regardless of this restriction, but at a cost to performance.
	     * @see https://developer.apple.com/reference/scenekit/scnphysicsbody/1514782-resettransform
	     */
	    value: function resetTransform() {}

	    /**
	     * @access private
	     * @returns {void}
	     */

	  }, {
	    key: '_updateRigidBody',
	    value: function _updateRigidBody() {
	      if (this._btRigidBody !== null) {}
	      //Ammo.destroy(this._btRigidBody)

	      //this._btRigidBody = this._createRigidBody()
	    }

	    /**
	     * @access private
	     * @returns {Ammo.btRigidBody} -
	     * @desc call Ammo.destroy(rigidBody) after using it.
	     */

	  }, {
	    key: '_createRigidBody',
	    value: function _createRigidBody() {
	      //let btTransform = null
	      //if(this.physicsShape === null){
	      //  return null
	      //}
	      //if(this._node !== null){
	      //  btTransform = this._node._createBtTransform()
	      //}else{
	      //  btTransform = new Ammo.btTransform()
	      //  btTransform.setIdentity()
	      //}
	      //const btShape = this.physicsShape._createBtCollisionShape()
	      //const inertia = this.momentOfInertia._createBtVector3()

	      //const info = new Ammo.btRigidBodyConstructionInfo(btTransform, btShape, inertia)
	      //const rigidBody = new Ammo.btRigidBody(info)

	      //return rigidBody
	    }
	  }, {
	    key: '_execDestroy',
	    value: function _execDestroy() {}
	    //if(this.physicsShape !== null){
	    //  this.physicsShape._destroy()
	    //  this.physicsShape = null
	    //}
	    //if(this._btRigidBody !== null){
	    //  Ammo.destroy(this._btRigidBody)
	    //  this._btRigidBody = null
	    //}


	    // FIXME: use physics library

	  }, {
	    key: 'isResting',
	    get: function get() {
	      return this._isResting;
	    }
	  }, {
	    key: '_position',
	    get: function get() {
	      var pos = new _SCNVector2.default(0, 0, 0);
	      if (this._node !== null) {
	        pos = this._node._worldTranslation;
	      }
	      if (this.physicsShape !== null && this.physicsShape._sourceGeometry !== null) {
	        var c = this.physicsShape._sourceGeometry.getBoundingSphere().center;
	        pos = pos.add(c);
	      }
	      return pos;
	    }
	  }, {
	    key: '_radius',
	    get: function get() {
	      if (this.physicsShape === null || this.physicsShape._sourceGeometry === null) {
	        return 0;
	      }
	      return this.physicsShape._sourceGeometry.getBoundingSphere().radius;
	    }
	  }], [{
	    key: 'static',
	    value: function _static() {
	      return new SCNPhysicsBody(_SCNPhysicsBodyType2.default.static);
	    }

	    /**
	     * Creates a physics body that can be affected by forces and collisions.
	     * @access public
	     * @returns {SCNPhysicsBody} - 
	     * @desc Use dynamic bodies for the elements of your scene that are moved by the physics simulation.For the body to participate in collision detection or respond to forces, you must attach it to the physicsBody property of an SCNNode object in a scene.SceneKit automatically creates a physics shape for the body when you attach it to a node, based on that nodes geometry property. To create a physics shape thats based on the geometries of a node and its hierarchy of children, or to control the level of detail in a physics shape, create the physics shape manually using an SCNPhysicsShape class method.NoteFor nodes containing custom geometry, the physics shape SceneKit automatically creates is a rough approximation of the geometry. This approximation, or convex hull, provides a compromise between accuracy and performance in collision detection. For the best collision detection performance, create an SCNPhysicsShape instance based on a basic geometry class (SCNBox, SCNSphere, SCNPyramid, SCNCone, SCNCylinder, or SCNCapsule).
	     * @see https://developer.apple.com/reference/scenekit/scnphysicsbody/1514766-dynamic
	     */

	  }, {
	    key: 'dynamic',
	    value: function dynamic() {
	      return new SCNPhysicsBody(_SCNPhysicsBodyType2.default.dynamic);
	    }

	    /**
	     * Creates a physics body that is unaffected by forces or collisions but that can cause collisions affecting other bodies when moved.
	     * @access public
	     * @returns {SCNPhysicsBody} - 
	     * @desc Use kinematic bodies for scene elements that you want to control directly but whose movement manipulates other elements. For example, to allow the user to push objects around with a finger, you might create a kinematic body and attach it to an invisible node that you move follow touch events. (In macOS, use the same technique to allow the user to move objects with the mouse pointer.)For the body to participate in collision detection or respond to forces, you must attach it to the physicsBody property of an SCNNode object in a scene.SceneKit automatically creates a physics shape for the body when you attach it to a node, based on that nodes geometry property. To create a physics shape thats based on the geometries of a node and its hierarchy of children, or to control the level of detail in a physics shape, create the physics shape manually using an SCNPhysicsShape class method.NoteFor nodes containing custom geometry, the physics shape SceneKit automatically creates is a rough approximation of the geometry. This approximation, or convex hull, provides a compromise between accuracy and performance in collision detection. For the best collision detection performance, create an SCNPhysicsShape instance based on a basic geometry class (SCNBox, SCNSphere, SCNPyramid, SCNCone, SCNCylinder, or SCNCapsule).
	     * @see https://developer.apple.com/reference/scenekit/scnphysicsbody/1514776-kinematic
	     */

	  }, {
	    key: 'kinematic',
	    value: function kinematic() {
	      return new SCNPhysicsBody(_SCNPhysicsBodyType2.default.kinematic);
	    }
	  }]);

	  return SCNPhysicsBody;
	}(_NSObject3.default);

	exports.default = SCNPhysicsBody;

/***/ },
/* 104 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * Constants that determine how a physics body interacts with forces and other bodies, used by the type property and when creating a physics body.
	 * @typedef {Object} SCNPhysicsBodyType
	 * @property {number} static - A physics body that is unaffected by forces or collisions and cannot move.
	 * @property {number} dynamic - A physics body that can be affected by forces and collisions.
	 * @property {number} kinematic - A physics body that is unaffected by forces or collisions but that can cause collisions affecting other bodies when moved.
	 * @see https://developer.apple.com/reference/scenekit/scnphysicsbodytype
	 */

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var SCNPhysicsBodyType = {
	  static: 0,
	  dynamic: 1,
	  kinematic: 2
	};

	exports.default = SCNPhysicsBodyType;

/***/ },
/* 105 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _NSObject2 = __webpack_require__(2);

	var _NSObject3 = _interopRequireDefault(_NSObject2);

	var _SCNGeometry = __webpack_require__(68);

	var _SCNGeometry2 = _interopRequireDefault(_SCNGeometry);

	var _SCNNode = __webpack_require__(65);

	var _SCNNode2 = _interopRequireDefault(_SCNNode);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var _Option = {
	  collisionMargin: 'SCNPhysicsShapeCollisionMarginKey',
	  keepAsCompound: 'SCNPhysicsShapeKeepAsCompoundKey',
	  scale: 'SCNPhysicsShapeScaleKey',
	  type: 'SCNPhysicsShapeTypeKey'
	};

	var _ShapeType = {
	  boundingBox: 'boundingBox',
	  concavePolyhedron: 'concaveMesh',
	  convexHull: 'convexHull'
	};

	/**
	 * An abstraction of a physics bodys solid volume for use in tuning or optimizing collision detection.
	 * @access public
	 * @extends {NSObject}
	 * @see https://developer.apple.com/reference/scenekit/scnphysicsshape
	 */

	var SCNPhysicsShape = function (_NSObject) {
	  _inherits(SCNPhysicsShape, _NSObject);

	  _createClass(SCNPhysicsShape, null, [{
	    key: '_propTypes',
	    get: function get() {
	      return {
	        $constructor: function $constructor(propNames, propValues) {
	          return new SCNPhysicsShape(propValues.referenceObject, propValues.options);
	        },
	        options: ['NSArray', null],
	        referenceObject: ['NSObject', null]
	      };
	    }

	    // Creating Physics Shapes

	    /**
	     * Creates a physics shape based on a geometry object.
	     * @access public
	     * @constructor
	     * @param {SCNGeometry} geometry - A geometry object.
	     * @param {?Map<SCNPhysicsShape.Option, Object>} [options = null] - A dictionary of options affecting the level of detail of the physics shape, or nil to use default options. For applicable keys and their possible values, see Shape Creation Options Keys.
	     * @desc If you create a physics shape using one of the basic geometry classes (SCNBox, SCNSphere, SCNPyramid, SCNCone, SCNCylinder, or SCNCapsule), SceneKit uses an idealized form of that geometry for the physics shape instead of using the geometrys vertex data to simulate collisions. For example, if you create a physics shape from an SCNSphere object, SceneKit simulates collisions for any object that passes within the spheres radius. Because the idealized forms of simple geometries are computationally much simpler than the vertex data needed for displaying them, using basic geometries for physics shapes (or compound shapes created from basic geometries with the init(shapes:transforms:) method) often provides the best balance between simulation accuracy and performance. To use the newly created physics shape, create a physics body with the the init(type:shape:) method, or assign the shape to the physicsShape property of an existing body.
	     * @see https://developer.apple.com/reference/scenekit/scnphysicsshape/1508897-init
	     */

	  }]);

	  function SCNPhysicsShape(geometry) {
	    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

	    _classCallCheck(this, SCNPhysicsShape);

	    var _this = _possibleConstructorReturn(this, (SCNPhysicsShape.__proto__ || Object.getPrototypeOf(SCNPhysicsShape)).call(this));

	    var _options = options;
	    if (Array.isArray(_options)) {
	      _options = new Map(_options);
	    }

	    _this._sourceGeometry = null;

	    // Getting Information About a Shape
	    _this._sourceObject = geometry;
	    if (_this._sourceObject instanceof _SCNGeometry2.default) {
	      _this._sourceGeometry = _this._sourceObject;
	    } else if (_this._sourceObject instanceof _SCNNode2.default) {
	      _this._sourceGeometry = _this._sourceObject.geometry;
	    } else {
	      //throw new Error(`can't use it for source object: ${geometry.className}`)
	    }
	    if (!_this._sourceGeometry) {
	      //throw new Error('source geometry is null')
	    }

	    _this._options = _options;
	    _this._transforms = null;
	    return _this;
	  }

	  // Getting Information About a Shape

	  /**
	   * The object that was used to create the shape.
	   * @type {Object}
	   * @desc This property, along with the transforms and options properties, provides the information that was used to create the shape. You can use this information, for example, to draw editing or debugging UI in your scene.If the shape was created with the init(geometry:options:) method, the source object is an SCNGeometry object, and the options property contains the options affecting the shapes construction from that geometry.If the shape was created with the init(node:options:) method, the source object is an SCNNode object, and the options property contains the options affecting the shapes construction from that node.If the shape was created with the init(shapes:transforms:) method, the source object is an array of SCNPhysicsShape objects and the transforms property describes how those shapes combine to form a compound shape.
	   * @see https://developer.apple.com/reference/scenekit/scnphysicsshape/1508888-sourceobject
	   */


	  _createClass(SCNPhysicsShape, [{
	    key: '_createBtCollisionShape',


	    /**
	     * @access private
	     * @returns {Ammo.btCollisionShape}
	     * @desc call Ammo.destroy(shape) after using it.
	     */
	    value: function _createBtCollisionShape() {
	      if (this._sourceObject === null) {
	        throw new Error('_sourceObject is null');
	      }
	      return this._sourceObject._createBtCollisionShape();
	    }
	  }, {
	    key: 'sourceObject',
	    get: function get() {
	      return this._sourceObject;
	    }

	    /**
	     * The options dictionary that was used to create the shape.
	     * @type {?Map<SCNPhysicsShape.Option, Object>}
	     * @desc You provide this dictionary in the init(geometry:options:) or init(node:options:) method. Use this dictionary along with the sourceObject property to recover the information that was used to create the shape. If the shape was created with the init(shapes:transforms:) method, this propertys value is nil.
	     * @see https://developer.apple.com/reference/scenekit/scnphysicsshape/1508904-options
	     */

	  }, {
	    key: 'options',
	    get: function get() {
	      return this._options;
	    }

	    /**
	     * The array of transforms that was used to create a compound shape.
	     * @type {?NSValue[]}
	     * @desc You provide this array of NSValue objects, each containing an SCNMatrix4 value, in the init(shapes:transforms:) method to create a compound shape. Use this array along with the sourceObject property to recover the information that was used to create the shape. If the shape was created with the init(geometry:options:) or init(node:options:) method, this property's value is nil.
	     * @see https://developer.apple.com/reference/scenekit/scnphysicsshape/1508898-transforms
	     */

	  }, {
	    key: 'transforms',
	    get: function get() {
	      return this._transforms;
	    }

	    // Structures

	    /**
	     * @type {Object} Option
	     * @property {string} collisionMargin 
	     * @property {string} keepAsCompound An option for selecting whether to create a group of independent shapes or combine them into a single shape.
	     * @property {string} scale An option for selecting the scale factor of the shape relative to the local coordinate space of the node containing it.
	     * @property {string} type An option for selecting the level of detail at which to create shapes from geometry.
	     * @see https://developer.apple.com/reference/scenekit/scnphysicsshape.option
	     */

	  }], [{
	    key: 'Option',
	    get: function get() {
	      return _Option;
	    }

	    /**
	     * @type {Object} ShapeType
	     * @property {string} boundingBox The physics shape is the smallest box containing the geometry.
	     * @property {string} concavePolyhedron The physics shape is a concave polyhedron closely following the surface of the geometry.
	     * @property {string} convexHull The physics shape is a convex polyhedron roughly enclosing the geometry.
	     * @see https://developer.apple.com/reference/scenekit/scnphysicsshape.shapetype
	     */

	  }, {
	    key: 'ShapeType',
	    get: function get() {
	      return _ShapeType;
	    }
	  }]);

	  return SCNPhysicsShape;
	}(_NSObject3.default);

	exports.default = SCNPhysicsShape;

/***/ },
/* 106 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _NSObject2 = __webpack_require__(2);

	var _NSObject3 = _interopRequireDefault(_NSObject2);

	var _SCNNode = __webpack_require__(65);

	var _SCNNode2 = _interopRequireDefault(_SCNNode);

	var _SCNVector = __webpack_require__(44);

	var _SCNVector2 = _interopRequireDefault(_SCNVector);

	var _SCNMatrix = __webpack_require__(46);

	var _SCNMatrix2 = _interopRequireDefault(_SCNMatrix);

	var _CGPoint = __webpack_require__(7);

	var _CGPoint2 = _interopRequireDefault(_CGPoint);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * Detailed information about a result from searching for elements of a scene located at a specified point, or along a specified line segment (or ray).
	 * @access public
	 * @extends {NSObject}
	 * @see https://developer.apple.com/reference/scenekit/scnhittestresult
	 */
	var SCNHitTestResult = function (_NSObject) {
	  _inherits(SCNHitTestResult, _NSObject);

	  /**
	   * constructor
	   * @access public
	   * @constructor
	   */
	  function SCNHitTestResult() {
	    _classCallCheck(this, SCNHitTestResult);

	    // Retrieving Information About a Hit-Test Result

	    var _this = _possibleConstructorReturn(this, (SCNHitTestResult.__proto__ || Object.getPrototypeOf(SCNHitTestResult)).call(this));

	    _this._node = null;
	    _this._geometryIndex = 0;
	    _this._faceIndex = 0;
	    _this._localCoordinates = null;
	    _this._worldCoordinates = null;
	    _this._localNormal = null;
	    _this._worldNormal = null;
	    _this._modelTransform = null;

	    // Instance Properties

	    _this._boneNode = null;
	    return _this;
	  }

	  // Retrieving Information About a Hit-Test Result

	  /**
	   * Returns the texture coordinates at the point of intersection for the specified texture mapping channel.
	   * @access public
	   * @param {number} channel - The index of the mapping channel in which to look up texture coordinates.
	   * @returns {CGPoint} - 
	   * @desc An SCNGeometry object can contain multiple sources of texture coordinates, or texture mapping channels. (With multiple channels, you can map texture images for different material properties in different ways.) To use the texture coordinates of a hit-test result, specify which texture coordinate source to look up coordinates in. For example, to add scorch marks to a game character hit by a laser, you might modify a texture image mapped to the multiply property of the geometrys material. Use the mappingChannel index from that material property as the channel parameter when calling textureCoordinates(withMappingChannel:) to ensure that you modify the correct location in the texture image.
	   * @see https://developer.apple.com/reference/scenekit/scnhittestresult/1522771-texturecoordinates
	   */


	  _createClass(SCNHitTestResult, [{
	    key: 'textureCoordinatesWithMappingChannel',
	    value: function textureCoordinatesWithMappingChannel(channel) {
	      return null;
	    }

	    /**
	     * The node whose geometry intersects the search ray.
	     * @type {SCNNode}
	     * @desc 
	     * @see https://developer.apple.com/reference/scenekit/scnhittestresult/1523256-node
	     */

	  }, {
	    key: 'node',
	    get: function get() {
	      return this._node;
	    }

	    /**
	     * The index of the geometry element whose surface the search ray intersects.
	     * @type {number}
	     * @desc Every SCNGeometry object contains one or more SCNGeometryElement objects that define how its vertices connect to form a surface. This property provides the index of the geometry element intersecting the search ray. For more information about that geometry element, use the geometrys geometryElement(at:) method.
	     * @see https://developer.apple.com/reference/scenekit/scnhittestresult/1522625-geometryindex
	     */

	  }, {
	    key: 'geometryIndex',
	    get: function get() {
	      return this._geometryIndex;
	    }

	    /**
	     * The index of the primitive in the geomety element intersected by the search ray.
	     * @type {number}
	     * @desc 
	     * @see https://developer.apple.com/reference/scenekit/scnhittestresult/1522888-faceindex
	     */

	  }, {
	    key: 'faceIndex',
	    get: function get() {
	      return this._faceIndex;
	    }

	    /**
	     * The point of intersection between the geometry and the search ray, in the local coordinate system of the node containing the geometry.
	     * @type {SCNVector3}
	     * @desc 
	     * @see https://developer.apple.com/reference/scenekit/scnhittestresult/1523032-localcoordinates
	     */

	  }, {
	    key: 'localCoordinates',
	    get: function get() {
	      return this._localCoordinates;
	    }

	    /**
	     * The point of intersection between the geometry and the search ray, in the scenes world coordinate system.
	     * @type {SCNVector3}
	     * @desc 
	     * @see https://developer.apple.com/reference/scenekit/scnhittestresult/1523058-worldcoordinates
	     */

	  }, {
	    key: 'worldCoordinates',
	    get: function get() {
	      return this._worldCoordinates;
	    }

	    /**
	     * The surface normal vector at the point of intersection, in the local coordinate system of the node containing the geometry intersected by the search ray.
	     * @type {SCNVector3}
	     * @desc 
	     * @see https://developer.apple.com/reference/scenekit/scnhittestresult/1523953-localnormal
	     */

	  }, {
	    key: 'localNormal',
	    get: function get() {
	      return this._localNormal;
	    }

	    /**
	     * The surface normal vector at the point of intersection, in the scenes world coordinate system.
	     * @type {SCNVector3}
	     * @desc 
	     * @see https://developer.apple.com/reference/scenekit/scnhittestresult/1524066-worldnormal
	     */

	  }, {
	    key: 'worldNormal',
	    get: function get() {
	      return this._worldNormal;
	    }

	    /**
	     * The world transform matrix of the node containing the intersection.
	     * @type {SCNMatrix4}
	     * @desc Use this matrix to transform vectors from the local coordinate space of the node whose geometry is intersected by the search ray to the scenes world coordinate system.
	     * @see https://developer.apple.com/reference/scenekit/scnhittestresult/1523496-modeltransform
	     */

	  }, {
	    key: 'modelTransform',
	    get: function get() {
	      return this._modelTransform;
	    }

	    // Instance Properties

	    /**
	     * 
	     * @type {SCNNode}
	     * @desc 
	     * @see https://developer.apple.com/reference/scenekit/scnhittestresult/1823463-bonenode
	     */

	  }, {
	    key: 'boneNode',
	    get: function get() {
	      return this._boneNode;
	    }
	  }]);

	  return SCNHitTestResult;
	}(_NSObject3.default);

	exports.default = SCNHitTestResult;

/***/ },
/* 107 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _BinaryRequest2 = __webpack_require__(97);

	var _BinaryRequest3 = _interopRequireDefault(_BinaryRequest2);

	var _NSKeyedUnarchiver = __webpack_require__(33);

	var _NSKeyedUnarchiver2 = _interopRequireDefault(_NSKeyedUnarchiver);

	var _NSObject3 = __webpack_require__(2);

	var _NSObject4 = _interopRequireDefault(_NSObject3);

	var _SCNAnimatable = __webpack_require__(66);

	var _SCNAnimatable2 = _interopRequireDefault(_SCNAnimatable);

	var _SCNMatrix = __webpack_require__(46);

	var _SCNMatrix2 = _interopRequireDefault(_SCNMatrix);

	var _SCNParticleBirthLocation = __webpack_require__(108);

	var _SCNParticleBirthLocation2 = _interopRequireDefault(_SCNParticleBirthLocation);

	var _SCNParticleBirthDirection = __webpack_require__(109);

	var _SCNParticleBirthDirection2 = _interopRequireDefault(_SCNParticleBirthDirection);

	var _SCNVector = __webpack_require__(44);

	var _SCNVector2 = _interopRequireDefault(_SCNVector);

	var _SCNVector3 = __webpack_require__(45);

	var _SCNVector4 = _interopRequireDefault(_SCNVector3);

	var _SCNParticleImageSequenceAnimationMode = __webpack_require__(110);

	var _SCNParticleImageSequenceAnimationMode2 = _interopRequireDefault(_SCNParticleImageSequenceAnimationMode);

	var _SCNParticleBlendMode = __webpack_require__(111);

	var _SCNParticleBlendMode2 = _interopRequireDefault(_SCNParticleBlendMode);

	var _SCNParticleOrientationMode = __webpack_require__(112);

	var _SCNParticleOrientationMode2 = _interopRequireDefault(_SCNParticleOrientationMode);

	var _SCNParticleSortingMode = __webpack_require__(113);

	var _SCNParticleSortingMode2 = _interopRequireDefault(_SCNParticleSortingMode);

	var _SCNParticleEvent = __webpack_require__(114);

	var _SCNParticleEvent2 = _interopRequireDefault(_SCNParticleEvent);

	var _SCNParticleEventBlock = __webpack_require__(115);

	var _SCNParticleEventBlock2 = _interopRequireDefault(_SCNParticleEventBlock);

	var _SCNParticlePropertyController = __webpack_require__(116);

	var _SCNParticlePropertyController2 = _interopRequireDefault(_SCNParticlePropertyController);

	var _SCNParticleModifierStage = __webpack_require__(118);

	var _SCNParticleModifierStage2 = _interopRequireDefault(_SCNParticleModifierStage);

	var _SCNParticleModifierBlock = __webpack_require__(119);

	var _SCNParticleModifierBlock2 = _interopRequireDefault(_SCNParticleModifierBlock);

	var _SKColor = __webpack_require__(11);

	var _SKColor2 = _interopRequireDefault(_SKColor);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	//import SCNGeometry from './SCNGeometry'

	//import SCNNode from './SCNNode'


	var _ParticleProperty = {
	  angle: 'Angle',
	  angularVelocity: 'AngularVelocity',
	  bounce: 'Bounce',
	  charge: 'Charge',
	  color: 'Color',
	  contactNormal: 'ContactNormal',
	  contactPoint: 'ContactPoint',
	  frame: 'Frame',
	  frameRate: 'FrameRate',
	  friction: 'Friction',
	  life: 'Life',
	  opacity: 'Opacity',
	  position: 'Position',
	  rotationAxis: 'RotationAxis',
	  size: 'Size',
	  velocity: 'Velocity'
	};

	var _Particle = function (_NSObject) {
	  _inherits(_Particle, _NSObject);

	  /**
	   * @access public
	   * @constructor
	   */
	  function _Particle() {
	    _classCallCheck(this, _Particle);

	    /**
	     * @type {SCNVector3}
	     */
	    var _this = _possibleConstructorReturn(this, (_Particle.__proto__ || Object.getPrototypeOf(_Particle)).call(this));

	    _this.position = null;

	    /**
	     * @type {SCNVector3}
	     */
	    _this.axis = null;

	    /**
	     * @type {number}
	     */
	    _this.angle = 0;

	    /**
	     * @type {number}
	     */
	    _this.size = 1;

	    /**
	     * @type {SKColor}
	     */
	    _this.color = null;

	    /**
	     * @type {SCNVector3}
	     */
	    _this.velocity = null;

	    /**
	     * @type {number}
	     */
	    _this.angularVelocity = 0;

	    /**
	     * @type {SCNVector3}
	     */
	    _this.acceleration = null;

	    /**
	     * @type {number}
	     */
	    _this.birthTime = 0;

	    /**
	     * @type {number}
	     */
	    _this.lifeSpan = 0;

	    /**
	     * @type {number}
	     */
	    _this.imageFrameRate = 0;

	    /**
	     * @type {number}
	     */
	    _this.initialImageFrame = 0;

	    /**
	     * @type {number}
	     */
	    _this.texLeft = 0;

	    /**
	     * @type {number}
	     */
	    _this.texRight = 0;

	    /**
	     * @type {number}
	     */
	    _this.texTop = 0;

	    /**
	     * @type {number}
	     */
	    _this.texBottom = 0;

	    _this._maxParticleIndex = 0;
	    return _this;
	  }

	  /**
	   * @access public
	   * @returns {number[]} -
	   */


	  _createClass(_Particle, [{
	    key: 'floatArray',
	    value: function floatArray() {
	      var baseArray = [].concat(_toConsumableArray(this.position.floatArray()), _toConsumableArray(this.velocity.floatArray()), _toConsumableArray(this.axis.floatArray()), [this.angle], _toConsumableArray(this.color.floatArray()), [this.size]);
	      return [].concat(_toConsumableArray(baseArray), [this.texLeft, this.texTop], _toConsumableArray(baseArray), [this.texRight, this.texTop], _toConsumableArray(baseArray), [this.texLeft, this.texBottom], _toConsumableArray(baseArray), [this.texRight, this.texBottom]);
	    }

	    /**
	     * @access public
	     * @returns {Float32Array} -
	     */

	  }, {
	    key: 'float32Array',
	    value: function float32Array() {
	      return new Float32Array(this.floatArray());
	    }
	  }]);

	  return _Particle;
	}(_NSObject4.default);

	/**
	 * Manages the animation and rendering of a system of small image sprites, or particles, using ahigh-level simulation whose general behavior you specify.
	 * @access public
	 * @extends {NSObject}
	 * @implements {SCNAnimatable}
	 * @see https://developer.apple.com/reference/scenekit/scnparticlesystem
	 */


	var SCNParticleSystem = function (_NSObject2) {
	  _inherits(SCNParticleSystem, _NSObject2);

	  _createClass(SCNParticleSystem, null, [{
	    key: '_propTypes',
	    get: function get() {
	      return {
	        emissionDuration: 'float',
	        emissionDurationVariation: 'float',
	        idleDuration: 'float',
	        idleDurationVariation: 'float',
	        loops: 'boolean',
	        warmupDuration: 'float',
	        birthRate: 'float',
	        birthRateVariation: 'float',
	        emitterShape: 'SCNGeometry',
	        birthLocation: 'integer',
	        birthDirection: 'integer',
	        emittingDirection: 'SCNVector3',
	        spreadingAngle: 'float',
	        particleAngle: 'float',
	        particleAngleVariation: 'float',
	        particleVelocity: 'float',
	        particleVelocityVariation: 'float',
	        particleAngularVelocity: 'float',
	        particleAngularVelocityVariation: 'float',
	        particleLifeSpan: 'float',
	        particleLifeSpanVariation: 'float',
	        particleSize: 'float',
	        particleSizeVariation: 'float',
	        particleColor: 'plist',
	        particleColorVariation: 'SCNVector4',
	        particleImage: ['NSMutableDictionary', function (obj, dict, key, coder) {
	          var path = '';
	          if (typeof dict.path !== 'undefined') {
	            path = coder._directoryPath + dict.path;
	          } else if (typeof dict.URL !== 'undefined') {
	            path = dict.URL;
	          }
	          obj._loadParticleImage(path, coder._directoryPath);
	        }],
	        fresnelExponent: 'float',
	        stretchFactor: 'float',
	        imageSequenceRowCount: 'integer',
	        imageSequenceColumnCount: 'integer',
	        imageSequenceInitialFrame: 'float',
	        imageSequenceInitialFrameVariation: 'float',
	        imageSequenceFrameRate: 'float',
	        imageSequenceFrameRateVariation: 'float',
	        imageSequenceAnimationMode: 'integer',
	        affectedByGravity: ['boolean', 'isAffectedByGravity'],
	        affectedByPhysicsFields: ['boolean', 'isAffectedByPhysicsFields'],
	        colliderNodes: 'NSArray',
	        particleDiesOnCollision: 'boolean',
	        acceleration: 'SCNVector3',
	        dampingFactor: 'float',
	        particleMass: 'float',
	        particleMassVariation: 'float',
	        particleCharge: 'float',
	        particleChargeVariation: 'float',
	        particleBounce: 'float',
	        particleBounceVariation: 'float',
	        particleFriction: 'float',
	        particleFrictionVariation: 'float',
	        systemSpawnedOnCollision: 'SCNParticleSystem',
	        systemSpawnedOnDying: 'SCNParticleSystem',
	        systemSpawnedOnLiving: 'SCNParticleSystem',
	        blendMode: 'integer',
	        orientationMode: 'integer',
	        sortingMode: 'integer',
	        lightingEnabled: ['boolean', 'isLightingEnabled'],
	        blackPassEnabled: ['boolean', 'isBlackPassEnabled'],
	        isLocal: 'boolean',
	        speedFactor: 'float',
	        propertyControllers: ['NSMutableDictionary', function (obj, dict) {
	          Object.keys(_ParticleProperty).forEach(function (key) {
	            var d = dict[_ParticleProperty[key]];
	            if (typeof d !== 'undefined') {
	              d.animation.keyPath = key;
	              //console.error(`SCNParticleSystem key: ${key}, ${d.animation.className}`)
	              //if(key === 'size'){
	              //  d.animation._isMultiplicative = true
	              //}
	            }
	          });
	          obj.propertyControllers = dict;
	        }],

	        seed: ['integer', null],
	        softParticlesEnabled: ['boolean', null],
	        fixedTimeStep: ['float', null],
	        renderingMode: ['integer', null],
	        physicsCollisionsEnabled: ['boolean', null]
	      };
	    }

	    /**
	     * constructor
	     * @access public
	     * @constructor
	     * @param {string} name - The name of a particle system file in the apps bundle resources directory, with or without the .scnp extension.
	     * @param {?string} directory - The subdirectory path in the apps bundle resources directory.
	     */

	  }]);

	  function SCNParticleSystem() {
	    var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
	    var directory = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

	    _classCallCheck(this, SCNParticleSystem);

	    // Managing Particle Emission Timing

	    /**
	     * The duration, in seconds, over which the system spawns new particles. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnparticlesystem/1523998-emissionduration
	     */
	    var _this2 = _possibleConstructorReturn(this, (SCNParticleSystem.__proto__ || Object.getPrototypeOf(SCNParticleSystem)).call(this));

	    _this2.emissionDuration = 1.0;

	    /**
	     * The range, in seconds, of randomized emission duration values. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnparticlesystem/1523842-emissiondurationvariation
	     */
	    _this2.emissionDurationVariation = 0.0;

	    /**
	     * The duration, in seconds, of periods when the system emits no particles. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnparticlesystem/1522998-idleduration
	     */
	    _this2.idleDuration = 0.0;

	    /**
	     * The range, in seconds, of randomized idle duration values. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnparticlesystem/1523018-idledurationvariation
	     */
	    _this2.idleDurationVariation = 0.0;

	    /**
	     * A Boolean value that determines whether the system repeats its emission and idle periods.
	     * @type {boolean}
	     * @see https://developer.apple.com/reference/scenekit/scnparticlesystem/1522618-loops
	     */
	    _this2.loops = true;

	    /**
	     * The duration, in seconds, for which particles are spawned before the system is first rendered. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnparticlesystem/1522597-warmupduration
	     */
	    _this2.warmupDuration = 0.0;

	    /**
	     * The number of particles spawned during each emission period. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnparticlesystem/1522857-birthrate
	     */
	    _this2.birthRate = 0.0;

	    /**
	     * The range of randomized particle birth rate values. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnparticlesystem/1524147-birthratevariation
	     */
	    _this2.birthRateVariation = 0.0;

	    // Managing Particle Emission Locations

	    /**
	     * The shape of the region of space where the system spawns new particles.
	     * @type {?SCNGeometry}
	     * @see https://developer.apple.com/reference/scenekit/scnparticlesystem/1522737-emittershape
	     */
	    _this2.emitterShape = null;

	    /**
	     * The possible locations for newly spawned particles, relative to the emitter shape.
	     * @type {SCNParticleBirthLocation}
	     * @see https://developer.apple.com/reference/scenekit/scnparticlesystem/1522899-birthlocation
	     */
	    _this2.birthLocation = _SCNParticleBirthLocation2.default.surface;

	    /**
	     * The possible initial directions for newly spawned particles, relative to the emitter shape.
	     * @type {SCNParticleBirthDirection}
	     * @see https://developer.apple.com/reference/scenekit/scnparticlesystem/1523361-birthdirection
	     */
	    _this2.birthDirection = _SCNParticleBirthDirection2.default.constant;

	    /**
	     * The initial direction for newly spawned particles. Animatable.
	     * @type {SCNVector3}
	     * @see https://developer.apple.com/reference/scenekit/scnparticlesystem/1523600-emittingdirection
	     */
	    _this2.emittingDirection = new _SCNVector2.default(0, 1, 0);

	    /**
	     * The range, in degrees, of randomized initial particle directions. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnparticlesystem/1522862-spreadingangle
	     */
	    _this2.spreadingAngle = 0.0;

	    // Managing Particle Motion

	    /**
	     * The rotation angle, in degrees, of newly spawned particles. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnparticlesystem/1523896-particleangle
	     */
	    _this2.particleAngle = 0.0;

	    /**
	     * The range, in degrees of randomized initial particle angles. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnparticlesystem/1522828-particleanglevariation
	     */
	    _this2.particleAngleVariation = 0.0;

	    /**
	     * The initial speed, in units per second, for newly spawned particles. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnparticlesystem/1523946-particlevelocity
	     */
	    _this2.particleVelocity = 0.0;

	    /**
	     * The range, in units per second, of randomized initial particle speeds. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnparticlesystem/1524157-particlevelocityvariation
	     */
	    _this2.particleVelocityVariation = 0.0;

	    /**
	     * The initial spin rate, in degrees per second, of newly spawned particles. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnparticlesystem/1522757-particleangularvelocity
	     */
	    _this2.particleAngularVelocity = 0.0;

	    /**
	     * The range, in degrees per second, of randomized initial angular velocities for particles. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnparticlesystem/1523590-particleangularvelocityvariation
	     */
	    _this2.particleAngularVelocityVariation = 0.0;

	    /**
	     * The duration, in seconds, for which each particle is rendered before being removed from the scene. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnparticlesystem/1523575-particlelifespan
	     */
	    _this2.particleLifeSpan = 1.0;

	    /**
	     * The range, in seconds, of randomized particle life spans. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnparticlesystem/1523567-particlelifespanvariation
	     */
	    _this2.particleLifeSpanVariation = 0.0;

	    // Specifying Particle Appearance

	    /**
	     * The rendered size, in units of the scenes world coordinate space, of the particle image. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnparticlesystem/1523508-particlesize
	     */
	    _this2.particleSize = 1.0;

	    /**
	     * The range of randomized particle sizes. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnparticlesystem/1522716-particlesizevariation
	     */
	    _this2.particleSizeVariation = 0.0;

	    /**
	     * The color of newly spawned particles. Animatable.
	     * @type {SKColor}
	     * @see https://developer.apple.com/reference/scenekit/scnparticlesystem/1523248-particlecolor
	     */
	    _this2.particleColor = _SKColor2.default.white;

	    /**
	     * The ranges of randomized particle color components. Animatable.
	     * @type {SCNVector4}
	     * @see https://developer.apple.com/reference/scenekit/scnparticlesystem/1523639-particlecolorvariation
	     */
	    _this2.particleColorVariation = new _SCNVector4.default(0, 0, 0, 0);

	    /**
	     * The texture image SceneKit uses to render each particle.
	     * @type {?Object}
	     * @see https://developer.apple.com/reference/scenekit/scnparticlesystem/1524153-particleimage
	     */
	    _this2.particleImage = null;

	    /**
	     * The reflectivity exponent SceneKit uses when rendering the particles image as a cube map. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnparticlesystem/1523317-fresnelexponent
	     */
	    _this2.fresnelExponent = 0.0;

	    /**
	     * A multiplier for stretching particle images along their direction of motion. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnparticlesystem/1523338-stretchfactor
	     */
	    _this2.stretchFactor = 0.0;

	    // Animating Particle Images

	    /**
	     * The number of rows for treating the particle image as a grid of animation frames.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnparticlesystem/1523340-imagesequencerowcount
	     */
	    _this2.imageSequenceRowCount = 1;

	    /**
	     * The number of columns for treating the particle image as a grid of animation frames.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnparticlesystem/1523462-imagesequencecolumncount
	     */
	    _this2.imageSequenceColumnCount = 1;

	    /**
	     * The index of the first frame in a particle image animation. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnparticlesystem/1523511-imagesequenceinitialframe
	     */
	    _this2.imageSequenceInitialFrame = 0.0;

	    /**
	     * The range of randomized initial frames for particle image animation. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnparticlesystem/1523821-imagesequenceinitialframevariati
	     */
	    _this2.imageSequenceInitialFrameVariation = 0.0;

	    /**
	     * The rate, in frames per second, of particle image animation. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnparticlesystem/1524075-imagesequenceframerate
	     */
	    _this2.imageSequenceFrameRate = 0.0;

	    /**
	     * The range, in frames per second, of randomized frame rates for particle image animation. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnparticlesystem/1523667-imagesequenceframeratevariation
	     */
	    _this2.imageSequenceFrameRateVariation = 0.0;

	    /**
	     * The animation mode for particle image animation.
	     * @type {SCNParticleImageSequenceAnimationMode}
	     * @see https://developer.apple.com/reference/scenekit/scnparticlesystem/1522816-imagesequenceanimationmode
	     */
	    _this2.imageSequenceAnimationMode = _SCNParticleImageSequenceAnimationMode2.default.repeat;

	    // Simulating Physics for Particles

	    /**
	     * A Boolean value that determines whether gravity, as defined by the scenes physics simulation, affects the motion of particles.
	     * @type {boolean}
	     * @see https://developer.apple.com/reference/scenekit/scnparticlesystem/1523452-isaffectedbygravity
	     */
	    _this2.isAffectedByGravity = false;

	    /**
	     * A Boolean value that determines whether physics fields in the scene affect the motion of particles.
	     * @type {boolean}
	     * @see https://developer.apple.com/reference/scenekit/scnparticlesystem/1523353-isaffectedbyphysicsfields
	     */
	    _this2.isAffectedByPhysicsFields = false;

	    /**
	     * The nodes whose geometry the systems particles can collide with.
	     * @type {?SCNNode[]}
	     * @see https://developer.apple.com/reference/scenekit/scnparticlesystem/1523516-collidernodes
	     */
	    _this2.colliderNodes = null;

	    /**
	     * A Boolean value that determines whether particles are removed from the scene upon colliding with another object.
	     * @type {boolean}
	     * @see https://developer.apple.com/reference/scenekit/scnparticlesystem/1523357-particlediesoncollision
	     */
	    _this2.particleDiesOnCollision = false;

	    /**
	     * The constant acceleration vector, in units per second per second, applied to all particles in the system. Animatable.
	     * @type {SCNVector3}
	     * @see https://developer.apple.com/reference/scenekit/scnparticlesystem/1522766-acceleration
	     */
	    _this2.acceleration = new _SCNVector2.default(0, 0, 0);

	    /**
	     * A factor that slows particles relative to their velocity. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnparticlesystem/1522931-dampingfactor
	     */
	    _this2.dampingFactor = 0.0;

	    /**
	     * The mass, in kilograms, of each particle in the system. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnparticlesystem/1522607-particlemass
	     */
	    _this2.particleMass = 1.0;

	    /**
	     * The range, in kilograms, of randomized particle masses. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnparticlesystem/1523408-particlemassvariation
	     */
	    _this2.particleMassVariation = 0.0;

	    /**
	     * The electric charge, in coulombs, of each particle in the system. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnparticlesystem/1523156-particlecharge
	     */
	    _this2.particleCharge = 0.0;

	    /**
	     * The range, in coulombs, of randomized particle charges. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnparticlesystem/1523377-particlechargevariation
	     */
	    _this2.particleChargeVariation = 0.0;

	    /**
	     * The restitution coefficient of each particle in the system. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnparticlesystem/1522637-particlebounce
	     */
	    _this2.particleBounce = 0.7;

	    /**
	     * The range of randomized restitution coefficients for particles. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnparticlesystem/1522662-particlebouncevariation
	     */
	    _this2.particleBounceVariation = 0.0;

	    /**
	     * The friction coefficient of each particle in the system. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnparticlesystem/1524010-particlefriction
	     */
	    _this2.particleFriction = 1.0;

	    /**
	     * The range of randomized friction coefficients for particles. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnparticlesystem/1522868-particlefrictionvariation
	     */
	    _this2.particleFrictionVariation = 0.0;

	    // Spawning Additional Particle Systems

	    /**
	     * Another particle system to be added to the scene when a particle collides with scene geometry.
	     * @type {?SCNParticleSystem}
	     * @see https://developer.apple.com/reference/scenekit/scnparticlesystem/1524068-systemspawnedoncollision
	     */
	    _this2.systemSpawnedOnCollision = null;

	    /**
	     * Another particle system to be added to the scene when a particle dies.
	     * @type {?SCNParticleSystem}
	     * @see https://developer.apple.com/reference/scenekit/scnparticlesystem/1524091-systemspawnedondying
	     */
	    _this2.systemSpawnedOnDying = null;

	    /**
	     * Another particle system to be added to the scene for each living particle in the system.
	     * @type {?SCNParticleSystem}
	     * @see https://developer.apple.com/reference/scenekit/scnparticlesystem/1522751-systemspawnedonliving
	     */
	    _this2.systemSpawnedOnLiving = null;

	    // Managing Particle Rendering

	    /**
	     * The blending mode for compositing particle images into the rendered scene.
	     * @type {SCNParticleBlendMode}
	     * @see https://developer.apple.com/reference/scenekit/scnparticlesystem/1523728-blendmode
	     */
	    _this2.blendMode = _SCNParticleBlendMode2.default.additive;

	    /**
	     * The mode defining whether and how particles may rotate.
	     * @type {SCNParticleOrientationMode}
	     * @see https://developer.apple.com/reference/scenekit/scnparticlesystem/1523131-orientationmode
	     */
	    _this2.orientationMode = _SCNParticleOrientationMode2.default.billboardScreenAligned;

	    /**
	     * The mode defining the order in which SceneKit renders the systems particles.
	     * @type {SCNParticleSortingMode}
	     * @see https://developer.apple.com/reference/scenekit/scnparticlesystem/1522795-sortingmode
	     */
	    _this2.sortingMode = _SCNParticleSortingMode2.default.none;

	    /**
	     * A Boolean value that determines whether SceneKit applies lighting to particle images when rendering.
	     * @type {boolean}
	     * @see https://developer.apple.com/reference/scenekit/scnparticlesystem/1522794-islightingenabled
	     */
	    _this2.isLightingEnabled = false;

	    /**
	     * A Boolean value that determines whether SceneKit renders particles in black before rendering the particle image.
	     * @type {boolean}
	     * @see https://developer.apple.com/reference/scenekit/scnparticlesystem/1523901-isblackpassenabled
	     */
	    _this2.isBlackPassEnabled = false;

	    // Controlling Particle Simulation

	    /**
	     * A Boolean value that specifies whether the particle simulation runs in the local coordinate space of the node containing it.
	     * @type {boolean}
	     * @see https://developer.apple.com/reference/scenekit/scnparticlesystem/1522855-islocal
	     */
	    _this2.isLocal = false;

	    /**
	     * A multiplier for the speed at which SceneKit runs the particle simulation. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnparticlesystem/1522988-speedfactor
	     */
	    _this2.speedFactor = 1.0;

	    // Modifying Particles Over Time

	    /**
	     * A dictionary that optionally associates particle properties with objects that animate a propertys value for each particle.
	     * @type {?Map<SCNParticleSystem.ParticleProperty, SCNParticlePropertyController>}
	     * @see https://developer.apple.com/reference/scenekit/scnparticlesystem/1522775-propertycontrollers
	     */
	    _this2.propertyControllers = null;

	    _this2._program = null;
	    _this2._vertexArray = null;
	    _this2._vertexBuffer = null;
	    _this2._indexBuffer = null;
	    _this2._particles = [];
	    _this2._glIndexSize = null;
	    _this2._particleTexture = null;

	    _this2._finished = false;
	    _this2._startTime = null;
	    _this2._prevTime = 0;
	    _this2._nextBirthTime = 0;
	    _this2._emissionEndTime = 0;
	    _this2._idleEndTime = 0;
	    _this2._numImages = null;
	    _this2._imageWidth = null;
	    _this2._imageHeight = null;

	    _this2._loadingPromise = null;
	    //if(name !== null){
	    //  let path = name
	    //  if(directory !== null){
	    //    path = `${directory}/${name}`
	    //  }
	    //  this._loadingPromise = _BinaryRequest.get(path)
	    //  .then((data) => {
	    //    const system = NSKeyedUnarchiver.unarchiveObjectWithData(data, path)
	    //    if(!(system instanceof SCNParticleSystem)){
	    //      throw new Error(`file ${path} is not an instance of SCNParticleSystem`)
	    //    }
	    //    return system
	    //  })
	    //}
	    return _this2;
	  }

	  // Creating a Particle System

	  /**
	   * Loads a particle system from a file in the apps bundle resources.
	   * @access public
	   * @param {string} name - The name of a particle system file in the apps bundle resources directory, with or without the .scnp extension.
	   * @param {?string} directory - The subdirectory path in the apps bundle resources directory.
	   * @returns {void}
	   * @desc A SceneKit particle file created by Xcode contains an archived SCNParticleSystem instance, so you can also use the NSKeyedArchiver and NSKeyedUnarchiver classes to write and read particle files.
	   * @see https://developer.apple.com/reference/scenekit/scnparticlesystem/1522772-init
	   */


	  _createClass(SCNParticleSystem, [{
	    key: 'reset',


	    // Controlling Particle Simulation

	    /**
	     * Returns the particle system to its initial state.
	     * @access public
	     * @returns {void}
	     * @desc Calling this method removes all currently live particles from the scene.
	     * @see https://developer.apple.com/reference/scenekit/scnparticlesystem/1522968-reset
	     */
	    value: function reset() {
	      this._finished = false;
	      this._startTime = null;
	      this._prevTime = 0;
	      this._nextBirthTime = 0;
	      this._emissionEndTime = 0;
	      this._idleEndTime = 0;

	      this._particles = [];
	    }

	    // Modifying Particles in Response to Particle System Events

	    /**
	     * Adds a block that modifies particle properties, to be executed at a specified event in the lifetimes of particles in the system.
	     * @access public
	     * @param {SCNParticleEvent} event - The event at which to call the block. See SCNParticleEvent for allowed values.
	     * @param {SCNParticleSystem.ParticleProperty[]} properties - An array containing one or more of the constants listed in Particle Property Keys, each of which specifies a property of the appearance or behaviors of particles in the particle system.
	     * @param {SCNParticleEventBlock} block - A SCNParticleEventBlock block to be called every time SceneKit renders a frame. In this block you can modify the properties of particles in the system.
	     * @returns {void}
	     * @desc By associating a block with one or more particle properties, you can run arbitrary code that modifies those properties when a significant event in the particle simulation occurs for one or more particles. For example, you can use the following code with a confetti effect to randomly switch between two distinct colors for each spawned particle:[system handleEvent:SCNParticleEventBirth
	        forProperties:@[SCNParticlePropertyColor]
	            withBlock:^(void **data, size_t *dataStride, uint32_t *indices , NSInteger count) {
	                for (NSInteger i = 0; i < count; ++i) {
	                    float *color = (float *)((char *)data[0] + dataStride[0] * i);
	                    if (rand() & 0x1) { // Switch the green and red color components.
	                        color[0] = color[1];
	                        color[1] = 0;
	                    }
	                }
	            }];
	    [system handleEvent:SCNParticleEventBirth
	        forProperties:@[SCNParticlePropertyColor]
	            withBlock:^(void **data, size_t *dataStride, uint32_t *indices , NSInteger count) {
	                for (NSInteger i = 0; i < count; ++i) {
	                    float *color = (float *)((char *)data[0] + dataStride[0] * i);
	                    if (rand() & 0x1) { // Switch the green and red color components.
	                        color[0] = color[1];
	                        color[1] = 0;
	                    }
	                }
	            }];
	      * @see https://developer.apple.com/reference/scenekit/scnparticlesystem/1523251-handle
	     */

	  }, {
	    key: 'handleForPropertiesHandler',
	    value: function handleForPropertiesHandler(event, properties, block) {}

	    // Modifying Particles Over Time

	    /**
	     * Adds a block that modifies particle properties, to be executed each time SceneKit renders a frame.
	     * @access public
	     * @param {SCNParticleSystem.ParticleProperty[]} properties - An array containing one or more of the constants listed in Particle Property Keys, each of which specifies a property of the appearance or behaviors of particles in the particle system.
	     * @param {SCNParticleModifierStage} stage - The stage of SceneKits particle simulation during which to call the block. See SCNParticleModifierStage for allowed values.
	     * @param {SCNParticleModifierBlock} block - A SCNParticleModifierBlock block to be called every time SceneKit renders a frame. In this block you can modify the properties of all particles in the system.
	     * @returns {void}
	     * @desc By associating a block with one or more particle properties, you can run arbitrary code that modifies those properties during each frame of animation. This option provides maximum flexibility for changing the appearance or behavior of particles over time. ImportantRunning your own code to update particle properties every frame can have a severe impact on rendering performance. If the behavior over time that you want for your particle system can be described more declaratively, use the propertyControllers property and SCNParticlePropertyController class instead. If you need to change particle properties only at certain times (rather than continuously), add a handler block for an event using the handle(_:forProperties:handler:) method.
	     * @see https://developer.apple.com/reference/scenekit/scnparticlesystem/1522635-addmodifier
	     */

	  }, {
	    key: 'addModifierForPropertiesAtModifier',
	    value: function addModifierForPropertiesAtModifier(properties, stage, block) {}

	    /**
	     * Removes particle modifier blocks for the specified stage of the particle simulation.
	     * @access public
	     * @param {SCNParticleModifierStage} stage - The stage of SceneKits particle simulation during which to call the block. See SCNParticleModifierStage for allowed values.
	     * @returns {void}
	     * @see https://developer.apple.com/reference/scenekit/scnparticlesystem/1524077-removemodifiers
	     */

	  }, {
	    key: 'removeModifiersAt',
	    value: function removeModifiersAt(stage) {}

	    /**
	     * Removes all particle modifier blocks associated with the particle system.
	     * @access public
	     * @returns {void}
	     * @see https://developer.apple.com/reference/scenekit/scnparticlesystem/1523614-removeallmodifiers
	     */

	  }, {
	    key: 'removeAllModifiers',
	    value: function removeAllModifiers() {}

	    // Structures
	    /**
	     * @type {Object} ParticleProperty
	     * @property {string} angle The rotation angle, in radians, of the particle about its axis.
	     * @property {string} angularVelocity The particles angular velocity (or rate of spin), in radians per second.
	     * @property {string} bounce The particles restitution coefficient.
	     * @property {string} charge The particles electric charge, in coulombs.
	     * @property {string} color The particles tint color, as a vector of red, green, blue, and alpha component values.
	     * @property {string} contactNormal The normal vector, in scene coordinate space, of a collision between a particle and a geometry in the scene.
	     * @property {string} contactPoint The location, in scene coordinate space, of a collision between a particle and a geometry in the scene.
	     * @property {string} frame The current frame index of the particles image animation.
	     * @property {string} frameRate The rate, in frames per second, of the particles image animation.
	     * @property {string} friction The particles friction coefficient.
	     * @property {string} life The remaining time in the particles life span, in seconds.
	     * @property {string} opacity The particles opacity (or alpha value).
	     * @property {string} position The particles position vector in scene coordinate space.
	     * @property {string} rotationAxis The particles axis of rotation, expressed as a vector in the particles local coordinate space.
	     * @property {string} size The width and height of the rendered particle image, in units of scene coordinate space.
	     * @property {string} velocity The particles velocity vector in units (of scene coordinate space) per second.
	     * @see https://developer.apple.com/reference/scenekit/scnparticlesystem.particleproperty
	     */

	  }, {
	    key: '_loadParticleImage',


	    /**
	     * @access private
	     * @param {string} path -
	     * @returns {Image} -
	     */
	    value: function _loadParticleImage(path, directoryPath) {
	      var _this3 = this;

	      var image = new Image();
	      if (path.indexOf('file:///') === 0) {
	        var paths = path.slice(8).split('/');
	        var pathCount = 1;
	        var _path = directoryPath + paths.slice(-pathCount).join('/');
	        image.onload = function () {
	          //console.info(`image ${_path} onload`)
	          _this3.particleImage = image;
	        };
	        image.onerror = function () {
	          pathCount += 1;
	          if (pathCount > paths.length) {
	            //console.info(`image ${path} load error. pathCount > paths.length`)
	          } else {
	            //console.info(`image ${_path} load error.`)
	            _path = directoryPath + paths.slice(-pathCount).join('/');
	            //console.info(`try ${_path}`)
	            image.src = _path;
	          }
	        };
	        image.src = _path;
	      } else {
	        var _paths = path.split('/');
	        var _pathCount = 0;
	        image.onload = function () {
	          //console.info(`image ${path} onload`)
	          _this3.particleImage = image;
	        };
	        image.onerror = function () {
	          _pathCount += 1;
	          if (_pathCount > _paths.length) {
	            // load error
	          } else {
	            image.src = directoryPath + _paths.slice(-_pathCount).join('/');
	          }
	        };
	        image.src = path;
	      }
	      return image;
	    }
	  }, {
	    key: '_initializeVAO',
	    value: function _initializeVAO(gl, program) {
	      if (this._vertexArray !== null) {
	        return;
	      }
	      this._vertexArray = gl.createVertexArray();
	      gl.bindVertexArray(this._vertexArray);

	      this._vertexBuffer = gl.createBuffer();
	      gl.bindBuffer(gl.ARRAY_BUFFER, this._vertexBuffer);

	      // prepare vertex array data
	      // TODO: retain attribute locations
	      var positionLoc = gl.getAttribLocation(program, 'position');
	      var velocityLoc = gl.getAttribLocation(program, 'velocity');
	      var rotationLoc = gl.getAttribLocation(program, 'rotation');
	      var colorLoc = gl.getAttribLocation(program, 'color');
	      var sizeLoc = gl.getAttribLocation(program, 'size');
	      //const lifeLoc = gl.getAttribLocation(program, 'life')
	      var cornerLoc = gl.getAttribLocation(program, 'corner');

	      // vertexAttribPointer(ulong idx, long size, ulong type, bool norm, long stride, ulong offset)
	      gl.enableVertexAttribArray(positionLoc);
	      gl.vertexAttribPointer(positionLoc, 3, gl.FLOAT, false, 68, 0);
	      gl.enableVertexAttribArray(velocityLoc);
	      gl.vertexAttribPointer(velocityLoc, 3, gl.FLOAT, false, 68, 12);
	      gl.enableVertexAttribArray(rotationLoc);
	      gl.vertexAttribPointer(rotationLoc, 4, gl.FLOAT, false, 68, 24);
	      gl.enableVertexAttribArray(colorLoc);
	      gl.vertexAttribPointer(colorLoc, 4, gl.FLOAT, false, 68, 40);
	      gl.enableVertexAttribArray(sizeLoc);
	      gl.vertexAttribPointer(sizeLoc, 1, gl.FLOAT, false, 68, 56);
	      gl.enableVertexAttribArray(cornerLoc);
	      gl.vertexAttribPointer(cornerLoc, 2, gl.FLOAT, false, 68, 60);

	      /*
	      const arr = []
	      this._particles.forEach((particle) => {
	        arr.push(...particle.floatArray())
	      })
	      const particleData = new Float32Array(arr)
	      gl.bufferData(gl.ARRAY_BUFFER, particleData, gl.DYNAMIC_DRAW)
	      */

	      var len = this._maxParticles + 5;
	      this._updateIndexBuffer(gl, len);

	      // initialize parameters
	      this._numImages = this.imageSequenceRowCount * this.imageSequenceColumnCount;
	      this._imageWidth = 2.0 / this.imageSequenceColumnCount;
	      this._imageHeight = 2.0 / this.imageSequenceRowCount;
	    }
	  }, {
	    key: '_updateIndexBuffer',
	    value: function _updateIndexBuffer(context, length) {
	      var gl = context;
	      var indexData = [];
	      var index = 0;
	      for (var i = 0; i < length; i++) {
	        indexData.push(index + 0);
	        indexData.push(index + 3);
	        indexData.push(index + 2);
	        indexData.push(index + 0);
	        indexData.push(index + 1);
	        indexData.push(index + 3);
	        index += 4;
	      }
	      var glIndexData = null;
	      if (index < 256) {
	        glIndexData = new Uint8Array(indexData);
	        this._glIndexSize = gl.UNSIGNED_BYTE;
	      } else if (index < 65536) {
	        glIndexData = new Uint16Array(indexData);
	        this._glIndexSize = gl.UNSIGNED_SHORT;
	      } else {
	        glIndexData = new Uint32Array(indexData);
	        this._glIndexSize = gl.UNSIGNED_INT;
	      }

	      if (this._indexBuffer === null) {
	        this._indexBuffer = gl.createBuffer();
	      }
	      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer);
	      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, glIndexData, gl.STATIC_DRAW);

	      this._maxParticleIndex = length;
	    }

	    /**
	     * @access private
	     * @param {number} birthTime -
	     * @param {SCNVector3} position -
	     * @param {SCNVector4} orientation -
	     * @returns {_Particle} -
	     */
	    //_createParticle(birthTime, position, orientation) {

	  }, {
	    key: '_createParticle',
	    value: function _createParticle(birthTime, transform) {
	      var p = new _Particle();

	      var position = transform.getTranslation();
	      var velocity = this.particleVelocity + this.particleVelocityVariation * (Math.random() - 0.5);
	      var spreadingAngle = this.spreadingAngle / 180.0 * Math.PI * Math.random();
	      var spreadingAngleRot = 2.0 * Math.PI * Math.random();
	      var angleMat = _SCNMatrix2.default.matrixWithRotation(this._normal.x, this._normal.y, this._normal.z, spreadingAngle);
	      var rotMat = _SCNMatrix2.default.matrixWithRotation(this._direction.x, this._direction.y, this._direction.z, spreadingAngleRot);

	      // emitterShape, birthLocation, emittingDirection, spreadingAngle, particleAngle/Variation, particleVelocity
	      if (this.emitterShape === null) {
	        p.position = position;
	      } else if (this.birthLocation === _SCNParticleBirthLocation2.default.surface) {
	        var pVec = null;
	        var vVec = null;
	        switch (this.emitterShape.className) {
	          case 'SCNBox':
	            {
	              // FIXME: calculate the area
	              var rnd = Math.floor(Math.random() * 6);
	              var rnd1 = Math.random() - 0.5;
	              var rnd2 = Math.random() - 0.5;
	              var w = this.emitterShape.width;
	              var h = this.emitterShape.height;
	              var l = this.emitterShape.length;

	              // TODO: chamferRadius
	              if (rnd === 0) {
	                // right
	                pVec = new _SCNVector2.default(w * 0.5, h * rnd1, l * rnd2);
	                vVec = new _SCNVector2.default(1, 0, 0);
	              } else if (rnd === 1) {
	                // left
	                pVec = new _SCNVector2.default(-w * 0.5, h * rnd1, l * rnd2);
	                vVec = new _SCNVector2.default(-1, 0, 0);
	              } else if (rnd === 2) {
	                // top
	                pVec = new _SCNVector2.default(w * rnd1, h * 0.5, l * rnd2);
	                vVec = new _SCNVector2.default(0, 1, 0);
	              } else if (rnd === 3) {
	                // bottom
	                pVec = new _SCNVector2.default(w * rnd1, -h * 0.5, l * rnd2);
	                vVec = new _SCNVector2.default(0, -1, 0);
	              } else if (rnd === 4) {
	                // front
	                pVec = new _SCNVector2.default(w * rnd1, h * rnd2, l * 0.5);
	                vVec = new _SCNVector2.default(0, 0, 1);
	              } else {
	                // back
	                pVec = new _SCNVector2.default(w * rnd1, h * rnd2, -l * 0.5);
	                vVec = new _SCNVector2.default(0, 0, -1);
	              }
	              break;
	            }
	          case 'SCNSphere':
	            {
	              var v = new _SCNVector2.default(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5).normalize();
	              pVec = v.mul(this.emitterShape.radius);
	              vVec = v;
	              break;
	            }
	          default:
	            // TODO: implement
	            throw new Error('surface emitter for ' + this.emitterShape.className + ' is not implemented');
	        }
	        pVec = pVec.rotate(transform);
	        p.position = position.add(pVec);
	        if (this.birthDirection === _SCNParticleBirthDirection2.default.surfaceNormal) {
	          p.velocity = vVec.rotate(transform).normalize().mul(velocity);
	        }
	      } else if (this.birthLocation === _SCNParticleBirthLocation2.default.volume) {
	        var _pVec = null;
	        switch (this.emitterShape.className) {
	          case 'SCNBox':
	            {
	              var x = (Math.random() - 0.5) * this.emitterShape.width;
	              var y = (Math.random() - 0.5) * this.emitterShape.height;
	              var z = (Math.random() - 0.5) * this.emitterShape.length;
	              _pVec = new _SCNVector2.default(x, y, z);
	              break;
	            }
	          case 'SCNSphere':
	            {
	              var r = Math.random() * this.emitterShape.radius;
	              var s = Math.random() * Math.PI;
	              var t = Math.random() * Math.PI * 2.0;
	              var rsins = r * Math.sin(s);
	              var _x3 = rsins * Math.cos(t);
	              var _y = rsins * Math.sin(t);
	              var _z = r * Math.cos(s);
	              _pVec = new _SCNVector2.default(_x3, _y, _z);
	              break;
	            }
	          default:
	            // TODO: implement
	            throw new Error('volume emitter for ' + this.emitterShape.className + ' is not implemented');
	        }
	        _pVec = _pVec.rotate(transform);
	        p.position = position.add(_pVec);
	        if (this.birthDirection === _SCNParticleBirthDirection2.default.surfaceNormal) {
	          throw new Error('combination of birthLocation=volume and birthDirection=surfaceNormal is not implemented.');
	        }
	      } else {
	        // TODO: implement
	        throw new Error('birthLocation ' + this.birthLocation + ' is not implemented.');
	      }

	      if (this.orientationMode === _SCNParticleOrientationMode2.default.billboardScreenAligned) {
	        p.axis = new _SCNVector2.default(0, 0, 1);
	      } else {
	        p.axis = new _SCNVector2.default(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5).normalize();
	      }
	      p.angle = (this.particleAngle + this.particleAngleVariation * (Math.random() - 0.5)) / 180.0 * Math.PI;
	      p.size = this.particleSize + this.particleSizeVariation * (Math.random() - 0.5);
	      p.color = this._createColor();

	      switch (this.birthDirection) {
	        case _SCNParticleBirthDirection2.default.constant:
	          {
	            p.velocity = this._direction.rotate(angleMat).rotate(rotMat).rotate(transform).mul(velocity);
	            break;
	          }
	        case _SCNParticleBirthDirection2.default.surfaceNormal:
	          {
	            break;
	          }
	        case _SCNParticleBirthDirection2.default.random:
	          {
	            var rndAngle = 2.0 * Math.PI * Math.random();
	            var rndMat = _SCNMatrix2.default.matrixWithRotation(this._normal.x, this._normal.y, this._normal.z, rndAngle);
	            p.velocity = this._direction.rotate(rndMat).rotate(rotMat).rotate(transform).mul(velocity);
	            break;
	          }
	        default:
	          {
	            throw new Error('unknown birth direction: ' + this.birthDirection);
	          }
	      }
	      p.angularVelocity = (this.particleAngularVelocity + this.particleAngularVelocityVariation * (Math.random() - 0.5)) / 180.0 * Math.PI;
	      p.acceleration = this.acceleration._copy();
	      p.birthTime = birthTime;
	      p.lifeSpan = this.particleLifeSpan + this.particleLifeSpanVariation * (Math.random() * 2.0 - 1.0);

	      p.imageFrameRate = this.imageSequenceFrameRate + this.imageSequenceFrameRateVariation * (Math.random() - 0.5);
	      if (p.imageFrameRate < 0) {
	        p.imageFrameRate = 0;
	      }

	      p.initialImageFrame = this.imageSequenceInitialFrame + this.imageSequenceInitialFrameVariation * (Math.random() - 0.5);

	      return p;
	    }

	    /**
	     * @access private
	     * @param {SCNNode} node -
	     * @param {?SCNVector3} gravity -
	     * @param {number} elapsedTime -
	     * @returns {void}
	     */

	  }, {
	    key: '_updateParticles',
	    value: function _updateParticles(transform, gravity, currentTime) {
	      var _this4 = this;

	      if (this._prevTime <= 0) {
	        this._prevTime = currentTime;
	        this._nextBirthTime = currentTime;
	        this._startTime = currentTime;

	        this._direction = this.emittingDirection.normalize();
	        var u = new _SCNVector2.default(this._direction.z, this._direction.x, this._direction.y);
	        this._normal = this._direction.cross(u);

	        this._updateEndTime();
	      }

	      // generate particles
	      if (this.birthRate + this.birthRateVariation > 0) {
	        while (this._nextBirthTime <= currentTime) {
	          var p = this._createParticle(this._nextBirthTime, transform);
	          this._particles.push(p);
	          var rate = this.birthRate + this.birthRateVariation * (Math.random() - 0.5);
	          if (rate < 0.0000001) {
	            rate = 0.0000001;
	          }
	          this._nextBirthTime += 1.0 / rate;
	          if (this._nextBirthTime > this._emissionEndTime) {
	            this._nextBirthTime = this._idleEndTime;
	            if (!this.loops) {
	              this._finished = true;
	            }
	            this._updateEndTime();
	          }
	        }
	      }

	      var dt = (currentTime - this._prevTime) * this.speedFactor;
	      var damping = 1;
	      if (this.dampingFactor > 0) {
	        damping = Math.pow((100 - this.dampingFactor) * 0.01, dt * 60.0);
	      }

	      this._particles.forEach(function (p) {
	        var pdt = (currentTime - p.birthTime) * _this4.speedFactor;
	        var t = pdt / p.lifeSpan;
	        p.life = t;
	        if (t > 1) {
	          return;
	        }
	        var acceleration = p.acceleration;
	        if (gravity !== null && _this4.isAffectedByGravity) {
	          acceleration = acceleration.add(gravity);
	        }
	        //p.position.x += (0.5 * acceleration.x * dt + p.velocity.x) * dt
	        //p.position.y += (0.5 * acceleration.y * dt + p.velocity.y) * dt
	        //p.position.z += (0.5 * acceleration.z * dt + p.velocity.z) * dt
	        //p.velocity.x += acceleration.x * dt
	        //p.velocity.y += acceleration.y * dt
	        //p.velocity.z += acceleration.z * dt
	        p.angle += p.angularVelocity * dt;
	        p.velocity.x = (p.velocity.x + acceleration.x * dt) * damping;
	        p.velocity.y = (p.velocity.y + acceleration.y * dt) * damping;
	        p.velocity.z = (p.velocity.z + acceleration.z * dt) * damping;
	        p.position.x += p.velocity.x * dt;
	        p.position.y += p.velocity.y * dt;
	        p.position.z += p.velocity.z * dt;
	        if (_this4.propertyControllers !== null) {
	          Object.keys(_this4.propertyControllers).forEach(function (key) {
	            _this4.propertyControllers[key].animation._applyAnimation(p, t, false); // should I use p.life instead of t?
	          });
	        }

	        var frame = p.initialImageFrame + p.imageFrameRate * pdt;
	        var imageFrame = 0;
	        switch (p.imageSequenceAnimationMode) {
	          case _SCNParticleImageSequenceAnimationMode2.default.repeat:
	            {
	              imageFrame = Math.floor(frame % _this4._numImages);
	              break;
	            }
	          case _SCNParticleImageSequenceAnimationMode2.default.clamp:
	            {
	              var fr = Math.floor(frame % _this4._numImages);
	              if (fr >= _this4._numImages - 1) {
	                imageFrame = _this4._numImages - 1;
	              } else {
	                imageFrame = fr;
	              }
	              break;
	            }
	          case _SCNParticleImageSequenceAnimationMode2.default.autoReverse:
	            {
	              var _fr = Math.floor(frame % (_this4._numImages * 2 - 2));
	              if (_fr >= _this4._numImages) {
	                _fr = _this4._numImages * 2 - 2 - _fr;
	              }
	              imageFrame = _fr;
	              break;
	            }
	        }
	        var imageY = Math.floor(imageFrame / _this4.imageSequenceRowCount);
	        var imageX = imageFrame % _this4.imageSequenceColumnCount;

	        p.texLeft = imageX * _this4._imageWidth - 1.0;
	        p.texTop = imageY * _this4._imageHeight - 1.0;
	        p.texRight = (imageX + 1) * _this4._imageWidth - 1.0;
	        p.texBottom = (imageY + 1) * _this4._imageHeight - 1.0;
	      });
	      this._particles = this._particles.filter(function (p) {
	        return p.life <= 1;
	      });
	      this._prevTime = currentTime;
	    }
	  }, {
	    key: '_updateEndTime',
	    value: function _updateEndTime() {
	      var startTime = this._idleEndTime === 0 ? this._startTime : this._idleEndTime;
	      var emissionDuration = this.emissionDuration + (Math.random() - 0.5) * this.emissionDurationVariation;
	      if (emissionDuration < 0) {
	        emissionDuration = 0;
	      }
	      this._emissionEndTime = startTime + emissionDuration;

	      var idleDuration = this.idleDuration + (Math.random() - 0.5) * this.idleDurationVariation;
	      if (idleDuration < 0) {
	        idleDuration = 0;
	      }
	      this._idleEndTime = this._emissionEndTime + idleDuration;
	    }

	    /**
	     * @access private
	     * @param {WebGLRenderingContext} gl -
	     * @param {WebGLProgram} program -
	     * @returns {void}
	     */

	  }, {
	    key: '_bufferMaterialData',
	    value: function _bufferMaterialData(gl, program) {
	      // particleTexture
	      if (this._particleTexture === null && this.particleImage !== null) {
	        this._particleTexture = this._createTexture(gl, this.particleImage);
	      }
	      if (this._particleTexture !== null) {
	        gl.activeTexture(gl.TEXTURE0);
	        gl.bindTexture(gl.TEXTURE_2D, this._particleTexture);
	        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
	        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
	        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
	        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
	      }

	      gl.uniform1i(gl.getUniformLocation(program, 'orientationMode'), this.orientationMode);
	      gl.uniform1f(gl.getUniformLocation(program, 'stretchFactor'), this.stretchFactor);

	      // buffer particle data
	      gl.bindBuffer(gl.ARRAY_BUFFER, this._vertexBuffer);
	      gl.bufferData(gl.ARRAY_BUFFER, this._particleData, gl.DYNAMIC_DRAW);

	      if (this._particles.length > this._maxParticleIndex) {
	        this._updateIndexBuffer(gl, this._particles.length + 10);
	      }

	      var blendFuncSrc = [gl.SRC_ALPHA, // additive
	      gl.ZERO, // subtract
	      gl.ZERO, // multiply
	      gl.ZERO, // screen
	      gl.SRC_ALPHA, // alpha
	      gl.ONE // replace
	      ];
	      var blendFuncDst = [gl.ONE, // additive
	      gl.ONE_MINUS_SRC_COLOR, // subtract
	      gl.SRC_COLOR, // multiply
	      gl.SRC_ALPHA, // screen... is it correct?
	      gl.ONE_MINUS_SRC_ALPHA, // alpha
	      gl.ZERO // replace
	      ];
	      gl.blendFunc(blendFuncSrc[this.blendMode], blendFuncDst[this.blendMode]);
	    }
	  }, {
	    key: '_createTexture',
	    value: function _createTexture(gl, image) {
	      var texture = gl.createTexture();

	      var canvas = document.createElement('canvas');
	      canvas.width = image.naturalWidth;
	      canvas.height = image.naturalHeight;
	      //console.warn(`image size: ${image.naturalWidth} ${image.naturalHeight}`)
	      canvas.getContext('2d').drawImage(image, 0, 0);

	      gl.bindTexture(gl.TEXTURE_2D, texture);
	      // texImage2D(target, level, internalformat, width, height, border, format, type, source)
	      // Safari complains that 'source' is not ArrayBufferView type, but WebGL2 should accept HTMLCanvasElement.
	      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, image.width, image.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, canvas);
	      gl.generateMipmap(gl.TEXTURE_2D);
	      gl.bindTexture(gl.TEXTURE_2D, null);

	      return texture;
	    }

	    /**
	     * @access private
	     * @returns {SKColor} -
	     */

	  }, {
	    key: '_createColor',
	    value: function _createColor() {
	      var hsb = this._rgb2hsb(this.particleColor);

	      // Hue
	      //hsb.x = (hsb.x + this.particleColorVariation.x * (Math.random() - 0.5)) % 360.0
	      hsb.x = (hsb.x + this.particleColorVariation.x * (Math.random() * 2.0 - 1.0)) % 360.0;
	      if (hsb.x < 0) {
	        hsb.x += 360.0;
	      }

	      // Saturation
	      hsb.y = Math.max(0, Math.min(1.0, hsb.y + this.particleColorVariation.y * (Math.random() - 0.5)));

	      // Brightness
	      hsb.z = Math.max(0, Math.min(1.0, hsb.z + this.particleColorVariation.z * (Math.random() - 0.5)));

	      // Alpha
	      hsb.w = Math.max(0, Math.min(1.0, hsb.w + this.particleColorVariation.w * (Math.random() - 0.5)));

	      return this._hsb2rgb(hsb);
	    }

	    /**
	     * @access private
	     * @param {SKColor} rgb -
	     * @returns {SCNVector4} -
	     */

	  }, {
	    key: '_rgb2hsb',
	    value: function _rgb2hsb(rgb) {
	      var hsb = new _SCNVector4.default();
	      var min = Math.min(rgb.red, Math.min(rgb.green, rgb.blue));
	      var max = Math.max(rgb.red, Math.max(rgb.green, rgb.blue));
	      var delta = max - min;
	      hsb.w = rgb.alpha;
	      hsb.z = max;

	      if (hsb.z === 0) {
	        hsb.x = 0;
	        hsb.y = 0;
	        return hsb;
	      }

	      hsb.y = delta / max;
	      if (hsb.y === 0) {
	        hsb.x = 0;
	        return hsb;
	      }

	      if (max === rgb.red) {
	        hsb.x = (60.0 * (rgb.green - rgb.blue) / delta + 360.0) % 360.0;
	      } else if (max === rgb.green) {
	        hsb.x = 60.0 * (rgb.blue - rgb.red) / delta + 120.0;
	      } else {
	        hsb.x = 60.0 * (rgb.red - rgb.green) / delta + 240.0;
	      }

	      return hsb;
	    }

	    /**
	     * @access private
	     * @param {SCNVector4} hsb -
	     * @returns {SKColor} -
	     */

	  }, {
	    key: '_hsb2rgb',
	    value: function _hsb2rgb(hsb) {
	      //const rgb = new SKColor(0, 0, 0, hsb.w)

	      if (hsb.y === 0) {
	        //rgb.red = hsb.z
	        //rgb.green = hsb.z
	        //rgb.blue = hsb.z
	        return new _SKColor2.default(hsb.z, hsb.z, hsb.z, hsb.w);
	      }

	      var region = Math.floor(hsb.x / 60.0);
	      /*
	      const c = hsb.z * hsb.y
	      const x = c * (region % 2)
	      const m = hsb.z - c
	       let r = 0
	      let g = 0
	      let b = 0
	      switch(region){
	        case 0:
	          r = c
	          g = x
	          break
	        case 1:
	          r = x
	          g = c
	          break
	        case 2:
	          g = c
	          b = x
	          break
	        case 3:
	          g = x
	          b = c
	          break
	        case 4:
	          r = x
	          b = c
	          break
	        default:
	          r = c
	          b = x
	          break
	      }
	      rgb.red = r + m
	      rgb.green = g + m
	      rgb.blue = b + m
	      
	      return rgb
	      */
	      var v = hsb.z;
	      var f = hsb.x / 60.0 - region;
	      var m = v * (1.0 - hsb.y);
	      var n = v * (1.0 - hsb.y * f);
	      var k = v * (1.0 - hsb.y * (1.0 - f));
	      switch (region) {
	        case 0:
	          return new _SKColor2.default(v, k, m, hsb.w);
	        case 1:
	          return new _SKColor2.default(n, v, m, hsb.w);
	        case 2:
	          return new _SKColor2.default(m, v, k, hsb.w);
	        case 3:
	          return new _SKColor2.default(m, n, v, hsb.w);
	        case 4:
	          return new _SKColor2.default(k, m, v, hsb.w);
	        default:
	          return new _SKColor2.default(v, m, n, hsb.w);
	      }
	    }
	  }, {
	    key: '_particleData',
	    get: function get() {
	      var arr = [];
	      this._particles.forEach(function (particle) {
	        arr.push.apply(arr, _toConsumableArray(particle.floatArray()));
	      });
	      return new Float32Array(arr);
	    }
	  }, {
	    key: '_maxParticles',
	    get: function get() {
	      var maxRate = this.birthRate + this.birthRateVariation * 0.5;
	      var maxLifeSpan = this.particleLifeSpan + this.particleLifeSpanVariation * 0.5;
	      return Math.ceil(maxRate * maxLifeSpan);
	    }
	  }], [{
	    key: 'systemNamedInDirectory',
	    value: function systemNamedInDirectory(name) {
	      var directory = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

	      //const system = new SCNParticleSystem(name, directory)
	      if (name !== null) {
	        var path = name;
	        if (directory !== null) {
	          path = directory + '/' + name;
	        }
	        return _BinaryRequest3.default.get(path).then(function (data) {
	          var system = _NSKeyedUnarchiver2.default.unarchiveObjectWithData(data, path);
	          if (!(system instanceof SCNParticleSystem)) {
	            throw new Error('file ' + path + ' is not an instance of SCNParticleSystem');
	          }
	          // FIXME: wait for images
	          system._loadingPromise = Promise.resolve(system);
	          return system;
	        });
	      }
	      return null;
	    }
	  }, {
	    key: 'ParticleProperty',
	    get: function get() {
	      return _ParticleProperty;
	    }
	  }]);

	  return SCNParticleSystem;
	}(_NSObject4.default);

	exports.default = SCNParticleSystem;

/***/ },
/* 108 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * Options for the initial location of each emitted particle, used by the birthLocation property.
	 * @typedef {Object} SCNParticleBirthLocation
	 * @property {number} surface - New particles can be created at any location on the surface of the emitter shape.
	 * @property {number} volume - New particles can be created at any location within the volume of the emitter shape.
	 * @property {number} vertex - New particles can be created at only at the locations of the vertices in the emitter shape.
	 * @see https://developer.apple.com/reference/scenekit/scnparticlebirthlocation
	 */

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var SCNParticleBirthLocation = {
	  surface: 0,
	  volume: 1,
	  vertex: 2
	};

	exports.default = SCNParticleBirthLocation;

/***/ },
/* 109 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * Options for the initial direction of each emitted particle, used by the birthDirection property.
	 * @typedef {Object} SCNParticleBirthDirection
	 * @property {number} constant - The emitting direction is the same for all particles.
	 * @property {number} surfaceNormal - The emitting direction for each particle is along the surface normal vector at the point where the particle is emitted.
	 * @property {number} random - SceneKit randomizes the emitting direction for each particle.
	 * @see https://developer.apple.com/reference/scenekit/scnparticlebirthdirection
	 */

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var SCNParticleBirthDirection = {
	  constant: 0,
	  surfaceNormal: 1,
	  random: 2
	};

	exports.default = SCNParticleBirthDirection;

/***/ },
/* 110 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * Options for animating each particle with a sequence of images, used by the imageSequenceAnimationMode property.
	 * @typedef {Object} SCNParticleImageSequenceAnimationMode
	 * @property {number} repeat - The animation loops after displaying all of its images.
	 * @property {number} clamp - The animation stops after displaying all of its images.
	 * @property {number} autoReverse - After the animation displays all of its images, it plays again in reverse order.
	 * @see https://developer.apple.com/reference/scenekit/scnparticleimagesequenceanimationmode
	 */

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var SCNParticleImageSequenceAnimationMode = {
	  repeat: 0,
	  clamp: 1,
	  autoReverse: 2
	};

	exports.default = SCNParticleImageSequenceAnimationMode;

/***/ },
/* 111 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * Options for combining source and destination pixel colors when compositing particles during rendering, used by the blendMode property.
	 * @typedef {Object} SCNParticleBlendMode
	 * @property {number} additive - The source and destination colors are added together.
	 * @property {number} subtract - The source color is subtracted from the destination color.
	 * @property {number} multiply - The source color is multiplied by the destination color.
	 * @property {number} screen - The source color is added to the destination color times the inverted source color.
	 * @property {number} alpha - The source and destination colors are blended by multiplying the source alpha value.
	 * @property {number} replace - The source color replaces the destination color.
	 * @see https://developer.apple.com/reference/scenekit/scnparticleblendmode
	 */

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var SCNParticleBlendMode = {
	  additive: 0,
	  subtract: 1,
	  multiply: 2,
	  screen: 3,
	  alpha: 4,
	  replace: 5
	};

	exports.default = SCNParticleBlendMode;

/***/ },
/* 112 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * Options for restricting the orientation of particles, used by the orientationMode property.
	 * @typedef {Object} SCNParticleOrientationMode
	 * @property {number} billboardScreenAligned - Each particles orientation is always fixed with respect to the point of view camera.
	 * @property {number} billboardViewAligned - Each particle always faces the point of view camera (but may rotate about an axis parallel to the view direction).
	 * @property {number} free - Particle orientations are not restricted; they may rotate freely in all axes.
	 * @property {number} billboardYAligned - The y-axis direction of each particle is always fixed with respect to the point of view camera.
	 * @see https://developer.apple.com/reference/scenekit/scnparticleorientationmode
	 */

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var SCNParticleOrientationMode = {
	  billboardScreenAligned: 0,
	  billboardViewAligned: 1,
	  free: 2,
	  billboardYAligned: 3
	};

	exports.default = SCNParticleOrientationMode;

/***/ },
/* 113 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * Options for the rendering order of particles, used by the sortingMode property.
	 * @typedef {Object} SCNParticleSortingMode
	 * @property {number} none - Particles are not sorted; they may be rendered in any order.
	 * @property {number} projectedDepth - Particles farther from the point of view (as measured using projected depth) are rendered before closer particles.
	 * @property {number} distance - Particles farther from the point of view (as measured using distance from the camera in scene space) are rendered before closer particles.
	 * @property {number} oldestFirst - Particles emitted earlier are rendered before particles emitted more recently.
	 * @property {number} youngestFirst - Particles emitted more recently are rendered before particles emitted earlier.
	 * @see https://developer.apple.com/reference/scenekit/scnparticlesortingmode
	 */

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var SCNParticleSortingMode = {
	  none: 0,
	  projectedDepth: 1,
	  distance: 2,
	  oldestFirst: 3,
	  youngestFirst: 4
	};

	exports.default = SCNParticleSortingMode;

/***/ },
/* 114 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * Significant events in the life spans of simulate particles, used by the handle(_:forProperties:handler:) method.
	 * @typedef {Object} SCNParticleEvent
	 * @property {number} birth - Occurs when new particles spawn.
	 * @property {number} death - Occurs when particles reach the end of their life span.
	 * @property {number} collision - Occurs when particles collide with scene geometry.
	 * @see https://developer.apple.com/reference/scenekit/scnparticleevent
	 */

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var SCNParticleEvent = {
	  birth: 0,
	  death: 1,
	  collision: 2
	};

	exports.default = SCNParticleEvent;

/***/ },
/* 115 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * The signature for blocks called by SceneKit in response to significant events during particle simulation, used by the handle(_:forProperties:handler:) method.
	 * @type {function(data: UnsafeMutablePointer<UnsafeMutableRawPointer>, dataStride: UnsafeMutablePointer<Int>, indices: ?UnsafeMutablePointer<UInt32>, count: number): void}
	 * @param {UnsafeMutablePointer<UnsafeMutableRawPointer>} data - An array of floating-point values containing stripes of property data for the systems particles. The width and format of each data stripe depend on the properties you specify when calling the handle(_:forProperties:handler:) method.
	 * @param {UnsafeMutablePointer<Int>} dataStride - An array identifying the offset, in bytes, of each propertys value in the data stripe for each particle. The order of offsets in this array corresponds to the order of the properties array you specify when calling the handle(_:forProperties:handler:) method.
	 * @param {?UnsafeMutablePointer<UInt32>} indices - An array in which each element is an index that identifies (in the data array) the data stripe for each particle affected by the event that caused SceneKit to call the handler block.When SceneKit calls your handler block for the birth event, you need not use this parameterat that time, the affected particles are indexed from 0 to the count parameters value.
	 * @param {number} count - The number of particles affected by the current event.
	 * @returns {void}
	 * @desc Use this block to change properties of individual particles when they are spawned, when they collide with scene geometry, or when they die (that is, reach the end of their life spans and are removed from the scene). The following example illustrates setting up a handler block for particle collision events:[system handleEvent:SCNParticleEventCollision
	      forProperties:@[SCNParticlePropertyAngle,
	                      SCNParticlePropertyRotationAxis,
	                      SCNParticlePropertyContactNormal]
	          withBlock:^(void **data, size_t *dataStride, uint32_t *indices, NSInteger count) {
	              // For each particle affected by the collision event,
	              // calculate pointers in the data to each property's value.
	              for (NSInteger i = 0; i < count; ++i) {
	                  // SCNParticlePropertyAngle (float)
	                  float *angle = (float *)((char *)data[0] + dataStride[0] * indices[i]);
	                  // angle[0] is the particle's rotation angle in radians.
	 
	                  // SCNParticlePropertyRotationAxis (float3)
	                  float *axis = (float *)((char *)data[1] + dataStride[1] * indices[i]);
	                  // axis[0..2] are the xyz components of the particle's rotation axis.
	 
	                  // SCNParticlePropertyContactNormal (float3)
	                  float *norm = (float *)((char *)data[2] + dataStride[2] * indices[i]);
	                  // norm[0..2] are the xyz components of the contact normal vector.
	 
	                  // Now, use the norm vector to rotate the particle's axis/angle (not shown).
	              }
	          }];

	 * @see https://developer.apple.com/reference/scenekit/scnparticleeventblock
	 */

	Object.defineProperty(exports, "__esModule", {
	                 value: true
	});
	var SCNParticleEventBlock = function SCNParticleEventBlock(data, dataStride, indices, count) {};

	exports.default = SCNParticleEventBlock;

/***/ },
/* 116 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _NSObject2 = __webpack_require__(2);

	var _NSObject3 = _interopRequireDefault(_NSObject2);

	var _CAAnimation = __webpack_require__(48);

	var _CAAnimation2 = _interopRequireDefault(_CAAnimation);

	var _SCNParticleInputMode = __webpack_require__(117);

	var _SCNParticleInputMode2 = _interopRequireDefault(_SCNParticleInputMode);

	var _SCNNode = __webpack_require__(65);

	var _SCNNode2 = _interopRequireDefault(_SCNNode);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * An animation for a single property of the individual particles rendered by a particle system.
	 * @access public
	 * @extends {NSObject}
	 * @see https://developer.apple.com/reference/scenekit/scnparticlepropertycontroller
	 */
	var SCNParticlePropertyController = function (_NSObject) {
	  _inherits(SCNParticlePropertyController, _NSObject);

	  _createClass(SCNParticlePropertyController, null, [{
	    key: '_propTypes',
	    get: function get() {
	      return {
	        animation: ['NSMutableDictionary', function (obj, anim) {
	          obj.animation = _SCNNode2.default._loadAnimationData(anim, null);
	        }],
	        inputMode: 'integer',
	        inputBias: 'float',
	        inputScale: 'float',
	        inputOrigin: 'SCNNode'
	        // inputProperty: 'string' ?
	      };
	    }

	    // Creating a Property Controller

	    /**
	     * Creates a particle property controller with the specified Core Animation animation.
	     * @access public
	     * @constructor
	     * @param {CAAnimation} animation - A Core Animation object specifying the behavior of the property animation. Must not be nil.You can use different CAAnimation subclasses to animate effects in different ways. For example, a CABasicAnimation instance transitions a property from one value to another, and a CAKeyframeAnimation instance transitions a property through a series of values. You use properties of the animation object to define its timing curve, repeat mode, and other options.SceneKit ignores the keyPath, duration, and repeatCount properties of this animation object.
	     * @desc To set up a particle property animation:Create a CAAnimation object defining how a property of each particle in the system changes over time.Create a particle property controller using the init(animation:) method.Attach the property controller to a particle system using the propertyControllers dictionary, choosing a key listed in Particle Property Keys to identify the particle property it animates.For example, the following code sets up a controller to animate particle sizes:// 1. Create and configure an animation object.
	    CAKeyframeAnimation *animation = [CAKeyframeAnimation animation];
	    animation.values = @[ @0.1, @1.0, @3.0, @0.5 ];
	    // 2. Create a property controller from the animation object.
	    SCNParticlePropertyController *controller =
	      [SCNParticlePropertyController controllerWithAnimation:animation];
	    // 3. Assign the controller to a particle system, associating it with a particle property.
	    particleSystem.propertyControllers = @{ SCNParticlePropertySize: controller };
	    // 1. Create and configure an animation object.
	    CAKeyframeAnimation *animation = [CAKeyframeAnimation animation];
	    animation.values = @[ @0.1, @1.0, @3.0, @0.5 ];
	    // 2. Create a property controller from the animation object.
	    SCNParticlePropertyController *controller =
	      [SCNParticlePropertyController controllerWithAnimation:animation];
	    // 3. Assign the controller to a particle system, associating it with a particle property.
	    particleSystem.propertyControllers = @{ SCNParticlePropertySize: controller };
	      * @see https://developer.apple.com/reference/scenekit/scnparticlepropertycontroller/1523579-init
	     */

	  }]);

	  function SCNParticlePropertyController(animation) {
	    _classCallCheck(this, SCNParticlePropertyController);

	    // Managing the Controllers Animation

	    /**
	     * The Core Animation object defining the behavior of the property animation.
	     * @type {CAAnimation}
	     * @see https://developer.apple.com/reference/scenekit/scnparticlepropertycontroller/1523707-animation
	     */
	    var _this = _possibleConstructorReturn(this, (SCNParticlePropertyController.__proto__ || Object.getPrototypeOf(SCNParticlePropertyController)).call(this));

	    _this.animation = animation;

	    /**
	     * The mode that determines input values for the property controllers animation.
	     * @type {SCNParticleInputMode}
	     * @see https://developer.apple.com/reference/scenekit/scnparticlepropertycontroller/1522852-inputmode
	     */
	    _this.inputMode = null;

	    /**
	     * An offset to add to the input value of the controllers animation.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnparticlepropertycontroller/1523994-inputbias
	     */
	    _this.inputBias = 0;

	    /**
	     * A factor for multiplying the input value of the controllers animation. 
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnparticlepropertycontroller/1522903-inputscale
	     */
	    _this.inputScale = 0;

	    /**
	     * A node whose distance to each particle provides input values for the controllers animation.
	     * @type {?SCNNode}
	     * @see https://developer.apple.com/reference/scenekit/scnparticlepropertycontroller/1522895-inputorigin
	     */
	    _this.inputOrigin = null;

	    /**
	     * A particle property that provides input values for this property controllers animation.
	     * @type {?SCNParticleSystem.ParticleProperty}
	     * @see https://developer.apple.com/reference/scenekit/scnparticlepropertycontroller/1522973-inputproperty
	     */
	    _this.inputProperty = null;
	    return _this;
	  }

	  return SCNParticlePropertyController;
	}(_NSObject3.default);

	exports.default = SCNParticlePropertyController;

/***/ },
/* 117 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * Options for the input value of the property controllers animation, used by the inputMode property.
	 * @typedef {Object} SCNParticleInputMode
	 * @property {number} overLife - The controllers effect on a particle property is a function of the time since the particles birth.
	 * @property {number} overDistance - The controllers effect on a particle property is a function of the particles distance from the position of a specified node.
	 * @property {number} overOtherProperty - The controllers effect on a particle property is a function of another of the particles properties.
	 * @see https://developer.apple.com/reference/scenekit/scnparticleinputmode
	 */

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var SCNParticleInputMode = {
	  overLife: 0,
	  overDistance: 1,
	  overOtherProperty: 2
	};

	exports.default = SCNParticleInputMode;

/***/ },
/* 118 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * Stages of SceneKits particle simulation process into which you can insert modifier blocks, used by the addModifier(forProperties:at:modifier:) method.
	 * @typedef {Object} SCNParticleModifierStage
	 * @property {number} preDynamics - The stage before SceneKit simulates the motion of particles.
	 * @property {number} postDynamics - The stage after SceneKit simulates the motion of particles.
	 * @property {number} preCollision - The stage before SceneKit simulates the results of collisions between particles and scene geometry.
	 * @property {number} postCollision - The stage after SceneKit simulates the results of collisions between particles and scene geometry.
	 * @see https://developer.apple.com/reference/scenekit/scnparticlemodifierstage
	 */

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var SCNParticleModifierStage = {
	  preDynamics: 0,
	  postDynamics: 1,
	  preCollision: 2,
	  postCollision: 3
	};

	exports.default = SCNParticleModifierStage;

/***/ },
/* 119 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * The signature for blocks called by SceneKit to modify particle properties on each frame of simulation, used by the addModifier(forProperties:at:modifier:) method.
	 * @type {function(data: UnsafeMutablePointer<UnsafeMutableRawPointer>, dataStride: UnsafeMutablePointer<Int>, start: number, end: number, deltaTime: number): void}
	 * @param {UnsafeMutablePointer<UnsafeMutableRawPointer>} data - An array of floating-point values containing stripes of property data for the systems particles. The width and format of each data stripe depend on the properties you specify when calling the addModifier(forProperties:at:modifier:) method.
	 * @param {UnsafeMutablePointer<Int>} dataStride - An array identifying the offset, in bytes, of each propertys value in the data stripe for each particle. The order of offsets in this array corresponds to the order of the properties array you specify when calling the addModifier(forProperties:at:modifier:) method.
	 * @param {number} start - The index of the first particles data stripe in the data array.
	 * @param {number} end - The index of the last particles data stripe in the data array.
	 * @param {number} deltaTime - The elapsed time, in seconds, since the last frame of simulation.
	 * @returns {void}
	 * @desc Use this block to change properties of individual particles on each frame of simulation.ImportantRunning your own code to update particle properties every frame can have a severe impact on rendering performance. If the behavior over time that you want for your particle system can be described more declaratively, use the propertyControllers property and SCNParticlePropertyController class instead. If you need to change particle properties only at certain times (rather than continuously), add a handler block for an event using the handle(_:forProperties:handler:) method.The following example illustrates setting up a modifier block that alters particles position and velocity:[system addModifierForProperties:@[SCNParticlePropertyPosition,
	                                   SCNParticlePropertyVelocity]
	                         atStage:SCNParticleModifierStagePostDynamics
	                       withBlock:^(void **data, size_t *dataStride, NSInteger start, NSInteger end, float deltaTime) {
	                           // For each particle to be processed,
	                           // calculate pointers in the data to each property's value:
	                           for (NSInteger i = start; i < end; ++i) {
	                               // SCNParticlePropertyPosition (float3)
	                               float *pos = (float *)((char *)data[0] + dataStride[0] * i);
	                               // pos[0..2] are the xyz components of the particle's position.
	 
	                               // SCNParticlePropertyVelocity (float3)
	                               float *vel = (float *)((char *)data[1] + dataStride[1] * i);
	                               // vel[0..2] are the xyz components of the particle's position.
	 
	                               // Now, compute a new position and velocity (not shown).
	                           }
	                       }];

	 * @see https://developer.apple.com/reference/scenekit/scnparticlemodifierblock
	 */

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	var SCNParticleModifierBlock = function SCNParticleModifierBlock(data, dataStride, start, end, deltaTime) {};

	exports.default = SCNParticleModifierBlock;

/***/ },
/* 120 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * Options for drawing overlays with SceneKit content that can aid in debugging, used with the debugOptions property.
	 * @access public
	 * @see https://developer.apple.com/reference/scenekit/scndebugoptions
	 */

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var SCNDebugOptions = function () {
	  function SCNDebugOptions() {
	    _classCallCheck(this, SCNDebugOptions);
	  }

	  _createClass(SCNDebugOptions, [{
	    key: 'init',


	    // Initializers

	    /**
	     * 
	     * @access public
	     * @param {number} rawValue - 
	     * @returns {void}
	     * @see https://developer.apple.com/reference/scenekit/scndebugoptions/1523870-init
	     */
	    value: function init(rawValue) {

	      // Constants

	      this._showPhysicsShapes = null;
	      this._showBoundingBoxes = null;
	      this._showLightInfluences = null;
	      this._showLightExtents = null;
	      this._showPhysicsFields = null;
	      this._showWireframe = null;
	    }
	  }, {
	    key: 'showPhysicsShapes',


	    // Constants
	    /**
	     * Display the physics shapes for any nodes with attached SCNPhysicsBody objects.
	     * @type {SCNDebugOptions}
	     * @desc 
	     * @see https://developer.apple.com/reference/scenekit/scndebugoptions/1522896-showphysicsshapes
	     */
	    get: function get() {
	      return this._showPhysicsShapes;
	    }
	    /**
	     * Display the bounding boxes for any nodes with content.
	     * @type {SCNDebugOptions}
	     * @desc 
	     * @see https://developer.apple.com/reference/scenekit/scndebugoptions/1523258-showboundingboxes
	     */

	  }, {
	    key: 'showBoundingBoxes',
	    get: function get() {
	      return this._showBoundingBoxes;
	    }
	    /**
	     * Display the locations of each SCNLight object in the scene.
	     * @type {SCNDebugOptions}
	     * @desc 
	     * @see https://developer.apple.com/reference/scenekit/scndebugoptions/1522606-showlightinfluences
	     */

	  }, {
	    key: 'showLightInfluences',
	    get: function get() {
	      return this._showLightInfluences;
	    }
	    /**
	     * Display the regions affected by each SCNLight object in the scene.
	     * @type {SCNDebugOptions}
	     * @desc Only lights whose type is omni or spot have an area of effect; directional and ambient lights affect the entire scene.
	     * @see https://developer.apple.com/reference/scenekit/scndebugoptions/1522894-showlightextents
	     */

	  }, {
	    key: 'showLightExtents',
	    get: function get() {
	      return this._showLightExtents;
	    }
	    /**
	     * Display the regions affected by each SCNPhysicsField object in the scene.
	     * @type {SCNDebugOptions}
	     * @desc 
	     * @see https://developer.apple.com/reference/scenekit/scndebugoptions/1523589-showphysicsfields
	     */

	  }, {
	    key: 'showPhysicsFields',
	    get: function get() {
	      return this._showPhysicsFields;
	    }
	    /**
	     * Display geometries in the scene with wireframe rendering.
	     * @type {SCNDebugOptions}
	     * @desc When this option is enabled, SceneKit still renders scene geometry with all associated materials, then overlays a wireframe rendering of the same geometry. You can use this option, for example, to debug material rendering issues.
	     * @see https://developer.apple.com/reference/scenekit/scndebugoptions/1523384-showwireframe
	     */

	  }, {
	    key: 'showWireframe',
	    get: function get() {
	      return this._showWireframe;
	    }
	  }]);

	  return SCNDebugOptions;
	}();

	exports.default = SCNDebugOptions;

/***/ },
/* 121 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * Options for choosing the graphics technology for an SCNView object (or other SceneKit renderer) to use for drawing its contents. Used by the renderingAPI property and the preferredRenderingAPI option when initializing an SCNView object.
	 * @typedef {Object} SCNRenderingAPI
	 * @property {number} metal - Use the Metal framework for SceneKit rendering.
	 * @property {number} openGLES2 - Use the OpenGL ES 2.0 API for SceneKit rendering in iOS.
	 * @property {number} openGLLegacy - Use the Legacy OpenGL API for SceneKit rendering in macOS.
	 * @property {number} openGLCore32 - Use the OpenGL 3.2 Core Profile API for SceneKit rendering in macOS.
	 * @property {number} openGLCore41 - Use the OpenGL 4.1 Core Profile API for SceneKit rendering in macOS.
	 * @property {number} webGL - Use the OpenGL 4.1 Core Profile API for SceneKit rendering in macOS.
	 * @see https://developer.apple.com/reference/scenekit/scnrenderingapi
	 */

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var SCNRenderingAPI = {
	  metal: 0,
	  openGLLegacy: 1,
	  openGLCore32: 2,
	  openGLCore41: 3,
	  openGLES2: 999,
	  webGL: 998
	};

	exports.default = SCNRenderingAPI;

/***/ },
/* 122 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * 
	 * @typedef {Object} SCNHitTestOption
	 * @property {string} backFaceCulling - An option to ignore faces not oriented toward the camera.
	 * @property {string} boundingBoxOnly - An option to search for objects by bounding box only.
	 * @property {string} categoryBitMask - 
	 * @property {string} clipToZRange - An option to search for objects only within the depth range of the current point of view.
	 * @property {string} firstFoundOnly - An option to return only the first object found.
	 * @property {string} ignoreChildNodes - An option to ignore child nodes when searching.
	 * @property {string} ignoreHiddenNodes - An option to ignore hidden nodes when searching.
	 * @property {string} rootNode - The root of the node hierarchy to be searched.
	 * @property {string} sortResults - An option to sort the results of a hit-test.
	 * @see https://developer.apple.com/reference/scenekit/scnhittestoption
	 */

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var SCNHitTestOption = {
	  backFaceCulling: 'kHitTestBackFaceCulling',
	  boundingBoxOnly: 'kHitTestBoundingBoxOnly',
	  categoryBitMask: 'kHitTestCategoryBitMask',
	  clipToZRange: 'kHitTestClipToZRange',
	  firstFoundOnly: 'kHitTestFirstFoundOnly',
	  ignoreChildNodes: 'kHitTestIgnoreChildNodes',
	  ignoreHiddenNodes: 'kHitTestSkipHiddenNode',
	  rootNode: 'kHitTestRootNode',
	  sortResults: 'kHitTestSortResults'
	};

	exports.default = SCNHitTestOption;

/***/ },
/* 123 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _SCNSceneRenderer = __webpack_require__(89);

	var _SCNSceneRenderer2 = _interopRequireDefault(_SCNSceneRenderer);

	var _SCNScene = __webpack_require__(90);

	var _SCNScene2 = _interopRequireDefault(_SCNScene);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	/**
	 * Methods your app can implement to participate in SceneKits animation loop or perform additional rendering. 
	 * @interface
	 * @see https://developer.apple.com/reference/scenekit/scnscenerendererdelegate
	 */
	var SCNSceneRendererDelegate = function () {
	  function SCNSceneRendererDelegate() {
	    _classCallCheck(this, SCNSceneRendererDelegate);
	  }

	  _createClass(SCNSceneRendererDelegate, [{
	    key: 'init',


	    /**
	     * constructor
	     * @access public
	     * @returns {void}
	     */
	    value: function init() {}

	    // Adding Custom Logic to the Rendering Loop

	    /**
	     * Tells the delegate to perform any updates that need to occur before actions, animations, and physics are evaluated.
	     * @access public
	     * @param {SCNSceneRenderer} renderer - 
	     * @param {number} time - The current system time, in seconds. Use this parameter for any time-based elements of your game logic.
	     * @returns {void}
	     * @desc SceneKit calls this method exactly once per frame, so long as the SCNView object (or other SCNSceneRenderer object) displaying the scene is not paused. Implement this method to add game logic to the rendering loop. Any changes you make to the scene graph during this method are immediately reflected in the displayed scene. That is, SceneKit immediately updates the hierarchy of presentation nodes it uses to render the scene (instead of using the SCNTransaction class to batch your changes).
	      * @see https://developer.apple.com/reference/scenekit/scnscenerendererdelegate/1522937-renderer
	     */

	  }, {
	    key: 'rendererUpdateAtTime',
	    value: function rendererUpdateAtTime(renderer, time) {}

	    /**
	     * Tells the delegate to perform any updates that need to occur after actions and animations are evaluated.
	     * @access public
	     * @param {SCNSceneRenderer} renderer - 
	     * @param {number} time - The current system time, in seconds. Use this parameter for any time-based elements of your game logic.
	     * @returns {void}
	     * @desc SceneKit calls this method exactly once per frame, so long as the SCNView object (or other SCNSceneRenderer object) displaying the scene is not paused. Implement this method to add game logic to the rendering loop. Any changes you make to the scene graph during this method are immediately reflected in the displayed scene. That is, SceneKit immediately updates the hierarchy of presentation nodes it uses to render the scene (instead of using the SCNTransaction class to batch your changes).
	      * @see https://developer.apple.com/reference/scenekit/scnscenerendererdelegate/1523038-renderer
	     */

	  }, {
	    key: 'rendererDidApplyAnimationsAtTime',
	    value: function rendererDidApplyAnimationsAtTime(renderer, time) {}

	    /**
	     * Tells the delegate to perform any updates that need to occur after physics simulations are performed.
	     * @access public
	     * @param {SCNSceneRenderer} renderer - 
	     * @param {number} time - The current system time, in seconds. Use this parameter for any time-based elements of your game logic.
	     * @returns {void}
	     * @desc SceneKit calls this method exactly once per frame, so long as the SCNView object (or other SCNSceneRenderer object) displaying the scene is not paused. Implement this method to add game logic to the rendering loop. Any changes you make to the scene graph during this method are immediately reflected in the displayed scene. That is, SceneKit immediately updates the hierarchy of presentation nodes it uses to render the scene (instead of using the SCNTransaction class to batch your changes).
	    This method is the last opportunity SceneKit provides for you to change the scene graph before rendering.
	     * @see https://developer.apple.com/reference/scenekit/scnscenerendererdelegate/1522738-renderer
	     */

	  }, {
	    key: 'rendererDidSimulatePhysicsAtTime',
	    value: function rendererDidSimulatePhysicsAtTime(renderer, time) {}

	    // Rendering Custom Scene Content

	    /**
	     * Tells the delegate that the renderer has cleared the viewport and is about to render the scene.
	     * @access public
	     * @param {SCNSceneRenderer} renderer - 
	     * @param {SCNScene} scene - The SCNScene object to be rendered.
	     * @param {number} time - The current system time, in seconds. If your custom rendering involves animation, use this parameter to compute your own animation state.
	     * @returns {void}
	     * @desc Implement this method to perform custom drawing before SceneKit renders a scenefor example, to draw backdrop content underneath SceneKit content. You should only execute Metal or OpenGL drawing commands (and any setup required to perform them) in this methodthe results of modifying SceneKit objects during this method are undefined.To render using Metal, use the renderer parameter to retrieve the scene renderers currentRenderCommandEncoder object and encode your own drawing commands. If you need to reference other Metal state, see the properties listed in SCNSceneRenderer.To render using OpenGL, simply call the relevant OpenGL drawing commandsSceneKit automatically makes its OpenGL context the current context before calling this method. If you need to reference the OpenGL context being rendered into, examine the context property of the renderer parameter.You must draw using the appropriate graphics technology for the view currently being rendered. Use the renderingAPI property of the renderer object to determine whether Metal or OpenGL is in use. 
	     * @see https://developer.apple.com/reference/scenekit/scnscenerendererdelegate/1523483-renderer
	     */

	  }, {
	    key: 'rendererWillRenderSceneAtTime',
	    value: function rendererWillRenderSceneAtTime(renderer, scene, time) {}

	    /**
	     * Tells the delegate that the renderer has rendered the scene.
	     * @access public
	     * @param {SCNSceneRenderer} renderer - 
	     * @param {SCNScene} scene - The scene object that was rendered.
	     * @param {number} time - The current system time, in seconds. If your custom rendering involves animation, use this parameter to compute your own animation state.
	     * @returns {void}
	     * @desc Implement this method to perform custom drawing after SceneKit has rendered a scenefor example, to draw overlay content on top of SceneKit content. You should only execute Metal or OpenGL drawing commands (and any setup required to perform them) in this methodthe results of modifying SceneKit objects in this method are undefined.To render using Metal, use the renderer parameter to retrieve the scene renderers currentRenderCommandEncoder object and encode your own drawing commands. If you need to reference other Metal state, see the properties listed in SCNSceneRenderer.To render using OpenGL, simply call the relevant OpenGL drawing commandsSceneKit automatically makes its OpenGL context the current context before calling this method. If you need to reference the OpenGL context being rendered into, examine the context property of the renderer parameter.You must draw using the appropriate graphics technology for the view currently being rendered. Use the renderingAPI property of the renderer object to determine whether Metal or OpenGL is in use. 
	     * @see https://developer.apple.com/reference/scenekit/scnscenerendererdelegate/1524233-renderer
	     */

	  }, {
	    key: 'rendererDidRenderSceneAtTime',
	    value: function rendererDidRenderSceneAtTime(renderer, scene, time) {}
	  }]);

	  return SCNSceneRendererDelegate;
	}();

	exports.default = SCNSceneRendererDelegate;

/***/ },
/* 124 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * Modes for antialiased rendering of the views scene, used by the SCNView property.
	 * @typedef {Object} SCNAntialiasingMode
	 * @property {number} none - Disables antialiased rendering.
	 * @property {number} multisampling2X - Enables multisample antialiasing, with two samples per screen pixel.
	 * @property {number} multisampling4X - Enables multisample antialiasing, with four samples per screen pixel.
	 * @property {number} multisampling8X - Enables multisample antialiasing, with eight samples per screen pixel.
	 * @property {number} multisampling16X - Enables multisample antialiasing, with sixteen samples per screen pixel.
	 * @see https://developer.apple.com/reference/scenekit/scnantialiasingmode
	 */

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var SCNAntialiasingMode = {
	  none: 0,
	  multisampling2X: 1,
	  multisampling4X: 2,
	  multisampling8X: 3,
	  multisampling16X: 4
	};

	exports.default = SCNAntialiasingMode;

/***/ },
/* 125 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _NSObject2 = __webpack_require__(2);

	var _NSObject3 = _interopRequireDefault(_NSObject2);

	var _SCNProgramDelegate = __webpack_require__(126);

	var _SCNProgramDelegate2 = _interopRequireDefault(_SCNProgramDelegate);

	var _SCNBufferFrequency = __webpack_require__(127);

	var _SCNBufferFrequency2 = _interopRequireDefault(_SCNBufferFrequency);

	var _SCNBufferBindingBlock = __webpack_require__(128);

	var _SCNBufferBindingBlock2 = _interopRequireDefault(_SCNBufferBindingBlock);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * A complete Metal or OpenGL shader program that replaces SceneKit's rendering of a geometry or material.
	 * @access public
	 * @extends {NSObject}
	 * @see https://developer.apple.com/reference/scenekit/scnprogram
	 */
	var SCNProgram = function (_NSObject) {
	  _inherits(SCNProgram, _NSObject);

	  /**
	   * constructor
	   * @access public
	   * @constructor
	   */
	  function SCNProgram() {
	    _classCallCheck(this, SCNProgram);

	    // Working with OpenGL Shader Source Code

	    /**
	     * GLSL source code for the programs vertex shader.
	     * @type {?string}
	     * @see https://developer.apple.com/reference/scenekit/scnprogram/1522891-vertexshader
	     */
	    var _this = _possibleConstructorReturn(this, (SCNProgram.__proto__ || Object.getPrototypeOf(SCNProgram)).call(this));

	    _this.vertexShader = null;

	    /**
	     * GLSL source code for the programs fragment shader.
	     * @type {?string}
	     * @see https://developer.apple.com/reference/scenekit/scnprogram/1523135-fragmentshader
	     */
	    _this.fragmentShader = null;

	    /**
	     * GLSL source code for the programs optional geometry shader.
	     * @type {?string}
	     * @see https://developer.apple.com/reference/scenekit/scnprogram/1524049-geometryshader
	     */
	    _this.geometryShader = null;

	    /**
	     * GLSL source code for the programs optional tessellation control shader.
	     * @type {?string}
	     * @see https://developer.apple.com/reference/scenekit/scnprogram/1523852-tessellationcontrolshader
	     */
	    _this.tessellationControlShader = null;

	    /**
	     * GLSL source code for the programs optional tessellation evaluation shader.
	     * @type {?string}
	     * @see https://developer.apple.com/reference/scenekit/scnprogram/1523760-tessellationevaluationshader
	     */
	    _this.tessellationEvaluationShader = null;

	    // Providing a Delegate Object

	    /**
	     * The delegate of the program object.
	     * @type {?SCNProgramDelegate}
	     * @see https://developer.apple.com/reference/scenekit/scnprogram/1522611-delegate
	     */
	    _this.delegate = null;

	    // Managing Opacity

	    /**
	     * A Boolean value that indicates whether fragments rendered by the program are fully opaque.
	     * @type {boolean}
	     * @see https://developer.apple.com/reference/scenekit/scnprogram/1522844-isopaque
	     */
	    _this.isOpaque = false;

	    // Working With Metal Shaders

	    /**
	     * The name of the vertex shader function to load from a Metal shader library.
	     * @type {?string}
	     * @see https://developer.apple.com/reference/scenekit/scnprogram/1522799-vertexfunctionname
	     */
	    _this.vertexFunctionName = null;

	    /**
	     * The name of the fragment shader function to load from a Metal shader library.
	     * @type {?string}
	     * @see https://developer.apple.com/reference/scenekit/scnprogram/1524012-fragmentfunctionname
	     */
	    _this.fragmentFunctionName = null;

	    /**
	     * The Metal shader library containing shader functions to be used by this program.
	     * @type {?MTLLibrary}
	     * @see https://developer.apple.com/reference/scenekit/scnprogram/1522934-library
	     */
	    _this.library = null;

	    /**
	     * @access private
	     * @type {WebGLProgram}
	     */
	    _this._glProgram = null;

	    /**
	     * @access private
	     * @type {WebGLTexture}
	     */
	    _this._dummyTexture = null;
	    return _this;
	  }

	  // Mapping GLSL Symbols to SceneKit Semantics

	  /**
	   * Associates a SceneKit semantic identifier with the specified GLSL vertex attribute or uniform variable.
	   * @access public
	   * @param {?string} semantic - A SceneKit semantic identifier. See Geometry Semantic Identifiers and Rendering Transform Keys for possible values.
	   * @param {string} symbol - The name declared in the programs GLSL source code for the vertex attribute or uniform variable to be associated with the semantic.
	   * @param {?Map<string, Object>} [options = null] - A dictionary of options affecting the semantic. See Program Semantic Options for applicable keys and values.
	   * @returns {void}
	   * @desc Use this method to provide inputs managed by SceneKit to your GLSL program.To use vertex attributes provided by SCNGeometry objects, use the constants listed in Geometry Semantic Identifiers.To use the coordinate transformations defined by the scenes node hierarchy and point-of-view camera, use the constants listed in Rendering Transform Keys.
	   * @see https://developer.apple.com/reference/scenekit/scnprogram/1522730-setsemantic
	   */


	  _createClass(SCNProgram, [{
	    key: 'setSemanticForSymbol',
	    value: function setSemanticForSymbol(semantic, symbol) {
	      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
	    }

	    /**
	     * Returns the SceneKit semantic identifiers associated with the specified GLSL vertex attribute or uniform variable.
	     * @access public
	     * @param {string} symbol - The name declared in the programs GLSL source code for a vertex attribute or uniform variable semantic.
	     * @returns {?string} - 
	     * @see https://developer.apple.com/reference/scenekit/scnprogram/1523350-semantic
	     */

	  }, {
	    key: 'semanticForSymbol',
	    value: function semanticForSymbol(symbol) {
	      return null;
	    }

	    // Providing Input for Metal Shaders

	    /**
	     * Registers a block for SceneKit to call at render time for binding a Metal buffer to the shader program.
	     * @access public
	     * @param {string} name - The name identifying the buffer in Metal shader source code.
	     * @param {SCNBufferFrequency} frequency - An option specifying whether SceneKit calls the block only once per rendered frame or more frequently (for example, once for each object to be rendered).
	     * @param {SCNBufferBindingBlock} block - A block to be run when SceneKit prepares for rendering with the Metal shader.
	     * @returns {void}
	     * @desc Use this method to associate a block with a Metal shader program to handle setup of a buffer used in that shader. SceneKit calls your block before rendering any objects whose program property is set to this SCNProgram object. In the block, use the writeBytes(_:count:) method to provide data for the buffer.  
	      * @see https://developer.apple.com/reference/scenekit/scnprogram/1524047-handlebinding
	     */

	  }, {
	    key: 'handleBindingOfBufferNamedHandler',
	    value: function handleBindingOfBufferNamedHandler(name, frequency, block) {}
	  }, {
	    key: '_setDummyTextureForContext',
	    value: function _setDummyTextureForContext(context) {
	      var gl = context;
	      this._createDummyTextureForContext(gl);

	      var texNames = [gl.TEXTURE0, gl.TEXTURE1, gl.TEXTURE2, gl.TEXTURE3, gl.TEXTURE4, gl.TEXTURE5, gl.TEXTURE6, gl.TEXTURE7];
	      var texSymbols = ['u_emissionTexture', 'u_ambientTexture', 'u_diffuseTexture', 'u_specularTexture', 'u_reflectiveTexture', 'u_transparentTexture', 'u_multiplyTexture', 'u_normalTexture'];
	      for (var i = 0; i < texNames.length; i++) {
	        var texName = texNames[i];
	        var symbol = texSymbols[i];
	        var loc = gl.getUniformLocation(this._glProgram, symbol);
	        if (loc !== null) {
	          gl.uniform1i(loc, i);
	          gl.activeTexture(texName);
	          gl.bindTexture(gl.TEXTURE_2D, this._dummyTexture);
	        }
	      }
	    }
	  }, {
	    key: '_createDummyTextureForContext',
	    value: function _createDummyTextureForContext(context) {
	      if (this._dummyTexture !== null) {
	        return;
	      }
	      var gl = context;
	      var canvas = document.createElement('canvas');
	      canvas.width = 1;
	      canvas.height = 1;
	      var c = canvas.getContext('2d');
	      c.fillStyle = 'rgba(255, 255, 255, 1.0)';
	      c.fillRect(0, 0, 1, 1);

	      this._dummyTexture = gl.createTexture();

	      gl.bindTexture(gl.TEXTURE_2D, this._dummyTexture);
	      // texImage2D(target, level, internalformat, width, height, border, format, type, source)
	      // Safari complains that 'source' is not ArrayBufferView type, but WebGL2 should accept HTMLCanvasElement.
	      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, canvas);
	      gl.bindTexture(gl.TEXTURE_2D, null);
	    }
	  }]);

	  return SCNProgram;
	}(_NSObject3.default);

	exports.default = SCNProgram;

/***/ },
/* 126 */
/***/ function(module, exports) {

	'use strict';

	//import SCNProgram from './SCNProgram'
	//import SCNRenderer from './SCNRenderer'


	/**
	 * The interface for tracking errors that occur when compiling shader source code.
	 * @interface
	 * @see https://developer.apple.com/reference/scenekit/scnprogramdelegate
	 */

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var SCNProgramDelegate = function () {
	  function SCNProgramDelegate() {
	    _classCallCheck(this, SCNProgramDelegate);
	  }

	  _createClass(SCNProgramDelegate, [{
	    key: 'init',


	    /**
	     * constructor
	     * @access public
	     * @returns {void}
	     */
	    value: function init() {}

	    // Handling Shader Compilation Errors

	    /**
	     * Tells the delegate that an error occurred when compiling GLSL source code.
	     * @access public
	     * @param {SCNProgram} program - The program that generated the compilation error.
	     * @param {Error} error - The compilation error that was raised.
	     * @returns {void}
	     * @desc Examine the error parameter for details of the compilation error provided by the GLSL compiler.
	     * @see https://developer.apple.com/reference/scenekit/scnprogramdelegate/1523007-program
	     */

	  }, {
	    key: 'programHandleError',
	    value: function programHandleError(program, error) {}

	    // Finding Fragment Opaqueness

	    /**
	     * Asks the delegate whether fragments rendered by a program are opaque.
	     * @deprecated
	     * @access public
	     * @param {SCNProgram} program - 
	     * @returns {boolean} - 
	     * @see https://developer.apple.com/reference/scenekit/scnprogramdelegate/1523068-programisopaque
	     */

	  }, {
	    key: 'programIsOpaque',
	    value: function programIsOpaque(program) {
	      return false;
	    }

	    // Binding and Unbinding Values

	    /**
	     * Invoked on the delegate to let it bind program values and/or associated graphics resources (such as textures) for symbols.
	     * @deprecated
	     * @access public
	     * @param {SCNProgram} program - The SCNProgram object to bind values for.
	     * @param {string} symbol - The name of the symbol to bind a value for.
	     * @param {number} location - The location of the symbol within the program object to be modified.
	     * @param {number} programID - The underlying OpenGL program object in which the binding is made.
	     * @param {SCNRenderer} renderer - The renderer that is currently rendering the scene.
	     * @returns {boolean} - 
	     * @desc If you use the handleBinding(ofSymbol:handler:) method to associate a handler block with a SceneKit object for a symbol, SceneKit will not call the delegates program(_:bindValueForSymbol:atLocation:programID:renderer:) method for that symbol when rendering that object.
	     * @see https://developer.apple.com/reference/scenekit/scnprogramdelegate/1524155-program
	     */

	  }, {
	    key: 'programBindValueForSymbolAtLocation',
	    value: function programBindValueForSymbolAtLocation(program, symbol, location, programID, renderer) {
	      return false;
	    }

	    /**
	     * Invoked on the delegate to let it unbind program values and/or also unbind associated graphic resources (such as textures).
	     * @deprecated
	     * @access public
	     * @param {SCNProgram} program - The SCNProgram object to unbind values for.
	     * @param {string} symbol - The name of the symbol to unbind a value for.
	     * @param {number} location - The location of the symbol within the program object to be modified.
	     * @param {number} programID - The underlying OpenGL program object in which the unbinding is done.
	     * @param {SCNRenderer} renderer - The renderer that is currently rendering the scene.
	      * @returns {void}
	     * @desc If you use the handleUnbinding(ofSymbol:handler:) method to associate a handler block with a SceneKit object for a symbol, SceneKit will not call the delegates program(_:unbindValueForSymbol:atLocation:programID:renderer:) method for that symbol when rendering that object.
	     * @see https://developer.apple.com/reference/scenekit/scnprogramdelegate/1523857-program
	     */

	  }, {
	    key: 'programUnbindValueForSymbolAtLocation',
	    value: function programUnbindValueForSymbolAtLocation(program, symbol, location, programID, renderer) {}
	  }]);

	  return SCNProgramDelegate;
	}();

	exports.default = SCNProgramDelegate;

/***/ },
/* 127 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * Options for how often SceneKit should execute the binding handler you provide with the handleBinding(ofBufferNamed:frequency:handler:) method.
	 * @typedef {Object} SCNBufferFrequency
	 * @property {number} perFrame - Execute the binding handler once for each frame to be rendered using the shader.
	 * @property {number} perNode - Execute the binding handler once for each frame, for each node to be rendered using the shader.
	 * @property {number} perShadable - Execute the binding handler once for each frame, for each node, for each material or geometry to be rendered using the shader.
	 * @see https://developer.apple.com/reference/scenekit/scnbufferfrequency
	 */

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var SCNBufferFrequency = {
	  perFrame: 0,
	  perNode: 1,
	  perShadable: 2
	};

	exports.default = SCNBufferFrequency;

/***/ },
/* 128 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _SCNBufferStream = __webpack_require__(129);

	var _SCNBufferStream2 = _interopRequireDefault(_SCNBufferStream);

	var _SCNNode = __webpack_require__(65);

	var _SCNNode2 = _interopRequireDefault(_SCNNode);

	var _SCNShadable = __webpack_require__(70);

	var _SCNShadable2 = _interopRequireDefault(_SCNShadable);

	var _SCNRenderer = __webpack_require__(88);

	var _SCNRenderer2 = _interopRequireDefault(_SCNRenderer);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * A block SceneKit calls at render time for working with buffers in a Metal shader, used by the handleBinding(ofBufferNamed:frequency:handler:) method.
	 * @type {function(buffer: SCNBufferStream, node: SCNNode, shadable: SCNShadable, renderer: SCNRenderer): void}
	 * @param {SCNBufferStream} buffer - An object that provides write access to the buffer. Use the writeBytes(_:count:) method on this object to write data for use by the shader.
	 * @param {SCNNode} node - The node to be rendered using the shader program.
	 * @param {SCNShadable} shadable - The material or geometry to be rendered using the shader program.
	 * @param {SCNRenderer} renderer - The view (or other SceneKit renderer) responsible for rendering.
	 * @returns {void}
	 * @see https://developer.apple.com/reference/scenekit/scnbufferbindingblock
	 */
	var SCNBufferBindingBlock = function SCNBufferBindingBlock(buffer, node, shadable, renderer) {};

	exports.default = SCNBufferBindingBlock;

/***/ },
/* 129 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * An object that manages a Metal buffer used by a custom shader program. 
	 * @interface
	 * @see https://developer.apple.com/reference/scenekit/scnbufferstream
	 */

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var SCNBufferStream = function () {
	  function SCNBufferStream() {
	    _classCallCheck(this, SCNBufferStream);
	  }

	  _createClass(SCNBufferStream, [{
	    key: 'init',


	    /**
	     * constructor
	     * @access public
	     * @returns {void}
	     */
	    value: function init() {}

	    // Writing Data to a Buffer

	    /**
	     * Required. Copies the specified data bytes into the underlying Metal buffer for use by a shader.
	     * @access public
	     * @param {Object} bytes - The memory address from which to copy data.
	     * @param {number} length - The number of bytes to copy into the Metal buffer.
	     * @returns {void}
	     * @see https://developer.apple.com/reference/scenekit/scnbufferstream/1523175-writebytes
	     */

	  }, {
	    key: 'writeBytesCount',
	    value: function writeBytesCount(bytes, length) {}
	  }]);

	  return SCNBufferStream;
	}();

	exports.default = SCNBufferStream;

/***/ },
/* 130 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _NSObject2 = __webpack_require__(2);

	var _NSObject3 = _interopRequireDefault(_NSObject2);

	var _SCNAnimatable = __webpack_require__(66);

	var _SCNAnimatable2 = _interopRequireDefault(_SCNAnimatable);

	var _SCNTechniqueSupport = __webpack_require__(85);

	var _SCNTechniqueSupport2 = _interopRequireDefault(_SCNTechniqueSupport);

	var _SCNMaterialProperty = __webpack_require__(76);

	var _SCNMaterialProperty2 = _interopRequireDefault(_SCNMaterialProperty);

	var _SCNMatrix = __webpack_require__(46);

	var _SCNMatrix2 = _interopRequireDefault(_SCNMatrix);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * A set of camera attributes that can be attached to a node to provide a point of view for displaying the scene.
	 * @access public
	 * @extends {NSObject}
	 * @implements {SCNAnimatable}
	 * @implements {SCNTechniqueSupport}
	 * @see https://developer.apple.com/reference/scenekit/scncamera
	 */
	var SCNCamera = function (_NSObject) {
	  _inherits(SCNCamera, _NSObject);

	  _createClass(SCNCamera, null, [{
	    key: '_propTypes',
	    get: function get() {
	      return {
	        name: 'string',
	        zNear: 'float',
	        zFar: 'float',
	        yFov: 'float',
	        xFov: 'float',
	        automaticallyAdjustsZRange: 'boolean',
	        usesOrthographicProjection: 'boolean',
	        orthographicScale: 'float',
	        categoryBitMask: 'integer',
	        focalDistance: 'float',
	        focalSize: 'float',
	        focalBlurRadius: 'float',
	        aperture: 'float',
	        motionBlurIntensity: 'float',
	        wantsHDR: 'boolean',
	        exposureOffset: 'float',
	        averageGray: 'float',
	        whitePoint: 'float',
	        minimumExposure: 'float',
	        maximumExposure: 'float',
	        wantsExposureAdaptation: 'boolean',
	        exposureAdaptationDarkeningSpeedFactor: 'float',
	        exposureAdaptationBrighteningSpeedFactor: 'float',
	        exposureAdaptationDuration: ['float', null],
	        contrast: 'float',
	        saturation: 'float',
	        //_colorGrading: 'SCNMaterialProperty',
	        bloomIntensity: 'float',
	        bloomThreshold: 'float',
	        bloomBlurRadius: 'float',
	        colorFringeIntensity: 'float',
	        colorFringeStrength: 'float',
	        vignettingIntensity: 'float',
	        vignettingPower: 'float',
	        //projectionTransform: 'SCNMatrix4'

	        entityID: ['string', '_entityID']
	      };
	    }

	    /**
	     * constructor
	     * @access public
	     * @returns {void}
	     */

	  }]);

	  function SCNCamera() {
	    _classCallCheck(this, SCNCamera);

	    // Managing Camera Attributes

	    /**
	     * A name associated with the camera object.
	     * @type {?string}
	     * @see https://developer.apple.com/reference/scenekit/scncamera/1436623-name
	     */
	    var _this = _possibleConstructorReturn(this, (SCNCamera.__proto__ || Object.getPrototypeOf(SCNCamera)).call(this));

	    _this.name = null;

	    // Adjusting Camera Perspective

	    /**
	     * The camera's near depth limit. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scncamera/1436592-znear
	     */
	    _this.zNear = 1.0;

	    /**
	     * The cameras far depth limit. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scncamera/1436596-zfar
	     */
	    _this.zFar = 100.0;

	    /**
	     * The cameras field of view, in degrees, on the vertical axis. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scncamera/1436598-yfov
	     */
	    _this.yFov = 0;

	    /**
	     * The camera's field of view, in degrees, on the horizontal axis. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scncamera/1436608-xfov
	     */
	    _this.xFov = 0;

	    /**
	     * A Boolean value that determines whether the camera automatically adjusts its zNear and zFar depth limits.
	     * @type {boolean}
	     * @see https://developer.apple.com/reference/scenekit/scncamera/1436610-automaticallyadjustszrange
	     */
	    _this.automaticallyAdjustsZRange = false;

	    // Managing the Camera Projection

	    /**
	     * A Boolean value that determines whether the camera uses an orthographic projection.
	     * @type {boolean}
	     * @see https://developer.apple.com/reference/scenekit/scncamera/1436621-usesorthographicprojection
	     */
	    _this.usesOrthographicProjection = false;

	    /**
	     * Specifies the cameras magnification factor when using an orthographic projection.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scncamera/1436612-orthographicscale
	     */
	    _this.orthographicScale = 1.0;

	    // Choosing Nodes to Be Visible to the Camera

	    /**
	     * A mask that defines which categories this camera belongs to.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scncamera/1436625-categorybitmask
	     */
	    _this.categoryBitMask = -1;

	    // Adding Depth of Field and Blur Effects

	    /**
	     * The distance from the camera at which objects appear in sharp focus. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scncamera/1436600-focaldistance
	     */
	    _this.focalDistance = 10.0;

	    /**
	     * The width of the distance range at which objects appear in sharp focus. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scncamera/1436604-focalsize
	     */
	    _this.focalSize = 0.0;

	    /**
	     * The maximum amount of blurring, in pixels, applied to areas outside the cameras depth of field. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scncamera/1436606-focalblurradius
	     */
	    _this.focalBlurRadius = 0.0;

	    /**
	     * A factor that determines the transition between in-focus and out-of-focus areas. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scncamera/1436594-aperture
	     */
	    _this.aperture = 0.125;

	    /**
	     * A factor that determines the intensity of motion blur effects. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scncamera/1644099-motionblurintensity
	     */
	    _this.motionBlurIntensity = 0.0;

	    // Adding High Dynamic Range Effects

	    /**
	     * A Boolean value that determines whether SceneKit applies High Dynamic Range (HDR) postprocessing effects to a scene.
	     * @type {boolean}
	     * @see https://developer.apple.com/reference/scenekit/scncamera/1644101-wantshdr
	     */
	    _this.wantsHDR = false;

	    /**
	     * A logarithmic bias that adjusts the results of SceneKits tone mapping operation, brightening or darkening the visible scene.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scncamera/1644105-exposureoffset
	     */
	    _this.exposureOffset = 0;

	    /**
	     * The luminance level to use as the midpoint of a tone mapping curve.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scncamera/1644097-averagegray
	     */
	    _this.averageGray = 0.18;

	    /**
	     * The luminance level to use as the upper end of a tone mapping curve.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scncamera/1644110-whitepoint
	     */
	    _this.whitePoint = 1.0;

	    /**
	     * The minimum exposure value to use in tone mapping.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scncamera/1644103-minimumexposure
	     */
	    _this.minimumExposure = -15.0;

	    /**
	     * The minimum exposure value to use in tone mapping.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scncamera/1644120-maximumexposure
	     */
	    _this.maximumExposure = 15.0;

	    // Adding Automatic HDR Exposure Adaptation

	    /**
	     * A Boolean value that determines whether SceneKit automatically adjusts the exposure level.
	     * @type {boolean}
	     * @see https://developer.apple.com/reference/scenekit/scncamera/1644117-wantsexposureadaptation
	     */
	    _this.wantsExposureAdaptation = false;

	    /**
	     * The relative duration of automatically animated exposure transitions from dark to bright areas.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scncamera/1644093-exposureadaptationbrighteningspe
	     */
	    _this.exposureAdaptationBrighteningSpeedFactor = 0.4;

	    /**
	     * The relative duration of automatically animated exposure transitions from bright to dark areas.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scncamera/1644094-exposureadaptationdarkeningspeed
	     */
	    _this.exposureAdaptationDarkeningSpeedFactor = 0.6;

	    // Adjusting Rendered Colors

	    /**
	     * An adjustment factor to apply to the overall visual contrast of the rendered scene.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scncamera/1644112-contrast
	     */
	    _this.contrast = 0.0;

	    /**
	     * An adjustment factor to apply to the overall color saturation of the rendered scene.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scncamera/1644100-saturation
	     */
	    _this.saturation = 1.0;

	    _this._colorGrading = new _SCNMaterialProperty2.default();

	    // Adding Stylistic Visual Effects

	    /**
	     * The magnitude of bloom effect to apply to highlights in the rendered scene. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scncamera/1644104-bloomintensity
	     */
	    _this.bloomIntensity = 0.0;

	    /**
	     * The brightness threshold at which to apply a bloom effect to highlights in the rendered scene. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scncamera/1644098-bloomthreshold
	     */
	    _this.bloomThreshold = 0.5;

	    /**
	     * The radius, in pixels, for the blurring portion of the bloom effect applied to highlights in the rendered scene. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scncamera/1644096-bloomblurradius
	     */
	    _this.bloomBlurRadius = 4.0;

	    /**
	     * The blend factor for fading the color fringing effect applied to the rendered scene.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scncamera/1644108-colorfringeintensity
	     */
	    _this.colorFringeIntensity = 1.0;

	    /**
	     * The magnitude of color fringing effect to apply to the rendered scene.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scncamera/1644113-colorfringestrength
	     */
	    _this.colorFringeStrength = 0.0;

	    /**
	     * The magnitude of vignette (darkening around edges) effect to apply to the rendered scene.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scncamera/1644106-vignettingintensity
	     */
	    _this.vignettingIntensity = 1.0;

	    /**
	     * The amount of the rendered scene to darken with a vignette effect.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scncamera/1644118-vignettingpower
	     */
	    _this.vignettingPower = 0.0;

	    // Instance Properties

	    /**
	     * 
	     * @type {SCNMatrix4}
	     * @see https://developer.apple.com/reference/scenekit/scncamera/1690501-projectiontransform
	     */
	    _this.projectionTransform = null;

	    /**
	     * @access private
	     * @type {?string}
	     */
	    _this._entityID = null;
	    return _this;
	  }

	  // Creating a Camera

	  /**
	   * Creates a camera from the specified Model I/O camera object.
	   * @access public
	   * @param {MDLCamera} mdlCamera - A Model I/O camera object.
	   * @returns {void}
	   * @desc The Model I/O framework provides universal support for import, export, description, and processing of several 3D asset file formats and related resources. (For details, see Model I/O.) The MDLCamera class is a generic description of a viewpoint on a scene, supporting a superset of the attributes described by the SCNCamera class.
	   * @see https://developer.apple.com/reference/scenekit/scncamera/1419839-init
	   */


	  _createClass(SCNCamera, [{
	    key: 'init',
	    value: function init(mdlCamera) {}

	    // Adjusting Rendered Colors
	    /**
	     * A texture for applying color grading effects to the entire rendered scene.
	     * @type {SCNMaterialProperty}
	     * @desc The contents value for this material property must be a 3D color lookup table, or a 2D texture image that represents such a table arranged in a horizontal strip. A lookup table is a cube of color values: the red, green, and blue components of an input color map to the x, y, and z coordinates of a location in that cube, and at that location in the cube is a corresponding output color. You can provide data in this cubic format as a Metal texture with the type3D texture type.The 2D representation of a 3D color cube is an arrangement of slices: for example, a 16 x 16 x 16 color cube becomes a horizontal strip of 16 squares, each 16 x 16 pixels (that is, a 256 x 16 image). Each square contains a gradation of red and green components, and together the 16 squares form a gradation for the blue component. To provide a 2D representation of a color cube, set this material propertys contents value to an image.By using a color table, you can easily create custom color effects that apply to an entire rendered scene:Create a basic color table image such as Figure 1, where the color value for each R, G, and B coordinate in the cube is the corresponding RGB color.Figure 1 Basic color table imageUse an image editor to create the color effect you want using some other imagesuch as a screenshot of your game. Apply only effects that affect pixel colors without modifying pixel positions. (For example, you can use hue/saturation, color curves, or color matrix filters, but not blur or distort filters.)Figure 2 Creating a color grading effectApply the same color effect you created in step 2 to your basic color table image. You can even perform these steps together: paste the basic color table into your game screenshot, apply an effect to the combined picture, then crop the picture to just the modified color table. Figure 2 shows an example effect.Assign your customized color table image (such as the example in Figure 3) to this property. When rendering, SceneKit looks up the RGB values for each pixel in the rendered scene, and displays the corresponding color values from the color table.Figure 3 Custom color table image for color gradingBasic color table imageCreating a color grading effectCustom color table image for color grading
	     * @see https://developer.apple.com/reference/scenekit/scncamera/1644114-colorgrading
	     */

	  }, {
	    key: '_updateProjectionTransform',


	    /**
	     * @access private
	     * @param {CGRect} viewRect -
	     * @returns {void}
	     */
	    value: function _updateProjectionTransform(viewRect) {
	      var m = new _SCNMatrix2.default();
	      var left = viewRect.minX;
	      var right = viewRect.maxX;
	      var top = viewRect.maxY;
	      var bottom = viewRect.minY;
	      var aspect = viewRect.size.width / viewRect.size.height;

	      if (this.usesOrthographicProjection) {
	        //this.orthographicScale
	        m.m11 = 2 / (right - left);
	        m.m12 = 0;
	        m.m13 = 0;
	        m.m14 = 0;
	        m.m21 = 0;
	        m.m22 = 2 / (top - bottom);
	        m.m23 = 0;
	        m.m24 = 0;
	        m.m31 = 0;
	        m.m32 = 0;
	        m.m33 = -2 / (this.zFar - this.zNear);
	        m.m34 = 0;
	        m.m41 = -(right + left) / (right - left);
	        m.m42 = -(top + bottom) / (top - bottom);
	        m.m43 = -(this.zFar + this.zNear) / (this.zFar - this.zNear);
	        m.m44 = 1;
	      } else {
	        // perspective
	        //this.yFov
	        //this.xFov
	        //this.automaticallyAdjustsZRange
	        var m11 = 1;
	        var m22 = 1;
	        if (this.yFov <= 0 && this.xFov <= 0) {
	          var cot = 1.0 / Math.tan(Math.PI / 6.0);
	          m11 = cot / aspect;
	          m22 = cot;
	        } else if (this.yFov <= 0) {
	          var _cot = 1.0 / Math.tan(this.xFov * Math.PI / 360.0);
	          m11 = _cot;
	          m22 = _cot * aspect;
	        } else if (this.xFov <= 0) {
	          var _cot2 = 1.0 / Math.tan(this.yFov * Math.PI / 360.0);
	          m11 = _cot2 / aspect;
	          m22 = _cot2;
	        } else {
	          // FIXME: compare xFov to yFov
	          var _cot3 = 1.0 / Math.tan(this.yFov * Math.PI / 360.0);
	          m11 = _cot3 / aspect;
	          m22 = _cot3;
	        }

	        m.m11 = m11;
	        m.m12 = 0;
	        m.m13 = 0;
	        m.m14 = 0;
	        m.m21 = 0;
	        m.m22 = m22;
	        m.m23 = 0;
	        m.m24 = 0;
	        m.m31 = 0;
	        m.m32 = 0;
	        m.m33 = -(this.zFar + this.zNear) / (this.zFar - this.zNear);
	        m.m34 = -1;
	        m.m41 = 0;
	        m.m42 = 0;
	        m.m43 = -2 * this.zFar * this.zNear / (this.zFar - this.zNear);
	        m.m44 = 0;
	      }
	      this.projectionTransform = m;
	    }
	  }, {
	    key: 'colorGrading',
	    get: function get() {
	      return this._colorGrading;
	    }
	  }]);

	  return SCNCamera;
	}(_NSObject3.default);

	exports.default = SCNCamera;

/***/ },
/* 131 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

	var _CGPoint = __webpack_require__(7);

	var _CGPoint2 = _interopRequireDefault(_CGPoint);

	var _CGRect = __webpack_require__(8);

	var _CGRect2 = _interopRequireDefault(_CGRect);

	var _CGSize = __webpack_require__(9);

	var _CGSize2 = _interopRequireDefault(_CGSize);

	var _SKBlendMode = __webpack_require__(132);

	var _SKBlendMode2 = _interopRequireDefault(_SKBlendMode);

	var _SKColor = __webpack_require__(11);

	var _SKColor2 = _interopRequireDefault(_SKColor);

	var _SKNode2 = __webpack_require__(133);

	var _SKNode3 = _interopRequireDefault(_SKNode2);

	var _SKTexture = __webpack_require__(134);

	var _SKTexture2 = _interopRequireDefault(_SKTexture);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	//import SKWarpable from './SKWarpable'
	//import SKShader from './SKShader'
	//import SKAttributeValue from './SKAttributeValue'
	//import NSCoder from '../undefined/NSCoder'

	/**
	 * @access private
	 * @type {string}
	 */
	var _defaultVertexShader = '#version 300 es\n  precision mediump float;\n\n  in vec3 position;\n  in vec2 texcoord;\n\n  uniform float screenWidth;\n  uniform float screenHeight;\n\n  //out vec3 v_position;\n  out vec2 v_texcoord;\n\n  void main() {\n    vec3 pos = position;\n    pos.x = (pos.x * 2.0 / screenWidth) - 1.0;\n    pos.y = (pos.y * 2.0 / screenHeight) - 1.0;\n    v_texcoord = texcoord;\n    gl_Position = vec4(pos, 1.0);\n  }\n';

	/**
	 * @access private
	 * @type {string}
	 */
	var _defaultFragmentShader = '#version 300 es\n  precision mediump float;\n\n  uniform sampler2D spriteTexture;\n  uniform float alpha;\n  in vec2 v_texcoord;\n\n  out vec4 outColor;\n\n  void main() {\n    outColor = texture(spriteTexture, v_texcoord);\n    outColor.a *= alpha;\n  }\n';

	/**
	 * A node that draws a rectangular texture, image or color. 
	 * @access public
	 * @extends {SKNode}
	 * @implements {SKWarpable}
	 * @see https://developer.apple.com/reference/spritekit/skspritenode
	 */

	var SKSpriteNode = function (_SKNode) {
	  _inherits(SKSpriteNode, _SKNode);

	  // Initializing a New Sprite

	  /**
	   * Initializes a textured sprite using an image file, optionally adding a normal map to simulate 3D lighting.
	   * @access public
	   * @constructor
	   * @param {string} name - The name of an image file stored in the app bundle.
	   * @param {boolean} generateNormalMap - If true, a normal map is generated from the image texture without applying any filter to it (SKTextureNormalMapFilteringTypeNone). If false, no normal map is generated (matching the behavior of the spriteNodeWithImageNamed: class method).
	   * @desc The normal map is used only when lighting is enabled in the scene. For more information, see Adding Lighting to a Sprite and SKLightNode.
	   * @see https://developer.apple.com/reference/spritekit/skspritenode/1519721-init
	   */
	  function SKSpriteNode() {
	    var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
	    var generateNormalMap = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

	    _classCallCheck(this, SKSpriteNode);

	    // Inspecting Physical Properties

	    /**
	     * The dimensions of the sprite, in points.
	     * @type {CGSize}
	     * @see https://developer.apple.com/reference/spritekit/skspritenode/1519668-size
	     */
	    var _this = _possibleConstructorReturn(this, (SKSpriteNode.__proto__ || Object.getPrototypeOf(SKSpriteNode)).call(this));

	    _this.size = new _CGSize2.default(0, 0);

	    /**
	     * Defines the point in the sprite that corresponds to the nodes position.
	     * @type {CGPoint}
	     * @see https://developer.apple.com/reference/spritekit/skspritenode/1519877-anchorpoint
	     */
	    _this.anchorPoint = new _CGPoint2.default(0.5, 0.5);

	    // Inspecting the Sprites Texture

	    /**
	     * The texture used to draw the sprite.
	     * @type {?SKTexture}
	     * @see https://developer.apple.com/reference/spritekit/skspritenode/1520011-texture
	     */
	    _this._texture = null;

	    /**
	     * A property that defines how the texture is applied to the sprite.
	     * @type {CGRect}
	     * @see https://developer.apple.com/reference/spritekit/skspritenode/1520119-centerrect
	     */
	    _this.centerRect = new _CGRect2.default(new _CGPoint2.default(0, 0), new _CGSize2.default(1, 1));

	    /**
	     * A floating-point value that describes how the color is blended with the sprites texture.
	     * @type {number}
	     * @see https://developer.apple.com/reference/spritekit/skspritenode/1519780-colorblendfactor
	     */
	    _this.colorBlendFactor = 0;

	    // Inspecting Color Properties

	    /**
	     * The sprites color.
	     * @type {SKColor}
	     * @see https://developer.apple.com/reference/spritekit/skspritenode/1519639-color
	     */
	    _this.color = new _SKColor2.default(1.0, 1.0, 1.0, 0.0);

	    // Blending the Sprite with the Framebuffer

	    /**
	     * The blend mode used to draw the sprite into the parents framebuffer.
	     * @type {SKBlendMode}
	     * @see https://developer.apple.com/reference/spritekit/skspritenode/1519931-blendmode
	     */
	    _this.blendMode = _SKBlendMode2.default.alpha;

	    // Adding Lighting to a Sprite

	    /**
	     * A mask that defines how this sprite is lit by light nodes in the scenes.
	     * @type {number}
	     * @see https://developer.apple.com/reference/spritekit/skspritenode/1519637-lightingbitmask
	     */
	    _this.lightingBitMask = 0;

	    /**
	     * A mask that defines which lights add additional shadows to the sprite.
	     * @type {number}
	     * @see https://developer.apple.com/reference/spritekit/skspritenode/1519974-shadowedbitmask
	     */
	    _this.shadowedBitMask = 0;

	    /**
	     * A mask that defines which lights are occluded by this sprite.
	     * @type {number}
	     * @see https://developer.apple.com/reference/spritekit/skspritenode/1520325-shadowcastbitmask
	     */
	    _this.shadowCastBitMask = 0;

	    /**
	     * A texture that specifies the normal map for the sprite.
	     * @type {?SKTexture}
	     * @see https://developer.apple.com/reference/spritekit/skspritenode/1519657-normaltexture
	     */
	    _this.normalTexture = null;

	    // Working with Custom Shaders

	    /**
	     * A property that determines whether the sprite is rendered using a custom shader.
	     * @type {?SKShader}
	     * @see https://developer.apple.com/reference/spritekit/skspritenode/1519714-shader
	     */
	    _this.shader = null;

	    /**
	     * The values of each attribute associated with the node's attached shader.
	     * @type {Map<string, SKAttributeValue>}
	     * @see https://developer.apple.com/reference/spritekit/skspritenode/2715845-attributevalues
	     */
	    _this.attributeValues = new Map();

	    // Instance Properties

	    //this._customPlaygroundQuickLook = new PlaygroundQuickLook()
	    _this._customPlaygroundQuickLook = null;

	    /**
	     * @access private
	     * @type {WebGLProgram}
	     */
	    _this._program = null;

	    _this._vertexArrayObject = null;
	    _this._vertexBuffer = null;
	    _this._indexBuffer = null;

	    _this._loadingImagePromise = null;

	    if (name !== null) {
	      _this.texture = _SKTexture2.default.textureWithImageNamed(name);
	      //if(generateNormalMap){
	      //  this.normalTexture = this.texture.generatingNormalMap()
	      //}
	    }
	    return _this;
	  }

	  /**
	   * Initializes a colored sprite node.
	   * @access public
	   * @param {CGColor} color - The color for the resulting sprite node.
	   * @param {CGSize} size - The size of the sprite node in points.
	   * @returns {SKSpriteNode} -
	   * @desc Although textured nodes are the most common way to use the SKSpriteNode class, you can also create sprite nodes without a texture. The behavior of the class changes when the node lacks a texture:The sprite node that is returned from this method has its texture property set to nil.There is no texture to stretch, so the centerRect parameter is ignored.There is no colorization step; the color property is used as the sprites color.The sprite node's alpha component is used to determine how it is blended into the buffer.Listing 1 shows how to create a red sprite node 100 x 100 points in size.Listing 1 Creating a non-textured sprite nodelet node = SKSpriteNode(color: .red,
	                        size: CGSize(width: 100, height: 100))
	  Creating a non-textured sprite nodelet node = SKSpriteNode(color: .red,
	                        size: CGSize(width: 100, height: 100))
	    * @see https://developer.apple.com/reference/spritekit/skspritenode/1519762-init
	   */


	  _createClass(SKSpriteNode, [{
	    key: 'scaleTo',


	    // Inspecting Physical Properties

	    /**
	     * Scales to sprite node to a specified size. 
	     * @access public
	     * @param {CGSize} size - 
	     * @returns {void}
	     * @desc This method works by setting the sprite node's xScale and yScale to achieve the specified size in its parent's coordinate space. 
	     * @see https://developer.apple.com/reference/spritekit/skspritenode/1645445-scale
	     */
	    value: function scaleTo(size) {}

	    // Working with Custom Shaders

	    /**
	     * Sets an attribute value for an attached shader.
	     * @access public
	     * @param {SKAttributeValue} value - An attribute value object containing the scalar or vector value to set in the attached shader.
	     * @param {string} key - The attribute name.
	     * @returns {void}
	     * @see https://developer.apple.com/reference/spritekit/skspritenode/2715849-setvalue
	     */

	  }, {
	    key: 'setValueForAttribute',
	    value: function setValueForAttribute(value, key) {}

	    /**
	     * The value of a shader attribute.
	     * @access public
	     * @param {string} key - The attribute name.
	     * @returns {?SKAttributeValue} - 
	     * @see https://developer.apple.com/reference/spritekit/skspritenode/2715846-value
	     */

	  }, {
	    key: 'valueForAttributeNamed',
	    value: function valueForAttributeNamed(key) {
	      return null;
	    }

	    // Initializers

	    /**
	     * 
	     * @access public
	     * @param {NSCoder} aDecoder - 
	     * @returns {void}
	     * @see https://developer.apple.com/reference/spritekit/skspritenode/1520399-init
	     */

	  }, {
	    key: 'initCoder',
	    value: function initCoder(aDecoder) {}

	    // Instance Properties
	    /**
	     * A custom playground quick look for this instance.
	     * @type {PlaygroundQuickLook}
	     * @desc 
	     * @see https://developer.apple.com/reference/spritekit/skspritenode/1645797-customplaygroundquicklook
	     */

	  }, {
	    key: '_render',


	    /**
	     * @access private
	     * @param {WebGLRenderingContext} gl -
	     * @param {CGRect} viewRect -
	     * @returns {void}
	     */
	    value: function _render(gl, viewRect) {
	      var p = this.__presentation;
	      if (this.texture === null) {
	        return;
	      }
	      if (this.texture._glTexture === null) {
	        this.texture._createTexture(gl);
	        if (this.texture._glTexture === null) {
	          // the texture is not ready
	          return;
	        }
	        this.size = new _CGSize2.default(this.texture._image.naturalWidth, this.texture._image.naturalHeight);
	        p.size = this.size.copy();
	      }
	      if (this._program === null) {
	        this._program = this._createProgram(gl);
	      }
	      var program = this._program;
	      gl.useProgram(program);

	      if (this._vertexArrayObject === null) {
	        this._createVertexArrayObject(gl, program);
	      }
	      gl.bindVertexArray(this._vertexArrayObject);

	      gl.uniform1f(gl.getUniformLocation(program, 'screenWidth'), viewRect.size.width);
	      gl.uniform1f(gl.getUniformLocation(program, 'screenHeight'), viewRect.size.height);
	      gl.uniform1f(gl.getUniformLocation(program, 'alpha'), p.alpha);

	      var data = this._createVertexData();
	      gl.bindBuffer(gl.ARRAY_BUFFER, this._vertexBuffer);
	      gl.bufferData(gl.ARRAY_BUFFER, data, gl.DYNAMIC_DRAW);

	      gl.uniform1i(gl.getUniformLocation(program, 'spriteTexture'), 0);
	      gl.activeTexture(gl.TEXTURE0);
	      gl.bindTexture(gl.TEXTURE_2D, this.texture._glTexture);
	      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
	      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
	      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
	      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

	      gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_BYTE, 0);
	    }
	  }, {
	    key: '_createProgram',
	    value: function _createProgram(gl) {
	      var program = gl.createProgram();
	      var vsText = _defaultVertexShader;
	      var fsText = _defaultFragmentShader;

	      // initialize vertex shader
	      var vertexShader = gl.createShader(gl.VERTEX_SHADER);
	      gl.shaderSource(vertexShader, vsText);
	      gl.compileShader(vertexShader);
	      if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
	        var info = gl.getShaderInfoLog(vertexShader);
	        throw new Error('SKSpriteNode vertex shader compile error: ' + info);
	      }

	      // initialize fragment shader
	      var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
	      gl.shaderSource(fragmentShader, fsText);
	      gl.compileShader(fragmentShader);
	      if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
	        var _info = gl.getShaderInfoLog(fragmentShader);
	        throw new Error('particle fragment shader compile error: ' + _info);
	      }

	      gl.attachShader(program, vertexShader);
	      gl.attachShader(program, fragmentShader);

	      // link program object
	      gl.linkProgram(program);
	      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
	        var _info2 = gl.getProgramInfoLog(program);
	        throw new Error('program link error: ' + _info2);
	      }

	      //gl.useProgram(program)

	      return program;
	    }

	    /**
	     * @access private
	     * @param {WebGLRenderingContext} gl -
	     * @param {WebGLProgram} program -
	     * @returns {void}
	     */

	  }, {
	    key: '_createVertexArrayObject',
	    value: function _createVertexArrayObject(gl, program) {
	      this._vertexArrayObject = gl.createVertexArray();
	      gl.bindVertexArray(this._vertexArrayObject);

	      this._vertexBuffer = gl.createBuffer();
	      gl.bindBuffer(gl.ARRAY_BUFFER, this._vertexBuffer);

	      var positionLoc = gl.getAttribLocation(program, 'position');
	      gl.bindAttribLocation(program, positionLoc, 'position');
	      gl.enableVertexAttribArray(positionLoc);
	      // idx, size, type, norm, stride, offset
	      gl.vertexAttribPointer(positionLoc, 3, gl.FLOAT, false, 20, 0);

	      var texcoordLoc = gl.getAttribLocation(program, 'texcoord');
	      gl.bindAttribLocation(program, texcoordLoc, 'texcoord');
	      gl.enableVertexAttribArray(texcoordLoc);
	      // idx, size, type, norm, stride, offset
	      gl.vertexAttribPointer(texcoordLoc, 2, gl.FLOAT, false, 20, 12);

	      this._indexBuffer = gl.createBuffer();
	      var indexData = new Uint8Array([0, 3, 2, 0, 1, 3]);
	      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer);
	      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indexData, gl.STATIC_DRAW);
	    }
	  }, {
	    key: '_createVertexData',
	    value: function _createVertexData() {
	      var p = this.__presentation;
	      var w = p.size.width * p._worldXScale;
	      var h = p.size.height * p._worldYScale;
	      var pos = p._worldPosition;
	      var zPos = p._worldZPosition;
	      var left = pos.x - p.anchorPoint.x * w;
	      var right = pos.x + (1.0 - p.anchorPoint.x) * w;
	      var top = pos.y + (1.0 - p.anchorPoint.y) * h;
	      var bottom = pos.y - p.anchorPoint.y * h;
	      var arr = [left, top, zPos, p.centerRect.minX, p.centerRect.minY, right, top, zPos, p.centerRect.maxX, p.centerRect.minY, left, bottom, zPos, p.centerRect.minX, p.centerRect.maxY, right, bottom, zPos, p.centerRect.maxX, p.centerRect.maxY];
	      return new Float32Array(arr);
	    }
	  }, {
	    key: '_copyValue',
	    value: function _copyValue(src) {
	      _get(SKSpriteNode.prototype.__proto__ || Object.getPrototypeOf(SKSpriteNode.prototype), '_copyValue', this).call(this, src);
	      this.size = src.size.copy();
	      this.anchorPoint = src.anchorPoint.copy();
	      this._texture = src._texture ? src._texture : null;
	      this.centerRect = src.centerRect.copy();
	      this.colorBlendFactor = src.colorBlendFactor;
	      this.color = src.color.copy();
	      this.blendMode = src.blendMode;
	      this.lightingBitMask = src.lightingBitMask;
	      this.shadowedBitMask = src.shadowedBitMask;
	      this.shadowCastBitMask = src.shadowCastBitMask;
	      this.normalTexture = src.normalTexture ? src.normalTexture : null;
	      this.shader = src.shader;
	      this.attributeValues = src.attributeValues;
	      this._customerPlaygroundQuickLook = src._customerPlaygroundQuickLook;
	      // this._program
	      // this._vertexArrayObject
	      // this._vertexBuffer
	      // this._indexBuffer
	    }
	  }, {
	    key: 'customPlaygroundQuickLook',
	    get: function get() {
	      return this._customPlaygroundQuickLook;
	    }
	  }, {
	    key: 'texture',
	    get: function get() {
	      return this._texture;
	    },
	    set: function set(newValue) {
	      var _this2 = this;

	      this._texture = newValue;

	      this.size = new _CGSize2.default(0, 0);
	      this._frame = new _CGRect2.default(new _CGPoint2.default(0, 0), this.size);
	      if (this._texture) {
	        this._loadingImagePromise = this._texture._loadingImagePromise.then(function (texture) {
	          if (_this2._texture === texture) {
	            _this2.size = _this2._texture.size();
	            var x = -_this2.size.width * _this2.anchorPoint.x;
	            var y = -_this2.size.height * (1.0 - _this2.anchorPoint.y);
	            _this2._frame = new _CGRect2.default(new _CGPoint2.default(x, y), _this2.size);
	          }
	        });
	      } else {
	        this._loadingImagePromise = null;
	      }
	    }
	  }], [{
	    key: 'nodeWithColorSize',
	    value: function nodeWithColorSize(color, size) {
	      var node = new SKSpriteNode();
	      node.size = size;
	      node.color = color;
	      return node;
	    }

	    /**
	     * Initializes a textured sprite using an image file.
	     * @access public
	     * @param {string} name - The name of an image file stored in the app bundle.
	     * @returns {SKSpriteNode} -
	     * @desc This method creates a new texture object from the image file and assigns that texture to the texture property, the normalTexture properties is set to nil. The size property of the sprite is set to the dimensions of the image. The color property is set to white with an alpha of zero (1.0,1.0,1.0,0.0).
	     * @see https://developer.apple.com/reference/spritekit/skspritenode/1520391-init
	     */

	  }, {
	    key: 'nodeWithImageNamed',
	    value: function nodeWithImageNamed(name) {
	      var node = new SKSpriteNode(name);
	      if (!node._loadingImagePromise) {
	        return null;
	      }
	      var promise = node._loadingImagePromise.then(function () {
	        return Promise.resolve(node);
	      });
	      return promise;
	    }

	    /**
	     * Initializes a textured sprite using an image file, optionally adding a normal map to simulate 3D lighting.
	     * @access public
	     * @param {string} name - The name of an image file stored in the app bundle.
	     * @param {boolean} generateNormalMap - If true, a normal map is generated from the image texture without applying any filter to it (SKTextureNormalMapFilteringTypeNone). If false, no normal map is generated (matching the behavior of the spriteNodeWithImageNamed: class method).
	     * @returns {SKSpriteNode} -
	     * @desc The normal map is used only when lighting is enabled in the scene. For more information, see Adding Lighting to a Sprite and SKLightNode.
	     * @see https://developer.apple.com/reference/spritekit/skspritenode/1519721-init
	     */

	  }, {
	    key: 'nodeWithImageNamedNormalMapped',
	    value: function nodeWithImageNamedNormalMapped(name, generateNormalMap) {}
	  }]);

	  return SKSpriteNode;
	}(_SKNode3.default);

	exports.default = SKSpriteNode;

/***/ },
/* 132 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * The modes that describe how the source and destination pixel colors are used to calculate the new destination color.
	 * @typedef {Object} SKBlendMode
	 * @property {number} alpha - The source and destination colors are blended by multiplying the source alpha value.
	 * @property {number} add - The source and destination colors are added together.
	 * @property {number} subtract - The source color is subtracted from the destination color.
	 * @property {number} multiply - The source color is multiplied by the destination color.
	 * @property {number} multiplyX2 - The source color is multiplied by the destination color and then doubled.
	 * @property {number} screen - The source color is added to the destination color times the inverted source color.
	 * @property {number} replace - The source color replaces the destination color.
	 * @see https://developer.apple.com/reference/spritekit/skblendmode
	 */

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var SKBlendMode = {
	  alpha: 0,
	  add: 1,
	  subtract: 2,
	  multiply: 3,
	  multiplyX2: 4,
	  screen: 5,
	  replace: 6
	};

	exports.default = SKBlendMode;

/***/ },
/* 133 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

	var _NSObject2 = __webpack_require__(2);

	var _NSObject3 = _interopRequireDefault(_NSObject2);

	var _CGPoint = __webpack_require__(7);

	var _CGPoint2 = _interopRequireDefault(_CGPoint);

	var _CGRect = __webpack_require__(8);

	var _CGRect2 = _interopRequireDefault(_CGRect);

	var _CGSize = __webpack_require__(9);

	var _CGSize2 = _interopRequireDefault(_CGSize);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	//import UIFocusItem from '../undefined/UIFocusItem'
	//import SKScene from './SKScene'
	//import SKAction from './SKAction'
	//import SKPhysicsBody from './SKPhysicsBody'
	//import GKPolygonObstacle from '../undefined/GKPolygonObstacle'
	//import GKEntity from '../undefined/GKEntity'
	//import NSMutableDictionary from '../undefined/NSMutableDictionary'
	//import SKConstraint from './SKConstraint'
	//import SKReachConstraints from './SKReachConstraints'
	//import NSCoder from '../undefined/NSCoder'
	//import SKAttributeValue from './SKAttributeValue'


	/**
	 * The SKNode class is the fundamental building block of most SpriteKit content. 
	 * @access public
	 * @extends {NSObject}
	 * @implements {UIFocusItem}
	 * @see https://developer.apple.com/reference/spritekit/sknode
	 */
	var SKNode = function (_NSObject) {
	  _inherits(SKNode, _NSObject);

	  // Initializers

	  /**
	   * 
	   * @access public
	   * @constructor
	   * @see https://developer.apple.com/reference/spritekit/sknode/1483097-init
	   */
	  function SKNode() {
	    _classCallCheck(this, SKNode);

	    // Inspecting the Nodes Position

	    /**
	     * The position of the node in its parent's coordinate system.
	     * @type {CGPoint}
	     * @see https://developer.apple.com/reference/spritekit/sknode/1483101-position
	     */
	    var _this = _possibleConstructorReturn(this, (SKNode.__proto__ || Object.getPrototypeOf(SKNode)).call(this));

	    _this.position = new _CGPoint2.default(0, 0);

	    /**
	     * The height of the node relative to its parent.
	     * @type {number}
	     * @see https://developer.apple.com/reference/spritekit/sknode/1483107-zposition
	     */
	    _this.zPosition = 0.0;

	    _this._frame = new _CGRect2.default(new _CGPoint2.default(0, 0), new _CGSize2.default(0, 0));

	    // Setting a Nodes Scaling and Rotation

	    /**
	     * A scaling factor that multiplies the width of a node and its children.
	     * @type {number}
	     * @see https://developer.apple.com/reference/spritekit/sknode/1483087-xscale
	     */
	    _this.xScale = 1.0;

	    /**
	     * A scaling factor that multiplies the height of a node and its children.
	     * @type {number}
	     * @see https://developer.apple.com/reference/spritekit/sknode/1483046-yscale
	     */
	    _this.yScale = 1.0;

	    /**
	     * The Euler rotation about the z axis (in radians).
	     * @type {number}
	     * @see https://developer.apple.com/reference/spritekit/sknode/1483089-zrotation
	     */
	    _this.zRotation = 0.0;

	    // Inspecting a Nodes Visibility

	    /**
	     * The transparency value applied to the nodes contents.
	     * @type {number}
	     * @see https://developer.apple.com/reference/spritekit/sknode/1483023-alpha
	     */
	    _this.alpha = 1.0;

	    /**
	     * A Boolean value that determines whether a node and its descendants are rendered.
	     * @type {boolean}
	     * @see https://developer.apple.com/reference/spritekit/sknode/1483048-ishidden
	     */
	    _this.isHidden = false;

	    // Determining Whether a Node Supports User Interaction

	    /**
	     * A Boolean value that indicates whether the node receives touch events.
	     * @type {boolean}
	     * @see https://developer.apple.com/reference/spritekit/sknode/1483109-isuserinteractionenabled
	     */
	    _this.isUserInteractionEnabled = false;

	    // Working with Node Trees

	    _this._children = [];
	    _this._parent = null;
	    _this._scene = null;

	    // Naming Nodes

	    /**
	     * The nodes assignable name.
	     * @type {?string}
	     * @see https://developer.apple.com/reference/spritekit/sknode/1483136-name
	     */
	    _this.name = null;

	    // Running Actions

	    /**
	     * A speed modifier applied to all actions executed by a node and its descendants.
	     * @type {number}
	     * @see https://developer.apple.com/reference/spritekit/sknode/1483036-speed
	     */
	    _this.speed = 1.0;

	    /**
	     * A Boolean value that determines whether actions on the node and its descendants are processed.
	     * @type {boolean}
	     * @see https://developer.apple.com/reference/spritekit/sknode/1483113-ispaused
	     */
	    _this.isPaused = false;

	    /**
	     * @access private
	     * @type {Map}
	     */
	    _this._actions = new Map();

	    // Adding Physics to a Node

	    /**
	     * The physics body associated with the node.
	     * @type {?SKPhysicsBody}
	     * @see https://developer.apple.com/reference/spritekit/sknode/1483117-physicsbody
	     */
	    _this.physicsBody = null;

	    // Working with GameplayKit Entities

	    /**
	     * The GameplayKit entity this node represents.
	     * @type {?GKEntity}
	     * @see https://developer.apple.com/reference/spritekit/sknode/1640688-entity
	     */
	    //this.entity = null


	    // Storing Custom Node Data

	    /**
	     * A dictionary containing arbitrary data.
	     * @type {?NSMutableDictionary}
	     * @see https://developer.apple.com/reference/spritekit/sknode/1483121-userdata
	     */
	    _this.userData = null;

	    // Constraining a Nodes Behavior Relative to Other Nodes

	    /**
	     * Specifies the list of constraints to apply to the node.
	     * @type {?SKConstraint[]}
	     * @see https://developer.apple.com/reference/spritekit/sknode/1483124-constraints
	     */
	    _this.constraints = null;

	    /**
	     * Specifies the reach constraints to apply to the node when executing a reach action.
	     * @type {?SKReachConstraints}
	     * @see https://developer.apple.com/reference/spritekit/sknode/1483019-reachconstraints
	     */
	    _this.reachConstraints = null;

	    // Instance Properties

	    /**
	     * 
	     * @type {?Object[]}
	     * @see https://developer.apple.com/reference/spritekit/sknode/1645045-accessibilitychildren
	     */
	    _this.accessibilityChildren = [];

	    /**
	     * 
	     * @type {CGRect}
	     * @see https://developer.apple.com/reference/spritekit/sknode/1645044-accessibilityframe
	     */
	    _this.accessibilityFrame = new _CGRect2.default(new _CGPoint2.default(0, 0), new _CGSize2.default(0, 0));

	    /**
	     * 
	     * @type {?string}
	     * @see https://developer.apple.com/reference/spritekit/sknode/1645041-accessibilityhelp
	     */
	    _this.accessibilityHelp = null;

	    /**
	     * 
	     * @type {?string}
	     * @see https://developer.apple.com/reference/spritekit/sknode/1645039-accessibilitylabel
	     */
	    _this.accessibilityLabel = null;

	    /**
	     * 
	     * @type {?Object}
	     * @see https://developer.apple.com/reference/spritekit/sknode/1645042-accessibilityparent
	     */
	    _this.accessibilityParent = null;

	    /**
	     * 
	     * @type {?string}
	     * @see https://developer.apple.com/reference/spritekit/sknode/1645036-accessibilityrole
	     */
	    _this.accessibilityRole = 'AXImage';

	    /**
	     * 
	     * @type {?string}
	     * @see https://developer.apple.com/reference/spritekit/sknode/1645035-accessibilityroledescription
	     */
	    _this.accessibilityRoleDescription = 'SKNode';

	    /**
	     * 
	     * @type {?string}
	     * @see https://developer.apple.com/reference/spritekit/sknode/1645043-accessibilitysubrole
	     */
	    _this.accessibilitySubrole = null;

	    /**
	     * The values of each attribute associated with the node's attached shader. 
	     * @type {Map<string, SKAttributeValue>}
	     * @see https://developer.apple.com/reference/spritekit/sknode/1644181-attributevalues
	     */
	    _this.attributeValues = new Map();

	    /**
	     * 
	     * @type {boolean}
	     * @see https://developer.apple.com/reference/spritekit/sknode/1645038-isaccessibilityelement
	     */
	    _this.isAccessibilityElement = false;

	    /**
	     * 
	     * @type {boolean}
	     * @see https://developer.apple.com/reference/spritekit/sknode/1645037-isaccessibilityenabled
	     */
	    _this.isAccessibilityEnabled = false;

	    /**
	     * @type {SKNode}
	     * @access private
	     */
	    _this.__presentation = null;

	    _this._isPresentationInstance = false;
	    _this._worldPosition = new _CGPoint2.default(0, 0);
	    _this._worldZPosition = 0;
	    _this._worldXScale = 1;
	    _this._worldYScale = 1;
	    _this._worldZRotation = 0;
	    return _this;
	  }

	  /**
	   * 
	   * @access public
	   * @param {NSCoder} aDecoder - 
	   * @returns {void}
	   * @see https://developer.apple.com/reference/spritekit/sknode/1483142-init
	   */
	  //initWithCoder(aDecoder) {
	  //}


	  // Creating a New Node

	  /**
	   * Creates a new node by loading an archive file from the games main bundle.
	   * @access public
	   * @param {string} filename - The name of the file, without a file extension. The file must be in the apps main bundle and have a .sks filename extension.
	   * @returns {void}
	   * @desc If you call this method on a subclass of the SKScene class and the object in the archive is an SKScene object, the returned object is initialized as if it is a member of the subclass. You use this behavior to create scene layouts in the Xcode Editor and provide custom behaviors in your subclass. 
	   * @see https://developer.apple.com/reference/spritekit/sknode/1483083-init
	   */


	  _createClass(SKNode, [{
	    key: 'calculateAccumulatedFrame',


	    // Inspecting the Nodes Position

	    /**
	     * Calculates a rectangle in the parents coordinate system that contains the content of the node and all of its descendants. 
	     * @access public
	     * @returns {CGRect} - 
	     * @desc The frame takes into the account the cumulative effect of the xScale, yScale, and zRotation properties of each node in the subtree.Listing 1 shows how calculateAccumulatedFrame() can be used display the bounding box of a shape node. The child node, although smaller than its parent, is rotated by 30 so that its bounds extend beyond its parent's bounds. After childNode has been added to parentNode, a further shape node, boundingBoxNode, is created with its size based on the accumulated frame of parentNode.Listing 1 Displaying the accumulated frame of a shape nodelet parentNode = SKShapeNode(rectOf: CGSize(width: 500, height: 500))
	    parentNode.lineWidth = 2
	    parentNode.strokeColor = .blue
	    parentNode.fillColor = .clear
	       
	    let childNode = SKShapeNode(rectOf: CGSize(width: 400, height: 400))
	    childNode.strokeColor = .red
	    childNode.fillColor = .clear
	    childNode.zRotation = -CGFloat.pi / 6 // pi / 6 = 30
	       
	    parentNode.addChild(childNode)
	       
	    let boundingBoxNode = SKShapeNode(rectOf: parentNode.calculateAccumulatedFrame().size)
	    boundingBoxNode.lineWidth = 1
	    boundingBoxNode.strokeColor = .black
	    boundingBoxNode.fillColor = .clear
	    boundingBoxNode.path = boundingBoxNode.path?.copy(dashingWithPhase: 0,
	                                                    lengths: [10,10])
	       
	    parentNode.addChild(boundingBoxNode)
	    Figure 1 shows the result of Listing 1 with parentNode rendered in blue, childNode rendered in red and the boundingBoxNode rendered with a dashed line. Figure 1 Displaying the accumulated frame of a shape nodeDisplaying the accumulated frame of a shape nodelet parentNode = SKShapeNode(rectOf: CGSize(width: 500, height: 500))
	    parentNode.lineWidth = 2
	    parentNode.strokeColor = .blue
	    parentNode.fillColor = .clear
	       
	    let childNode = SKShapeNode(rectOf: CGSize(width: 400, height: 400))
	    childNode.strokeColor = .red
	    childNode.fillColor = .clear
	    childNode.zRotation = -CGFloat.pi / 6 // pi / 6 = 30
	       
	    parentNode.addChild(childNode)
	       
	    let boundingBoxNode = SKShapeNode(rectOf: parentNode.calculateAccumulatedFrame().size)
	    boundingBoxNode.lineWidth = 1
	    boundingBoxNode.strokeColor = .black
	    boundingBoxNode.fillColor = .clear
	    boundingBoxNode.path = boundingBoxNode.path?.copy(dashingWithPhase: 0,
	                                                    lengths: [10,10])
	       
	    parentNode.addChild(boundingBoxNode)
	    Displaying the accumulated frame of a shape node
	     * @see https://developer.apple.com/reference/spritekit/sknode/1483066-calculateaccumulatedframe
	     */
	    value: function calculateAccumulatedFrame() {
	      var r = this._frame.copy();
	      var _iteratorNormalCompletion = true;
	      var _didIteratorError = false;
	      var _iteratorError = undefined;

	      try {
	        for (var _iterator = this._children[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	          var child = _step.value;

	          r = r.union(child.calculateAccumulatedFrame());
	        }
	      } catch (err) {
	        _didIteratorError = true;
	        _iteratorError = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion && _iterator.return) {
	            _iterator.return();
	          }
	        } finally {
	          if (_didIteratorError) {
	            throw _iteratorError;
	          }
	        }
	      }

	      return r;
	    }

	    /**
	     * A rectangle in the parents coordinate system that contains the nodes content, ignoring the nodes children.
	     * @type {CGRect}
	     * @desc The frame is the smallest rectangle that contains the nodes content, taking into account the nodes xScale, yScale, and zRotation properties. Not all nodes contain content of their own.
	     * @see https://developer.apple.com/reference/spritekit/sknode/1483026-frame
	     */

	  }, {
	    key: 'setScale',


	    // Setting a Nodes Scaling and Rotation

	    /**
	     * Sets the xScale and yScale properties of the node.
	     * @access public
	     * @param {number} scale - The new value to use for the nodes xScale and yScale properties.
	     * @returns {void}
	     * @see https://developer.apple.com/reference/spritekit/sknode/1483126-setscale
	     */
	    value: function setScale(scale) {
	      this.xScale = scale;
	      this.yScale = scale;
	    }

	    // Working with Node Trees

	    /**
	     * Adds a node to the end of the receivers list of child nodes.
	     * @access public
	     * @param {SKNode} node - The node to add. The node must not already have a parent.
	     * @returns {void}
	     * @see https://developer.apple.com/reference/spritekit/sknode/1483054-addchild
	     */

	  }, {
	    key: 'addChild',
	    value: function addChild(node) {
	      if (this._children.indexOf(node) >= 0) {
	        return;
	      }
	      node.removeFromParent();
	      this._children.push(node);
	      node._parent = this;
	    }

	    /**
	     * Inserts a child into a specific position in the receivers list of child nodes.
	     * @access public
	     * @param {SKNode} node - The node to add. The node must not already have a parent.
	     * @param {number} index - The position in the array to insert the node.
	     * @returns {void}
	     * @see https://developer.apple.com/reference/spritekit/sknode/1483062-insertchild
	     */

	  }, {
	    key: 'insertChildAt',
	    value: function insertChildAt(node, index) {
	      if (this._children.indexOf(node) >= 0) {
	        return;
	      }
	      node.removeFromParent();
	      this._insertObjectInChildrenAtIndex(node, index);
	      this._parent = this;
	    }

	    /**
	     * Compares the parameter node to the receiving node.
	     * @access public
	     * @param {SKNode} node - The node to compare to the receiving node.
	     * @returns {boolean} - 
	     * @see https://developer.apple.com/reference/spritekit/sknode/1483078-isequal
	     */

	  }, {
	    key: 'isEqualTo',
	    value: function isEqualTo(node) {
	      return false;
	    }

	    /**
	     * Moves the node to a new parent node in the scene. 
	     * @access public
	     * @param {SKNode} parent - An SKNode object to move the receiver to. This node must be in the same scene as the nodes current parent.
	     * @returns {void}
	     * @desc The node maintains its current position in scene coordinates.
	     * @see https://developer.apple.com/reference/spritekit/sknode/1483021-move
	     */

	  }, {
	    key: 'moveToParent',
	    value: function moveToParent(parent) {
	      parent.addChild(this);
	    }

	    /**
	     * Removes the receiving node from its parent.
	     * @access public
	     * @returns {void}
	     * @see https://developer.apple.com/reference/spritekit/sknode/1483119-removefromparent
	     */

	  }, {
	    key: 'removeFromParent',
	    value: function removeFromParent() {
	      var parentNode = this._parent;
	      if (parentNode === null) {
	        return;
	      }
	      var index = parentNode._children.indexOf(this);
	      if (index < 0) {
	        return;
	      }
	      parentNode._removeObjectFromChildrenAtIndex(index);
	    }

	    /**
	     * Removes all of the nodes children.
	     * @access public
	     * @returns {void}
	     * @see https://developer.apple.com/reference/spritekit/sknode/1483040-removeallchildren
	     */

	  }, {
	    key: 'removeAllChildren',
	    value: function removeAllChildren() {
	      var _iteratorNormalCompletion2 = true;
	      var _didIteratorError2 = false;
	      var _iteratorError2 = undefined;

	      try {
	        for (var _iterator2 = this._children[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
	          var child = _step2.value;

	          child.removeFromParent();
	        }
	      } catch (err) {
	        _didIteratorError2 = true;
	        _iteratorError2 = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion2 && _iterator2.return) {
	            _iterator2.return();
	          }
	        } finally {
	          if (_didIteratorError2) {
	            throw _iteratorError2;
	          }
	        }
	      }
	    }

	    /**
	     * Removes a list of children from the receiving node.
	     * @access public
	     * @param {SKNode[]} nodes - An array of SKNode objects that are all children of the receiving node.
	     * @returns {void}
	     * @see https://developer.apple.com/reference/spritekit/sknode/1483091-removechildren
	     */

	  }, {
	    key: 'removeChildrenIn',
	    value: function removeChildrenIn(nodes) {
	      var _iteratorNormalCompletion3 = true;
	      var _didIteratorError3 = false;
	      var _iteratorError3 = undefined;

	      try {
	        for (var _iterator3 = nodes[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
	          var node = _step3.value;

	          if (this._children.indexOf(node) >= 0) {
	            node.removeFromParent();
	          }
	        }
	      } catch (err) {
	        _didIteratorError3 = true;
	        _iteratorError3 = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion3 && _iterator3.return) {
	            _iterator3.return();
	          }
	        } finally {
	          if (_didIteratorError3) {
	            throw _iteratorError3;
	          }
	        }
	      }
	    }

	    /**
	     *
	     * @access private
	     * @param {number} index -
	     * @returns {void}
	     */

	  }, {
	    key: '_removeObjectFromChildrenAtIndex',
	    value: function _removeObjectFromChildrenAtIndex(index) {
	      var arr = this._children.splice(index, 1);
	      if (arr.length === 0) {
	        return;
	      }
	      var obj = arr[0];

	      obj._parent = null;
	    }

	    /**
	     *
	     * @access private
	     * @param {SCNNode} object -
	     * @param {number} index -
	     * @returns {void}
	     */

	  }, {
	    key: '_insertObjectInChildrenAtIndex',
	    value: function _insertObjectInChildrenAtIndex(object, index) {
	      var length = this._children.length;
	      if (index > length) {
	        throw new Error('SKNode.children out of index: ' + index + ' > ' + length);
	      }
	      this._children.splice(index, 0, object);
	    }

	    /**
	     * Returns a Boolean value that indicates whether the node is a descendant of the target node.
	     * @access public
	     * @param {SKNode} parent - An SKNode object to test against.
	     * @returns {boolean} - 
	     * @see https://developer.apple.com/reference/spritekit/sknode/1483111-inparenthierarchy
	     */

	  }, {
	    key: 'inParentHierarchy',
	    value: function inParentHierarchy(parent) {
	      return false;
	    }
	    /**
	     * The nodes children.
	     * @type {SKNode[]}
	     * @desc The objects in this array are all SKNode objects.
	     * @see https://developer.apple.com/reference/spritekit/sknode/1483028-children
	     */

	  }, {
	    key: 'childNodeWithName',


	    // Naming Nodes

	    /**
	     * Searches the children of the receiving node for a node with a specific name.
	     * @access public
	     * @param {string} name - The name to search for. This may be either the literal name of the node or a customized search string. See Searching the Node Tree.
	     * @returns {?SKNode} - 
	     * @desc If more than one child share the same name, the first node discovered is returned.
	     * @see https://developer.apple.com/reference/spritekit/sknode/1483060-childnode
	     */
	    value: function childNodeWithName(name) {
	      var _iteratorNormalCompletion4 = true;
	      var _didIteratorError4 = false;
	      var _iteratorError4 = undefined;

	      try {
	        for (var _iterator4 = this._children[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
	          var child = _step4.value;

	          if (child.name === name) {
	            return child;
	          }
	        }
	      } catch (err) {
	        _didIteratorError4 = true;
	        _iteratorError4 = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion4 && _iterator4.return) {
	            _iterator4.return();
	          }
	        } finally {
	          if (_didIteratorError4) {
	            throw _iteratorError4;
	          }
	        }
	      }

	      return null;
	    }

	    /**
	     * Search the children of the receiving node to perform processing for nodes which share a name.
	     * @access public
	     * @param {string} name - The name to search for. This may be either the literal name of the node or a customized search string. See Searching the Node Tree.
	     * @param {function(arg1: SKNode, arg2: UnsafeMutablePointer<ObjCBool>): void} block - A block to execute on nodes that match the name parameter. The block has the signature (node: SKNode, stop: UnsafeMutablePointer<ObjCBool>).
	     * @returns {void}
	     * @desc This method enumerates the child array in order, searching for nodes whose names match the search parameter. The block is called once for each node that matches the name parameter.The following code shows how you could enumerate through the child nodes of a scene with a name containing the string yellow. Each matching node is hidden until the enumeration finds a node that also contains the string triangle. When this node is reached, stop is set to true and the processing stops.Listing 1 Enumerating child nodesscene.enumerateChildNodes(withName: "*yellow*") {
	      (node, stop) in
	      
	      node.run(SKAction.hide())
	      
	      if let name = node.name, name.contains("triangle") {
	          stop.initialize(to: true)
	      }
	    }
	    You can also search by class name using enumerateChildNodes(withName:using:). However, for custom classes, you need to specify the fully annotated class name (i.e. the project name followed by the class name). The following code shows a custom class, SpaceshipNode, based on SKSpriteNode, and created in a project named SpaceGame. The first search fails to return an instance of  SpaceshipNode added as a child of parentNode:Listing 2 Enumerating child nodesclass SpaceshipNode: SKSpriteNode {
	    }
	       
	    let parentNode = SKNode()
	    let childNode = SpaceshipNode()
	    parentNode.addChild(childNode)
	       
	    parentNode.enumerateChildNodes(withName: "SpaceshipNode") {
	      node, _ in
	      // Unannotated name, returns no results 
	    }
	       
	    parentNode.enumerateChildNodes(withName: "SpaceGame.SpaceshipNode") {
	      node, _ in
	      // Annotated name, successfully returns `childNode` 
	    }
	       
	    parentNode.enumerateChildNodes(withName: "SKSpriteNode") {
	      node, _ in
	      // Superclass name, successfully returns `childNode` 
	    }
	    Enumerating child nodesscene.enumerateChildNodes(withName: "*yellow*") {
	      (node, stop) in
	      
	      node.run(SKAction.hide())
	      
	      if let name = node.name, name.contains("triangle") {
	          stop.initialize(to: true)
	      }
	    }
	    Enumerating child nodesclass SpaceshipNode: SKSpriteNode {
	    }
	       
	    let parentNode = SKNode()
	    let childNode = SpaceshipNode()
	    parentNode.addChild(childNode)
	       
	    parentNode.enumerateChildNodes(withName: "SpaceshipNode") {
	      node, _ in
	      // Unannotated name, returns no results 
	    }
	       
	    parentNode.enumerateChildNodes(withName: "SpaceGame.SpaceshipNode") {
	      node, _ in
	      // Annotated name, successfully returns `childNode` 
	    }
	       
	    parentNode.enumerateChildNodes(withName: "SKSpriteNode") {
	      node, _ in
	      // Superclass name, successfully returns `childNode` 
	    }
	      * @see https://developer.apple.com/reference/spritekit/sknode/1483024-enumeratechildnodes
	     */

	  }, {
	    key: 'enumerateChildNodesWithNameUsing',
	    value: function enumerateChildNodesWithNameUsing(name, block) {}

	    // Running Actions

	    /**
	     * Adds an action to the list of actions executed by the node.
	     * @access public
	     * @param {SKAction} action - The action to perform.
	     * @returns {void}
	     * @desc The new action is processed the next time the scenes animation loop is processed.
	     * @see https://developer.apple.com/reference/spritekit/sknode/1483093-run
	     */

	  }, {
	    key: 'run',
	    value: function run(action) {
	      this.runWithKey(action, Symbol());
	    }

	    /**
	     * Adds an action to the list of actions executed by the node.
	     * @access public
	     * @param {SKAction} action - The action to perform.
	     * @param {function(): void} block - A completion block called when the action completes.
	     * @returns {void}
	     * @see https://developer.apple.com/reference/spritekit/sknode/1483103-run
	     */

	  }, {
	    key: 'runCompletion',
	    value: function runCompletion(action, block) {
	      this._runActionForKeyCompletionHandler(action, Symbol(), block);
	    }

	    /**
	     * Adds an identifiable action to the list of actions executed by the node.
	     * @access public
	     * @param {SKAction} action - The action to perform.
	     * @param {string} key - A unique key used to identify the action.
	     * @returns {void}
	     * @desc This method is identical to run(_:), but the action is stored so that it can be retrieved later. If an action using the same key is already running, it is removed before the new action is added.
	     * @see https://developer.apple.com/reference/spritekit/sknode/1483042-run
	     */

	  }, {
	    key: 'runWithKey',
	    value: function runWithKey(action, key) {
	      this._runActionForKeyCompletionHandler(action, key, null);
	    }
	  }, {
	    key: '_runActionForKeyCompletionHandler',
	    value: function _runActionForKeyCompletionHandler(action, key, block) {
	      if (typeof key === 'undefined' || key === null) {
	        key = Symbol();
	      }
	      var act = action.copy();
	      // FIXME: use current frame time
	      act._actionStartTime = Date.now() * 0.001;
	      act._completionHandler = block;
	      this._actions.set(key, act);
	    }

	    /**
	     * Returns an action associated with a specific key.
	     * @access public
	     * @param {string} key - A string that uniquely identifies an action.
	     * @returns {?SKAction} - 
	     * @see https://developer.apple.com/reference/spritekit/sknode/1483138-action
	     */

	  }, {
	    key: 'actionForKey',
	    value: function actionForKey(key) {
	      return this._actions.get(key);
	    }

	    /**
	     * Returns a Boolean value that indicates whether the node is executing actions.
	     * @access public
	     * @returns {boolean} - 
	     * @see https://developer.apple.com/reference/spritekit/sknode/1483081-hasactions
	     */

	  }, {
	    key: 'hasActions',
	    value: function hasActions() {
	      return this._actions.size > 0;
	    }

	    /**
	     * Ends and removes all actions from the node.
	     * @access public
	     * @returns {void}
	     * @desc When an action is removed from the node, any remaining animation the action would perform is skipped; however, previous changes are not reverted. It is possible that an action may make a final change to the scene when removed; if so, it is documented for the specific action in SKAction.
	     * @see https://developer.apple.com/reference/spritekit/sknode/1483030-removeallactions
	     */

	  }, {
	    key: 'removeAllActions',
	    value: function removeAllActions() {
	      // TODO: stop actions
	      this._actions.clear();
	    }

	    /**
	     * Removes an action associated with a specific key.
	     * @access public
	     * @param {string} key - A string that uniquely identifies an action.
	     * @returns {void}
	     * @desc If an action is found that matches the key, it is removed from the node.
	     * @see https://developer.apple.com/reference/spritekit/sknode/1483076-removeaction
	     */

	  }, {
	    key: 'removeActionForKey',
	    value: function removeActionForKey(key) {
	      // TODO: stop action
	      this._actions.delete(key);
	    }

	    // Converting to and from the Nodes Coordinate System

	    /**
	     * Converts a point from the coordinate system of another node in the node tree to the coordinate system of this node.
	     * @access public
	     * @param {CGPoint} point - A point in the other nodes coordinate system.
	     * @param {SKNode} node - Another node in the same node tree as this node.
	     * @returns {CGPoint} - 
	     * @see https://developer.apple.com/reference/spritekit/sknode/1483058-convert
	     */

	  }, {
	    key: 'convertFrom',
	    value: function convertFrom(point, node) {
	      return null;
	    }

	    /**
	     * Converts a point in this nodes coordinate system to the coordinate system of another node in the node tree.
	     * @access public
	     * @param {CGPoint} point - A point in this nodes coordinate system.
	     * @param {SKNode} node - Another node in the same node tree as this node.
	     * @returns {CGPoint} - 
	     * @see https://developer.apple.com/reference/spritekit/sknode/1483056-convert
	     */

	  }, {
	    key: 'convertTo',
	    value: function convertTo(point, node) {
	      return null;
	    }

	    // Determining If a Point Lies in a Node

	    /**
	     * Returns a Boolean value that indicates whether a point lies inside the parents coordinate system.
	     * @access public
	     * @param {CGPoint} p - A CGPoint to test against.
	     * @returns {boolean} - 
	     * @see https://developer.apple.com/reference/spritekit/sknode/1483044-contains
	     */

	  }, {
	    key: 'contains',
	    value: function contains(p) {
	      return false;
	    }

	    /**
	     * Returns the deepest visible descendant that intersects a point.
	     * @access public
	     * @param {CGPoint} p - A point in the nodes coordinate system.
	     * @returns {SKNode} - 
	     * @desc A point is considered to be in a node if it lies inside the rectangle returned by the calculateAccumulatedFrame() method.
	     * @see https://developer.apple.com/reference/spritekit/sknode/1483099-atpoint
	     */

	  }, {
	    key: 'atPoint',
	    value: function atPoint(p) {
	      return null;
	    }

	    /**
	     * Returns an array of all visible descendants that intersect a point.
	     * @access public
	     * @param {CGPoint} p - A point in the nodes coordinate system.
	     * @returns {SKNode[]} - 
	     * @desc A point is considered to be in a node if it lies inside the rectangle returned by the calculateAccumulatedFrame() method.
	     * @see https://developer.apple.com/reference/spritekit/sknode/1483072-nodes
	     */

	  }, {
	    key: 'nodesAt',
	    value: function nodesAt(p) {
	      return null;
	    }

	    // Performing Node Intersections

	    /**
	     * Returns a Boolean value that indicates whether this node intersects the specified node.
	     * @access public
	     * @param {SKNode} node - Another node in the same node tree.
	     * @returns {boolean} - 
	     * @desc The two nodes are considered to intersect if their frames intersect. The children of both nodes are ignored in this test.
	     * @see https://developer.apple.com/reference/spritekit/sknode/1483140-intersects
	     */

	  }, {
	    key: 'intersects',
	    value: function intersects(node) {
	      return false;
	    }

	    // Creating GameplayKit Obstacles from a Set of Nodes

	    /**
	     * Converts each node into an obstacle by transforming its bounds into the scenes coordinate system.
	     * @access public
	     * @param {SKNode[]} nodes - An array of SKNode objects.
	     * @returns {GKPolygonObstacle[]} - 
	     * @desc Use the array of obstacles to create an obstacle graph (GKObstacleGraph) in GameplayKit. See GameplayKit and GameplayKit Programming Guide.
	     * @see https://developer.apple.com/reference/spritekit/sknode/1483132-obstacles
	     */

	  }, {
	    key: 'accessibilityHitTest',


	    // Instance Methods

	    /**
	     * 
	     * @access public
	     * @param {CGPoint} point - 
	     * @returns {?Object} - 
	     * @see https://developer.apple.com/reference/spritekit/sknode/1645040-accessibilityhittest
	     */
	    value: function accessibilityHitTest(point) {
	      return null;
	    }

	    /**
	     * Sets an attribute value for an attached shader
	     * @deprecated
	     * @access public
	     * @param {SKAttributeValue} value - An attribute value object containing the scalar or vector value to set in the attached shader. 
	     * @param {string} key - The attribute name.
	     * @returns {void}
	     * @see https://developer.apple.com/reference/spritekit/sknode/1644180-setvalue
	     */

	  }, {
	    key: 'setValueForAttribute',
	    value: function setValueForAttribute(value, key) {
	      this.attributeValues.set(key, value);
	    }

	    /**
	     * The value of a shader attribute.
	     * @deprecated
	     * @access public
	     * @param {string} key - The attribute name.
	     * @returns {?SKAttributeValue} - 
	     * @see https://developer.apple.com/reference/spritekit/sknode/1644182-value
	     */

	  }, {
	    key: 'valueForAttributeNamed',
	    value: function valueForAttributeNamed(key) {
	      return this.attributeValues.get(key);
	    }

	    /**
	     * @type {SKNode}
	     */

	  }, {
	    key: 'copy',


	    /**
	     *
	     * @access public
	     * @returns {SKNode} -
	     */
	    value: function copy() {
	      var node = _get(SKNode.prototype.__proto__ || Object.getPrototypeOf(SKNode.prototype), 'copy', this).call(this);
	      node._copyValue(this);
	      return node;
	    }
	  }, {
	    key: '_copyValue',
	    value: function _copyValue(src) {
	      this.position = src.position.copy();
	      this.zPosition = src.zPosition;
	      this._frame = src._frame;
	      this.xScale = src.xScale;
	      this.yScale = src.yScale;
	      this.zRotation = src.zRotation;
	      this.alpha = src.alpha;
	      this.isHidden = src.isHidden;
	      this.isUserInteractionEnabled = src.isUserInteractionEnabled;
	      this.name = src.name;
	      this.speed = src.speed;
	      this.isPaused = src.isPaused;
	      this._actions = new Map(src._actions);
	      this.physicsBody = src.physicsBody;
	      this.userData = src.userData;
	      this.constraints = src.constraints;
	      this.reachConstraints = src.reachConstraints;
	      this.accessibilityChildren = src.accessibilityChildren;
	      this.accessibilityFrame = src.accessibilityFrame.copy();
	      this.accessibilityHelp = src.accessibilityHelp;
	      this.accessibilityLabel = src.accessibilityLabel;
	      this.accessibilityParent = src.accessibilityParent;
	      this.accessibilityRole = src.accessibilityRole;
	      this.accessibilityRoleDescription = src.accessibilityRoleDescription;
	      this.accessibilitySubrole = src.accessibilitySubrole;
	      this.attributeValues = new Map(src.attributeValues);
	      this.isAccessibilityElement = src.isAccessibilityElement;
	      this.isAccessibilityEnabled = src.isAccessibilityEnabled;
	    }

	    /**
	     * @access private
	     * @param {WebGLRenderingContext} gl -
	     * @returns {void}
	     */

	  }, {
	    key: '_render',
	    value: function _render(gl) {
	      // nothing to draw
	    }
	  }, {
	    key: '_copyTransformToPresentation',
	    value: function _copyTransformToPresentation() {
	      if (this.__presentation === null) {
	        return;
	      }
	      var p = this.__presentation;
	      p.position = this.position;
	      p.zPosition = this.zPosition;
	      p.xScale = this.xScale;
	      p.yScale = this.yScale;
	      p.zRotation = this.zRotation;
	    }
	  }, {
	    key: '_updateWorldTransform',
	    value: function _updateWorldTransform() {
	      var p = null;
	      var pz = 0;
	      if (this._parent === null) {
	        p = new _CGPoint2.default(0, 0);
	      } else {
	        p = this._parent._worldPosition;
	        pz = this._parent._worldZPosition;
	      }
	      this._worldPosition = this.position.add(p);
	      this._worldZPosition = this.zPosition + pz;

	      if (this._presentation) {
	        var pp = null;
	        var ppz = 0;
	        var pxScale = 1;
	        var pyScale = 1;
	        if (this._parent === null) {
	          pp = new _CGPoint2.default(0, 0);
	        } else if (this._parent._presentation === null) {
	          pp = this._parent._worldPosition;
	          ppz = this._parent._worldZPosition;
	          pxScale = this._parent._worldXScale;
	          pyScale = this._parent._worldYScale;
	        } else {
	          pp = this._parent._presentation._worldPosition;
	          ppz = this._parent._presentation._worldZPosition;
	          pxScale = this._parent._presentation._worldXScale;
	          pyScale = this._parent._presentation._worldYScale;
	        }
	        //this._presentation._worldPosition = this._presentation.position.add(pp)
	        this._presentation._worldPosition.x = pp.x + this._presentation.position.x * pxScale;
	        this._presentation._worldPosition.y = pp.y + this._presentation.position.y * pyScale;
	        this._presentation._worldZPosition = this._presentation.zPosition + ppz;
	        this._presentation._worldXScale = this._presentation.xScale * pxScale;
	        this._presentation._worldYScale = this._presentation.yScale * pyScale;
	      }

	      var _iteratorNormalCompletion5 = true;
	      var _didIteratorError5 = false;
	      var _iteratorError5 = undefined;

	      try {
	        for (var _iterator5 = this._children[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
	          var child = _step5.value;

	          child._updateWorldTransform();
	        }
	      } catch (err) {
	        _didIteratorError5 = true;
	        _iteratorError5 = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion5 && _iterator5.return) {
	            _iterator5.return();
	          }
	        } finally {
	          if (_didIteratorError5) {
	            throw _iteratorError5;
	          }
	        }
	      }
	    }
	  }, {
	    key: 'frame',
	    get: function get() {
	      return this._frame;
	    }
	  }, {
	    key: 'children',
	    get: function get() {
	      return this._children.slice(0);
	    }
	    /**
	     * The nodes parent node.
	     * @type {?SKNode}
	     * @desc If the node is not in a node tree, the value is nil.
	     * @see https://developer.apple.com/reference/spritekit/sknode/1483080-parent
	     */

	  }, {
	    key: 'parent',
	    get: function get() {
	      return this._parent;
	    }

	    /**
	     * The scene node that contains the node.
	     * @type {?SKScene}
	     * @desc If the node is not embedded in a scene, the value is nil.
	     * @see https://developer.apple.com/reference/spritekit/sknode/1483064-scene
	     */

	  }, {
	    key: 'scene',
	    get: function get() {
	      return this._scene;
	    }
	  }, {
	    key: '_presentation',
	    get: function get() {
	      return this.__presentation;
	    }
	  }], [{
	    key: 'nodeWithFileNamed',
	    value: function nodeWithFileNamed(filename) {
	      var node = new SKNode();
	      return node;
	    }
	  }, {
	    key: 'obstaclesFromNodeBounds',
	    value: function obstaclesFromNodeBounds(nodes) {
	      return null;
	    }

	    /**
	     * Converts each node into an obstacle by transforming the nodes physics body shape into the scenes coordinate system.
	     * @access public
	     * @param {SKNode[]} nodes - An array of SKNode objects.
	     * @returns {GKPolygonObstacle[]} - 
	     * @desc Use the array of obstacles to create an obstacle graph (GKObstacleGraph) in GameplayKit. See GameplayKit and GameplayKit Programming Guide.
	     * @see https://developer.apple.com/reference/spritekit/sknode/1483085-obstacles
	     */

	  }, {
	    key: 'obstaclesFromNodePhysicsBodies',
	    value: function obstaclesFromNodePhysicsBodies(nodes) {
	      return null;
	    }

	    /**
	     * Converts each node into an obstacle by first transforming the nodes texture into a physics shape and then converting that shape into the scenes coordinate system.
	     * @access public
	     * @param {SKNode[]} sprites - An array of SKNode objects.
	     * @param {number} accuracy - A floating point value between 0.001 and 1.0, inclusive. Higher values create a more precise (but more complex) representation of the obstacle.
	     * @returns {GKPolygonObstacle[]} - 
	     * @desc Use the array of obstacles to create an obstacle graph (GKObstacleGraph) in GameplayKit. See GameplayKit and GameplayKit Programming Guide.
	     * @see https://developer.apple.com/reference/spritekit/sknode/1483134-obstacles
	     */

	  }, {
	    key: 'obstaclesFromSpriteTextures',
	    value: function obstaclesFromSpriteTextures(sprites, accuracy) {
	      return null;
	    }
	  }]);

	  return SKNode;
	}(_NSObject3.default);

	exports.default = SKNode;

/***/ },
/* 134 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _NSObject2 = __webpack_require__(2);

	var _NSObject3 = _interopRequireDefault(_NSObject2);

	var _CGRect = __webpack_require__(8);

	var _CGRect2 = _interopRequireDefault(_CGRect);

	var _CGSize = __webpack_require__(9);

	var _CGSize2 = _interopRequireDefault(_CGSize);

	var _SKTextureFilteringMode = __webpack_require__(135);

	var _SKTextureFilteringMode2 = _interopRequireDefault(_SKTextureFilteringMode);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	//import GKNoiseMap from '../undefined/GKNoiseMap'


	/**
	 * A representation of an image for use in SpriteKit.
	 * @access public
	 * @extends {NSObject}
	 * @see https://developer.apple.com/reference/spritekit/sktexture
	 */
	var SKTexture = function (_NSObject) {
	  _inherits(SKTexture, _NSObject);

	  /**
	   * constructor
	   * @access public
	   * @constructor
	   */
	  function SKTexture() {
	    _classCallCheck(this, SKTexture);

	    // Inspecting a Textures Properties

	    /**
	     * The filtering mode used when the size of a sprite drawn with the texture is not drawn at the textures native size.
	     * @type {SKTextureFilteringMode}
	     * @see https://developer.apple.com/reference/spritekit/sktexture/1519659-filteringmode
	     */
	    var _this = _possibleConstructorReturn(this, (SKTexture.__proto__ || Object.getPrototypeOf(SKTexture)).call(this));

	    _this.filteringMode = _SKTextureFilteringMode2.default.linear;

	    /**
	     * A Boolean value that indicates whether the texture attempts to generate mipmaps.
	     * @type {boolean}
	     * @see https://developer.apple.com/reference/spritekit/sktexture/1519960-usesmipmaps
	     */
	    _this.usesMipmaps = false;

	    // Instance Properties

	    _this._customPlaygroundQuickLook = null;

	    _this._image = null;
	    _this._glTexture = null;

	    _this._loadingImagePromise = null;
	    return _this;
	  }

	  // Creating New Textures from Images

	  /**
	   * Create a new texture object from an image file stored in the app bundle.
	   * @access public
	   * @param {string} name - The name of the image file.
	   * @returns {void}
	   * @desc The new texture object is initialized with the name of the image file and then control returns immediately to your game. Sprite Kit loads and prepares the texture data when it is needed by your game.When loading the texture data, Sprite Kit searches the app bundle for an image file with the specified filename. If a matching image file cannot be found, Sprite Kit searches for the texture in any texture atlases stored in the app bundle. If the specified image does not exist anywhere in the bundle, Sprite Kit creates a placeholder texture image.
	   * @see https://developer.apple.com/reference/spritekit/sktexture/1520086-init
	   */


	  _createClass(SKTexture, [{
	    key: 'applying',


	    /**
	     * Creates a new texture by applying a Core Image filter to an existing texture.
	     * @access public
	     * @param {CIFilter} filter - A Core Image filter that requires a single inputImage parameter and produces an outputImage parameter.
	     * @returns {SKTexture} - 
	     * @desc The image data is copied before control is returned to your game.
	     * @see https://developer.apple.com/reference/spritekit/sktexture/1520388-applying
	     */
	    value: function applying(filter) {
	      return null;
	    }

	    /**
	     * Returns the textures image data as a Quartz 2D image.
	     * @access public
	     * @returns {CGImage} - 
	     * @see https://developer.apple.com/reference/spritekit/sktexture/1519755-cgimage
	     */

	  }, {
	    key: 'cgImage',
	    value: function cgImage() {
	      return this._image;
	    }

	    // Creating Textures from Raw Pixel Data

	    /**
	     * Creates a new texture from raw pixel data.
	     * @access public
	     * @param {Data} pixelData - An NSData object that holds the bitmap data. The pixels must be 32 bpp, 8bpc (unsigned integer) RGBA pixel data. The color components should have been already multiplied by the alpha value.
	     * @param {CGSize} size - The size of the new texture in points.
	     * @returns {void}
	     * @desc The image data is copied before control is returned to your game.Creating textures from raw pixel data is useful if you have a CPU based routine for creating imagery. The following code shows how you can use init(data:size:) to create a texture containing random colors and a solid alpha. The bytes array is populated by iterating over the total number of pixels and adding four UInt8 values for the red, green, blue, and alpha channels.let width = 128
	    let height = 128
	    let bytes = stride(from: 0, to: width * height, by: 1).flatMap {
	      _ in
	      return [
	          UInt8(drand48() * 255), // red
	          UInt8(drand48() * 255), // green
	          UInt8(drand48() * 255), // blue
	          UInt8(255)              // alpha
	      ]
	    }
	    let data = Data(bytes: bytes)
	    let texture = SKTexture(data: data,
	                          size: CGSize(width: width, height: height))
	    let width = 128
	    let height = 128
	    let bytes = stride(from: 0, to: width * height, by: 1).flatMap {
	      _ in
	      return [
	          UInt8(drand48() * 255), // red
	          UInt8(drand48() * 255), // green
	          UInt8(drand48() * 255), // blue
	          UInt8(255)              // alpha
	      ]
	    }
	    let data = Data(bytes: bytes)
	    let texture = SKTexture(data: data,
	                          size: CGSize(width: width, height: height))
	      * @see https://developer.apple.com/reference/spritekit/sktexture/1519962-init
	     */

	  }, {
	    key: 'generatingNormalMap',


	    // Creating Normal Map Textures

	    /**
	     * Creates a normal map texture by analyzing the contents of an existing texture.
	     * @access public
	     * @returns {SKTexture} - 
	     * @see https://developer.apple.com/reference/spritekit/sktexture/1519687-generatingnormalmap
	     */
	    value: function generatingNormalMap() {
	      return null;
	    }

	    /**
	     * Creates a normal map texture by analyzing the contents of an existing texture.
	     * @access public
	     * @param {number} smoothness - A number between 0.0 and 1.0 indicating how much the texture should be smoothed before the normal map is generated. A value of 0.0 means that the texture is not smoothed at all before being processed.
	     * @param {number} contrast - A value used to magnify the effect of the generated normal map. A value of 1.0 indicates no magnification is applied.
	     * @returns {SKTexture} - 
	     * @see https://developer.apple.com/reference/spritekit/sktexture/1520441-generatingnormalmap
	     */

	  }, {
	    key: 'generatingNormalMapWithSmoothness',
	    value: function generatingNormalMapWithSmoothness(smoothness, contrast) {
	      return null;
	    }

	    // Creating Noise Textures

	    /**
	     * Creates a new texture whose contents are procedurally generated directional noise data.
	     * @access public
	     * @param {number} smoothness - A value that indicates how similar neighboring texels will be in the resulting texture. The value should be between 0.0 and 1.0. A value of 1.0 generates a smooth surface.
	     * @param {CGSize} size - The size of the new texture in points.
	     * @returns {void}
	     * @desc The noise texture is tileable with itself. The RGB values stored in the texture can be used as directional (XYZ) data. The alpha values are also randomized and can be used as magnitude data, if desired.The following code creates three sprite nodes with textures generated by init(vectorNoiseWithSmoothness:size:) with smoothness values of 0.0, 0.5 and 1.0.let columWidth = scene.size.width / 3
	    for i in 0...2 {
	      
	      let size = CGSize(width: ceil(columWidth),
	                        height: 0.5 * scene.size.height)
	      
	      let smoothness = CGFloat(i) / 2
	      
	      let vectorTexture = SKTexture(vectorNoiseWithSmoothness: smoothness,
	                                    size: size)
	      
	      let sprite = SKSpriteNode(texture: vectorTexture, size: size)
	      
	      sprite.position = CGPoint(x: CGFloat(i) * columWidth + (columWidth / 2),
	                                y: 
	    scene.size.height / 2)
	       
	      scene.addChild(sprite)
	    }
	    let columWidth = scene.size.width / 3
	    for i in 0...2 {
	      
	      let size = CGSize(width: ceil(columWidth),
	                        height: 0.5 * scene.size.height)
	      
	      let smoothness = CGFloat(i) / 2
	      
	      let vectorTexture = SKTexture(vectorNoiseWithSmoothness: smoothness,
	                                    size: size)
	      
	      let sprite = SKSpriteNode(texture: vectorTexture, size: size)
	      
	      sprite.position = CGPoint(x: CGFloat(i) * columWidth + (columWidth / 2),
	                                y: 
	    scene.size.height / 2)
	       
	      scene.addChild(sprite)
	    }
	      * @see https://developer.apple.com/reference/spritekit/sktexture/1520393-init
	     */

	  }, {
	    key: 'size',


	    // Inspecting a Textures Properties

	    /**
	     * The size of the texture.
	     * @access public
	     * @returns {CGSize} - 
	     * @desc If the texture was created using an image file and that image file hasnt been loaded, calling this method forces the texture data to be loaded from the file.
	     * @see https://developer.apple.com/reference/spritekit/sktexture/1519772-size
	     */
	    value: function size() {
	      if (this._image === null) {
	        return new _CGSize2.default(0, 0);
	      }
	      return new _CGSize2.default(this._image.naturalWidth, this._image.naturalHeight);
	    }

	    /**
	     * A rectangle that defines the portion of the texture used to render its image.
	     * @access public
	     * @returns {CGRect} - 
	     * @desc The default value is a rectangle that covers the entire texture (0,0) - (1,1). You cannot set this value directly; to use only a portion of a texture, use the init(rect:in:) method to create a new texture.
	     * @see https://developer.apple.com/reference/spritekit/sktexture/1519707-texturerect
	     */

	  }, {
	    key: 'textureRect',
	    value: function textureRect() {
	      return null;
	    }

	    // Preloading the Texture Data

	    /**
	     * Load the texture data into memory, calling a completion handler after the task completes.
	     * @access public
	     * @param {function(): void} completionHandler - A block called after the texture data is loaded.
	     * @returns {void}
	     * @desc SpriteKit creates a background task to load the texture data from the associated file, then returns control to your game. After the texture data is loaded, your completion handler is called. Typically, you use this method when you want to guarantee that a particular texture is in memory before accessing it.If you need to preload multiple textures at once, use the preload(_:withCompletionHandler:) method instead.
	     * @see https://developer.apple.com/reference/spritekit/sktexture/1520172-preload
	     */

	  }, {
	    key: 'preload',
	    value: function preload(completionHandler) {}

	    /**
	     * Load the texture data of multiple textures into memory.
	     * @access public
	     * @param {SKTexture[]} textures - An array of SKTexture objects.
	     * @param {function(): void} completionHandler - A block called after all of the textures are loaded.
	     * @returns {void}
	     * @desc SpriteKit creates a background task that loads the texture data for all of the textures in the array, then returns control to your game. Your completion handler is called after all of the textures are loaded.
	     * @see https://developer.apple.com/reference/spritekit/sktexture/1519817-preload
	     */

	  }, {
	    key: '_loadImage',
	    value: function _loadImage(path) {
	      var _this2 = this;

	      var image = new Image();
	      this._loadingImagePromise = new Promise(function (resolve, reject) {
	        if (path.indexOf('file:///') === 0) {
	          var paths = path.slice(8).split('/');
	          var pathCount = 1;
	          var _path = paths.slice(-pathCount).join('/');
	          console.info('image loading: ' + _path);
	          image.onload = function () {
	            console.info('image ' + _path + ' onload');
	            _this2._image = image;
	            resolve(_this2);
	          };
	          image.onerror = function () {
	            pathCount += 1;
	            if (pathCount > paths.length) {
	              console.error('image ' + path + ' load error.');
	              reject(_this2);
	            } else {
	              // retry
	              console.info('image ' + _path + ' load error.');
	              _path = paths.slice(-pathCount).join('/');
	              console.info('try ' + _path);
	              image.src = _path;
	            }
	          };
	        } else {
	          console.info('image loading: ' + path);
	          image.onload = function () {
	            _this2._image = image;
	            resolve(_this2);
	          };
	          image.onerror = function () {
	            console.info('image ' + path + ' load error.');
	            reject(_this2);
	          };
	          image.src = path;
	        }
	      });
	    }
	  }, {
	    key: '_createTexture',
	    value: function _createTexture(gl) {
	      if (this._image === null) {
	        return;
	      }
	      var texture = gl.createTexture();

	      var canvas = document.createElement('canvas');
	      canvas.width = this._image.naturalWidth;
	      canvas.height = this._image.naturalHeight;
	      canvas.getContext('2d').drawImage(this._image, 0, 0);

	      gl.bindTexture(gl.TEXTURE_2D, texture);
	      // texImage2D(target, level, internalformat, width, height, border, format, type, source)
	      // Safari complains that 'source' is not ArrayBufferView type, but WebGL2 should accept HTMLCanvasElement.
	      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this._image.width, this._image.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, canvas);
	      gl.generateMipmap(gl.TEXTURE_2D);
	      gl.bindTexture(gl.TEXTURE_2D, null);

	      this._glTexture = texture;
	    }
	  }, {
	    key: 'customPlaygroundQuickLook',


	    // Instance Properties
	    /**
	     * 
	     * @type {PlaygroundQuickLook}
	     * @desc 
	     * @see https://developer.apple.com/reference/spritekit/sktexture/1645801-customplaygroundquicklook
	     */
	    get: function get() {
	      return this._customPlaygroundQuickLook;
	    }
	  }], [{
	    key: 'textureWithImageNamed',
	    value: function textureWithImageNamed(name) {
	      console.log('SKTexture image name: ' + name);
	      var texture = new SKTexture();
	      texture._loadImage(name);
	      return texture;
	    }

	    /**
	     * Create a new texture object from an image object.
	     * @access public
	     * @param {Image} image - An image.
	     * @returns {void}
	     * @desc The image data is copied before control is returned to your game.
	     * @see https://developer.apple.com/reference/spritekit/sktexture/1520136-init
	     */

	  }, {
	    key: 'textureWithImage',
	    value: function textureWithImage(image) {
	      var texture = new SKTexture();
	      texture._image = image;
	      this._loadingImagePromise = Promise.resolve(this);
	      return texture;
	    }

	    /**
	     * Create a new texture object from a Quartz 2D image.
	     * @access public
	     * @param {CGImage} image - A Quartz 2D image (CGImage) object. For more information, see Quartz 2D Programming Guide and CGImage.
	     * @returns {void}
	     * @desc The image data is copied before control is returned to your game.
	     * @see https://developer.apple.com/reference/spritekit/sktexture/1519576-init
	     */

	  }, {
	    key: 'textureWithCgImage',
	    value: function textureWithCgImage(image) {
	      var texture = new SKTexture();
	      texture._image = image;
	      this._loadingImagePromise = Promise.resolve(this);
	      return texture;
	    }

	    /**
	     * Creates a new texture from a subset of an existing texture.
	     * @access public
	     * @param {CGRect} rect - A rectangle in the unit coordinate space that specifies the portion of the texture to use.
	     * @param {SKTexture} texture - The texture to create the new texture from.
	     * @returns {void}
	     * @desc The returned texture object shares the same texture data as the original texture object, meaning that only one copy of the texture data is kept in memory.If you call this method on a texture that itself was created using this method, the original texture is used as the source instead. That is, the rectangle is considered to be in the source textures coordinate system. To do this, you should use the source texture's textureRect() rather than relying on hard coded {(0,0) (1,1)} as the coordinates.  Listing 1 shows how you can use the source texture's textureRect() to calculate the portion of the texture to use.Listing 1 Creating a texture from a portion of another texture.let originalTexture = SKTexture(imageNamed: "sourceImage.png")
	    let rect = CGRect(origin: originalTexture.textureRect().origin,
	                    size: CGSize(width: originalTexture.textureRect().midX,
	                                 height: originalTexture.textureRect().midY))
	    let croppedTexture = SKTexture(rect: rect,
	                                 in: originalTexture)
	    In the above example, if originalTexture had a size of (348.0, 282.0) and a textureRect() of {(0,0) (1,1)}, croppedTexture will have a size of (174.0, 141.0) and a textureRect() of {(0,0) (1,1)}. croppedTexture will be a copy of the bottom left quadrant of originalTexture.Creating a texture from a portion of another texture.let originalTexture = SKTexture(imageNamed: "sourceImage.png")
	    let rect = CGRect(origin: originalTexture.textureRect().origin,
	                    size: CGSize(width: originalTexture.textureRect().midX,
	                                 height: originalTexture.textureRect().midY))
	    let croppedTexture = SKTexture(rect: rect,
	                                 in: originalTexture)
	      * @see https://developer.apple.com/reference/spritekit/sktexture/1520425-init
	     */

	  }, {
	    key: 'textureWithRectIn',
	    value: function textureWithRectIn(rect, texture) {
	      var texutre = new SKTexture();
	      return texture;
	    }
	  }, {
	    key: 'textureWithDataSize',
	    value: function textureWithDataSize(pixelData, size) {}
	  }, {
	    key: 'textureWithVectorNoiseWithSmoothness',
	    value: function textureWithVectorNoiseWithSmoothness(smoothness, size) {}

	    /**
	     * Creates a new texture whose contents are procedurally generated colored noise data.
	     * @access public
	     * @param {number} smoothness - A value that indicates how similar neighboring texels will be in the resulting texture. The value should be between 0.0 and 1.0. A value of 1.0 generates a smooth surface.
	     * @param {CGSize} size - The size of the new texture in points.
	     * @param {boolean} grayscale - If true, all four components of each texel will have equal values. If false, all four values are completely randomized.
	     * @returns {void}
	     * @desc Unlike other textures produced by SpriteKit, the texels are not premultiplied by the alpha value. Your custom shaders should compensate for this as necessary.The following code creates three sprite nodes with textures generated by init(noiseWithSmoothness:size:grayscale:) with smoothness values of 0.0, 0.5 and 1.0.let columWidth = scene.size.width / 3
	    for i in 0...2 {
	      
	      let size = CGSize(width: ceil(columWidth),
	                        height: 0.5 * scene.size.height)
	      
	      let smoothness = CGFloat(i) / 2
	      
	      let noiseTexture = SKTexture(noiseWithSmoothness: smoothness,
	                                    size: size,
	                                    grayscale: false)
	      
	      let sprite = SKSpriteNode(texture: noiseTexture, size: size)
	      
	      sprite.position = CGPoint(x: CGFloat(i) * columWidth + (columWidth / 2),
	                                y: scene.size.height / 2)
	      
	      scene.addChild(sprite)
	    }
	    let columWidth = scene.size.width / 3
	    for i in 0...2 {
	      
	      let size = CGSize(width: ceil(columWidth),
	                        height: 0.5 * scene.size.height)
	      
	      let smoothness = CGFloat(i) / 2
	      
	      let noiseTexture = SKTexture(noiseWithSmoothness: smoothness,
	                                    size: size,
	                                    grayscale: false)
	      
	      let sprite = SKSpriteNode(texture: noiseTexture, size: size)
	      
	      sprite.position = CGPoint(x: CGFloat(i) * columWidth + (columWidth / 2),
	                                y: scene.size.height / 2)
	      
	      scene.addChild(sprite)
	    }
	      * @see https://developer.apple.com/reference/spritekit/sktexture/1519971-init
	     */

	  }, {
	    key: 'textureWithNoiseWithSmoothness',
	    value: function textureWithNoiseWithSmoothness(smoothness, size, grayscale) {}
	  }, {
	    key: 'preloadWithCompletionHandler',
	    value: function preloadWithCompletionHandler(textures, completionHandler) {}
	  }]);

	  return SKTexture;
	}(_NSObject3.default);

	exports.default = SKTexture;

/***/ },
/* 135 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * Texture filtering modes to use when the texture is drawn in a size other than its native size.
	 * @typedef {Object} SKTextureFilteringMode
	 * @property {number} nearest - Each pixel is drawn using the nearest point in the texture. This mode is faster, but the results are often pixelated.
	 * @property {number} linear - Each pixel is drawn by using a linear filter of multiple texels in the texture. This mode produces higher quality results but may be slower.
	 * @see https://developer.apple.com/reference/spritekit/sktexturefilteringmode
	 */

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var SKTextureFilteringMode = {
	  nearest: 0,
	  linear: 1
	};

	exports.default = SKTextureFilteringMode;

/***/ },
/* 136 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * Options for SceneKits rendering of shadows cast by a light, used by the shadowMode property.
	 * @typedef {Object} SCNShadowMode
	 * @property {number} forward - SceneKit renders shadows during lighting computations.
	 * @property {number} deferred - SceneKit renders shadows in a postprocessing pass.
	 * @property {number} modulated - SceneKit renders shadows by projecting the lights gobo image. The light does not illuminate the scene.
	 * @see https://developer.apple.com/reference/scenekit/scnshadowmode
	 */

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var SCNShadowMode = {
	  forward: 0,
	  deferred: 1,
	  modulated: 2
	};

	exports.default = SCNShadowMode;

/***/ },
/* 137 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

	var _NSObject2 = __webpack_require__(2);

	var _NSObject3 = _interopRequireDefault(_NSObject2);

	var _SCNAnimatable = __webpack_require__(66);

	var _SCNAnimatable2 = _interopRequireDefault(_SCNAnimatable);

	var _SCNGeometry = __webpack_require__(68);

	var _SCNGeometry2 = _interopRequireDefault(_SCNGeometry);

	var _SCNMorpherCalculationMode = __webpack_require__(138);

	var _SCNMorpherCalculationMode2 = _interopRequireDefault(_SCNMorpherCalculationMode);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var _weightsPattern = new RegExp(/^weights\[(\d+)\]$/);

	/**
	 * An object that manages smooth transitions between a node's base geometry and one or more target geometries.
	 * @access public
	 * @extends {NSObject}
	 * @implements {SCNAnimatable}
	 * @see https://developer.apple.com/reference/scenekit/scnmorpher
	 */

	var SCNMorpher = function (_NSObject) {
	  _inherits(SCNMorpher, _NSObject);

	  /**
	   * constructor
	   * @access public
	   * @constructor
	   */
	  function SCNMorpher() {
	    _classCallCheck(this, SCNMorpher);

	    // Specifying Morph Targets

	    /**
	     * The array of target geometries to morph between.
	     * @type {SCNGeometry[]}
	     * @see https://developer.apple.com/reference/scenekit/scnmorpher/1523572-targets
	     */
	    var _this = _possibleConstructorReturn(this, (SCNMorpher.__proto__ || Object.getPrototypeOf(SCNMorpher)).call(this));

	    _this.targets = [];

	    /**
	     * @type {number[]}
	     */
	    _this._weights = [];

	    // Changing Interpolation Mode

	    /**
	     * The interpolation formula for blending between target geometries.
	     * @type {SCNMorpherCalculationMode}
	     * @see https://developer.apple.com/reference/scenekit/scnmorpher/1523754-calculationmode
	     */
	    _this.calculationMode = _SCNMorpherCalculationMode2.default.normalized;
	    return _this;
	  }

	  // Blending between Morph Targets

	  /**
	   * Returns the weight value for the specified target index.
	   * @access public
	   * @param {number} targetIndex - The index of a geometry in the morphers targets array.
	   * @returns {number} - 
	   * @desc Target geometries and their weights determine the current form of the surface produced by the morpher. For example, if a morpher has one target whose weight is 0.5, the form of the resulting surface will be halfway between those of the base geometry and the target geometry.
	   * @see https://developer.apple.com/reference/scenekit/scnmorpher/1522940-weight
	   */


	  _createClass(SCNMorpher, [{
	    key: 'weightForTargetAt',
	    value: function weightForTargetAt(targetIndex) {
	      return this._weights[targetIndex];
	    }

	    /**
	     * Specifies a weight value at a specified target index.
	     * @access public
	     * @param {number} weight - A number specifying the contribution of the target geometry to the blended surface, generally between 0.0 and 1.0.
	     * @param {number} targetIndex - The index of a geometry in the morphers targets array.
	     * @returns {void}
	     * @desc Target geometries and their weights determine the current form of the surface produced by the morpher. For example, if a morpher has one target whose weight is 0.5, the form of the resulting surface will be halfway between those of the base geometry and the target geometry.You can also animate weights implicitly or explicitly using the keypath weights[index], where index corresponds to the targetIndex parameter of this method.
	     * @see https://developer.apple.com/reference/scenekit/scnmorpher/1522886-setweight
	     */

	  }, {
	    key: 'setWeightForTargetAt',
	    value: function setWeightForTargetAt(weight, targetIndex) {
	      this._weights[targetIndex] = weight;
	    }
	  }, {
	    key: 'setValueForKey',
	    value: function setValueForKey(value, key) {
	      //console.log(`SCNMorpher.setValueForKey: ${key}: ${value}`)
	      var weightsMatch = key.match(_weightsPattern);
	      if (weightsMatch !== null) {
	        if (weightsMatch.length > 1) {
	          var index = weightsMatch[1];
	          if (typeof this._weights[index] !== 'undefined') {
	            //console.log(`_weights[ ${index} ] = ${value}`)
	            this._weights[index] = value;
	          }
	        }
	        return;
	      }

	      _get(SCNMorpher.prototype.__proto__ || Object.getPrototypeOf(SCNMorpher.prototype), 'setValueForKey', this).call(this, value, key);
	    }

	    /*
	    setValueForKeyPath(value, keyPath) {
	      console.log(`SCNMorpher.setValueForKeyPath: ${keyPath}: ${value}`)
	      const paths = keyPath.split('.')
	      const key = paths.shift()
	      const restPath = paths.join('.')
	       const weightsMatch = key.match(_weightsPattern)
	      if(weightsMatch !== null){
	        if(weightsMatch.length > 1){
	          //const targetIndex = this.targets.findIndex((target) => target.name === restPath)
	          //if(targetIndex >= 0){
	          //  this._weights[targetIndex] = value
	          //}
	          const index = weightsMatch[1]
	          if(typeof this._weights[index] !== 'undefined'){
	            console.log(`_weights[ ${index} ] = ${value}`)
	            this._weights[index] = value
	          }
	        }
	      }else{
	        super.setValueForKeyPath(value, keyPath)
	      }
	    }
	    */

	    /**
	     * @access private
	     * @param {SCNNode} node -
	     */

	  }, {
	    key: '_morph',
	    value: function _morph(node) {
	      var _this2 = this;

	      //console.log(`SCNMorpher._morph ${node.name}`)
	      var p = node.presentation;
	      if (node.geometry === null || p === null || p.geometry === null) {
	        // data is not ready
	        return;
	      }
	      var pg = p.geometry;
	      var totalWeightForSemantic = new Map();

	      // reset presentation geometry
	      node.geometry.geometrySources.forEach(function (source) {
	        // FIXME: copy more than 1 source.
	        var pSource = pg.getGeometrySourcesForSemantic(source.semantic)[0];
	        pSource.fill(0);
	        //newData.set(source.semantic, Array(source._data.length).fill(0))
	        totalWeightForSemantic.set(source.semantic, 0.0);
	      });

	      // should I morph elements?
	      //node.geometry.geometryElements().forEach((element) => {
	      //})

	      var targetCount = this.targets.length;
	      //console.log(`targetCount: ${targetCount}`)

	      var _loop = function _loop(i) {
	        var target = _this2.targets[i];
	        var weight = _this2._weights[i];
	        if (weight === 0 || typeof weight === 'undefined') {
	          return 'continue';
	        }
	        //console.log(`morph ${target.name} weight ${weight}`)
	        target.geometrySources.forEach(function (source) {
	          var pSource = pg.getGeometrySourcesForSemantic(source.semantic)[0];
	          if (typeof pSource === 'undefined') {
	            return;
	          }
	          totalWeightForSemantic.set(source.semantic, totalWeightForSemantic.get(source.semantic) + weight);

	          // FIXME: don't access private properties
	          var srcIndex = source._dataOffset / source._bytesPerComponent;
	          var srcStride = source._dataStride / source._bytesPerComponent;
	          var dstIndex = pSource._dataOffset / pSource._bytesPerComponent;
	          var dstStride = pSource._dataStride / pSource._bytesPerComponent;
	          var componentCount = source._componentsPerVector;
	          var vectorCount = source._vectorCount;
	          for (var j = 0; j < vectorCount; j++) {
	            for (var k = 0; k < componentCount; k++) {
	              pSource._data[dstIndex + k] += source._data[srcIndex + k] * weight;
	            }
	            srcIndex += srcStride;
	            dstIndex += dstStride;
	          }
	        });
	      };

	      for (var i = 0; i < targetCount; i++) {
	        var _ret = _loop(i);

	        if (_ret === 'continue') continue;
	      }

	      //console.log(`node.geometry.geometrySources.length: ${node.geometry.geometrySources.length}`)
	      node.geometry.geometrySources.forEach(function (source) {
	        //console.log(`add baseGeometry`)
	        // FIXME: copy more than 1 source.
	        var pSource = pg.getGeometrySourcesForSemantic(source.semantic)[0];
	        var srcIndex = source._dataOffset / source._bytesPerComponent;
	        var srcStride = source._dataStride / source._bytesPerComponent;
	        var dstIndex = pSource._dataOffset / pSource._bytesPerComponent;
	        var dstStride = pSource._dataStride / pSource._bytesPerComponent;
	        var componentCount = source._componentsPerVector;
	        var vectorCount = source._vectorCount;

	        if (_this2.calculationMode === _SCNMorpherCalculationMode2.default.normalized) {
	          var _weight = 1.0 - totalWeightForSemantic.get(source.semantic);
	          // FIXME: don't access private properties
	          for (var i = 0; i < vectorCount; i++) {
	            for (var j = 0; j < componentCount; j++) {
	              pSource._data[dstIndex + j] += source._data[srcIndex + j] * _weight;
	            }
	            srcIndex += srcStride;
	            dstIndex += dstStride;
	          }
	        } else {
	          //console.log(`additive: vector: ${vectorCount}, component: ${componentCount}`)
	          // calculationMode: additive
	          // FIXME: don't access private properties
	          for (var _i = 0; _i < vectorCount; _i++) {
	            for (var _j = 0; _j < componentCount; _j++) {
	              pSource._data[dstIndex + _j] += source._data[srcIndex + _j];
	            }
	            srcIndex += srcStride;
	            dstIndex += dstStride;
	          }
	        }
	      });

	      // TODO: needs to update normal vector?

	      //console.log(`_morph done`)
	    }
	  }]);

	  return SCNMorpher;
	}(_NSObject3.default);

	exports.default = SCNMorpher;

/***/ },
/* 138 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * The interpolation formulas for blending between target geometries.
	 * @typedef {Object} SCNMorpherCalculationMode
	 * @property {number} normalized - Target weights must be in the range between 0.0 and 1.0, and the contribution of the base geometry to the morphed surface is related to the sum of target weights. This is the default mode.
	 * @property {number} additive - Target weights may take on any value, and weighted contributions for each target are added to the base geometry,
	 * @see https://developer.apple.com/reference/scenekit/scnmorphercalculationmode
	 */

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var SCNMorpherCalculationMode = {
	  normalized: 0,
	  additive: 1
	};

	exports.default = SCNMorpherCalculationMode;

/***/ },
/* 139 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _NSObject2 = __webpack_require__(2);

	var _NSObject3 = _interopRequireDefault(_NSObject2);

	var _SCNGeometry = __webpack_require__(68);

	var _SCNGeometry2 = _interopRequireDefault(_SCNGeometry);

	var _SCNNode = __webpack_require__(65);

	var _SCNNode2 = _interopRequireDefault(_SCNNode);

	var _SCNGeometrySource = __webpack_require__(71);

	var _SCNGeometrySource2 = _interopRequireDefault(_SCNGeometrySource);

	var _SCNMatrix = __webpack_require__(46);

	var _SCNMatrix2 = _interopRequireDefault(_SCNMatrix);

	var _SCNMatrix4MakeTranslation = __webpack_require__(78);

	var _SCNMatrix4MakeTranslation2 = _interopRequireDefault(_SCNMatrix4MakeTranslation);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * An object that manages the relationship between skeletal animations and the nodes and geometries they animate.
	 * @access public
	 * @extends {NSObject}
	 * @see https://developer.apple.com/reference/scenekit/scnskinner
	 */
	var SCNSkinner = function (_NSObject) {
	  _inherits(SCNSkinner, _NSObject);

	  _createClass(SCNSkinner, null, [{
	    key: '_propTypes',
	    get: function get() {
	      return {
	        $constructor: function $constructor(propNames, propValues) {
	          var invTransforms = [];
	          var len = propValues.bones.length;
	          for (var i = 0; i < len; i++) {
	            var inv = propValues['baseGeometryBindTransform-' + i];
	            //console.log(`inv ${i} ${inv.float32Array()}`)
	            if (typeof inv === 'undefined') {
	              throw new Error('boneInverseBindTransforms ' + i + ' does not exist');
	            }
	            invTransforms.push(inv);
	          }

	          var instance = new SCNSkinner(propValues.baseGeometry, propValues.bones, invTransforms, propValues.boneWeights, propValues.boneIndices);
	          instance.skeleton = propValues.skeleton;
	          instance.baseGeometryBindTransform = propValues.baseGeometryBindTransform;
	          return instance;
	        },
	        $unknownKey: function $unknownKey(key) {
	          //console.warn(`SCNSkinner unknownKey ${key}`)
	          var pattern = new RegExp(/^baseGeometryBindTransform-(\d+)$/);
	          var result = key.match(pattern);
	          if (result !== null) {
	            return ['SCNMatrix4', null];
	          }
	          return null;
	        },
	        baseGeometry: ['SCNGeometry', null],
	        baseGeometryBindTransform: ['SCNMatrix4', null],
	        skeleton: ['SCNNode', null],
	        bones: ['NSArray', null],
	        boneWeights: ['SCNGeometrySource', null],
	        boneIndices: ['SCNGeometrySource', null]
	      };
	    }

	    // Creating a Skinner Object

	    /**
	     * Creates a skinner object with the specified visible geometry and skeleton information.
	     * @access public
	     * @constructor
	     * @param {?SCNGeometry} baseGeometry - The geometry whose surface the skinners animation skeleton deforms.
	     * @param {SCNNode[]} bones - An array of SCNNode objects, each representing a bone or control point for the animation skeleton.
	     * @param {?NSValue[]} boneInverseBindTransforms - An array of NSValue objects containing SCNMatrix4 transforms, each of which corresponds to a node in the bones array. Each value is the inverse matrix (see SCNMatrix4Invert(_:)) of that nodes transform property for the skeletons default pose.
	     * @param {SCNGeometrySource} boneWeights - The geometry source defining the influence of each bone on the positions of vertices in the geometry. For details, see the boneWeights property.
	     * @param {SCNGeometrySource} boneIndices - The geometry source defining the mapping from bone indices in skeleton data to the skinners bones array. For details, see the boneIndices property.
	     * @desc To use the skinner object in a scene, assign it to the skinner property of a node. That nodes geometry property should reference the same SCNGeometry object as the skinners baseGeometry property.
	     * @see https://developer.apple.com/reference/scenekit/scnskinner/1523964-init
	     */

	  }]);

	  function SCNSkinner(baseGeometry, bones, boneInverseBindTransforms, boneWeights, boneIndices) {
	    _classCallCheck(this, SCNSkinner);

	    // data length consistency check
	    var _this = _possibleConstructorReturn(this, (SCNSkinner.__proto__ || Object.getPrototypeOf(SCNSkinner)).call(this));

	    var boneLen = bones.length;
	    //const vectorLen = baseGeometry.getGeometrySourcesForSemantic(SCNGeometrySource.Semantic.vertex).vectorCount
	    if (boneInverseBindTransforms.length !== boneLen) {
	      throw new Error('SCNSkinner: bones.length (' + boneLen + ') !== boneInverseBindTransforms.length (' + boneInverseBindTransforms.length + ')');
	    }
	    //if(boneWeights.vectorCount !== vectorLen){
	    //  throw new Error(`SCNSkinner: vertices.length (${vectorLen}) !== boneWeights.vectorCount (${boneWeights.vectorCount})`)
	    //}
	    //if(boneIndices.vectorCount !== vectorLen){
	    //  throw new Error(`SCNSkinner: vertices.length (${vectorLen}) !== boneIndices.vectorCount (${boneIndices.vectorCount})`)
	    //}
	    if (boneWeights.componentsPerVector !== boneIndices.componentsPerVector) {
	      throw new Error('SCNSkinner: boneWeights.componentsPerVector (' + boneWeights.componentsPerVector + ') !== boneIndices.componentsPerVector (' + boneWeights.componentsPerVector + ')');
	    }

	    // Working with a Skinned Geometry

	    /**
	     * The geometry whose surface the skinners animation skeleton deforms.
	     * @type {?SCNGeometry}
	     * @see https://developer.apple.com/reference/scenekit/scnskinner/1522823-basegeometry
	     */
	    _this.baseGeometry = baseGeometry;

	    /**
	     * The coordinate transformation for the skinners geometry in its default state.
	     * @type {SCNMatrix4}
	     * @see https://developer.apple.com/reference/scenekit/scnskinner/1523160-basegeometrybindtransform
	     */
	    _this.baseGeometryBindTransform = (0, _SCNMatrix4MakeTranslation2.default)(0, 0, 0);

	    // Working with an Animation Skeleton

	    /**
	     * The root node of the skinner objects animation skeleton.
	     * @type {?SCNNode}
	     * @see https://developer.apple.com/reference/scenekit/scnskinner/1523048-skeleton
	     */
	    _this.skeleton = null;

	    /**
	     * @access private
	     * @type {SCNNode[]}
	     */
	    _this._bones = bones;

	    /**
	     * @access private
	     * @type {SCNMatrix4[]}
	     */
	    _this._boneInverseBindTransforms = boneInverseBindTransforms;

	    /**
	     * @access private
	     * @type {SCNGeometrySource}
	     */
	    _this._boneWeights = boneWeights;

	    /**
	     * @access private
	     * @type {SCNGeometrySource}
	     */
	    _this._boneIndices = boneIndices;

	    // add geometrySources to baseGeometry
	    //baseGeometry._geometrySources.push(boneWeights)
	    //baseGeometry._geometrySources.push(boneIndices)
	    return _this;
	  }

	  // Working with an Animation Skeleton

	  /**
	   * The control nodes of the animation skeleton.
	   * @type {SCNNode[]}
	   * @desc An array of SCNNode objects, each of which represents a control point of the animation skeleton. Moving a node deforms the surface of the skinners geometry, based on the skeleton data from which the skinner object was created.
	   * @see https://developer.apple.com/reference/scenekit/scnskinner/1522732-bones
	   */


	  _createClass(SCNSkinner, [{
	    key: 'float32Array',


	    /**
	     * returns Float32Array of 3x4 matrices
	     * @access public
	     * @returns {Float32Array} -
	     */
	    value: function float32Array() {
	      var arr = [];
	      var len = this._bones.length;
	      for (var i = 0; i < len; i++) {
	        var bone = this._bones[i];
	        // TODO: implement appropriate matrix multiplication.
	        //       it doesn't consider the rotation of initial pose so far.
	        //const mat = this._boneInverseBindTransforms[i].mult(bone._presentation._worldTransform)
	        var mat = this.baseGeometryBindTransform.mult(this._boneInverseBindTransforms[i]).mult(bone._presentation._worldTransform);
	        //const mat = bone._presentation._worldTransform.mult(this._boneInverseBindTransforms[i])
	        //mat = bone.presentation.transform.mult(mat)
	        //if(bone._parent !== null){
	        //  mat = mat.mult(bone._parent.presentation._worldTransform)
	        //  //mat = bone._parent.presentation._worldTransform.mult(mat)
	        //}
	        //mat = bone.presentation.transform.mult(mat)
	        //mat = mat.mult(bone.presentation.transform)
	        arr.push.apply(arr, _toConsumableArray(mat.floatArray3x4f()));

	        /*
	        if(!mat.isIdentity()){
	          console.warn(`inverse: ${this._boneInverseBindTransforms[i].floatArray3x4f()}`)
	          console.warn(`presentation.worldTransform: ${bone.presentation._worldTransform.floatArray3x4f()}`)
	          console.warn(`parent.presentation.world: ${bone._parent.presentation._worldTransform.floatArray3x4f()}`)
	          console.warn(`presentation.transform: ${bone.presentation.transform.floatArray3x4f()}`)
	          console.warn(`worldTransform: ${bone._worldTransform.floatArray3x4f()}`)
	          console.warn(`transfrom: ${bone.transform.floatArray3x4f()}`)
	          console.warn(`presentation.position.y: ${bone.presentation.position.y}`)
	          console.warn(`position.y: ${bone.position.y}`)
	          console.warn(`mat: ${mat.floatArray3x4f()}`)
	          throw new Error(`mat ${i} ${bone.name} is not identity`)
	        }
	        */
	      }

	      // DEBUG
	      /*
	      console.log('boneInverseBindTransforms')
	      for(let i=0; i<4; i++){
	        const mat = this._boneInverseBindTransforms[i]
	        console.log(mat.floatArray3x4f())
	      }
	      console.log('bone._presentation._worldTransform')
	      for(let i=0; i<4; i++){
	        const mat = this._bones[i]._presentation._worldTransform
	        console.log(mat.floatArray3x4f())
	      }
	      */

	      return new Float32Array(arr);
	    }
	  }, {
	    key: 'bones',
	    get: function get() {
	      return this._bones.slice(0);
	    }

	    /**
	     * The default transforms for the animation skeletons bone nodes.
	     * @type {?SCNMatrix4[]}
	     * @desc An array of NSValue objects containing SCNMatrix4 transforms, each of which corresponds to a node in the bones array. Each value is the inverse matrix (see SCNMatrix4Invert(_:)) of that nodes transform property for the skeletons default pose.
	     * @see https://developer.apple.com/reference/scenekit/scnskinner/1523802-boneinversebindtransforms
	     */

	  }, {
	    key: 'boneInverseBindTransforms',
	    get: function get() {
	      return this._boneInverseBindTransforms.slice(0);
	    }

	    /**
	     * The geometry source that defines the influence of each bone on the positions the geometrys vertices.
	     * @type {SCNGeometrySource}
	     l* @desc This geometry sources semantic property must be boneWeights. Its data is an array of floating-point vectors, whose componentsPerVector count is the number of bones influencing each vertex. Each vector corresponds to a vertex in the geometrys vertex geometry source, and each component in a vector specifies the influence of a bone on that vertexs position. The boneIndices source determines which nodes in the bones array correspond to each component in the vector. A component value of 0.0 means that the bone has no influence on that vertex; positive or negative values scale the transformation of a bone node before SceneKit applies that transformation to the vertex.NoteSceneKit performs skeletal animation on the GPU only if the componentsPerVector count in this geometry source is 4 or less. Larger vectors result in CPU-based animation and drastically reduced rendering performance.
	     * @see https://developer.apple.com/reference/scenekit/scnskinner/1522986-boneweights
	     */

	  }, {
	    key: 'boneWeights',
	    get: function get() {
	      return this._boneWeights;
	    }

	    /**
	     * The geometry source defining the mapping from bone indices in skeleton data to the skinners bones array.
	     * @type {SCNGeometrySource}
	     * @desc This geometry sources semantic property must be boneIndices. Its data is an array of integer vectors, each of which corresponds to a weight vector in the boneWeights geometry source. Each component in a vector specifies the index of the node in the bones array for the corresponding bone weight component.
	     * @see https://developer.apple.com/reference/scenekit/scnskinner/1524117-boneindices
	     */

	  }, {
	    key: 'boneIndices',
	    get: function get() {
	      return this._boneIndices;
	    }

	    /**
	     * @access public
	     * @returns {number} -
	     */

	  }, {
	    key: 'numSkinningJoints',
	    get: function get() {
	      return this._boneWeights.componentsPerVector;
	    }
	  }]);

	  return SCNSkinner;
	}(_NSObject3.default);

	exports.default = SCNSkinner;

/***/ },
/* 140 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _SCNMatrix = __webpack_require__(46);

	var _SCNMatrix2 = _interopRequireDefault(_SCNMatrix);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Returns a matrix describing a scale transformation.
	 * @access public
	 * @param {number} sx - The scale factor in the x-axis direction.
	 * @param {number} sy - The scale factor in the y-axis direction.
	 * @param {number} sz - The scale factor in the z-axis direction.
	 * @returns {SCNMatrix4} - 
	 * @see https://developer.apple.com/reference/scenekit/1409681-scnmatrix4makescale
	 */
	var SCNMatrix4MakeScale = function SCNMatrix4MakeScale(sx, sy, sz) {
	  return new _SCNMatrix2.default(sx, 0, 0, 0, 0, sy, 0, 0, 0, 0, sz, 0, 0, 0, 0, 1);
	};

	exports.default = SCNMatrix4MakeScale;

/***/ },
/* 141 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _NSObject2 = __webpack_require__(2);

	var _NSObject3 = _interopRequireDefault(_NSObject2);

	var _SCNAnimatable = __webpack_require__(66);

	var _SCNAnimatable2 = _interopRequireDefault(_SCNAnimatable);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * The abstract superclass for objects thatautomatically adjust the position, rotation, or scale of a node based on rules you define.
	 * @access public
	 * @extends {NSObject}
	 * @implements {SCNAnimatable}
	 * @see https://developer.apple.com/reference/scenekit/scnconstraint
	 */
	var SCNConstraint = function (_NSObject) {
	  _inherits(SCNConstraint, _NSObject);

	  function SCNConstraint() {
	    _classCallCheck(this, SCNConstraint);

	    return _possibleConstructorReturn(this, (SCNConstraint.__proto__ || Object.getPrototypeOf(SCNConstraint)).apply(this, arguments));
	  }

	  _createClass(SCNConstraint, [{
	    key: 'init',


	    /**
	     * constructor
	     * @access public
	     * @returns {void}
	     */
	    value: function init() {

	      // Tuning a Constraints Effect on Nodes

	      /**
	       * The influence of the constraint on the nodes transformation.
	       * @type {number}
	       * @see https://developer.apple.com/reference/scenekit/scnconstraint/1468692-influencefactor
	       */
	      this.influenceFactor = 0;
	    }
	  }]);

	  return SCNConstraint;
	}(_NSObject3.default);

	exports.default = SCNConstraint;

/***/ },
/* 142 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * Values that inform SceneKits rendering for movement-related effects, used by the movabilityHint property.
	 * @typedef {Object} SCNMovabilityHint
	 * @property {number} fixed - The node is not expected to move over time.
	 * @property {number} movable - The node is expected to move over time.
	 * @see https://developer.apple.com/reference/scenekit/scnmovabilityhint
	 */

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var SCNMovabilityHint = {
	  fixed: 0,
	  movable: 1
	};

	exports.default = SCNMovabilityHint;

/***/ },
/* 143 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _SCNNode = __webpack_require__(65);

	var _SCNNode2 = _interopRequireDefault(_SCNNode);

	var _SCNRenderer = __webpack_require__(88);

	var _SCNRenderer2 = _interopRequireDefault(_SCNRenderer);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	/**
	 * Methods you can implement to use your own custom Metal or OpenGL drawing code to render content for a node. 
	 * @interface
	 * @see https://developer.apple.com/reference/scenekit/scnnoderendererdelegate
	 */
	var SCNNodeRendererDelegate = function () {
	  function SCNNodeRendererDelegate() {
	    _classCallCheck(this, SCNNodeRendererDelegate);
	  }

	  _createClass(SCNNodeRendererDelegate, [{
	    key: 'init',


	    /**
	     * constructor
	     * @access public
	     * @returns {void}
	     */
	    value: function init() {}

	    // Customizing the Rendering of a Node

	    /**
	     * Tells the delegate to perform rendering for a node.
	     * @access public
	     * @param {SCNNode} node - The node to render.
	     * @param {SCNRenderer} renderer - The SceneKit object (such as an SCNView instance) responsible for rendering the scene. 
	     * @param {Map<string, Object>} _arguments - 
	     * @returns {void}
	     * @desc Implement this method to perform custom rendering for a node. You should only execute Metal or OpenGL drawing commands (and any setup required to perform them) in this methodthe results of modifying SceneKit objects in this method are undefined.To render using Metal, use the renderer parameter to retrieve the scene renderers currentRenderCommandEncoder object and encode your own drawing commands. If you need to reference other Metal state, see the properties listed in SCNSceneRenderer.To render using OpenGL, simply call the relevant OpenGL drawing commandsSceneKit automatically makes its OpenGL context the current context before calling this method. If you need to reference the OpenGL context being rendered into, examine the context property of the renderer parameter.You must draw using the appropriate graphics technology for the view currently being rendered. Use the renderingAPI property of the renderer object to determine whether Metal or OpenGL is in use. 
	     * @see https://developer.apple.com/reference/scenekit/scnnoderendererdelegate/1407993-rendernode
	     */

	  }, {
	    key: 'renderNode',
	    value: function renderNode(node, renderer, _arguments) {}
	  }]);

	  return SCNNodeRendererDelegate;
	}();

	exports.default = SCNNodeRendererDelegate;

/***/ },
/* 144 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _NSObject2 = __webpack_require__(2);

	var _NSObject3 = _interopRequireDefault(_NSObject2);

	var _SCNFieldForceEvaluator = __webpack_require__(145);

	var _SCNFieldForceEvaluator2 = _interopRequireDefault(_SCNFieldForceEvaluator);

	var _SCNVector = __webpack_require__(44);

	var _SCNVector2 = _interopRequireDefault(_SCNVector);

	var _SCNPhysicsFieldScope = __webpack_require__(146);

	var _SCNPhysicsFieldScope2 = _interopRequireDefault(_SCNPhysicsFieldScope);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * An object that applies forces, such as gravitation, electromagnetism, and turbulence, to physics bodies within a certain area of effect. 
	 * @access public
	 * @extends {NSObject}
	 * @see https://developer.apple.com/reference/scenekit/scnphysicsfield
	 */
	var SCNPhysicsField = function (_NSObject) {
	  _inherits(SCNPhysicsField, _NSObject);

	  function SCNPhysicsField() {
	    _classCallCheck(this, SCNPhysicsField);

	    return _possibleConstructorReturn(this, (SCNPhysicsField.__proto__ || Object.getPrototypeOf(SCNPhysicsField)).apply(this, arguments));
	  }

	  _createClass(SCNPhysicsField, [{
	    key: 'init',


	    /**
	     * constructor
	     * @access public
	     * @returns {void}
	     */
	    value: function init() {

	      // Specifying a Fields Area of Effect

	      /**
	       * A location marking the end of the fields area of effect.
	       * @type {SCNVector3}
	       * @see https://developer.apple.com/reference/scenekit/scnphysicsfield/1388138-halfextent
	       */
	      this.halfExtent = null;

	      /**
	       * The area affected by the field, either inside or outside its region.
	       * @type {SCNPhysicsFieldScope}
	       * @see https://developer.apple.com/reference/scenekit/scnphysicsfield/1388136-scope
	       */
	      this.scope = null;

	      /**
	       * A Boolean value that determines whether the fields area of effect is shaped like a box or ellipsoid.
	       * @type {boolean}
	       * @see https://developer.apple.com/reference/scenekit/scnphysicsfield/1388158-usesellipsoidalextent
	       */
	      this.usesEllipsoidalExtent = false;

	      /**
	       * The offset of the fields center within its area of effect.
	       * @type {SCNVector3}
	       * @see https://developer.apple.com/reference/scenekit/scnphysicsfield/1388154-offset
	       */
	      this.offset = null;

	      /**
	       * The fields directional axis.
	       * @type {SCNVector3}
	       * @see https://developer.apple.com/reference/scenekit/scnphysicsfield/1388128-direction
	       */
	      this.direction = null;

	      // Specifying a Fields Behavior

	      /**
	       * A multiplier for the force that the field applies to objects in its area of effect.
	       * @type {number}
	       * @see https://developer.apple.com/reference/scenekit/scnphysicsfield/1388132-strength
	       */
	      this.strength = 0;

	      /**
	       * An exponent that determines how the fields strength diminishes with distance.
	       * @type {number}
	       * @see https://developer.apple.com/reference/scenekit/scnphysicsfield/1388146-falloffexponent
	       */
	      this.falloffExponent = 0;

	      /**
	       * The minimum value for distance-based effects.
	       * @type {number}
	       * @see https://developer.apple.com/reference/scenekit/scnphysicsfield/1388148-minimumdistance
	       */
	      this.minimumDistance = 0;

	      /**
	       * A Boolean value that determines whether the fields effect is enabled.
	       * @type {boolean}
	       * @see https://developer.apple.com/reference/scenekit/scnphysicsfield/1388117-isactive
	       */
	      this.isActive = false;

	      /**
	       * A Boolean value that determines whether the field overrides other fields whose areas of effect it overlaps.
	       * @type {boolean}
	       * @see https://developer.apple.com/reference/scenekit/scnphysicsfield/1388126-isexclusive
	       */
	      this.isExclusive = false;

	      // Choosing Physics Bodies to Be Affected by the Field

	      /**
	       * A mask that defines which categories this physics field belongs to.
	       * @type {number}
	       * @see https://developer.apple.com/reference/scenekit/scnphysicsfield/1388119-categorybitmask
	       */
	      this.categoryBitMask = 0;
	    }

	    // Creating Physics Fields

	    /**
	     * Creates a field that slows any object in its area of effect with a force proportional to the objects velocity.
	     * @access public
	     * @returns {SCNPhysicsField} - 
	     * @desc Like the damping and angularDamping properties of a physics body, drag fields can simulate effects such as fluid friction or air resistance. Unlike those properties, drag fields can simulate different intensities of fluid friction in different areas of your scene. For example, you can use a drag field to represent underwater areas.The default falloffExponent value for a drag field is 0.0, indicating that the fields effect is constant throughout its area of effect.
	     * @see https://developer.apple.com/reference/scenekit/scnphysicsfield/1388164-drag
	     */

	  }], [{
	    key: 'drag',
	    value: function drag() {
	      return null;
	    }

	    /**
	     * Creates a field whose forces circulate around an axis.
	     * @access public
	     * @returns {SCNPhysicsField} - 
	     * @desc The force on an object in a vortex field is tangential to the line from the objects position to the fields axis and proportional to the objects mass. (The fields axis is a line that is parallel to its direction vector and that passes through its center. For details, see the offset property.) For example, when a vortex fields area of effect contains many objects, the resulting scene resembles a tornado: The objects simultaneously revolve around and fly away from the fields center.By default, a vortex circulates counterclockwise relative to its direction vector. To make it circulate clockwise, set the fields strength property to a negative value.The default falloffExponent value for a vortex field is 0.0, indicating that the fields effect is constant throughout its area of effect.
	     * @see https://developer.apple.com/reference/scenekit/scnphysicsfield/1388160-vortex
	     */

	  }, {
	    key: 'vortex',
	    value: function vortex() {
	      return null;
	    }

	    /**
	     * Creates a field that accelerates objects toward its center.
	     * @access public
	     * @returns {SCNPhysicsField} - 
	     * @desc Because the force of gravity on an object is proportional to the objects mass, this force accelerates all objects at the same distance from the fields center by the same amount. The fields strength property measures this acceleration in meters per second per second.By default, a radial gravity field attracts objects toward its center. To make it repel objects instead, set the fields strength property to a negative value.The default falloffExponent value for a radial gravity field is 2.0, indicating that the fields effect diminishes with the square of distance from its center.
	     * @see https://developer.apple.com/reference/scenekit/scnphysicsfield/1388115-radialgravity
	     */

	  }, {
	    key: 'radialGravity',
	    value: function radialGravity() {
	      return null;
	    }

	    /**
	     * Creates a field that accelerates objects in a specific direction.
	     * @access public
	     * @returns {SCNPhysicsField} - 
	     * @desc Because the force of gravity on an object is proportional to the objects mass, this force accelerates all objects in the fields area of affect by the same amount. The fields strength property measures this acceleration in meters per second per second.By default, a linear gravity field accelerates objects in along its direction vector. To make it accelerate objects in the opposite direction, set the fields strength property to a negative value.The default falloffExponent value for a linear gravity field is 0.0, indicating that the fields effect is constant throughout its area of effect.
	     * @see https://developer.apple.com/reference/scenekit/scnphysicsfield/1388130-lineargravity
	     */

	  }, {
	    key: 'linearGravity',
	    value: function linearGravity() {
	      return null;
	    }

	    /**
	     * Creates a field that applies random forces to objects in its area of effect.
	     * @access public
	     * @param {number} smoothness - The amount of randomness in the field. A value of 0.0 specifies maximum noise, and a value of 1.0 specifies no noise at all.
	     * @param {number} speed - The fields variation over time. Specify 0.0 for a static field.
	     * @returns {SCNPhysicsField} - 
	     * @desc Use this field type to simulate effects involving random motion, such as fireflies or gently falling snow.In calculating the direction and strength of the fields effect on an object, SceneKit uses a Perlin simplex noise function. This function produces a velocity field that varies over time.The default falloffExponent value for a noise field is 0.0, indicating that the fields effect is constant throughout its area of effect. This field type ignores the fields direction property.
	     * @see https://developer.apple.com/reference/scenekit/scnphysicsfield/1388150-noisefield
	     */

	  }, {
	    key: 'noiseFieldAnimationSpeed',
	    value: function noiseFieldAnimationSpeed(smoothness, speed) {
	      return null;
	    }

	    /**
	     * Creates a field that applies random forces to objects in its area of effect, with magnitudes proportional to those objects velocities.
	     * @access public
	     * @param {number} smoothness - The amount of randomness in the field. A value of 0.0 specifies maximum noise, and a value of 1.0 specifies no noise at all.
	     * @param {number} speed - The fields variation over time. Specify 0.0 for a static field.
	     * @returns {SCNPhysicsField} - 
	     * @desc Like a noise field, a turbulence field applies forces in random directions to the objects that it affects. Unlike a noise field, a turbulence field applies a force whose magnitude is proportional to the speed of each affected object. For example, an object passing through a noise field shakes as it travels through the field, but an object passing through a turbulence field shakes more violently the faster it travels. The fields strength property scales the magnitude of the turbulence effect.The default falloffExponent value for a turbulence field is 0.0, indicating that the fields effect is constant throughout its area of effect.
	     * @see https://developer.apple.com/reference/scenekit/scnphysicsfield/1388162-turbulencefield
	     */

	  }, {
	    key: 'turbulenceFieldAnimationSpeed',
	    value: function turbulenceFieldAnimationSpeed(smoothness, speed) {
	      return null;
	    }

	    /**
	     * Creates a field that pulls objects toward its center with a spring-like force.
	     * @access public
	     * @returns {SCNPhysicsField} - 
	     * @desc The force a spring field applies to objects in its area of effect is linearly proportional to the distance from the object to the center of the field. (That is, the field behaves according to Hookes Law of real-world spring forces.) An object placed at the center of the field and moved away will oscillate around the center, with a period of oscillation that is proportional to the objects mass. The fields strength property scales the magnitude of the spring effecta larger strength simulates a stiffer spring.The default falloffExponent value for a spring field is 1.0, indicating that the fields effect diminishes linearly with distance from its center.
	     * @see https://developer.apple.com/reference/scenekit/scnphysicsfield/1388134-spring
	     */

	  }, {
	    key: 'spring',
	    value: function spring() {
	      return null;
	    }

	    /**
	     * Creates a field that attracts or repels objects based on their electrical charge and on their distance from the fields center.
	     * @access public
	     * @returns {SCNPhysicsField} - 
	     * @desc Use this field type to make objects behave differently from one another when they enter a region, or to make an object's behavior different from its mass-based behavior. An electric field behaves according to the first part of the Lorentz force equation modeling real-world electromagnetic forcesthe field applies a force whose magnitude is proportional to electric charge and distance.By default, physics bodies and particle systems have no electric charge, so they are unaffected by electric and magnetic fields. Use the charge property of a physics body or the particleCharge property of a particle system to add charge-based behavior.When the fields strength value is positive (the default), it attracts bodies whose charge is negative and repels bodies whose charge is positive. To reverse this behavior, set the fields strength property to a negative value.The default falloffExponent value for an electric field is 2.0, indicating that the fields effect diminishes with the square of its distance from its center.
	     * @see https://developer.apple.com/reference/scenekit/scnphysicsfield/1388152-electric
	     */

	  }, {
	    key: 'electric',
	    value: function electric() {
	      return null;
	    }

	    /**
	     * Creates a field that attracts or repels objects based on their electrical charge, velocity, and distance from the fields axis.
	     * @access public
	     * @returns {SCNPhysicsField} - 
	     * @desc Use this field type to make objects behave differently from one another when they enter a region, or to make an object's behavior different from its mass based behavior. A magnetic field behaves according to the second part of the Lorentz force equation modeling real-world electromagnetic forcesthe field applies a force determined by the cross product of an objects velocity vector and the magnetic field vector at the objects location, with magnitude proportional to the objects electric charge. By default, physics bodies and particle systems have no electric charge, so they are unaffected by electric and magnetic fields. Use the charge property of a physics body or the particleCharge property of a particle system to add charge-based behavior.When the fields strength value is positive (the default), the magnetic field vectors circulate counterclockwise relative to the fields direction vector. (That is, the magnetic field models a real-world magnetic field created by current in a wire oriented in the fields direction.) To make field vectors circulate clockwise, set the fields strength property to a negative value.NoteThis SCNPhysicsField option models the real-world physics effect of magnetic fields on moving, electrically charged bodies, not the behavior of permanent magnets or electromagnets. To make objects in your scene simply attract or repel one another, use a different field type. For example, a field created by the radialGravity() method attracts or repels all dynamic bodies near it according to its strength property, and a field created by the electric() method selectively attracts or repels bodies according to their electric charge.The default falloffExponent value for a magnetic field is 2.0, indicating that the fields effect diminishes with the square of distance from its center.
	     * @see https://developer.apple.com/reference/scenekit/scnphysicsfield/1388168-magnetic
	     */

	  }, {
	    key: 'magnetic',
	    value: function magnetic() {
	      return null;
	    }

	    // Creating Custom Physics Fields

	    /**
	     * Creates a field that runs the specified block to determine the force a field applies to each object in its area of effect.
	     * @access public
	     * @param {SCNFieldForceEvaluator} block - A block that SceneKit runs for each object in the fields area of effect. See SCNFieldForceEvaluator. 
	     * @returns {SCNPhysicsField} - 
	     * @desc For custom physics fields, SceneKit ignores the direction, strength, falloffExponent, and minimumDistance properties. Instead, SceneKit calls your block to determine the direction and magnitude of force to apply to each physics body or particle in the fields area of effect.
	     * @see https://developer.apple.com/reference/scenekit/scnphysicsfield/1388140-customfield
	     */

	  }, {
	    key: 'customFieldEvaluationBlock',
	    value: function customFieldEvaluationBlock(block) {
	      return null;
	    }
	  }]);

	  return SCNPhysicsField;
	}(_NSObject3.default);

	exports.default = SCNPhysicsField;

/***/ },
/* 145 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _SCNVector = __webpack_require__(44);

	var _SCNVector2 = _interopRequireDefault(_SCNVector);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * The signature for a block that SceneKit calls to determine the effect of a custom field on an object.
	 * @type {function(position: SCNVector3, velocity: SCNVector3, mass: number, charge: number, time: number): SCNVector3}
	 * @param {SCNVector3} position - The position of the object affected by the field, in the local coordinate space of the node containing the field.
	 * @param {SCNVector3} velocity - The velocity of the object affected by the field, relative to the local coordinate space of the node containing the field.
	 * @param {number} mass - The mass of the object affected by the field. (See the mass property for physics bodies and the particleMass property for particle systems.) 
	 * @param {number} charge - The electrical charge of the object affected by the field. (See the charge property for physics bodies and the particleCharge property for particle systems.)
	 * @param {number} time - The elapsed time, in seconds, since the last simulation step.
	 * @returns {SCNVector3} -
	 * @desc Your block uses these parameters to compute and return an SCNVector3 force vector, which SceneKit then applies to the object affected by the field.
	 * @see https://developer.apple.com/reference/scenekit/scnfieldforceevaluator
	 */
	var SCNFieldForceEvaluator = function SCNFieldForceEvaluator(position, velocity, mass, charge, time) {};

	exports.default = SCNFieldForceEvaluator;

/***/ },
/* 146 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * Options for defining the region of space affected by a physics field, used by the scope property.
	 * @typedef {Object} SCNPhysicsFieldScope
	 * @property {number} insideExtent - The fields effect applies only to objects within the region of space defined by its position and extent.
	 * @property {number} outsideExtent - The fields effect applies only to objects outside the region of space defined by its position and extent.
	 * @see https://developer.apple.com/reference/scenekit/scnphysicsfieldscope
	 */

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var SCNPhysicsFieldScope = {
	  insideExtent: 0,
	  outsideExtent: 1
	};

	exports.default = SCNPhysicsFieldScope;

/***/ },
/* 147 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _NSObject2 = __webpack_require__(2);

	var _NSObject3 = _interopRequireDefault(_NSObject2);

	var _SCNAudioSource = __webpack_require__(148);

	var _SCNAudioSource2 = _interopRequireDefault(_SCNAudioSource);

	var _AVAudioMixerNode = __webpack_require__(13);

	var _AVAudioMixerNode2 = _interopRequireDefault(_AVAudioMixerNode);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * A controller for playback of a positional audio source in a SceneKit scene.
	 * @access public
	 * @extends {NSObject}
	 * @see https://developer.apple.com/reference/scenekit/scnaudioplayer
	 */
	var SCNAudioPlayer = function (_NSObject) {
	  _inherits(SCNAudioPlayer, _NSObject);

	  // Creating an Audio Player

	  /**
	   * Initializes an audio player for playing the specified simple audio source.
	   * @access public
	   * @constructor
	   * @param {SCNAudioSource} source - An audio source object.
	   * @desc Using this initializer is typically not necessary. Instead, call the audioPlayerWithSource: method, which returns a cached audio player object if one for the specified audio source has already been created and is available for use.
	   * @see https://developer.apple.com/reference/scenekit/scnaudioplayer/1522736-init
	   */
	  function SCNAudioPlayer(source) {
	    _classCallCheck(this, SCNAudioPlayer);

	    // Working with Audio Sources

	    var _this = _possibleConstructorReturn(this, (SCNAudioPlayer.__proto__ || Object.getPrototypeOf(SCNAudioPlayer)).call(this));

	    _this._audioSource = source;
	    _this._audioNode = new _AVAudioMixerNode2.default();
	    _this._audioNode._gainNode = source._gainNode;

	    // Responding to Playback

	    /**
	     * A block called by SceneKit when playback of the players audio source is about to begin.
	     * @type {?function(): void}
	     * @see https://developer.apple.com/reference/scenekit/scnaudioplayer/1524115-willstartplayback
	     */
	    _this.willStartPlayback = null;

	    /**
	     * A block called by SceneKit when playback of the players audio source has completed.
	     * @type {?function(): void}
	     * @see https://developer.apple.com/reference/scenekit/scnaudioplayer/1522818-didfinishplayback
	     */
	    _this.didFinishPlayback = null;
	    return _this;
	  }

	  /**
	   * Initializes an audio player for playing the specified AVFoundation audio node.
	   * @access public
	   * @param {AVAudioNode} audioNode - An audio node object.
	   * @returns {void}
	   * @desc Using this initializer is typically not necessary. Instead, call the audioPlayerWithAVAudioNode: method, which returns a cached audio player object if one for the specified AVAudioNode object has already been created and is available for use.
	   * @see https://developer.apple.com/reference/scenekit/scnaudioplayer/1523010-init
	   */


	  _createClass(SCNAudioPlayer, [{
	    key: 'initAvAudioNode',
	    value: function initAvAudioNode(audioNode) {

	      // Working with Audio Sources

	      this._audioSource = null;
	      this._audioNode = null;

	      // Responding to Playback

	      /**
	       * A block called by SceneKit when playback of the players audio source is about to begin.
	       * @type {?function(): void}
	       * @see https://developer.apple.com/reference/scenekit/scnaudioplayer/1524115-willstartplayback
	       */
	      this.willStartPlayback = null;

	      /**
	       * A block called by SceneKit when playback of the players audio source has completed.
	       * @type {?function(): void}
	       * @see https://developer.apple.com/reference/scenekit/scnaudioplayer/1522818-didfinishplayback
	       */
	      this.didFinishPlayback = null;
	    }

	    // Working with Audio Sources

	    /**
	     * The source of audio played by this player.
	     * @type {?SCNAudioSource}
	     * @desc An SCNAudioSource object represents a distinct source of audiofor example, a sound filethat can be reused and shared by many player objects. Use a players audio source to configure the default values for playback parameters such as volume and reverb. To vary those parameters in real time during playback, use the audioNode property to work with the underlying AVAudioNode object.If the player was created with the audioPlayerWithAVAudioNode: method, this propertys value is nil.
	     * @see https://developer.apple.com/reference/scenekit/scnaudioplayer/1523059-audiosource
	     */

	  }, {
	    key: '_play',
	    value: function _play() {
	      this._audioSource._play();
	    }
	  }, {
	    key: '_stop',
	    value: function _stop() {
	      this._audioSource._stop();
	    }
	  }, {
	    key: 'audioSource',
	    get: function get() {
	      return this._audioSource;
	    }

	    /**
	     * The audio node SceneKit uses for mixing audio from this player.
	     * @type {?AVAudioNode}
	     * @desc SceneKit uses this AVAudioNode object to perform 3D positional mixing during playback. Use this object to vary parameters such as volume and reverb in real time during playback. To set default values for those parameters, use the audioSource property.
	     * @see https://developer.apple.com/reference/scenekit/scnaudioplayer/1522747-audionode
	     */

	  }, {
	    key: 'audioNode',
	    get: function get() {
	      return this._audioNode;
	    }
	  }]);

	  return SCNAudioPlayer;
	}(_NSObject3.default);

	exports.default = SCNAudioPlayer;

/***/ },
/* 148 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _AjaxRequest2 = __webpack_require__(98);

	var _AjaxRequest3 = _interopRequireDefault(_AjaxRequest2);

	var _NSObject2 = __webpack_require__(2);

	var _NSObject3 = _interopRequireDefault(_NSObject2);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/*global AudioContextr*/
	var _AudioContext = function _AudioContext() {};
	if (typeof AudioContext !== 'undefined') {
	  _AudioContext = AudioContext;
	} else {
	  console.error('error: AudioContext is not supported');
	}
	var _context = new _AudioContext();

	/**
	 * A simple, reusable audio sourcemusic or sound effects loaded from a filefor use in positional audio playback.
	 * @access public
	 * @extends {NSObject}
	 * @see https://developer.apple.com/reference/scenekit/scnaudiosource
	 */

	var SCNAudioSource = function (_NSObject) {
	  _inherits(SCNAudioSource, _NSObject);

	  _createClass(SCNAudioSource, [{
	    key: 'initNamed',


	    // Creating an Audio Source

	    /**
	     * Returns the audio source associated with the specified filename.
	     * @access public
	     * @param {string} fileName - The name of an audio file. If this filename has not been previously requested, the method looks for an audio file with the specified name in the applications main bundle.
	     * @returns {void}
	     * @desc This method looks in the system caches for an audio source with the specified name and returns that object if it exists. If a matching audio source is not already in the cache, this method locates the audio file with the specified name in the applications main bundle, then creates a new audio source and caches it for reuse.
	     * @see https://developer.apple.com/reference/scenekit/scnaudiosource/1524138-init
	     */
	    value: function initNamed(fileName) {}

	    /**
	     * Initializes an audio source from an audio file in the applications main bundle.
	     * @access public
	     * @param {string} name - The name of an audio file in the applications main bundle.
	     * @returns {void}
	     * @desc Calling this method is equivalent to using the Bundle class to locate an audio file in the applications main bundle and then passing the resulting URL to the init(url:) method.
	     * @see https://developer.apple.com/reference/scenekit/scnaudiosource/1524225-init
	     */

	  }, {
	    key: 'initFileNamed',
	    value: function initFileNamed(name) {}

	    /**
	     * Initializes an audio source from the specified audio file.
	     * @access public
	     * @constructor
	     * @param {string} url - A URL locating an audio file.
	     * @see https://developer.apple.com/reference/scenekit/scnaudiosource/1523264-init
	     */

	  }]);

	  function SCNAudioSource(url) {
	    _classCallCheck(this, SCNAudioSource);

	    // Controlling 3D Audio Spatialization

	    /**
	     * A Boolean value that determines whether audio from this source uses 3D positional mixing.
	     * @type {boolean}
	     * @see https://developer.apple.com/reference/scenekit/scnaudiosource/1524185-ispositional
	     */
	    var _this = _possibleConstructorReturn(this, (SCNAudioSource.__proto__ || Object.getPrototypeOf(SCNAudioSource)).call(this));

	    _this.isPositional = false;

	    // Setting Default Playback Parameters

	    /**
	     * The default playback volume for the audio source.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnaudiosource/1524106-volume
	     */
	    //this.volume = 0

	    /**
	     * The default playback rate for the audio source.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnaudiosource/1524189-rate
	     */
	    _this.rate = 0;

	    /**
	     * The default blend of blend of unmodified and reverb-processed (also called dry and wet) audio for playback of the audio source.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnaudiosource/1523450-reverbblend
	     */
	    _this.reverbBlend = 0;

	    /**
	     * A Boolean value that determines whether the audio source should play repeatedly.
	     * @type {boolean}
	     * @see https://developer.apple.com/reference/scenekit/scnaudiosource/1524183-loops
	     */
	    //this.loops = false

	    /**
	     * A Boolean value that determines whether the audio source should stream content from its source URL when playing.
	     * @type {boolean}
	     * @see https://developer.apple.com/reference/scenekit/scnaudiosource/1523475-shouldstream
	     */
	    _this.shouldStream = false;

	    _this._loading = false;
	    _this._loadPromise = new Promise(function (resolve, reject) {
	      _this._resolve = resolve;
	      _this._reject = reject;
	    });
	    _this._url = url;
	    _this._buffer = null;
	    _this._gainNode = _context.createGain();
	    _this._loops = false;
	    _this._source = null;
	    //this._source = _context.createBufferSource()
	    //this._source.connect(this._gainNode)
	    //this._gainNode.connect(_context.destination)
	    return _this;
	  }

	  /**
	   * The default playback volume for the audio source.
	   * @type {number}
	   * @see https://developer.apple.com/reference/scenekit/scnaudiosource/1524106-volume
	   */


	  _createClass(SCNAudioSource, [{
	    key: 'load',


	    // Preloading Audio Data

	    /**
	     * Loads audio data from the source and prepares it for playing.
	     * @access public
	     * @returns {void}
	     * @desc This method reads audio data from the source file (specified when initializing the audio source) and performs any decompression necessary to prepare for playing audio. Use this method to control when your app or game incurs the run-time performance cost of such workfor example, you can load all audio source before starting a game level, instead of suffering a frame rate drop upon playing a new audio source during gameplay.This method has no effect if the shouldStream propertys value is true.
	     * @see https://developer.apple.com/reference/scenekit/scnaudiosource/1523399-load
	     */
	    value: function load() {
	      var _this2 = this;

	      if (this._loading) {
	        return;
	      }
	      this._loading = true;

	      var promise = _AjaxRequest3.default.get(this._url, { responseType: 'arraybuffer' }).then(function (data) {
	        _context.decodeAudioData(data, function (buffer) {
	          _this2._buffer = buffer;
	          _this2._resolve();
	        });
	      });
	    }
	  }, {
	    key: '_play',
	    value: function _play() {
	      var _this3 = this;

	      var when = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

	      this.load();
	      this._loadPromise.then(function () {
	        _this3._source = _context.createBufferSource();
	        _this3._source.buffer = _this3._buffer;
	        _this3._source.connect(_this3._gainNode);
	        _this3._gainNode.connect(_context.destination);
	        _this3._source.loop = _this3._loops;
	        _this3._source.start(when);
	      });
	    }
	  }, {
	    key: '_stop',
	    value: function _stop() {
	      var when = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

	      if (this._source) {
	        this._source.stop(when);
	        this._source = null;
	      }
	    }
	  }, {
	    key: 'volume',
	    get: function get() {
	      return this._gainNode.gain.value;
	    },
	    set: function set(newValue) {
	      this._gainNode.gain.value = newValue;
	    }

	    /**
	     * A Boolean value that determines whether the audio source should play repeatedly.
	     * @type {boolean}
	     * @see https://developer.apple.com/reference/scenekit/scnaudiosource/1524183-loops
	     */

	  }, {
	    key: 'loops',
	    get: function get() {
	      return this._loops;
	    },
	    set: function set(newValue) {
	      this._loops = newValue;
	      if (this._source !== null) {
	        this._source.loop = newValue;
	      }
	    }
	  }, {
	    key: '_duration',
	    get: function get() {
	      if (this._buffer) {
	        return this._buffer.duration;
	      }
	      return null;
	    }
	  }]);

	  return SCNAudioSource;
	}(_NSObject3.default);

	exports.default = SCNAudioSource;

/***/ },
/* 149 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _SCNAction2 = __webpack_require__(60);

	var _SCNAction3 = _interopRequireDefault(_SCNAction2);

	var _SCNActionTimingMode = __webpack_require__(61);

	var _SCNActionTimingMode2 = _interopRequireDefault(_SCNActionTimingMode);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var SCNActionGroup = function (_SCNAction) {
	  _inherits(SCNActionGroup, _SCNAction);

	  _createClass(SCNActionGroup, null, [{
	    key: '_propTypes',
	    get: function get() {
	      return {
	        _actions: 'NSArray',
	        _finished: 'boolean',
	        _duration: 'float',
	        _timingMode: 'integer',
	        _beginTime: 'float',
	        _isRunning: 'boolean',
	        _pausedTime: 'float',

	        name: ['string', null]
	      };
	    }

	    /**
	     * constructor
	     * @access public
	     * @constructor
	     */

	  }]);

	  function SCNActionGroup() {
	    _classCallCheck(this, SCNActionGroup);

	    var _this = _possibleConstructorReturn(this, (SCNActionGroup.__proto__ || Object.getPrototypeOf(SCNActionGroup)).call(this));

	    _this._actions = [];
	    return _this;
	  }

	  /**
	   * Creates an action that runs a collection of actions in parallel.
	   * @access public
	   * @param {SCNAction[]} actions - An array of SCNAction objects.
	   * @returns {SCNAction} - 
	   * @desc When the action executes, the actions that make up the group all start immediately and run in parallel. The duration of the group action is the longest duration among the collection of actions. If an action in the group has a duration less than the groups duration, the action completes and then idles until the group completes the remaining actions. This matters most when creating a repeating action that repeats a group.This action is reversible; it creates a new group action that contains the reverse of each action specified in the group. 
	   * @see https://developer.apple.com/reference/scenekit/scnaction/1522779-group
	   */


	  _createClass(SCNActionGroup, [{
	    key: 'copy',


	    /**
	     * @access public
	     * @returns {SCNActionGroup} -
	     */
	    value: function copy() {
	      var action = _get(SCNActionGroup.prototype.__proto__ || Object.getPrototypeOf(SCNActionGroup.prototype), 'copy', this).call(this);

	      action._actions = [];
	      this._actions.forEach(function (act) {
	        action._actions.push(act.copy());
	      });

	      return action;
	    }
	  }, {
	    key: '_applyAction',


	    /**
	     * apply action to the given node.
	     * @access private
	     * @param {Object} obj - target object to apply this action.
	     * @param {number} time - active time
	     * @param {boolean} [needTimeConversion = true] -
	     * @returns {void}
	     */
	    value: function _applyAction(obj, time) {
	      var needTimeConversion = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

	      //const dt = this._getTime(time, needTimeConversion) * this.duration
	      //this._actions.forEach((action) => {
	      //  if(!action._finished){
	      //    action._applyAction(obj, dt, false)
	      //  }
	      //})
	      var duration = this._activetimeFromTime(time);

	      var finished = true;
	      this._actions.forEach(function (action) {
	        if (!action._finished) {
	          action._applyAction(obj, duration, needTimeConversion);
	          if (!action._finished) {
	            finished = false;
	          }
	        }
	      });
	      this._finished = finished;
	    }
	  }, {
	    key: '_resetFinished',
	    value: function _resetFinished() {
	      this._actions.forEach(function (action) {
	        action._resetFinished();
	      });
	      this._finished = false;
	    }
	  }, {
	    key: 'duration',
	    get: function get() {
	      var d = 0;
	      this._actions.forEach(function (act) {
	        if (d < act.duration) {
	          d = act.duration;
	        }
	      });
	      return d;
	    }
	  }], [{
	    key: 'group',
	    value: function group(actions) {
	      var action = new SCNActionGroup();
	      action._actions = actions;
	      return action;
	    }
	  }]);

	  return SCNActionGroup;
	}(_SCNAction3.default);

	exports.default = SCNActionGroup;


	_SCNAction3.default.group = SCNActionGroup.group;

/***/ },
/* 150 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _SCNAction2 = __webpack_require__(60);

	var _SCNAction3 = _interopRequireDefault(_SCNAction2);

	var _SCNActionTimingMode = __webpack_require__(61);

	var _SCNActionTimingMode2 = _interopRequireDefault(_SCNActionTimingMode);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var SCNActionHide = function (_SCNAction) {
	  _inherits(SCNActionHide, _SCNAction);

	  _createClass(SCNActionHide, null, [{
	    key: '_propTypes',
	    get: function get() {
	      return {
	        _actions: 'NSArray',
	        _finished: 'boolean',
	        _duration: 'float',
	        _timingMode: 'integer',
	        _beginTime: 'float',
	        _isRunning: 'boolean',
	        _pausedTime: 'float',

	        name: ['string', null]
	      };
	    }

	    /**
	     * constructor
	     * @access public
	     * @constructor
	     */

	  }]);

	  function SCNActionHide() {
	    _classCallCheck(this, SCNActionHide);

	    var _this = _possibleConstructorReturn(this, (SCNActionHide.__proto__ || Object.getPrototypeOf(SCNActionHide)).call(this));

	    _this._actions = [];
	    _this._finished = false;
	    _this._duration = 0;
	    _this._timingMode = _SCNActionTimingMode2.default.linear;
	    _this._beginTime = 0;
	    _this._isRunning = false;
	    _this._pausedTime = 0;
	    return _this;
	  }

	  return SCNActionHide;
	}(_SCNAction3.default);

	exports.default = SCNActionHide;

/***/ },
/* 151 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _SCNAction2 = __webpack_require__(60);

	var _SCNAction3 = _interopRequireDefault(_SCNAction2);

	var _SCNActionTimingMode = __webpack_require__(61);

	var _SCNActionTimingMode2 = _interopRequireDefault(_SCNActionTimingMode);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var SCNActionJavaScript = function (_SCNAction) {
	  _inherits(SCNActionJavaScript, _SCNAction);

	  _createClass(SCNActionJavaScript, null, [{
	    key: '_propTypes',
	    get: function get() {
	      return {
	        _actions: 'NSArray',
	        _finished: 'boolean',
	        _duration: 'float',
	        _timingMode: 'integer',
	        _beginTime: 'float',
	        _isRunning: 'boolean',
	        _pausedTime: 'float'
	      };
	    }

	    /**
	     * constructor
	     * @access public
	     * @constructor
	     */

	  }]);

	  function SCNActionJavaScript() {
	    _classCallCheck(this, SCNActionJavaScript);

	    var _this = _possibleConstructorReturn(this, (SCNActionJavaScript.__proto__ || Object.getPrototypeOf(SCNActionJavaScript)).call(this));

	    _this._actions = [];
	    _this._finished = false;
	    _this._duration = 0;
	    _this._timingMode = _SCNActionTimingMode2.default.linear;
	    _this._beginTime = 0;
	    _this._isRunning = false;
	    _this._pausedTime = 0;
	    return _this;
	  }

	  return SCNActionJavaScript;
	}(_SCNAction3.default);

	exports.default = SCNActionJavaScript;

/***/ },
/* 152 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _SCNAction2 = __webpack_require__(60);

	var _SCNAction3 = _interopRequireDefault(_SCNAction2);

	var _SCNActionTimingMode = __webpack_require__(61);

	var _SCNActionTimingMode2 = _interopRequireDefault(_SCNActionTimingMode);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var SCNActionMove = function (_SCNAction) {
	  _inherits(SCNActionMove, _SCNAction);

	  _createClass(SCNActionMove, null, [{
	    key: '_propTypes',
	    get: function get() {
	      return {
	        _actions: 'NSArray',
	        _finished: 'boolean',
	        _duration: 'float',
	        _timingMode: 'integer',
	        _beginTime: 'float',
	        _isRunning: 'boolean',
	        _pausedTime: 'float'
	      };
	    }

	    /**
	     * constructor
	     * @access public
	     * @constructor
	     */

	  }]);

	  function SCNActionMove() {
	    _classCallCheck(this, SCNActionMove);

	    var _this = _possibleConstructorReturn(this, (SCNActionMove.__proto__ || Object.getPrototypeOf(SCNActionMove)).call(this));

	    _this._actions = [];
	    _this._finished = false;
	    _this._duration = 0;
	    _this._timingMode = _SCNActionTimingMode2.default.linear;
	    _this._beginTime = 0;
	    _this._isRunning = false;
	    _this._pausedTime = 0;
	    return _this;
	  }

	  return SCNActionMove;
	}(_SCNAction3.default);

	exports.default = SCNActionMove;

/***/ },
/* 153 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _SCNAction2 = __webpack_require__(60);

	var _SCNAction3 = _interopRequireDefault(_SCNAction2);

	var _SCNActionTimingMode = __webpack_require__(61);

	var _SCNActionTimingMode2 = _interopRequireDefault(_SCNActionTimingMode);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var SCNActionPerformSelector = function (_SCNAction) {
	  _inherits(SCNActionPerformSelector, _SCNAction);

	  _createClass(SCNActionPerformSelector, null, [{
	    key: '_propTypes',
	    get: function get() {
	      return {
	        _actions: 'NSArray',
	        _finished: 'boolean',
	        _duration: 'float',
	        _timingMode: 'integer',
	        _beginTime: 'float',
	        _isRunning: 'boolean',
	        _pausedTime: 'float'
	      };
	    }

	    /**
	     * constructor
	     * @access public
	     * @constructor
	     */

	  }]);

	  function SCNActionPerformSelector() {
	    _classCallCheck(this, SCNActionPerformSelector);

	    var _this = _possibleConstructorReturn(this, (SCNActionPerformSelector.__proto__ || Object.getPrototypeOf(SCNActionPerformSelector)).call(this));

	    _this._actions = [];
	    _this._finished = false;
	    _this._duration = 0;
	    _this._timingMode = _SCNActionTimingMode2.default.linear;
	    _this._beginTime = 0;
	    _this._isRunning = false;
	    _this._pausedTime = 0;
	    return _this;
	  }

	  return SCNActionPerformSelector;
	}(_SCNAction3.default);

	exports.default = SCNActionPerformSelector;

/***/ },
/* 154 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _SCNAction2 = __webpack_require__(60);

	var _SCNAction3 = _interopRequireDefault(_SCNAction2);

	var _SCNActionTimingMode = __webpack_require__(61);

	var _SCNActionTimingMode2 = _interopRequireDefault(_SCNActionTimingMode);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var SCNActionPlaySound = function (_SCNAction) {
	  _inherits(SCNActionPlaySound, _SCNAction);

	  _createClass(SCNActionPlaySound, null, [{
	    key: '_propTypes',
	    get: function get() {
	      return {
	        _actions: 'NSArray',
	        _finished: 'boolean',
	        _duration: 'float',
	        _timingMode: 'integer',
	        _beginTime: 'float',
	        _isRunning: 'boolean',
	        _pausedTime: 'float',

	        name: ['string', null]
	      };
	    }

	    /**
	     * constructor
	     * @access public
	     * @constructor
	     */

	  }]);

	  function SCNActionPlaySound() {
	    _classCallCheck(this, SCNActionPlaySound);

	    var _this = _possibleConstructorReturn(this, (SCNActionPlaySound.__proto__ || Object.getPrototypeOf(SCNActionPlaySound)).call(this));

	    _this._actions = [];
	    _this._finished = false;
	    _this._duration = 0;
	    _this._timingMode = _SCNActionTimingMode2.default.linear;
	    _this._beginTime = 0;
	    _this._isRunning = false;
	    _this._pausedTime = 0;

	    _this._source = null;
	    _this._wait = false;
	    return _this;
	  }

	  /**
	   * Creates an action that plays an audio source.
	   * @access public
	   * @param {SCNAudioSource} source - The audio source to play.
	   * @param {boolean} wait - If true, the duration of this action is the same as the length of the audio playback. If false, the action is considered to have completed immediately.
	   * @returns {SCNAction} - 
	   * @desc When the action executes, SceneKit plays the audio source on the target nodeany positional audio effects are based on the nodes position. For more information about positional audio in SceneKit, see SCNAudioPlayer.This action is not reversible; the reverse of this action is the same action.
	   * @see https://developer.apple.com/reference/scenekit/scnaction/1523651-playaudio
	   */


	  _createClass(SCNActionPlaySound, [{
	    key: 'copy',


	    /**
	     * @access public
	     * @returns {SCNActionPlaySound} -
	     */
	    value: function copy() {
	      var action = _get(SCNActionPlaySound.prototype.__proto__ || Object.getPrototypeOf(SCNActionPlaySound.prototype), 'copy', this).call(this);

	      action._source = this._source;
	      action._wait = this._wait;

	      return action;
	    }

	    /**
	     * apply action to the given node.
	     * @access private
	     * @param {Object} obj - target object to apply this action.
	     * @param {number} time - active time
	     * @param {boolean} [needTimeConversion = true] -
	     * @returns {void}
	     */

	  }, {
	    key: '_applyAction',
	    value: function _applyAction(obj, time) {
	      var needTimeConversion = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

	      if (!this._isRunning) {
	        this._source._play();
	        this._isRunning = true;
	      }
	      if (this._duration <= 0 && this._source._duration > 0) {
	        this._duration = this._source._duration;
	      }
	      var t = this._getTime(time, needTimeConversion);

	      if (!this.wait) {
	        this._finished = true;
	      } else if (!this._source.loops && t >= 1) {
	        this._finished = true;
	      } else {
	        this._finished = false;
	      }
	    }
	  }], [{
	    key: 'playAudioWaitForCompletion',
	    value: function playAudioWaitForCompletion(source, wait) {
	      var action = new SCNActionPlaySound();
	      action._source = source;
	      action._wait = wait;
	      return action;
	    }
	  }]);

	  return SCNActionPlaySound;
	}(_SCNAction3.default);

	exports.default = SCNActionPlaySound;


	_SCNAction3.default.playAudioWaitForCompletion = SCNActionPlaySound.playAudioWaitForCompletion;

/***/ },
/* 155 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _SCNAction2 = __webpack_require__(60);

	var _SCNAction3 = _interopRequireDefault(_SCNAction2);

	var _SCNActionTimingMode = __webpack_require__(61);

	var _SCNActionTimingMode2 = _interopRequireDefault(_SCNActionTimingMode);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var SCNActionReference = function (_SCNAction) {
	  _inherits(SCNActionReference, _SCNAction);

	  _createClass(SCNActionReference, null, [{
	    key: '_propTypes',
	    get: function get() {
	      return {
	        _actions: 'NSArray',
	        _finished: 'boolean',
	        _duration: 'float',
	        _timingMode: 'integer',
	        _beginTime: 'float',
	        _isRunning: 'boolean',
	        _pausedTime: 'float'
	      };
	    }

	    /**
	     * constructor
	     * @access public
	     * @constructor
	     */

	  }]);

	  function SCNActionReference() {
	    _classCallCheck(this, SCNActionReference);

	    var _this = _possibleConstructorReturn(this, (SCNActionReference.__proto__ || Object.getPrototypeOf(SCNActionReference)).call(this));

	    _this._actions = [];
	    _this._finished = false;
	    _this._duration = 0;
	    _this._timingMode = _SCNActionTimingMode2.default.linear;
	    _this._beginTime = 0;
	    _this._isRunning = false;
	    _this._pausedTime = 0;
	    return _this;
	  }

	  return SCNActionReference;
	}(_SCNAction3.default);

	exports.default = SCNActionReference;

/***/ },
/* 156 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _SCNAction2 = __webpack_require__(60);

	var _SCNAction3 = _interopRequireDefault(_SCNAction2);

	var _SCNActionTimingMode = __webpack_require__(61);

	var _SCNActionTimingMode2 = _interopRequireDefault(_SCNActionTimingMode);

	var _SCNNode = __webpack_require__(65);

	var _SCNNode2 = _interopRequireDefault(_SCNNode);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var SCNActionRemove = function (_SCNAction) {
	  _inherits(SCNActionRemove, _SCNAction);

	  _createClass(SCNActionRemove, null, [{
	    key: '_propTypes',
	    get: function get() {
	      return {
	        _actions: 'NSArray',
	        _finished: 'boolean',
	        _duration: 'float',
	        _timingMode: 'integer',
	        _beginTime: 'float',
	        _isRunning: 'boolean',
	        _pausedTime: 'float'
	      };
	    }

	    /**
	     * constructor
	     * @access public
	     * @constructor
	     */

	  }]);

	  function SCNActionRemove() {
	    _classCallCheck(this, SCNActionRemove);

	    var _this = _possibleConstructorReturn(this, (SCNActionRemove.__proto__ || Object.getPrototypeOf(SCNActionRemove)).call(this));

	    _this._actions = [];
	    _this._finished = false;
	    _this._duration = 0;
	    _this._timingMode = _SCNActionTimingMode2.default.linear;
	    _this._beginTime = 0;
	    _this._isRunning = false;
	    _this._pausedTime = 0;
	    return _this;
	  }

	  /**
	   * Creates an action that removes the node from its parent.
	   * @access public
	   * @returns {SCNAction} - 
	   * @desc When the action executes, the node is immediately removed from its parent.This action is not reversible; the reverse of this action is the same action.
	   * @see https://developer.apple.com/reference/scenekit/scnaction/1522966-removefromparentnode
	   */


	  _createClass(SCNActionRemove, [{
	    key: 'copy',


	    /**
	     * @access public
	     * @returns {SCNActionRotate} -
	     */
	    value: function copy() {
	      var action = _get(SCNActionRemove.prototype.__proto__ || Object.getPrototypeOf(SCNActionRemove.prototype), 'copy', this).call(this);
	      return action;
	    }

	    /**
	     * apply action to the given node.
	     * @access private
	     * @param {Object} obj - target object to apply this action.
	     * @param {number} time - active time
	     * @param {boolean} [needTimeConversion = true] -
	     * @returns {void}
	     */

	  }, {
	    key: '_applyAction',
	    value: function _applyAction(obj, time) {
	      var needTimeConversion = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

	      if (!(obj instanceof _SCNNode2.default)) {
	        throw new Error('unsupported class for SCNActionRemove: ' + obj.constructor.name);
	      }
	      obj.removeFromParentNode();
	      this._finished = true;
	    }
	  }], [{
	    key: 'removeFromParentNode',
	    value: function removeFromParentNode() {
	      var action = new SCNActionRemove();
	      return action;
	    }
	  }]);

	  return SCNActionRemove;
	}(_SCNAction3.default);

	exports.default = SCNActionRemove;


	_SCNAction3.default.removeFromParentNode = SCNActionRemove.removeFromParentNode;

/***/ },
/* 157 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _SCNAction2 = __webpack_require__(60);

	var _SCNAction3 = _interopRequireDefault(_SCNAction2);

	var _SCNActionTimingMode = __webpack_require__(61);

	var _SCNActionTimingMode2 = _interopRequireDefault(_SCNActionTimingMode);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var SCNActionRepeat = function (_SCNAction) {
	  _inherits(SCNActionRepeat, _SCNAction);

	  _createClass(SCNActionRepeat, null, [{
	    key: '_propTypes',
	    get: function get() {
	      return {
	        _timesToRepeat: 'float',
	        _finished: 'boolean',
	        _duration: 'float',
	        _timingMode: 'integer',
	        _beginTime: 'float',
	        _isRunning: 'boolean',
	        _repeatedAction: 'SCNAction',
	        _forever: 'boolean',
	        _timesRepeated: 'integer',
	        _pausedTime: 'float',

	        name: ['string', null]
	      };
	    }

	    /**
	     * constructor
	     * @access public
	     * @constructor
	     */

	  }]);

	  function SCNActionRepeat() {
	    _classCallCheck(this, SCNActionRepeat);

	    var _this = _possibleConstructorReturn(this, (SCNActionRepeat.__proto__ || Object.getPrototypeOf(SCNActionRepeat)).call(this));

	    _this._timesToRepeat = 0;
	    _this._repeatedAction = null;
	    _this._forever = false;
	    _this._timesRepeated = 0;
	    _this._finished = false;
	    _this._duration = 0;
	    _this._timingMode = _SCNActionTimingMode2.default.linear;
	    _this._beginTime = 0;
	    _this._isRunning = false;
	    _this._pausedTime = 0;
	    return _this;
	  }

	  /**
	   * Creates an action that repeats another action a specified number of times.
	   * @access public
	   * @param {SCNAction} action - The action to be executed.
	   * @param {number} count - The number of times to execute the action.
	   * @returns {SCNAction} - 
	   * @desc When the action executes, the associated action runs to completion and then repeats, until the count is reached.This action is reversible; it creates a new action that is the reverse of the specified action and then repeats it the same number of times.
	   * @see https://developer.apple.com/reference/scenekit/scnaction/1522764-repeat
	   */


	  _createClass(SCNActionRepeat, [{
	    key: 'copy',


	    /**
	     * @access public
	     * @returns {SCNActionRepeat} -
	     */
	    value: function copy() {
	      var action = _get(SCNActionRepeat.prototype.__proto__ || Object.getPrototypeOf(SCNActionRepeat.prototype), 'copy', this).call(this);

	      action._timesToRepeat = this._timesToRepeat;
	      action._repeatedAction = this._repeatedAction.copy();
	      action._forever = this._forever;
	      action._timesRepeated = this._timesRepeated;

	      return action;
	    }
	  }, {
	    key: '_getTime',
	    value: function _getTime(time, needTimeConversion) {
	      if (!needTimeConversion) {
	        return time;
	      }

	      var baseTime = this._basetimeFromTime(time);
	      if (this.timingFunction === null) {
	        return baseTime;
	      }

	      var n = Math.floor(baseTime);
	      var t = this.timingFunction._getValueAtTime(baseTime - n);
	      return n + t;
	    }

	    /**
	     * apply action to the given node.
	     * @access private
	     * @param {Object} obj - target object to apply this action.
	     * @param {number} time - active time
	     * @param {boolean} [needTimeConversion = true] -
	     * @returns {void}
	     */

	  }, {
	    key: '_applyAction',
	    value: function _applyAction(obj, time) {
	      var needTimeConversion = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

	      var dt = this._getTime(time, needTimeConversion);
	      var timesRepeated = Math.floor(dt);
	      while (timesRepeated > this._timesRepeated) {
	        this._timesRepeated += 1;
	        this._repeatedAction._applyAction(obj, 1.0, false);
	        if (!this._forever && this._timesRepeated >= this._timesToRepeat) {
	          this._finished = true;
	          return;
	        }
	        this._repeatedAction._resetFinished();
	      }
	      var t = dt - this._timesRepeated;
	      this._repeatedAction._applyAction(obj, t, false);
	      this._finished = false;
	    }
	  }, {
	    key: '_resetFinished',
	    value: function _resetFinished() {
	      this._repeatedAction._resetFinished();
	      this._timesRepeated = 0;
	      this._finished = false;
	    }
	  }, {
	    key: 'duration',
	    get: function get() {
	      if (this._forever) {
	        return Infinity;
	      }
	      return this._repeatedAction.duration * this._timesToRepeat;
	    }
	  }], [{
	    key: 'repeat',
	    value: function repeat(action, count) {
	      var _action = new SCNActionRepeat();
	      _action._repeatedAction = action;
	      _action._duration = action.duration;
	      _action._timesToRepeat = count;
	      _action._forever = count === Infinity;
	      return _action;
	    }

	    /**
	     * Creates an action that repeats another action forever.
	     * @access public
	     * @param {SCNAction} action - The action to execute.
	     * @returns {SCNAction} - 
	     * @desc When the action executes, the associated action runs to completion and then repeats.This action is reversible; it creates a new action that is the reverse of the specified action and then repeats it forever.NoteThe action to be repeated must have a non-instantaneous duration.
	     * @see https://developer.apple.com/reference/scenekit/scnaction/1522908-repeatforever
	     */

	  }, {
	    key: 'repeatForever',
	    value: function repeatForever(action) {
	      return this.repeat(action, Infinity);
	    }
	  }]);

	  return SCNActionRepeat;
	}(_SCNAction3.default);

	exports.default = SCNActionRepeat;


	_SCNAction3.default.repeat = SCNActionRepeat.repeat;
	_SCNAction3.default.repeatForever = SCNActionRepeat.repeatForever;

/***/ },
/* 158 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _SCNAction2 = __webpack_require__(60);

	var _SCNAction3 = _interopRequireDefault(_SCNAction2);

	var _SCNActionTimingMode = __webpack_require__(61);

	var _SCNActionTimingMode2 = _interopRequireDefault(_SCNActionTimingMode);

	var _SCNNode = __webpack_require__(65);

	var _SCNNode2 = _interopRequireDefault(_SCNNode);

	var _SCNVector = __webpack_require__(44);

	var _SCNVector2 = _interopRequireDefault(_SCNVector);

	var _SCNVector3 = __webpack_require__(45);

	var _SCNVector4 = _interopRequireDefault(_SCNVector3);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var SCNActionRotate = function (_SCNAction) {
	  _inherits(SCNActionRotate, _SCNAction);

	  _createClass(SCNActionRotate, null, [{
	    key: '_propTypes',
	    get: function get() {
	      return {
	        _rotX: 'float',
	        _rotY: 'float',
	        _rotZ: 'float',
	        _lastRotX: 'float',
	        _lastRotY: 'float',
	        _lastRotZ: 'float',
	        _axisRot: 'SCNVector4',
	        _isRelative: 'boolean',
	        _isReversed: 'boolean',
	        _isUnitArc: 'boolean',
	        _isAxisAngle: 'boolean',
	        _isRunning: 'boolean',
	        _finished: 'boolean',
	        _duration: 'float',
	        _pausedTime: 'float',
	        _timingMode: 'integer',
	        _beginTime: 'float',

	        name: ['string', null]
	      };
	    }

	    /**
	     * constructor
	     * @access public
	     * @constructor
	     */

	  }]);

	  function SCNActionRotate() {
	    _classCallCheck(this, SCNActionRotate);

	    var _this = _possibleConstructorReturn(this, (SCNActionRotate.__proto__ || Object.getPrototypeOf(SCNActionRotate)).call(this));

	    _this._rotX = 0;
	    _this._rotY = 0;
	    _this._rotZ = 0;
	    _this._lastRotX = 0;
	    _this._lastRotY = 0;
	    _this._lastRotZ = 0;
	    _this._axisRot = new _SCNVector4.default();
	    _this._isRelative = false;
	    _this._isReversed = false;
	    _this._isUnitArc = false;
	    _this._isAxisAngle = false;
	    _this._isRunning = false;
	    _this._finished = false;
	    _this._duration = 0;
	    _this._pausedTime = 0;
	    _this._timingMode = _SCNActionTimingMode2.default.linear;
	    _this._beginTime = 0;
	    return _this;
	  }

	  /**
	   * Creates an action that rotates the node in each of the three principal axes by angles relative to its current orientation.
	   * @access public
	   * @param {number} xAngle - The amount to rotate the node counterclockwise around the x-axis of its local coordinate space, in radians.
	   * @param {number} yAngle - The amount to rotate the node counterclockwise around the y-axis of its local coordinate space, in radians.
	   * @param {number} zAngle - The amount to rotate the node counterclockwise around the z-axis of its local coordinate space, in radians.
	   * @param {number} duration - The duration, in seconds, of the animation.
	   * @returns {SCNAction} - 
	   * @desc When the action executes, the nodes rotation property animates to the new angle.This action is reversible; the reverse is created as if the following code had been executed:[SCNAction rotateByX: -xAngle y: -yAngle z: -zAngle duration: duration];
	  [SCNAction rotateByX: -xAngle y: -yAngle z: -zAngle duration: duration];
	    * @see https://developer.apple.com/reference/scenekit/scnaction/1523522-rotateby
	   */


	  _createClass(SCNActionRotate, [{
	    key: 'copy',


	    /**
	     * @access public
	     * @returns {SCNActionRotate} -
	     */
	    value: function copy() {
	      var action = _get(SCNActionRotate.prototype.__proto__ || Object.getPrototypeOf(SCNActionRotate.prototype), 'copy', this).call(this);

	      action._rotX = this._rotX;
	      action._rotY = this._rotY;
	      action._rotZ = this._rotZ;
	      action._lastRotX = this._lastRotX;
	      action._lastRotY = this._lastRotY;
	      action._lastRotZ = this._lastRotZ;
	      action._axisRot = this._axisRot;
	      action._isRelative = this._isRelative;
	      action._isReveresed = this._isReversed;
	      action._isUnitArc = this._isUnitArc;
	      action._isAxisAngle = this._isAxisAngle;
	      action._isRunning = this._isRunning;
	      action._finished = this._finished;
	      action._duration = this._duration;
	      action._pausedTime = this._pausedTime;
	      action._timingMode = this._timingMode;

	      return action;
	    }

	    /**
	     * apply action to the given node.
	     * @access private
	     * @param {Object} obj - target object to apply this action.
	     * @param {number} time - active time
	     * @param {boolean} [needTimeConversion = true] -
	     * @returns {void}
	     */

	  }, {
	    key: '_applyAction',
	    value: function _applyAction(obj, time) {
	      var needTimeConversion = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

	      if (!(obj instanceof _SCNNode2.default)) {
	        throw new Error('unsupported class for SCNActionRotate: ' + obj.constructor.name);
	      }
	      var t = this._getTime(time, needTimeConversion);
	      //console.warn(`SCNActionRotate._applyAction t: ${t}`)

	      if (this._isAxisAngle) {
	        // rotation
	        var baseValue = obj.rotation;
	        var toValue = this._axisRot;
	        if (this._isRelative) {
	          var baseQuat = baseValue.rotationToQuat;
	          var byQuat = this._axisRot.rotationToQuat;
	          toValue = baseQuat.cross(byQuat).quatToRotation;
	        }
	        if (this._isUnitArc) {
	          var value = this._slerp(baseValue.rotationToQuat(), toValue.rotationToQuat(), t);
	          obj.presentation.orientation = value;
	        } else {
	          var _value = this._lerp(baseValue, toValue, t);
	          obj.presentation.rotation = _value;
	        }
	        if (this._finished) {
	          obj.rotation = toValue;
	        }
	      } else {
	        // eulerAngles
	        var _toValue = new _SCNVector2.default(this._rotX, this._rotY, this._rotZ);
	        var _value2 = null;
	        if (this._isRelative) {
	          var _baseValue = obj.orientation;
	          _value2 = _baseValue.cross(_toValue.mul(t).eulerAnglesToQuat());
	          obj.presentation.orientation = _value2;
	        } else if (this._isUnitArc) {
	          var _baseValue2 = obj.orientation;
	          _value2 = this._slerp(_baseValue2, _toValue.eulerAnglesToQuat(), t);
	          obj.presentation.orientation = _value2;
	        } else {
	          var _baseValue3 = obj.eulerAngles;
	          _value2 = this._lerp(_baseValue3, _toValue, t);
	          obj.presentation.eulerAngles = _value2;
	        }

	        //obj.presentation.eulerAngles = value
	        if (this._finished) {
	          if (this._isRelative) {
	            _toValue = obj.orientation.cross(_toValue.eulerAnglesToQuat());
	            obj.orientation = _toValue;
	          } else {
	            obj.eulerAngles = _toValue;
	          }
	        }
	      }
	    }
	  }], [{
	    key: 'rotateByXYZ',
	    value: function rotateByXYZ(xAngle, yAngle, zAngle, duration) {
	      var action = new SCNActionRotate();
	      // TODO: Do research the reason why I need to turn around X and Y axes.
	      action._rotX = -xAngle;
	      action._rotY = -yAngle;
	      action._rotZ = zAngle;
	      action._duration = duration;
	      action._isRelative = true;
	      return action;
	    }

	    /**
	     * Creates an action that rotates the node to absolute angles in each of the three principal axes.
	     * @access public
	     * @param {number} xAngle - The amount to rotate the node counterclockwise around the x-axis of its local coordinate space, in radians.
	     * @param {number} yAngle - The amount to rotate the node counterclockwise around the y-axis of its local coordinate space, in radians.
	     * @param {number} zAngle - The amount to rotate the node counterclockwise around the z-axis of its local coordinate space, in radians.
	     * @param {number} duration - The duration, in seconds, of the animation.
	     * @returns {SCNAction} - 
	     * @desc When the action executes, the nodes rotation property animates to the new angle. Calling this method is equivalent to calling rotateTo(x:y:z:duration:usesShortestUnitArc:) and passing false for the shortestUnitArc parameter.This action is not reversible; the reverse of this action has the same duration but does not change anything.
	     * @see https://developer.apple.com/reference/scenekit/scnaction/1524044-rotateto
	     */

	  }, {
	    key: 'rotateToXYZ',
	    value: function rotateToXYZ(xAngle, yAngle, zAngle, duration) {
	      var action = new SCNActionRotate();
	      action._rotX = xAngle;
	      action._rotY = yAngle;
	      action._rotZ = zAngle;
	      action._duration = duration;
	      return action;
	    }

	    /**
	     * Creates an action that rotates the node to absolute angles in each of the three principal axes.
	     * @access public
	     * @param {number} xAngle - The amount to rotate the node counterclockwise around the x-axis of its local coordinate space, in radians.
	     * @param {number} yAngle - The amount to rotate the node counterclockwise around the y-axis of its local coordinate space, in radians.
	     * @param {number} zAngle - The amount to rotate the node counterclockwise around the z-axis of its local coordinate space, in radians.
	     * @param {number} duration - The duration, in seconds, of the animation.
	     * @param {boolean} shortestUnitArc - If false (the default), the animation interpolates each component of the nodes rotation between its current value and the new value. If true, the animation makes the most direct rotation possible from the nodes current orientation to the new orientation.
	     * @returns {SCNAction} - 
	     * @desc When the action executes, the nodes rotation property animates to the new angle.This action is not reversible; the reverse of this action has the same duration but does not change anything.
	     * @see https://developer.apple.com/reference/scenekit/scnaction/1522808-rotateto
	     */

	  }, {
	    key: 'rotateToXYZUsesShortestUnitArc',
	    value: function rotateToXYZUsesShortestUnitArc(xAngle, yAngle, zAngle, duration, shortestUnitArc) {
	      var action = new SCNActionRotate();
	      action._rotX = xAngle;
	      action._rotY = yAngle;
	      action._rotZ = zAngle;
	      action._duration = duration;
	      action._isUnitArc = shortestUnitArc;
	      return action;
	    }

	    /**
	     * Creates an action that rotates the node by an angle around a specified axis.
	     * @access public
	     * @param {number} angle - The amount to rotate the node counterclockwise around the specified axis, in radians.
	     * @param {SCNVector3} axis - A vector in the nodes local coordinate space whose direction specifies the axis of rotation.
	     * @param {number} duration - The duration, in seconds, of the animation.
	     * @returns {SCNAction} - 
	     * @desc When the action executes, the nodes rotation property animates to the new angle.This action is reversible; the reverse is created as if the following code had been executed:[SCNAction rotateByAngle: -angle aroundAxis: axis duration: sec];
	    [SCNAction rotateByAngle: -angle aroundAxis: axis duration: sec];
	      * @see https://developer.apple.com/reference/scenekit/scnaction/1523805-rotate
	     */

	  }, {
	    key: 'rotateByAround',
	    value: function rotateByAround(angle, axis, duration) {
	      var action = new SCNActionRotate();
	      action._axisRot.w = angle;
	      action._axisRot.x = axis.x;
	      action._axisRot.y = axis.y;
	      action._axisRot.z = axis.z;
	      action._duration = duration;
	      action._isRelative = true;
	      action._isAxisAngle = true;
	      return action;
	    }

	    /**
	     * Creates an action that rotates the node to an absolute angle around a specified axis.
	     * @access public
	     * @param {SCNVector4} axisAngle - A four-component vector whose first three components are a vector in the nodes local coordinate space specifying an axis and whose fourth component is the amount to rotate the node counterclockwise around that axis, in radians.
	     * @param {number} duration - The duration, in seconds, of the animation.
	     * @returns {SCNAction} - 
	     * @desc When the action executes, the nodes rotation property animates to the new angle.This action is not reversible; the reverse of this action has the same duration but does not change anything.
	     * @see https://developer.apple.com/reference/scenekit/scnaction/1524191-rotate
	     */

	  }, {
	    key: 'rotateToAxisAngle',
	    value: function rotateToAxisAngle(axisAngle, duration) {
	      var action = new SCNActionRotate();
	      action._axisRot = axisAngle;
	      action._duration = duration;
	      action._isAxisAngle = true;
	      return action;
	    }
	  }]);

	  return SCNActionRotate;
	}(_SCNAction3.default);

	exports.default = SCNActionRotate;


	_SCNAction3.default.rotateByXYZ = SCNActionRotate.rotateByXYZ;
	_SCNAction3.default.rotateToXYZ = SCNActionRotate.rotateToXYZ;
	_SCNAction3.default.rotateToXYZUsesShortestUnitArc = SCNActionRotate.rotateToXYZUsesShortestUnitArc;
	_SCNAction3.default.rotateByAround = SCNActionRotate.rotateByAround;
	_SCNAction3.default.rotateToAxisAngle = SCNActionRotate.rotateToAxisAngle;

/***/ },
/* 159 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _SCNAction2 = __webpack_require__(60);

	var _SCNAction3 = _interopRequireDefault(_SCNAction2);

	var _SCNActionTimingMode = __webpack_require__(61);

	var _SCNActionTimingMode2 = _interopRequireDefault(_SCNActionTimingMode);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var SCNActionRunAction = function (_SCNAction) {
	  _inherits(SCNActionRunAction, _SCNAction);

	  _createClass(SCNActionRunAction, null, [{
	    key: '_propTypes',
	    get: function get() {
	      return {
	        _actions: 'NSArray',
	        _finished: 'boolean',
	        _duration: 'float',
	        _timingMode: 'integer',
	        _beginTime: 'float',
	        _isRunning: 'boolean',
	        _pausedTime: 'float'
	      };
	    }

	    /**
	     * constructor
	     * @access public
	     * @constructor
	     */

	  }]);

	  function SCNActionRunAction() {
	    _classCallCheck(this, SCNActionRunAction);

	    var _this = _possibleConstructorReturn(this, (SCNActionRunAction.__proto__ || Object.getPrototypeOf(SCNActionRunAction)).call(this));

	    _this._actions = [];
	    _this._finished = false;
	    _this._duration = 0;
	    _this._timingMode = _SCNActionTimingMode2.default.linear;
	    _this._beginTime = 0;
	    _this._isRunning = false;
	    _this._pausedTime = 0;
	    return _this;
	  }

	  return SCNActionRunAction;
	}(_SCNAction3.default);

	exports.default = SCNActionRunAction;

/***/ },
/* 160 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _SCNAction2 = __webpack_require__(60);

	var _SCNAction3 = _interopRequireDefault(_SCNAction2);

	var _SCNActionTimingMode = __webpack_require__(61);

	var _SCNActionTimingMode2 = _interopRequireDefault(_SCNActionTimingMode);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var SCNActionRunBlock = function (_SCNAction) {
	  _inherits(SCNActionRunBlock, _SCNAction);

	  _createClass(SCNActionRunBlock, null, [{
	    key: '_propTypes',
	    get: function get() {
	      return {
	        _actions: 'NSArray',
	        _finished: 'boolean',
	        _duration: 'float',
	        _timingMode: 'integer',
	        _beginTime: 'float',
	        _isRunning: 'boolean',
	        _pausedTime: 'float',

	        name: ['string', null]
	      };
	    }

	    /**
	     * constructor
	     * @access public
	     * @constructor
	     */

	  }]);

	  function SCNActionRunBlock() {
	    _classCallCheck(this, SCNActionRunBlock);

	    var _this = _possibleConstructorReturn(this, (SCNActionRunBlock.__proto__ || Object.getPrototypeOf(SCNActionRunBlock)).call(this));

	    _this._actions = [];
	    _this._finished = false;
	    _this._duration = 0;
	    _this._timingMode = _SCNActionTimingMode2.default.linear;
	    _this._beginTime = 0;
	    _this._isRunning = false;
	    _this._pausedTime = 0;
	    return _this;
	  }

	  /**
	   * @access public
	   * @returns {SCNActionFade} -
	   */


	  _createClass(SCNActionRunBlock, [{
	    key: 'copy',
	    value: function copy() {
	      var action = _get(SCNActionRunBlock.prototype.__proto__ || Object.getPrototypeOf(SCNActionRunBlock.prototype), 'copy', this).call(this);

	      action._block = this._block;

	      return action;
	    }

	    /**
	     * Creates an action that executes a block.
	     * @access public
	     * @param {function(arg1: SCNNode): void} block - The block to run. The block takes a single parameter:nodeThe node on which the action is running.
	     * @returns {SCNAction} - 
	     * @desc When the action executes, SceneKit calls the block. This action takes place instantaneously.This action is not reversible; the reverse action executes the same block.
	     * @see https://developer.apple.com/reference/scenekit/scnaction/1523637-run
	     */

	  }, {
	    key: '_applyAction',


	    /**
	     * apply action to the given node.
	     * @access private
	     * @param {Object} obj - target object to apply this action.
	     * @param {number} time - active time
	     * @param {boolean} [needTimeConversion = true] -
	     * @returns {void}
	     */
	    value: function _applyAction(obj, time) {
	      var needTimeConversion = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

	      this._block(obj);
	      this._finished = true;
	    }
	  }], [{
	    key: 'run',
	    value: function run(block) {
	      var action = new SCNActionRunBlock();
	      action._block = block;
	      return action;
	    }
	  }]);

	  return SCNActionRunBlock;
	}(_SCNAction3.default);

	exports.default = SCNActionRunBlock;


	_SCNAction3.default.run = SCNActionRunBlock.run;

/***/ },
/* 161 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _SCNAction2 = __webpack_require__(60);

	var _SCNAction3 = _interopRequireDefault(_SCNAction2);

	var _SCNActionTimingMode = __webpack_require__(61);

	var _SCNActionTimingMode2 = _interopRequireDefault(_SCNActionTimingMode);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var SCNActionScale = function (_SCNAction) {
	  _inherits(SCNActionScale, _SCNAction);

	  _createClass(SCNActionScale, null, [{
	    key: '_propTypes',
	    get: function get() {
	      return {
	        _actions: 'NSArray',
	        _finished: 'boolean',
	        _duration: 'float',
	        _timingMode: 'integer',
	        _beginTime: 'float',
	        _isRunning: 'boolean',
	        _pausedTime: 'float'
	      };
	    }

	    /**
	     * constructor
	     * @access public
	     * @constructor
	     */

	  }]);

	  function SCNActionScale() {
	    _classCallCheck(this, SCNActionScale);

	    var _this = _possibleConstructorReturn(this, (SCNActionScale.__proto__ || Object.getPrototypeOf(SCNActionScale)).call(this));

	    _this._actions = [];
	    _this._finished = false;
	    _this._duration = 0;
	    _this._timingMode = _SCNActionTimingMode2.default.linear;
	    _this._beginTime = 0;
	    _this._isRunning = false;
	    _this._pausedTime = 0;
	    return _this;
	  }

	  return SCNActionScale;
	}(_SCNAction3.default);

	exports.default = SCNActionScale;

/***/ },
/* 162 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _SCNAction2 = __webpack_require__(60);

	var _SCNAction3 = _interopRequireDefault(_SCNAction2);

	var _SCNActionTimingMode = __webpack_require__(61);

	var _SCNActionTimingMode2 = _interopRequireDefault(_SCNActionTimingMode);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var SCNActionSequence = function (_SCNAction) {
	  _inherits(SCNActionSequence, _SCNAction);

	  _createClass(SCNActionSequence, null, [{
	    key: '_propTypes',
	    get: function get() {
	      return {
	        _actions: 'NSArray',
	        _finished: 'boolean',
	        '_mycaction->_animIndex': ['integer', '_animIndex'],
	        _duration: 'float',
	        _timingMode: 'integer',
	        _beginTime: 'float',
	        _isRunning: 'boolean',
	        _pausedTime: 'float',

	        name: ['string', null]
	      };
	    }

	    /**
	     * Creates an action that runs a collection of actions sequentially.
	     * @access public
	     * @constructor
	     * @param {SCNAction[]} actions - An array of SCNAction objects.
	     * @desc When the action executes, the first action in the sequence starts and runs to completion. Subsequent actions in the sequence run in a similar fashion until all of the actions in the sequence have executed. The duration of the sequence action is the sum of the durations of the actions in the sequence.This action is reversible; it creates a new sequence action that reverses the order of the actions. Each action in the reversed sequence is itself reversed. For example, the actions reverseSequence and sequenceReverse in the code example below are equivalent:SCNAction *sequence = [SCNAction sequence:@[ actionA, actionB, actionC ]];
	    SCNAction *reverseSequence = [SCNAction sequence:@[ [actionC reversedAction],
	                                                      [actionB reversedAction],
	                                                      [actionA reversedAction] ]];
	    SCNAction *sequenceReverse = [sequence reversedAction];
	    SCNAction *sequence = [SCNAction sequence:@[ actionA, actionB, actionC ]];
	    SCNAction *reverseSequence = [SCNAction sequence:@[ [actionC reversedAction],
	                                                      [actionB reversedAction],
	                                                      [actionA reversedAction] ]];
	    SCNAction *sequenceReverse = [sequence reversedAction];
	      * @see https://developer.apple.com/reference/scenekit/scnaction/1522793-sequence
	     */

	  }]);

	  function SCNActionSequence() {
	    _classCallCheck(this, SCNActionSequence);

	    var _this = _possibleConstructorReturn(this, (SCNActionSequence.__proto__ || Object.getPrototypeOf(SCNActionSequence)).call(this));

	    _this._actions = [];
	    _this._finished = false;
	    _this._animIndex = 0;
	    _this._duration = 0;
	    _this._timingMode = _SCNActionTimingMode2.default.linear;
	    _this._beginTime = 0;
	    _this._isRunning = false;
	    _this._pausedTime = 0;
	    return _this;
	  }

	  /**
	   * Creates an action that runs a collection of actions sequentially.
	   * @access public
	   * @param {SCNAction[]} actions - An array of SCNAction objects.
	   * @returns {SCNAction} - 
	   * @desc When the action executes, the first action in the sequence starts and runs to completion. Subsequent actions in the sequence run in a similar fashion until all of the actions in the sequence have executed. The duration of the sequence action is the sum of the durations of the actions in the sequence.This action is reversible; it creates a new sequence action that reverses the order of the actions. Each action in the reversed sequence is itself reversed. For example, the actions reverseSequence and sequenceReverse in the code example below are equivalent:SCNAction *sequence = [SCNAction sequence:@[ actionA, actionB, actionC ]];
	  SCNAction *reverseSequence = [SCNAction sequence:@[ [actionC reversedAction],
	                                                    [actionB reversedAction],
	                                                    [actionA reversedAction] ]];
	  SCNAction *sequenceReverse = [sequence reversedAction];
	  SCNAction *sequence = [SCNAction sequence:@[ actionA, actionB, actionC ]];
	  SCNAction *reverseSequence = [SCNAction sequence:@[ [actionC reversedAction],
	                                                    [actionB reversedAction],
	                                                    [actionA reversedAction] ]];
	  SCNAction *sequenceReverse = [sequence reversedAction];
	    * @see https://developer.apple.com/reference/scenekit/scnaction/1522793-sequence
	   */


	  _createClass(SCNActionSequence, [{
	    key: 'copy',


	    /**
	     * @access public
	     * @returns {SCNActionSequence} -
	     */
	    value: function copy() {
	      var action = _get(SCNActionSequence.prototype.__proto__ || Object.getPrototypeOf(SCNActionSequence.prototype), 'copy', this).call(this);

	      action._actions = this._actions.slice(0);
	      action._animIndex = this._animIndex;

	      return action;
	    }

	    /**
	     * apply action to the given node.
	     * @access private
	     * @param {Object} obj - target object to apply this action.
	     * @param {number} time - active time
	     * @param {boolean} [needTimeConversion = true] -
	     * @returns {void}
	     */

	  }, {
	    key: '_applyAction',
	    value: function _applyAction(obj, time) {
	      var needTimeConversion = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

	      var total = this.duration;
	      var duration = 0;
	      if (total <= 0 || total === Infinity) {
	        duration = this._activetimeFromTime(time);
	      } else {
	        duration = this._getTime(time, needTimeConversion) * total;
	      }

	      for (var i = 0; i < this._animIndex; i++) {
	        duration -= this._actions[i].duration / this._actions[i].speed;
	      }
	      for (; this._animIndex < this._actions.length; this._animIndex++) {
	        var action = this._actions[this._animIndex];
	        //action._applyAction(obj, duration, needTimeConversion)
	        action._applyAction(obj, duration, true);
	        duration -= action.duration / action.speed;
	        if (duration < 0) {
	          break;
	        }
	      }
	      if (this._animIndex >= this._actions.length) {
	        this._finished = true;
	      }
	    }
	  }, {
	    key: '_resetFinished',
	    value: function _resetFinished() {
	      this._actions.forEach(function (action) {
	        action._resetFinished();
	      });
	      this._finished = false;
	      this._animIndex = 0;
	    }
	  }, {
	    key: 'duration',
	    get: function get() {
	      var d = 0;
	      this._actions.forEach(function (act) {
	        if (act.speed > 0) {
	          d += act.duration / act.speed;
	        }
	      });
	      return d;
	    }
	  }], [{
	    key: 'sequence',
	    value: function sequence(actions) {
	      var action = new SCNActionSequence();
	      action._actions = actions;
	      action._duration = 0;
	      return action;
	    }
	  }]);

	  return SCNActionSequence;
	}(_SCNAction3.default);

	exports.default = SCNActionSequence;


	_SCNAction3.default.sequence = SCNActionSequence.sequence;

/***/ },
/* 163 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * The signature for a block that manages animation timing, used by the timingFunction property.
	 * @type {function(time: number): number}
	 * @param {number} time - A fraction of the actions The input value for the timing function, as determined by the timingMode property and the actions current progress.
	 * @returns {number} -
	 * @desc Your block must return a floating-point value between 0.0 and 1.0, where 0.0 represents the starting state of the actions animation and 1.0 represents the end state.
	 * @see https://developer.apple.com/reference/scenekit/scnactiontimingfunction
	 */

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var SCNActionTimingFunction = function SCNActionTimingFunction(time) {};

	exports.default = SCNActionTimingFunction;

/***/ },
/* 164 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _SCNAction2 = __webpack_require__(60);

	var _SCNAction3 = _interopRequireDefault(_SCNAction2);

	var _SCNActionTimingMode = __webpack_require__(61);

	var _SCNActionTimingMode2 = _interopRequireDefault(_SCNActionTimingMode);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var SCNActionWait = function (_SCNAction) {
	  _inherits(SCNActionWait, _SCNAction);

	  _createClass(SCNActionWait, null, [{
	    key: '_propTypes',
	    get: function get() {
	      return {
	        _actions: 'NSArray',
	        _finished: 'boolean',
	        _duration: 'float',
	        _timingMode: 'integer',
	        _beginTime: 'float',
	        _isRunning: 'boolean',
	        _pausedTime: 'float',

	        name: ['string', null]
	      };
	    }

	    /**
	     * constructor
	     * @access public
	     * @constructor
	     */

	  }]);

	  function SCNActionWait() {
	    _classCallCheck(this, SCNActionWait);

	    var _this = _possibleConstructorReturn(this, (SCNActionWait.__proto__ || Object.getPrototypeOf(SCNActionWait)).call(this));

	    _this._actions = [];
	    _this._finished = false;
	    _this._duration = 0;
	    _this._timingMode = _SCNActionTimingMode2.default.linear;
	    _this._beginTime = 0;
	    _this._isRunning = false;
	    _this._pausedTime = 0;
	    return _this;
	  }

	  /**
	   * Creates an action that idles for a specified period of time.
	   * @access public
	   * @param {number} sec - The amount of time to wait.
	   * @returns {SCNAction} - 
	   * @desc When the action executes, the action waits for the specified amount of time and then ends. This is typically used as part of a sequence of actions to insert a delay between two other actions. You might also use it in conjunction with the runAction(_:completionHandler:) method to trigger code that needs to run at a later time.This action is not reversible; the reverse of this action is the same action.
	   * @see https://developer.apple.com/reference/scenekit/scnaction/1523915-wait
	   */


	  _createClass(SCNActionWait, null, [{
	    key: 'waitDuration',
	    value: function waitDuration(sec) {
	      var action = new SCNActionWait();
	      action._duration = sec;
	      return action;
	    }

	    /**
	     * Creates an action that idles for a randomized period of time.
	     * @access public
	     * @param {number} sec - The average amount of time to wait.
	     * @param {number} durationRange - The range of possible values for the duration.
	     * @returns {SCNAction} - 
	     * @desc When the action executes, the action waits for the specified amount of time and then ends. This is typically used as part of a sequence of actions to insert a delay between two other actions. However, you might also use it in conjunction with the runAction(_:completionHandler:) method to trigger code that needs to run at a later time.Each time the action is executed, the action computes a new random value for the duration. The duration may vary in either direction by up to half of the value of the durationRange parameter.This action is not reversible; the reverse of this action is the same action.
	     * @see https://developer.apple.com/reference/scenekit/scnaction/1523086-wait
	     */

	  }, {
	    key: 'waitDurationWithRange',
	    value: function waitDurationWithRange(sec, durationRange) {
	      var duration = Math.max(0, sec + (Math.random() - 0.5) * durationRange);
	      var action = new SCNActionWait();
	      action._duration = duration;
	      return action;
	    }
	  }]);

	  return SCNActionWait;
	}(_SCNAction3.default);

	exports.default = SCNActionWait;


	_SCNAction3.default.waitDuration = SCNActionWait.waitDuration;
	_SCNAction3.default.waitDurationWithRange = SCNActionWait.waitDurationWithRange;

/***/ },
/* 165 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _CAAnimation = __webpack_require__(48);

	var _CAAnimation2 = _interopRequireDefault(_CAAnimation);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Signature for the block called when an animation event triggers.
	 * @type {function(animation: CAAnimation, animatedObject: Object, playingBackward: boolean): void}
	 * @param {CAAnimation} animation - The animation triggering the animation event.
	 * @param {Object} animatedObject - The Scene Kit object affected by the animation.
	 * @param {boolean} playingBackward - true if the animation is playing in reverse; otherwise, false.
	 * @returns {void}
	 * @see https://developer.apple.com/reference/scenekit/scnanimationeventblock
	 */
	var SCNAnimationEventBlock = function SCNAnimationEventBlock(animation, animatedObject, playingBackward) {};

	exports.default = SCNAnimationEventBlock;

/***/ },
/* 166 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * Options for locking the orientation of nodes affected by a billboard constraint.
	 * @access public
	 * @see https://developer.apple.com/reference/scenekit/scnbillboardaxis
	 */

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var SCNBillboardAxis = function () {
	  function SCNBillboardAxis() {
	    _classCallCheck(this, SCNBillboardAxis);
	  }

	  _createClass(SCNBillboardAxis, [{
	    key: 'init',


	    // Initializers

	    /**
	     * 
	     * @access public
	     * @param {number} rawValue - 
	     * @returns {void}
	     * @see https://developer.apple.com/reference/scenekit/scnbillboardaxis/1524212-init
	     */
	    value: function init(rawValue) {

	      // Constants

	      this._X = null;
	      this._Y = null;
	      this._Z = null;
	      this._all = null;
	    }
	  }, {
	    key: 'X',


	    // Constants
	    /**
	     * Align an affected node such that its x-axis is always parallel to that of the view, leaving it free to rotate otherwise.
	     * @type {SCNBillboardAxis}
	     * @desc 
	     * @see https://developer.apple.com/reference/scenekit/scnbillboardaxis/1468664-x
	     */
	    get: function get() {
	      return this._X;
	    }
	    /**
	     * Align an affected node such that its y-axis is always parallel to that of the view, leaving it free to rotate otherwise.
	     * @type {SCNBillboardAxis}
	     * @desc 
	     * @see https://developer.apple.com/reference/scenekit/scnbillboardaxis/1468668-y
	     */

	  }, {
	    key: 'Y',
	    get: function get() {
	      return this._Y;
	    }
	    /**
	     * Align an affected node such that its z-axis is always perpendicular to the viewing plane, leaving it free to rotate otherwise.
	     * @type {SCNBillboardAxis}
	     * @desc 
	     * @see https://developer.apple.com/reference/scenekit/scnbillboardaxis/1468647-z
	     */

	  }, {
	    key: 'Z',
	    get: function get() {
	      return this._Z;
	    }
	    /**
	     * Align an affected node such that its orientation always matches that of the view.
	     * @type {SCNBillboardAxis}
	     * @desc This is the default option for newly created billboard constraints.
	     * @see https://developer.apple.com/reference/scenekit/scnbillboardaxis/1468666-all
	     */

	  }, {
	    key: 'all',
	    get: function get() {
	      return this._all;
	    }
	  }]);

	  return SCNBillboardAxis;
	}();

	exports.default = SCNBillboardAxis;

/***/ },
/* 167 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _SCNConstraint2 = __webpack_require__(141);

	var _SCNConstraint3 = _interopRequireDefault(_SCNConstraint2);

	var _SCNBillboardAxis = __webpack_require__(166);

	var _SCNBillboardAxis2 = _interopRequireDefault(_SCNBillboardAxis);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * A constraint that orients a node to always point toward the current camera.
	 * @access public
	 * @extends {SCNConstraint}
	 * @see https://developer.apple.com/reference/scenekit/scnbillboardconstraint
	 */
	var SCNBillboardConstraint = function (_SCNConstraint) {
	  _inherits(SCNBillboardConstraint, _SCNConstraint);

	  function SCNBillboardConstraint() {
	    _classCallCheck(this, SCNBillboardConstraint);

	    return _possibleConstructorReturn(this, (SCNBillboardConstraint.__proto__ || Object.getPrototypeOf(SCNBillboardConstraint)).apply(this, arguments));
	  }

	  _createClass(SCNBillboardConstraint, [{
	    key: 'init',


	    /**
	     * constructor
	     * @access public
	     * @returns {void}
	     */
	    value: function init() {

	      // Working with a Constraints Degrees of Freedom

	      /**
	       * An option that specifies which degrees of freedom the constraint affects.
	       * @type {SCNBillboardAxis}
	       * @see https://developer.apple.com/reference/scenekit/scnbillboardconstraint/1468685-freeaxes
	       */
	      this.freeAxes = null;
	    }
	  }]);

	  return SCNBillboardConstraint;
	}(_SCNConstraint3.default);

	exports.default = SCNBillboardConstraint;

/***/ },
/* 168 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _SCNGeometry2 = __webpack_require__(68);

	var _SCNGeometry3 = _interopRequireDefault(_SCNGeometry2);

	var _SCNVector = __webpack_require__(44);

	var _SCNVector2 = _interopRequireDefault(_SCNVector);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/*global Ammo*/

	/**
	 * A right circular cylinder geometry whose ends are capped with hemispheres.
	 * @access public
	 * @extends {SCNGeometry}
	 * @see https://developer.apple.com/reference/scenekit/scncapsule
	 */
	var SCNCapsule = function (_SCNGeometry) {
	  _inherits(SCNCapsule, _SCNGeometry);

	  // Creating a Capsule

	  /**
	   * Creates a capsule geometry with the specified radius and height.
	   * @access public
	   * @constructor
	   * @param {number} capRadius - The radius both of the capsules cylindrical body and of its hemispherical ends.
	   * @param {number} height - The height of the capsule along the y-axis of its local coordinate space.
	   * @desc The capsule is centered in its local coordinate system. For example, if you create a capsule whose cap radius is 5.0 and height is 20.0, it extends from -10.0 to 10.0 in the y-axis, and the circular cross section at the center of its body extends from -5.0 to 5.0 along the x- and z-axes.
	   * @see https://developer.apple.com/reference/scenekit/scncapsule/1523790-init
	   */
	  function SCNCapsule(capRadius, height) {
	    _classCallCheck(this, SCNCapsule);

	    // Adjusting a Capsules Dimensions

	    /**
	     * The radius both of the capsules circular center cross section and of its hemispherical ends. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scncapsule/1523926-capradius
	     */
	    var _this = _possibleConstructorReturn(this, (SCNCapsule.__proto__ || Object.getPrototypeOf(SCNCapsule)).call(this));

	    _this.capRadius = capRadius;

	    /**
	     * The extent of the capsule along its y-axis. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scncapsule/1522789-height
	     */
	    _this.height = height;

	    // Adjusting Geometric Detail

	    /**
	     * The number of subdivisions around the lateral circumference of the capsule. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scncapsule/1522735-radialsegmentcount
	     */
	    _this.radialSegmentCount = 0;

	    /**
	     * The number of subdivisions in the height of each hemispherical end of the capsule. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scncapsule/1523561-capsegmentcount
	     */
	    _this.capSegmentCount = 0;

	    /**
	     * The number of subdivisions in the sides of the capsule along its y-axis. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scncapsule/1523697-heightsegmentcount
	     */
	    _this.heightSegmentCount = 0;
	    return _this;
	  }

	  /**
	   * @access private
	   * @returns {Ammo.btCollisionShape}
	   * @desc call Ammo.destroy(shape) after using it.
	   */


	  _createClass(SCNCapsule, [{
	    key: '_createBtCollisionShape',
	    value: function _createBtCollisionShape() {}
	    //const height = (this.height - this.capRadius) * 0.5
	    //const shape = new Ammo.btCapsuleShape(this.capRadius, height)
	    //return shape


	    /**
	     * The center point and radius of the objects bounding sphere.
	     * @type {Object}
	     * @parameter {SCNVector3} _boundingSphere.center -
	     * @parameter {number} _boundingSphere.radius -
	     * @returns {Object} -
	     * @desc Scene Kit defines a bounding sphere in the local coordinate space using a center point and a radius. For example, if a nodes bounding sphere has the center point {3, 1, 4} and radius 2.0, all points in the vertex data of nodes geometry (and any geometry attached to its child nodes) lie within 2.0 units of the center point.The coordinates provided when reading this property are valid only if the object has a volume to be measured. For a geometry containing no vertex data or a node containing no geometry (and whose child nodes, if any, contain no geometry), the values center and radius are both zero.
	     * @see https://developer.apple.com/reference/scenekit/scnboundingvolume/2034707-boundingsphere
	     */

	  }, {
	    key: 'getBoundingSphere',
	    value: function getBoundingSphere() {
	      var c = new _SCNVector2.default(0, 0, 0);
	      var r = this.height * 0.5;

	      return { center: c, radius: r };
	    }
	  }]);

	  return SCNCapsule;
	}(_SCNGeometry3.default);

	exports.default = SCNCapsule;

/***/ },
/* 169 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * Options for which edges of an extruded shape are chamfered, used by the chamferMode property.
	 * @typedef {Object} SCNChamferMode
	 * @property {number} both - Apply a chamfer to both front and back edges of the extruded shape.
	 * @property {number} front - Apply a chamfer to only the front edge of the extruded shape.
	 * @property {number} back - Apply a chamfer to only the back edge of the extruded shape.
	 * @see https://developer.apple.com/reference/scenekit/scnchamfermode
	 */

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var SCNChamferMode = {
	  both: 0,
	  front: 1,
	  back: 2
	};

	exports.default = SCNChamferMode;

/***/ },
/* 170 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _SCNGeometry2 = __webpack_require__(68);

	var _SCNGeometry3 = _interopRequireDefault(_SCNGeometry2);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * A right circular cone or frustum geometry.
	 * @access public
	 * @extends {SCNGeometry}
	 * @see https://developer.apple.com/reference/scenekit/scncone
	 */
	var SCNCone = function (_SCNGeometry) {
	  _inherits(SCNCone, _SCNGeometry);

	  function SCNCone() {
	    _classCallCheck(this, SCNCone);

	    return _possibleConstructorReturn(this, (SCNCone.__proto__ || Object.getPrototypeOf(SCNCone)).apply(this, arguments));
	  }

	  _createClass(SCNCone, [{
	    key: 'init',


	    /**
	     * constructor
	     * @access public
	     * @returns {void}
	     */
	    value: function init() {

	      // Adjusting a Cones Dimensions

	      /**
	       * The radius of the cones circular top. Animatable.
	       * @type {number}
	       * @see https://developer.apple.com/reference/scenekit/scncone/1524240-topradius
	       */
	      this.topRadius = 0;

	      /**
	       * The radius of the cones circular base. Animatable.
	       * @type {number}
	       * @see https://developer.apple.com/reference/scenekit/scncone/1523198-bottomradius
	       */
	      this.bottomRadius = 0;

	      /**
	       * The extent of the cylinder along its y-axis. Animatable.
	       * @type {number}
	       * @see https://developer.apple.com/reference/scenekit/scncone/1523219-height
	       */
	      this.height = 0;

	      // Adjusting Geometric Detail

	      /**
	       * The number of subdivisions around the circumference of the cone. Animatable.
	       * @type {number}
	       * @see https://developer.apple.com/reference/scenekit/scncone/1523942-radialsegmentcount
	       */
	      this.radialSegmentCount = 0;

	      /**
	       * The number of subdivisions in the sides of the cone along its y-axis. Animatable.
	       * @type {number}
	       * @see https://developer.apple.com/reference/scenekit/scncone/1524113-heightsegmentcount
	       */
	      this.heightSegmentCount = 0;
	    }

	    // Creating a Cone

	    /**
	     * Creates a cone geometry with the given top radius, bottom radius, and height.
	     * @access public
	     * @param {number} topRadius - The radius of the cones top, forming a circle in the x- and z-axis dimensions of its local coordinate space.
	     * @param {number} bottomRadius - The radius of the cones base, forming a circle in the x- and z-axis dimensions of its local coordinate space.
	     * @param {number} height - The height of the cone along the y-axis of its local coordinate space.
	     * @returns {void}
	     * @desc The cone is centered in its local coordinate system. For example, if you create a cone whose bottom radius is 5.0, top radius is 0.0, and height is 10.0, its apex is at the point {0, 5.0, 0}, and its base lies in the plane whose y-coordinate is -5.0, extending from -5.0 to 5.0 along both the x- and z-axes.Pass zero for topRadius or bottomRadius or parameter to create a cone whose sides taper to a single point, or a different value to create a frustum with a circular top.
	     * @see https://developer.apple.com/reference/scenekit/scncone/1522863-init
	     */

	  }, {
	    key: 'init',
	    value: function init(topRadius, bottomRadius, height) {}
	  }]);

	  return SCNCone;
	}(_SCNGeometry3.default);

	exports.default = SCNCone;

/***/ },
/* 171 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _SCNGeometry2 = __webpack_require__(68);

	var _SCNGeometry3 = _interopRequireDefault(_SCNGeometry2);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * A right circular cylinder geometry.
	 * @access public
	 * @extends {SCNGeometry}
	 * @see https://developer.apple.com/reference/scenekit/scncylinder
	 */
	var SCNCylinder = function (_SCNGeometry) {
	  _inherits(SCNCylinder, _SCNGeometry);

	  // Creating a Cylinder

	  /**
	   * Creates a cylinder geometry with the specified radius and height.
	   * @access public
	   * @constructor
	   * @param {number} radius - The radius of the cylinders circular cross section in the x- and z-axis dimensions of its local coordinate space.
	   * @param {number} height - The height of the cylinder along the y-axis of its local coordinate space.
	   * @desc The cylinder is centered in its local coordinate system. For example, if you create a cylinder whose radius is 5.0 and height is 10.0, its circular cross section extends from -5.0 to 5.0 along the x- and z-axes, and the y-coordinates of its base and top are -5.0 and 5.0, respectively.
	   * @see https://developer.apple.com/reference/scenekit/scncylinder/1523685-init
	   */
	  function SCNCylinder(radius, height) {
	    _classCallCheck(this, SCNCylinder);

	    // Adjusting a Cylinders Dimensions

	    /**
	     * The radius of the cylinders circular cross section. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scncylinder/1522674-radius
	     */
	    var _this = _possibleConstructorReturn(this, (SCNCylinder.__proto__ || Object.getPrototypeOf(SCNCylinder)).call(this));

	    _this.radius = radius;

	    /**
	     * The extent of the cylinder along its y-axis. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scncylinder/1523678-height
	     */
	    _this.height = height;

	    // Adjusting Geometric Detail

	    /**
	     * The number of subdivisions around the circumference of the cylinder. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scncylinder/1524002-radialsegmentcount
	     */
	    _this.radialSegmentCount = 0;

	    /**
	     * The number of subdivisions in the sides of the cylinder along its y-axis. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scncylinder/1523330-heightsegmentcount
	     */
	    _this.heightSegmentCount = 0;
	    return _this;
	  }

	  return SCNCylinder;
	}(_SCNGeometry3.default);

	exports.default = SCNCylinder;

/***/ },
/* 172 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _SCNGeometry2 = __webpack_require__(68);

	var _SCNGeometry3 = _interopRequireDefault(_SCNGeometry2);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * An infinite plane that can optionally display a reflection of the scene above it.
	 * @access public
	 * @extends {SCNGeometry}
	 * @see https://developer.apple.com/reference/scenekit/scnfloor
	 */
	var SCNFloor = function (_SCNGeometry) {
	  _inherits(SCNFloor, _SCNGeometry);

	  function SCNFloor() {
	    _classCallCheck(this, SCNFloor);

	    return _possibleConstructorReturn(this, (SCNFloor.__proto__ || Object.getPrototypeOf(SCNFloor)).apply(this, arguments));
	  }

	  _createClass(SCNFloor, [{
	    key: 'init',


	    /**
	     * constructor
	     * @access public
	     * @returns {void}
	     */
	    value: function init() {

	      // Adding Reflections to a Floor

	      /**
	       * The intensity of the scenes reflection on the floor. Animatable.
	       * @type {number}
	       * @see https://developer.apple.com/reference/scenekit/scnfloor/1524175-reflectivity
	       */
	      this.reflectivity = 0;

	      /**
	       * The distance from the floor at which scene contents are no longer reflected. Animatable.
	       * @type {number}
	       * @see https://developer.apple.com/reference/scenekit/scnfloor/1522781-reflectionfalloffend
	       */
	      this.reflectionFalloffEnd = 0;

	      /**
	       * The distance from the floor at which scene contents are reflected at full intensity. Animatable.
	       * @type {number}
	       * @see https://developer.apple.com/reference/scenekit/scnfloor/1524237-reflectionfalloffstart
	       */
	      this.reflectionFalloffStart = 0;

	      /**
	       * The resolution scale factor of the offscreen buffer that SceneKit uses to render reflections.
	       * @type {number}
	       * @see https://developer.apple.com/reference/scenekit/scnfloor/1522809-reflectionresolutionscalefactor
	       */
	      this.reflectionResolutionScaleFactor = 0;

	      // Instance Properties

	      /**
	       * 
	       * @type {number}
	       * @see https://developer.apple.com/reference/scenekit/scnfloor/2091890-length
	       */
	      this.length = 0;

	      /**
	       * 
	       * @type {number}
	       * @see https://developer.apple.com/reference/scenekit/scnfloor/1845281-reflectioncategorybitmask
	       */
	      this.reflectionCategoryBitMask = 0;

	      /**
	       * 
	       * @type {number}
	       * @see https://developer.apple.com/reference/scenekit/scnfloor/1845280-width
	       */
	      this.width = 0;
	    }
	  }]);

	  return SCNFloor;
	}(_SCNGeometry3.default);

	exports.default = SCNFloor;

/***/ },
/* 173 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _SCNConstraint2 = __webpack_require__(141);

	var _SCNConstraint3 = _interopRequireDefault(_SCNConstraint2);

	var _SCNNode = __webpack_require__(65);

	var _SCNNode2 = _interopRequireDefault(_SCNNode);

	var _SCNVector = __webpack_require__(44);

	var _SCNVector2 = _interopRequireDefault(_SCNVector);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * A constraint that applies inverse kinematics to make a chain of nodes reach toward a target point.
	 * @access public
	 * @extends {SCNConstraint}
	 * @see https://developer.apple.com/reference/scenekit/scnikconstraint
	 */
	var SCNIKConstraint = function (_SCNConstraint) {
	  _inherits(SCNIKConstraint, _SCNConstraint);

	  function SCNIKConstraint() {
	    _classCallCheck(this, SCNIKConstraint);

	    return _possibleConstructorReturn(this, (SCNIKConstraint.__proto__ || Object.getPrototypeOf(SCNIKConstraint)).apply(this, arguments));
	  }

	  _createClass(SCNIKConstraint, [{
	    key: 'init',


	    // Creating an Inverse Kinematics Constraint

	    /**
	     * Initializes an inverse kinematics constraint whose chain of nodes begins with the specified node.
	     * @access public
	     * @param {SCNNode} chainRootNode - 
	     * @returns {void}
	     * @desc The root node is the highest node in the hierarchy moved by the constraint. For example, a robot arm may have two arm segments and a hand connected to a body. The upper arm is a child node of the body, the lower arm is a child node of the upper arm, and the hand is a child node of the lower arm. In this case, the upper arm is the chain root node, because the body should not move to follow the hand.The node you apply the constraint to (using that nodes constraints property) is the end effector of the chainthe lowest node in the hierarchy. When you set the constraints targetPosition property, SceneKit attempts to move this node toward the target point by rotating it relative to its parent node (and rotating its parent and ancestor nodes, up the chain ending with the chainRoot node). Continuing the above example, the end effector of the robot arm is its hand.
	     * @see https://developer.apple.com/reference/scenekit/scnikconstraint/1468694-init
	     */
	    value: function init(chainRootNode) {

	      // Adjusting the Constraints Limits of Motion

	      this._chainRootNode = null;

	      // Applying Inverse Kinematics to the Constrained Node

	      /**
	       * The desired position for the constrained node, in the scenes world coordinate space. Animatable.
	       * @type {SCNVector3}
	       * @see https://developer.apple.com/reference/scenekit/scnikconstraint/1468651-targetposition
	       */
	      this.targetPosition = null;
	    }

	    /**
	     * Creates an inverse kinematics constraint whose chain of nodes begins with the specified node.
	     * @access public
	     * @param {SCNNode} chainRootNode - 
	     * @returns {SCNIKConstraint} - 
	     * @desc The root node is the highest node in the hierarchy moved by the constraint. For example, a robot arm may have two arm segments and a hand connected to a body. The upper arm is a child node of the body, the lower arm is a child node of the upper arm, and the hand is a child node of the lower arm. In this case, the upper arm is the chain root node, because the body should not move to follow the hand.The node you apply the constraint to (using that nodes constraints property) is the end effector of the chainthe lowest node in the hierarchy. When you set the constraints targetPosition property, SceneKit attempts to move this node toward the target point by rotating it relative to its parent node (and rotating its parent and ancestor nodes, up the chain ending with the chainRoot node). Continuing the above example, the end effector of the robot arm is its hand.
	     * @see https://developer.apple.com/reference/scenekit/scnikconstraint/1468653-inversekinematicsconstraint
	     */

	  }, {
	    key: 'maxAllowedRotationAngleForJoint',


	    // Adjusting the Constraints Limits of Motion

	    /**
	     * Returns the rotation limit, in degrees, for the specified node.
	     * @access public
	     * @param {SCNNode} node - A node affected by the constrainteither the node whose constraints property references the constraint or one of that nodes parent or ancestor nodes, up to the node specified by the constraints chainRootNode property.
	     * @returns {number} - 
	     * @desc When SceneKit evaluates the IK constraint, it checks the target orientations of each node in the chain relative to their initial orientations (as of when the constraint was applied to a node). For each node in the chain, SceneKit limits the rotation (in any direction) between the initial and target orientations to the value returned by this method.The default rotation limit for each joint is 180 degrees in either direction, allowing unconstrained rotation.
	     * @see https://developer.apple.com/reference/scenekit/scnikconstraint/1468681-maxallowedrotationangle
	     */
	    value: function maxAllowedRotationAngleForJoint(node) {
	      return 0;
	    }

	    /**
	     * Sets the rotation limit, in degrees, for the specified node.
	     * @access public
	     * @param {number} angle - The maximum rotation, in degrees, that SceneKit should apply to the specified node when evaluating the constraint.
	     * @param {SCNNode} node - A node affected by the constrainteither the node whose constraints property references the constraint, or one of that nodes parent or ancestor nodes up to the node specified by the constraints chainRootNode property.
	     * @returns {void}
	     * @desc When SceneKit evaluates the IK constraint, it checks the target orientations of each node in the chain relative to their initial orientations (as of when the constraint was applied to a node). For each node in the chain, SceneKit limits the rotation (in any direction) between the initial and target orientations to the angle value specified with this method.The default rotation limit for each joint is 180 degrees in either direction, allowing unconstrained rotation.
	     * @see https://developer.apple.com/reference/scenekit/scnikconstraint/1468649-setmaxallowedrotationangle
	     */

	  }, {
	    key: 'setMaxAllowedRotationAngleForJoint',
	    value: function setMaxAllowedRotationAngleForJoint(angle, node) {}
	    /**
	     * The parent node of the hierarchy affected by the constraint.
	     * @type {SCNNode}
	     * @desc The root node is the highest node in the hierarchy moved by the constraint. For example, a robot arm may have two arm segments and a hand connected to a body. The upper arm is a child node of the body, the lower arm is a child node of the upper arm, and the hand is a child node of the lower arm. In this case, the upper arm is the chain root node, because the body should not move to follow the hand.
	     * @see https://developer.apple.com/reference/scenekit/scnikconstraint/1468690-chainrootnode
	     */

	  }, {
	    key: 'chainRootNode',
	    get: function get() {
	      return this._chainRootNode;
	    }
	  }], [{
	    key: 'inverseKinematicsConstraint',
	    value: function inverseKinematicsConstraint(chainRootNode) {
	      return null;
	    }
	  }]);

	  return SCNIKConstraint;
	}(_SCNConstraint3.default);

	exports.default = SCNIKConstraint;

/***/ },
/* 174 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _SCNScene = __webpack_require__(90);

	var _SCNScene2 = _interopRequireDefault(_SCNScene);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	/**
	 * A Core Animation layer that renders a SceneKit scene as its content.
	 * @access public
	 * @see https://developer.apple.com/reference/scenekit/scnlayer
	 */
	var SCNLayer = function () {
	  function SCNLayer() {
	    _classCallCheck(this, SCNLayer);
	  }

	  _createClass(SCNLayer, [{
	    key: 'init',


	    /**
	     * constructor
	     * @access public
	     * @returns {void}
	     */
	    value: function init() {

	      // Specifying a Scene

	      /**
	       * The scene to be displayed in the layer.
	       * @type {?SCNScene}
	       * @see https://developer.apple.com/reference/scenekit/scnlayer/1393188-scene
	       */
	      this.scene = null;
	    }
	  }]);

	  return SCNLayer;
	}();

	exports.default = SCNLayer;

/***/ },
/* 175 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _SCNConstraint2 = __webpack_require__(141);

	var _SCNConstraint3 = _interopRequireDefault(_SCNConstraint2);

	var _SCNNode = __webpack_require__(65);

	var _SCNNode2 = _interopRequireDefault(_SCNNode);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * A constraint that orients a node to always point toward a specified other node. 
	 * @access public
	 * @extends {SCNConstraint}
	 * @see https://developer.apple.com/reference/scenekit/scnlookatconstraint
	 */
	var SCNLookAtConstraint = function (_SCNConstraint) {
	  _inherits(SCNLookAtConstraint, _SCNConstraint);

	  // Creating a Look-At Constraint

	  /**
	   * Creates a look-at constraint for a specified target node.
	   * @access public
	   * @construtor
	   * @param {?SCNNode} target - The node that constrained nodes will be reoriented to point toward.
	   * @desc To attach constraints to an SCNNode object, use its constraints property.
	   * @see https://developer.apple.com/reference/scenekit/scnlookatconstraint/1468683-init
	   */
	  function SCNLookAtConstraint(target) {
	    _classCallCheck(this, SCNLookAtConstraint);

	    // Modifying a Constraint

	    /**
	     * A Boolean value that specifies whether constrained nodes are allowed to rotate.
	     * @type {boolean}
	     * @see https://developer.apple.com/reference/scenekit/scnlookatconstraint/1468675-isgimballockenabled
	     */
	    var _this = _possibleConstructorReturn(this, (SCNLookAtConstraint.__proto__ || Object.getPrototypeOf(SCNLookAtConstraint)).call(this));

	    _this.isGimbalLockEnabled = false;

	    /**
	     * The node toward which constrained nodes will point after being reoriented.
	     * @type {?SCNNode}
	     * @see https://developer.apple.com/reference/scenekit/scnlookatconstraint/1468677-target
	     */
	    _this.target = null;
	    return _this;
	  }

	  return SCNLookAtConstraint;
	}(_SCNConstraint3.default);

	exports.default = SCNLookAtConstraint;

/***/ },
/* 176 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _SCNMatrix = __webpack_require__(46);

	var _SCNMatrix2 = _interopRequireDefault(_SCNMatrix);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Returns a Boolean value that indicates whether the corresponding elements of two matrices are equal.
	 * @access public
	 * @param {SCNMatrix4} a - 
	 * @param {SCNMatrix4} b - 
	 * @returns {boolean} - 
	 * @desc This function performs a numeric (not bitwise) comparison of each pair of elements.
	 * @see https://developer.apple.com/reference/scenekit/1409665-scnmatrix4equaltomatrix4
	 */
	var SCNMatrix4EqualToMatrix4 = function SCNMatrix4EqualToMatrix4(a, b) {
	  if (!(a instanceof _SCNMatrix2.default)) {
	    return false;
	  }
	  return a.equalTo(b);
	};

	exports.default = SCNMatrix4EqualToMatrix4;

/***/ },
/* 177 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _SCNMatrix = __webpack_require__(46);

	var _SCNMatrix2 = _interopRequireDefault(_SCNMatrix);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	//import GLKMatrix4 from '../undefined/GLKMatrix4'

	/**
	 * Returns a SceneKit matrix corresponding to a GLKit matrix.
	 * @access public
	 * @param {GLKMatrix4} mat - A GLKit matrix.
	 * @returns {SCNMatrix4} - 
	 * @see https://developer.apple.com/reference/scenekit/1409699-scnmatrix4fromglkmatrix4
	 */
	var SCNMatrix4FromGLKMatrix4 = function SCNMatrix4FromGLKMatrix4(mat) {
	  return null;
	};

	exports.default = SCNMatrix4FromGLKMatrix4;

/***/ },
/* 178 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _SCNMatrix = __webpack_require__(46);

	var _SCNMatrix2 = _interopRequireDefault(_SCNMatrix);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * 
	 * @access public
	 * @param {number[][]} m - 
	 * @returns {SCNMatrix4} - 
	 * @see https://developer.apple.com/reference/scenekit/1522632-scnmatrix4frommat4
	 */
	var SCNMatrix4FromMat4 = function SCNMatrix4FromMat4(m) {
	  return null;
	};

	exports.default = SCNMatrix4FromMat4;

/***/ },
/* 179 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _SCNMatrix = __webpack_require__(46);

	var _SCNMatrix2 = _interopRequireDefault(_SCNMatrix);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Returns the inverse of the specified matrix.
	 * @access public
	 * @param {SCNMatrix4} m - 
	 * @returns {SCNMatrix4} - 
	 * @see https://developer.apple.com/reference/scenekit/1409682-scnmatrix4invert
	 */
	var SCNMatrix4Invert = function SCNMatrix4Invert(m) {
	  return m.invert();
	};

	exports.default = SCNMatrix4Invert;

/***/ },
/* 180 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _SCNMatrix = __webpack_require__(46);

	var _SCNMatrix2 = _interopRequireDefault(_SCNMatrix);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	//import SCNMatrix4EqualToMatrix4 from './SCNMatrix4EqualToMatrix4'

	var _identity = new _SCNMatrix2.default();

	/**
	 * Returns a Boolean value that indicates whether the specified matrix is equal to the identity matrix.
	 * @access public
	 * @param {SCNMatrix4} m - 
	 * @returns {boolean} - 
	 * @see https://developer.apple.com/reference/scenekit/1409715-scnmatrix4isidentity
	 */
	var SCNMatrix4IsIdentity = function SCNMatrix4IsIdentity(m) {
	  return m.isIdentity();
	};

	exports.default = SCNMatrix4IsIdentity;

/***/ },
/* 181 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _SCNMatrix = __webpack_require__(46);

	var _SCNMatrix2 = _interopRequireDefault(_SCNMatrix);

	var _SCNVector = __webpack_require__(44);

	var _SCNVector2 = _interopRequireDefault(_SCNVector);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Returns a matrix describing a rotation transformation.
	 * @access public
	 * @param {number} angle - The amount of rotation, in radians, measured counterclockwise around the rotation axis.
	 * @param {number} x - The x-component of the rotation axis.
	 * @param {number} y - The y-component of the rotation axis.
	 * @param {number} z - The z-component of the rotation axis.
	 * @returns {SCNMatrix4} - 
	 * @see https://developer.apple.com/reference/scenekit/1409686-scnmatrix4makerotation
	 */
	var SCNMatrix4MakeRotation = function SCNMatrix4MakeRotation(angle, x, y, z) {
	  var c = Math.cos(angle);
	  var s = Math.sin(angle);
	  var v = new _SCNVector2.default(x, y, z);
	  var m = new _SCNMatrix2.default();

	  var nx = v.x;
	  var ny = v.y;
	  var nz = v.z;

	  m.m11 = nx * nx * (1.0 - c) + c;
	  m.m12 = nx * ny * (1.0 - c) - nz * s;
	  m.m13 = nx * nz * (1.0 - c) + ny * s;
	  m.m14 = 0.0;
	  m.m21 = ny * nx * (1.0 - c) + nz * s;
	  m.m22 = ny * ny * (1.0 - c) + c;
	  m.m23 = ny * nz * (1.0 - c) - nx * s;
	  m.m24 = 0.0;
	  m.m31 = nz * nx * (1.0 - c) - ny * s;
	  m.m32 = nz * ny * (1.0 - c) + nx * s;
	  m.m33 = nz * nz * (1.0 - c) + c;
	  m.m34 = 0.0;
	  m.m41 = 0.0;
	  m.m42 = 0.0;
	  m.m43 = 0.0;
	  m.m44 = 1.0;

	  return m;
	};

	exports.default = SCNMatrix4MakeRotation;

/***/ },
/* 182 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _SCNMatrix = __webpack_require__(46);

	var _SCNMatrix2 = _interopRequireDefault(_SCNMatrix);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Returns the product of two matrices.
	 * @access public
	 * @param {SCNMatrix4} a - 
	 * @param {SCNMatrix4} b - 
	 * @returns {SCNMatrix4} - 
	 * @desc Matrix multiplication is not commutative. As a transformation, the result of multiplying a matrix A by a matrix B is the transformation represented by B followed by the transformation represented by A.
	 * @see https://developer.apple.com/reference/scenekit/1409697-scnmatrix4mult
	 */
	var SCNMatrix4Mult = function SCNMatrix4Mult(a, b) {
	  return a.mult(b);
	};

	exports.default = SCNMatrix4Mult;

/***/ },
/* 183 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _SCNMatrix = __webpack_require__(46);

	var _SCNMatrix2 = _interopRequireDefault(_SCNMatrix);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Returns a new matrix created by concatenating the specified matrix with a rotation transformation.
	 * @access public
	 * @param {SCNMatrix4} m - 
	 * @param {number} angle - The amount of rotation, in radians, measured counterclockwise around the rotation axis.
	 * @param {number} x - The x-component of the rotation axis.
	 * @param {number} y - The y-component of the rotation axis.
	 * @param {number} z - The z-component of the rotation axis.
	 * @returns {SCNMatrix4} - 
	 * @desc The resulting transformation consists of the specified rotation followed by the transformation represented by the mat parameter.
	 * @see https://developer.apple.com/reference/scenekit/1409659-scnmatrix4rotate
	 */
	var SCNMatrix4Rotate = function SCNMatrix4Rotate(m, angle, x, y, z) {
	  return m.rotation(x, y, z, angle);
	};

	exports.default = SCNMatrix4Rotate;

/***/ },
/* 184 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _SCNMatrix = __webpack_require__(46);

	var _SCNMatrix2 = _interopRequireDefault(_SCNMatrix);

	var _SCNMatrix4MakeScale = __webpack_require__(140);

	var _SCNMatrix4MakeScale2 = _interopRequireDefault(_SCNMatrix4MakeScale);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Returns a new matrix created by concatenating the specified matrix with a scale transformation.
	 * @access public
	 * @param {SCNMatrix4} m - 
	 * @param {number} sx - 
	 * @param {number} sy - 
	 * @param {number} sz - 
	 * @returns {SCNMatrix4} - 
	 * @desc The resulting transformation consists of the specified scale followed by the transformation represented by the mat parameter.
	 * @see https://developer.apple.com/reference/scenekit/1409653-scnmatrix4scale
	 */
	var SCNMatrix4Scale = function SCNMatrix4Scale(m, sx, sy, sz) {
	  return m.mult((0, _SCNMatrix4MakeScale2.default)(sx, sy, sz));
	};

	exports.default = SCNMatrix4Scale;

/***/ },
/* 185 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	//import GLKMatrix4 from '../undefined/GLKMatrix4'

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _SCNMatrix = __webpack_require__(46);

	var _SCNMatrix2 = _interopRequireDefault(_SCNMatrix);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Returns a GLKit matrix corresponding to a SceneKit matrix.
	 * @access public
	 * @param {SCNMatrix4} mat - A SceneKit matrix.
	 * @returns {GLKMatrix4} - 
	 * @see https://developer.apple.com/reference/scenekit/1409703-scnmatrix4toglkmatrix4
	 */
	var SCNMatrix4ToGLKMatrix4 = function SCNMatrix4ToGLKMatrix4(mat) {
	  return null;
	};exports.default = SCNMatrix4ToGLKMatrix4;

/***/ },
/* 186 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _SCNMatrix = __webpack_require__(46);

	var _SCNMatrix2 = _interopRequireDefault(_SCNMatrix);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * @access public
	 * @type {function}
	 * @param {SCNMatrix4} m - 
	 * @returns {number[][]} - 
	 * @see https://developer.apple.com/reference/scenekit/1523928-scnmatrix4tomat4
	 */
	var SCNMatrix4ToMat4 = function SCNMatrix4ToMat4(m) {
	  return null;
	};

	exports.default = SCNMatrix4ToMat4;

/***/ },
/* 187 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _SCNMatrix = __webpack_require__(46);

	var _SCNMatrix2 = _interopRequireDefault(_SCNMatrix);

	var _SCNMatrix4MakeTranslation = __webpack_require__(78);

	var _SCNMatrix4MakeTranslation2 = _interopRequireDefault(_SCNMatrix4MakeTranslation);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Returns a new matrix created by concatenating the specified matrix with a translation transformation.
	 * @access public
	 * @param {SCNMatrix4} m - 
	 * @param {number} tx - 
	 * @param {number} ty - 
	 * @param {number} tz - 
	 * @returns {SCNMatrix4} - 
	 * @desc The resulting transformation consists of the specified translation followed by the transformation represented by the mat parameter.
	 * @see https://developer.apple.com/reference/scenekit/1409717-scnmatrix4translate
	 */
	var SCNMatrix4Translate = function SCNMatrix4Translate(m, tx, ty, tz) {
	  return m.mult((0, _SCNMatrix4MakeTranslation2.default)(tx, ty, tz));
	};

	exports.default = SCNMatrix4Translate;

/***/ },
/* 188 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _SCNPhysicsBehavior2 = __webpack_require__(100);

	var _SCNPhysicsBehavior3 = _interopRequireDefault(_SCNPhysicsBehavior2);

	var _SCNPhysicsBody = __webpack_require__(103);

	var _SCNPhysicsBody2 = _interopRequireDefault(_SCNPhysicsBody);

	var _SCNVector = __webpack_require__(44);

	var _SCNVector2 = _interopRequireDefault(_SCNVector);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * A physics behavior that connects two physics bodies and allows them to pivot around each other in any direction.
	 * @access public
	 * @extends {SCNPhysicsBehavior}
	 * @see https://developer.apple.com/reference/scenekit/scnphysicsballsocketjoint
	 */
	var SCNPhysicsBallSocketJoint = function (_SCNPhysicsBehavior) {
	  _inherits(SCNPhysicsBallSocketJoint, _SCNPhysicsBehavior);

	  // Creating a Ball and Socket Joint

	  /**
	   * Creates a ball and socket joint connecting two physics bodies.
	   * @access public
	   * @constructor
	   * @param {SCNPhysicsBody} bodyA - The first physics body to be connected by the joint.
	   * @param {SCNVector3} anchorA - The point at which the joint connects, relative to the node containing the first body.
	   * @param {SCNPhysicsBody} bodyB - The second physics body to be connected by the joint.
	   * @param {SCNVector3} anchorB - The point at which the joint connects, relative to the node containing the second body.
	   * @desc For a behavior to take effect, add it to the physics simulation by calling the addBehavior(_:) method on your scenes SCNPhysicsWorld object. The physics bodies constrained by the joint must be attached to nodes in the scene.
	   * @see https://developer.apple.com/reference/scenekit/scnphysicsballsocketjoint/1387926-init
	   */
	  function SCNPhysicsBallSocketJoint(bodyA, anchorA, bodyB, anchorB) {
	    _classCallCheck(this, SCNPhysicsBallSocketJoint);

	    // Managing the Characteristics of a Ball and Socket Joint

	    /**
	     * The point at which the joint connects, relative to the node containing the first body.
	     * @type {SCNVector3}
	     * @see https://developer.apple.com/reference/scenekit/scnphysicsballsocketjoint/1387956-anchora
	     */
	    var _this = _possibleConstructorReturn(this, (SCNPhysicsBallSocketJoint.__proto__ || Object.getPrototypeOf(SCNPhysicsBallSocketJoint)).call(this));

	    _this.anchorA = null;

	    /**
	     * The point at which the joint connects, relative to the node containing the second body.
	     * @type {SCNVector3}
	     * @see https://developer.apple.com/reference/scenekit/scnphysicsballsocketjoint/1387965-anchorb
	     */
	    _this.anchorB = null;

	    _this._bodyA = null;
	    _this._bodyB = null;
	    return _this;
	  }

	  // Managing the Characteristics of a Ball and Socket Joint

	  /**
	   * The first physics body connected by the joint.
	   * @type {SCNPhysicsBody}
	   * @desc 
	   * @see https://developer.apple.com/reference/scenekit/scnphysicsballsocketjoint/1387981-bodya
	   */


	  _createClass(SCNPhysicsBallSocketJoint, [{
	    key: 'bodyA',
	    get: function get() {
	      return this._bodyA;
	    }

	    /**
	     * The second physics body connected by the joint.
	     * @type {?SCNPhysicsBody}
	     * @desc This propertys value is nil if the joint was created using the init(body:anchor:) method.
	     * @see https://developer.apple.com/reference/scenekit/scnphysicsballsocketjoint/1387902-bodyb
	     */

	  }, {
	    key: 'bodyB',
	    get: function get() {
	      return this._bodyB;
	    }
	  }]);

	  return SCNPhysicsBallSocketJoint;
	}(_SCNPhysicsBehavior3.default);

	exports.default = SCNPhysicsBallSocketJoint;

/***/ },
/* 189 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * Default values for a physics bodys categoryBitMask and collisionBitMask properties.
	 * @access public
	 * @see https://developer.apple.com/reference/scenekit/scnphysicscollisioncategory
	 */

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var SCNPhysicsCollisionCategory = function () {
	  function SCNPhysicsCollisionCategory() {
	    _classCallCheck(this, SCNPhysicsCollisionCategory);
	  }

	  _createClass(SCNPhysicsCollisionCategory, [{
	    key: 'init',


	    // Initializers

	    /**
	     * 
	     * @access public
	     * @param {number} rawValue - 
	     * @returns {void}
	     * @see https://developer.apple.com/reference/scenekit/scnphysicscollisioncategory/1523649-init
	     */
	    value: function init(rawValue) {

	      // Constants

	      this._default = null;
	      this._static = null;
	      this._all = null;
	    }
	  }, {
	    key: 'default',


	    // Constants
	    /**
	     * The default categoryBitMask value for dynamic and kinematic bodies.
	     * @type {SCNPhysicsCollisionCategory}
	     * @desc 
	     * @see https://developer.apple.com/reference/scenekit/scnphysicscollisioncategory/1514799-default
	     */
	    get: function get() {
	      return this._default;
	    }
	    /**
	     * The default categoryBitMask value for static bodies.
	     * @type {SCNPhysicsCollisionCategory}
	     * @desc 
	     * @see https://developer.apple.com/reference/scenekit/scnphysicscollisioncategory/1514778-static
	     */

	  }, {
	    key: 'static',
	    get: function get() {
	      return this._static;
	    }
	    /**
	     * This is the default value for a physics bodys collisionBitMask property.
	     * @type {SCNPhysicsCollisionCategory}
	     * @desc With this collision mask, a physics body can collide with all other physics bodies.
	     * @see https://developer.apple.com/reference/scenekit/scnphysicscollisioncategory/1514784-all
	     */

	  }, {
	    key: 'all',
	    get: function get() {
	      return this._all;
	    }
	  }]);

	  return SCNPhysicsCollisionCategory;
	}();

	exports.default = SCNPhysicsCollisionCategory;

/***/ },
/* 190 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _SCNPhysicsBehavior2 = __webpack_require__(100);

	var _SCNPhysicsBehavior3 = _interopRequireDefault(_SCNPhysicsBehavior2);

	var _SCNPhysicsBody = __webpack_require__(103);

	var _SCNPhysicsBody2 = _interopRequireDefault(_SCNPhysicsBody);

	var _SCNVector = __webpack_require__(44);

	var _SCNVector2 = _interopRequireDefault(_SCNVector);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * A physics behavior that connects two bodies and allows them to pivot around each other on a single axis.
	 * @access public
	 * @extends {SCNPhysicsBehavior}
	 * @see https://developer.apple.com/reference/scenekit/scnphysicshingejoint
	 */
	var SCNPhysicsHingeJoint = function (_SCNPhysicsBehavior) {
	  _inherits(SCNPhysicsHingeJoint, _SCNPhysicsBehavior);

	  // Creating a Hinge Joint

	  /**
	   * Creates a hinge joint connecting two physics bodies.
	   * @access public
	   * @constructor
	   * @param {SCNPhysicsBody} bodyA - The first physics body to be connected by the joint.
	   * @param {SCNVector3} axisA - The axis that the hinge pivots around, relative to the node containing the first body.
	   * @param {SCNVector3} anchorA - The point at which the hinge connects, relative to the node containing the first body.
	   * @param {SCNPhysicsBody} bodyB - The second physics body to be connected by the joint.
	   * @param {SCNVector3} axisB - The axis that the hinge pivots around, relative to the node containing the second body.
	   * @param {SCNVector3} anchorB - The point at which the hinge connects, relative to the node containing the second body.
	   * @desc For a behavior to take effect, add it to the physics simulation by calling the addBehavior(_:) method on your scenes SCNPhysicsWorld object. The physics bodies constrained by the joint must be attached to nodes in the scene.
	   * @see https://developer.apple.com/reference/scenekit/scnphysicshingejoint/1387898-init
	   */
	  function SCNPhysicsHingeJoint(bodyA, axisA, anchorA, bodyB, axisB, anchorB) {
	    _classCallCheck(this, SCNPhysicsHingeJoint);

	    // Managing the Characteristics of a Hinge Joint

	    /**
	     * The axis that the hinge pivots around, relative to the node containing the first body.
	     * @type {SCNVector3}
	     * @see https://developer.apple.com/reference/scenekit/scnphysicshingejoint/1387888-axisa
	     */
	    var _this = _possibleConstructorReturn(this, (SCNPhysicsHingeJoint.__proto__ || Object.getPrototypeOf(SCNPhysicsHingeJoint)).call(this));

	    _this.axisA = null;

	    /**
	     * The point at which the hinge connects, relative to the node containing the first body.
	     * @type {SCNVector3}
	     * @see https://developer.apple.com/reference/scenekit/scnphysicshingejoint/1387936-anchora
	     */
	    _this.anchorA = null;

	    /**
	     * The axis that the hinge pivots around, relative to the node containing the second body.
	     * @type {SCNVector3}
	     * @see https://developer.apple.com/reference/scenekit/scnphysicshingejoint/1387914-axisb
	     */
	    _this.axisB = null;

	    /**
	     * The point at which the hinge connects, relative to the node containing the second body.
	     * @type {SCNVector3}
	     * @see https://developer.apple.com/reference/scenekit/scnphysicshingejoint/1387979-anchorb
	     */
	    _this.anchorB = null;

	    _this._bodyA = null;
	    _this._bodyB = null;
	    return _this;
	  }

	  // Managing the Characteristics of a Hinge Joint

	  /**
	   * The first physics body connected by the joint.
	   * @type {SCNPhysicsBody}
	   * @desc 
	   * @see https://developer.apple.com/reference/scenekit/scnphysicshingejoint/1387973-bodya
	   */


	  _createClass(SCNPhysicsHingeJoint, [{
	    key: 'bodyA',
	    get: function get() {
	      return this._bodyA;
	    }

	    /**
	     * The second physics body connected by the joint.
	     * @type {?SCNPhysicsBody}
	     * @desc This propertys value is nil if the joint was created using the init(body:axis:anchor:) method.
	     * @see https://developer.apple.com/reference/scenekit/scnphysicshingejoint/1387918-bodyb
	     */

	  }, {
	    key: 'bodyB',
	    get: function get() {
	      return this._bodyB;
	    }
	  }]);

	  return SCNPhysicsHingeJoint;
	}(_SCNPhysicsBehavior3.default);

	exports.default = SCNPhysicsHingeJoint;

/***/ },
/* 191 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _SCNPhysicsBehavior2 = __webpack_require__(100);

	var _SCNPhysicsBehavior3 = _interopRequireDefault(_SCNPhysicsBehavior2);

	var _SCNPhysicsBody = __webpack_require__(103);

	var _SCNPhysicsBody2 = _interopRequireDefault(_SCNPhysicsBody);

	var _SCNVector = __webpack_require__(44);

	var _SCNVector2 = _interopRequireDefault(_SCNVector);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * A physics behavior that connects two bodies and allows them to slide against each other and rotate around their connecting points.
	 * @access public
	 * @extends {SCNPhysicsBehavior}
	 * @see https://developer.apple.com/reference/scenekit/scnphysicssliderjoint
	 */
	var SCNPhysicsSliderJoint = function (_SCNPhysicsBehavior) {
	  _inherits(SCNPhysicsSliderJoint, _SCNPhysicsBehavior);

	  // Creating a Slider Joint

	  /**
	   * Creates a slider joint connecting two physics bodies.
	   * @access public
	   * @constructor
	   * @param {SCNPhysicsBody} bodyA - The first physics body to be connected by the joint.
	   * @param {SCNVector3} axisA - The axis along which the first body can slide, relative to the node containing it.
	   * @param {SCNVector3} anchorA - The point at which the joint connects, relative to the node containing the first body.
	   * @param {SCNPhysicsBody} bodyB - The second physics body to be connected by the joint.
	   * @param {SCNVector3} axisB - The axis along which the second body can slide, relative to the node containing it.
	   * @param {SCNVector3} anchorB - The point at which the joint connects, relative to the node containing the second body.
	   * @desc This method defines the location where the bodies are pinned together. To define their sliding or rotation motion relative to that point, use the properties listed in Limiting the Motion of a Slider Joint.For a behavior to take effect, add it to the physics simulation by calling the addBehavior(_:) method on your scenes SCNPhysicsWorld object. The physics bodies constrained by the joint must be attached to nodes in the scene.
	   * @see https://developer.apple.com/reference/scenekit/scnphysicssliderjoint/1387922-init
	   */
	  function SCNPhysicsSliderJoint(bodyA, axisA, anchorA, bodyB, axisB, anchorB) {
	    _classCallCheck(this, SCNPhysicsSliderJoint);

	    // Managing the Characteristics of a Slider Joint

	    /**
	     * The axis along which the first body can slide, relative to the node containing it.
	     * @type {SCNVector3}
	     * @see https://developer.apple.com/reference/scenekit/scnphysicssliderjoint/1387900-axisa
	     */
	    var _this = _possibleConstructorReturn(this, (SCNPhysicsSliderJoint.__proto__ || Object.getPrototypeOf(SCNPhysicsSliderJoint)).call(this));

	    _this.axisA = null;

	    /**
	     * The point at which the joint connects, relative to the node containing the first body.
	     * @type {SCNVector3}
	     * @see https://developer.apple.com/reference/scenekit/scnphysicssliderjoint/1387958-anchora
	     */
	    _this.anchorA = null;

	    /**
	     * The axis along which the second body can slide, relative to the node containing it.
	     * @type {SCNVector3}
	     * @see https://developer.apple.com/reference/scenekit/scnphysicssliderjoint/1387948-axisb
	     */
	    _this.axisB = null;

	    /**
	     * The point at which the joint connects, relative to the node containing the second body.
	     * @type {SCNVector3}
	     * @see https://developer.apple.com/reference/scenekit/scnphysicssliderjoint/1387916-anchorb
	     */
	    _this.anchorB = null;

	    _this._bodyA = null;
	    _this._bodyB = null;

	    // Limiting the Motion of a Slider Joint

	    /**
	     * The minimum distance between the anchor points of the two bodies, relative to their initial positions.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnphysicssliderjoint/1387920-minimumlinearlimit
	     */
	    _this.minimumLinearLimit = 0;

	    /**
	     * The maximum distance between the anchor points of the two bodies, relative to their initial positions.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnphysicssliderjoint/1387890-maximumlinearlimit
	     */
	    _this.maximumLinearLimit = 0;

	    /**
	     * The minimum rotation angle between the two bodies, measured in radians relative to their initial orientations.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnphysicssliderjoint/1387967-minimumangularlimit
	     */
	    _this.minimumAngularLimit = 0;

	    /**
	     * The maximum rotation angle between the two bodies, measured in radians relative to their initial orientations.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnphysicssliderjoint/1387924-maximumangularlimit
	     */
	    _this.maximumAngularLimit = 0;

	    // Applying Forces and Torques

	    /**
	     * The velocity at which the joints connected bodies should slide.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnphysicssliderjoint/1387938-motortargetlinearvelocity
	     */
	    _this.motorTargetLinearVelocity = 0;

	    /**
	     * The maximum linear force that the joint can apply to its connected bodies, in newtons.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnphysicssliderjoint/1387954-motormaximumforce
	     */
	    _this.motorMaximumForce = 0;

	    /**
	     * The angular velocity at which the joints connected bodies should rotate around it.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnphysicssliderjoint/1387908-motortargetangularvelocity
	     */
	    _this.motorTargetAngularVelocity = 0;

	    /**
	     * The maximum torque that the joint can apply to its connected bodies, in newton-meters.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnphysicssliderjoint/1387961-motormaximumtorque
	     */
	    _this.motorMaximumTorque = 0;

	    return _this;
	  }

	  // Managing the Characteristics of a Slider Joint

	  /**
	   * The first physics body connected by the joint.
	   * @type {SCNPhysicsBody}
	   * @desc 
	   * @see https://developer.apple.com/reference/scenekit/scnphysicssliderjoint/1387987-bodya
	   */


	  _createClass(SCNPhysicsSliderJoint, [{
	    key: 'bodyA',
	    get: function get() {
	      return this._bodyA;
	    }

	    /**
	     * The second physics body connected by the joint.
	     * @type {?SCNPhysicsBody}
	     * @desc This propertys value is nil if the joint was created using the init(body:axis:anchor:) method.
	     * @see https://developer.apple.com/reference/scenekit/scnphysicssliderjoint/1387896-bodyb
	     */

	  }, {
	    key: 'bodyB',
	    get: function get() {
	      return this._bodyB;
	    }
	  }]);

	  return SCNPhysicsSliderJoint;
	}(_SCNPhysicsBehavior3.default);

	exports.default = SCNPhysicsSliderJoint;

/***/ },
/* 192 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _SCNPhysicsBehavior2 = __webpack_require__(100);

	var _SCNPhysicsBehavior3 = _interopRequireDefault(_SCNPhysicsBehavior2);

	var _SCNPhysicsBody = __webpack_require__(103);

	var _SCNPhysicsBody2 = _interopRequireDefault(_SCNPhysicsBody);

	var _SCNPhysicsVehicleWheel = __webpack_require__(193);

	var _SCNPhysicsVehicleWheel2 = _interopRequireDefault(_SCNPhysicsVehicleWheel);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * A physics behavior that modifies a physics body to behave like a car, motorcycle, or other wheeled vehicle.
	 * @access public
	 * @extends {SCNPhysicsBehavior}
	 * @see https://developer.apple.com/reference/scenekit/scnphysicsvehicle
	 */
	var SCNPhysicsVehicle = function (_SCNPhysicsBehavior) {
	  _inherits(SCNPhysicsVehicle, _SCNPhysicsBehavior);

	  // Creating a Vehicle

	  /**
	   * Creates a vehicle behavior.
	   * @access public
	   * @constructor
	   * @param {SCNPhysicsBody} chassisBody - A physics body to serve as the vehicles chassis.
	   * @param {SCNPhysicsVehicleWheel[]} wheels - An array of SCNPhysicsVehicleWheel objects representing the vehicles wheels. A vehicle must have at least one wheel.
	   * @desc Each object in the wheels array associates a node with the wheel to serve as its visual representation and defines properties for the wheels physical characteristics. Each wheel object must reference a unique node, which should be a child of the node containing the physics body used for the vehicles chassis. Typically, you load a node hierarchy representing the vehicle and all of its wheels from a scene file and then designate which nodes serve as the body and wheels.For a behavior to take effect, you must add it to the physics simulation by calling the addBehavior(_:) method on your scenes SCNPhysicsWorld object.
	   * @see https://developer.apple.com/reference/scenekit/scnphysicsvehicle/1387943-init
	   */
	  function SCNPhysicsVehicle(chassisBody, wheels) {
	    _classCallCheck(this, SCNPhysicsVehicle);

	    // Working with a Vehicles Physical Characteristics

	    var _this = _possibleConstructorReturn(this, (SCNPhysicsVehicle.__proto__ || Object.getPrototypeOf(SCNPhysicsVehicle)).call(this));

	    _this._chassisBody = null;
	    _this._wheels = null;

	    // Driving a Vehicle

	    _this._speedInKilometersPerHour = 0;
	    return _this;
	  }

	  // Working with a Vehicles Physical Characteristics

	  /**
	   * The physics body representing the vehicles chassis.
	   * @type {SCNPhysicsBody}
	   * @desc The vehicles chassis must be a dynamic body.
	   * @see https://developer.apple.com/reference/scenekit/scnphysicsvehicle/1387985-chassisbody
	   */


	  _createClass(SCNPhysicsVehicle, [{
	    key: 'applyEngineForceForWheelAt',


	    // Driving a Vehicle

	    /**
	     * Applies a force between the specified wheel and the ground under the vehicle.
	     * @access public
	     * @param {number} value - The magnitude of the force, in newtons.
	     * @param {number} index - The index of the wheel applying the force.
	     * @returns {void}
	     * @desc Applying a positive force turns the wheel in a direction that would move the vehicle forward; applying a negative force moves the vehicle in reverse.As with all physical quantities in SceneKit, you need not use realistic force measurements in your appthe effects of the physics simulation depend on the relative differences between forces, not on their absolute values. You may use whatever values produce the behavior or gameplay youre looking for as long as you use them consistently.Calling this method applies a force for one step (or frame) of the physics simulation. To continuously accelerate a vehicle, call this method again on subequent simulation steps (for example, from your scene renderer delegates renderer(_:updateAtTime:) method) until the vehicle reaches your desired speed.
	     * @see https://developer.apple.com/reference/scenekit/scnphysicsvehicle/1387963-applyengineforce
	     */
	    value: function applyEngineForceForWheelAt(value, index) {}

	    /**
	     * Applies a force between the specified wheel and the ground under the vehicle.
	     * @access public
	     * @param {number} value - The magnitude of the torque, in newton-meters.
	     * @param {number} index - The index of the wheel applying the force.
	     * @returns {void}
	     * @desc Applying a braking force causes the wheel to slow down regardless of the direction its currently spinning in.As with all physical quantities in SceneKit, you need not use realistic force measurements in your appthe effects of the physics simulation depend on the relative differences between forces, not on their absolute values. You may use whatever values produce the behavior or gameplay youre looking for as long as you use them consistently.Calling this method applies a braking force for one step (or frame) of the physics simulation. To continuously decelerate a vehicle, call this method again on subequent simulation steps (for example, from your scene renderer delegates renderer(_:updateAtTime:) method) until the vehicle stops or reaches your desired speed.
	     * @see https://developer.apple.com/reference/scenekit/scnphysicsvehicle/1387894-applybrakingforce
	     */

	  }, {
	    key: 'applyBrakingForceForWheelAt',
	    value: function applyBrakingForceForWheelAt(value, index) {}

	    /**
	     * Pivots the specified wheel around its steering axis.
	     * @access public
	     * @param {number} value - The angle to set the wheel at relative to its steering axis, in radians.
	     * @param {number} index - The index, in the vehicles wheels array, of the wheel to be pivoted.
	     * @returns {void}
	     * @desc Steering angles are relative to the wheels steeringAxis vector. With the default steering axis of {0.0, -1.0, 0.0}, a steering angle of 0.0 represents neutral steering, positive values steer the vehicle to the right, and negative values steer to the left.
	     * @see https://developer.apple.com/reference/scenekit/scnphysicsvehicle/1387952-setsteeringangle
	     */

	  }, {
	    key: 'setSteeringAngleForWheelAt',
	    value: function setSteeringAngleForWheelAt(value, index) {}

	    /**
	     * The vehicles ground speed, in kilometers per hour.
	     * @type {number}
	     * @desc 
	     * @see https://developer.apple.com/reference/scenekit/scnphysicsvehicle/1387910-speedinkilometersperhour
	     */

	  }, {
	    key: 'chassisBody',
	    get: function get() {
	      return this._chassisBody;
	    }

	    /**
	     * An array of SCNPhysicsVehicleWheel objects representing the vehicles wheels.
	     * @type {SCNPhysicsVehicleWheel[]}
	     * @desc You can dynamically change the suspension and traction properties of a wheel connected to the vehicle by using the corresponding SCNPhysicsVehicleWheel object or by using Key-value coding with a keypath of the form wheels[index].propertyName. For example, the following code changes the size of the first wheel attached to the vehicle, simulating a failed tire:SCNPhysicsVehicle *vehicle = [SCNPhysicsVehicle vehicleWithChassisBody:car wheels:wheels];
	    [vehicle setValue:@0.1 forKeyPath:@"wheels[0].radius"];
	    SCNPhysicsVehicle *vehicle = [SCNPhysicsVehicle vehicleWithChassisBody:car wheels:wheels];
	    [vehicle setValue:@0.1 forKeyPath:@"wheels[0].radius"];
	      * @see https://developer.apple.com/reference/scenekit/scnphysicsvehicle/1387906-wheels
	     */

	  }, {
	    key: 'wheels',
	    get: function get() {
	      return this._wheels;
	    }
	  }, {
	    key: 'speedInKilometersPerHour',
	    get: function get() {
	      return this._speedInKilometersPerHour;
	    }
	  }]);

	  return SCNPhysicsVehicle;
	}(_SCNPhysicsBehavior3.default);

	exports.default = SCNPhysicsVehicle;

/***/ },
/* 193 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _NSObject2 = __webpack_require__(2);

	var _NSObject3 = _interopRequireDefault(_NSObject2);

	var _SCNNode = __webpack_require__(65);

	var _SCNNode2 = _interopRequireDefault(_SCNNode);

	var _SCNVector = __webpack_require__(44);

	var _SCNVector2 = _interopRequireDefault(_SCNVector);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * The appearance and physical characteristics of an individual wheel associated with anphysics vehicle behavior.
	 * @access public
	 * @extends {NSObject}
	 * @see https://developer.apple.com/reference/scenekit/scnphysicsvehiclewheel
	 */
	var SCNPhysicsVehicleWheel = function (_NSObject) {
	  _inherits(SCNPhysicsVehicleWheel, _NSObject);

	  // Creating a Wheel

	  /**
	   * Creates a wheel object.
	   * @access public
	   * @constructor
	   * @param {SCNNode} node - The node whose contents provide the wheels visual representation.
	   * @desc The node representing a wheel must be a child of the node whose physics body serves as the chassis of the SCNPhysicsVehicle behavior the wheel is attached to. Each wheel object must reference a unique node. To use the wheel, add it to the vehicle behavior using the addWheel: method.SceneKit uses the nodes bounding box to determine the wheels initial size, and it uses the nodes position to determine the where the wheel connects to the vehicles chassis. You can change attributes using the radius and connectionPosition properties.
	   * @see https://developer.apple.com/reference/scenekit/scnphysicsvehiclewheel/1387989-init
	   */
	  function SCNPhysicsVehicleWheel(node) {
	    _classCallCheck(this, SCNPhysicsVehicleWheel);

	    // Managing a Wheels Connection to a Vehicle

	    /**
	     * The position of the wheels connection to the vehicles chassis.
	     * @type {SCNVector3}
	     * @see https://developer.apple.com/reference/scenekit/scnphysicsvehiclewheel/1387959-connectionposition
	     */
	    var _this = _possibleConstructorReturn(this, (SCNPhysicsVehicleWheel.__proto__ || Object.getPrototypeOf(SCNPhysicsVehicleWheel)).call(this));

	    _this.connectionPosition = null;

	    /**
	     * The direction of the axis that the wheel spins around to move the vehicle.
	     * @type {SCNVector3}
	     * @see https://developer.apple.com/reference/scenekit/scnphysicsvehiclewheel/1387969-axle
	     */
	    _this.axle = null;

	    /**
	     * The direction of the axis that the wheel pivots around to steer the vehicle.
	     * @type {SCNVector3}
	     * @see https://developer.apple.com/reference/scenekit/scnphysicsvehiclewheel/1387882-steeringaxis
	     */
	    _this.steeringAxis = null;

	    // Simulating Wheel Size

	    /**
	     * The radius of the wheel.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnphysicsvehiclewheel/1387991-radius
	     */
	    _this.radius = 0;

	    // Simulating Traction

	    /**
	     * The traction between the wheel and any surface in contact with it.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnphysicsvehiclewheel/1387904-frictionslip
	     */
	    _this.frictionSlip = 0;

	    // Simulating Suspension

	    /**
	     * The spring coefficient of the suspension between the vehicle and the wheel.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnphysicsvehiclewheel/1387983-suspensionstiffness
	     */
	    _this.suspensionStiffness = 0;

	    /**
	     * The coefficient that limits the speed of the suspension returning to its rest length when compressed.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnphysicsvehiclewheel/1387971-suspensioncompression
	     */
	    _this.suspensionCompression = 0;

	    /**
	     * The damping ratio that limits oscillation in the vehicles suspension.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnphysicsvehiclewheel/1387886-suspensiondamping
	     */
	    _this.suspensionDamping = 0;

	    /**
	     * The maximum distance that the wheel is allowed to move up or down relative to its connection point, in centimeters.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnphysicsvehiclewheel/1387928-maximumsuspensiontravel
	     */
	    _this.maximumSuspensionTravel = 0;

	    /**
	     * The maximum force of the suspension between the vehicle and the wheel, in newtons.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnphysicsvehiclewheel/1387934-maximumsuspensionforce
	     */
	    _this.maximumSuspensionForce = 0;

	    /**
	     * The resting length of the suspension, in meters.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnphysicsvehiclewheel/1387880-suspensionrestlength
	     */
	    _this.suspensionRestLength = 0;

	    // Inspecting the Wheel Node

	    _this._node = null;
	    return _this;
	  }

	  // Inspecting the Wheel Node

	  /**
	   * The node providing the wheels visual representation.
	   * @type {SCNNode}
	   * @desc SceneKit automatically rotates and repositions this node in response to the physics simulation.
	   * @see https://developer.apple.com/reference/scenekit/scnphysicsvehiclewheel/1387892-node
	   */


	  _createClass(SCNPhysicsVehicleWheel, [{
	    key: 'node',
	    get: function get() {
	      return this._node;
	    }
	  }]);

	  return SCNPhysicsVehicleWheel;
	}(_NSObject3.default);

	exports.default = SCNPhysicsVehicleWheel;

/***/ },
/* 194 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _SCNGeometry2 = __webpack_require__(68);

	var _SCNGeometry3 = _interopRequireDefault(_SCNGeometry2);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * A rectangular, one-sided plane geometry of specified width and height.
	 * @access public
	 * @extends {SCNGeometry}
	 * @see https://developer.apple.com/reference/scenekit/scnplane
	 */
	var SCNPlane = function (_SCNGeometry) {
	  _inherits(SCNPlane, _SCNGeometry);

	  _createClass(SCNPlane, null, [{
	    key: '_propTypes',
	    get: function get() {
	      return {
	        materials: 'NSArray',
	        width: 'float',
	        height: 'float',
	        widthSegmentCount: 'integer',
	        heightSegmentCount: 'integer',
	        cornerRadius: 'float',
	        cornerSegmentCount: 'integer',

	        name: 'string',
	        primitiveType: ['integer', null],
	        subdivisionLevel: 'integer',
	        subdivisionSettings: ['bytes', null]
	      };
	    }

	    // Creating a Plane

	    /**
	     * Creates a plane geometry with the specified width and height.
	     * @access public
	     * @constructor
	     * @param {number} width - The width of the plane along the x-axis of its local coordinate space.
	     * @param {number} height - The height of the plane along the y-axis of its local coordinate space.
	     * @desc The plane is centered in its local coordinate system. For example, if you create a plane whose width and height are both 10.0, it extends from -5.0 to 5.0 along both the x- and y-axes, and the z-coordinate of all points in the plane is zero.
	     * @see https://developer.apple.com/reference/scenekit/scnplane/1523631-init
	     */

	  }]);

	  function SCNPlane(width, height) {
	    _classCallCheck(this, SCNPlane);

	    // Adjusting a Planes Dimensions

	    /**
	     * The extent of the plane along its horizontal axis. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnplane/1523782-width
	     */
	    var _this = _possibleConstructorReturn(this, (SCNPlane.__proto__ || Object.getPrototypeOf(SCNPlane)).call(this));

	    _this.width = 0;

	    /**
	     * The extent of the plane along its vertical axis. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnplane/1522837-height
	     */
	    _this.height = 0;

	    // Adjusting Geometric Detail

	    /**
	     * The number of subdivisions in the planes surface along its horizontal axis. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnplane/1523991-widthsegmentcount
	     */
	    _this.widthSegmentCount = 0;

	    /**
	     * The number of subdivisions in the planes surface along its vertical axis. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnplane/1522889-heightsegmentcount
	     */
	    _this.heightSegmentCount = 0;

	    // Adding Rounded Corners

	    /**
	     * The radius of curvature for the planes corners. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnplane/1523005-cornerradius
	     */
	    _this.cornerRadius = 0;

	    /**
	     * The number of line segments used to create each rounded corner of the plane. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnplane/1524234-cornersegmentcount
	     */
	    _this.cornerSegmentCount = 0;

	    return _this;
	  }

	  return SCNPlane;
	}(_SCNGeometry3.default);

	exports.default = SCNPlane;

/***/ },
/* 195 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _SCNGeometry2 = __webpack_require__(68);

	var _SCNGeometry3 = _interopRequireDefault(_SCNGeometry2);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * A right rectangular pyramid geometry.
	 * @access public
	 * @extends {SCNGeometry}
	 * @see https://developer.apple.com/reference/scenekit/scnpyramid
	 */
	var SCNPyramid = function (_SCNGeometry) {
	  _inherits(SCNPyramid, _SCNGeometry);

	  // Creating a Pyramid

	  /**
	   * Creates a pyramid geometry with the specified width, height, and length.
	   * @access public
	   * @constructor
	   * @param {number} width - The width of the pyramid along the x-axis of its local coordinate space.
	   * @param {number} height - The height of the pyramid along the y-axis of its local coordinate space.
	   * @param {number} length - The length of the pyramid along the z-axis of its local coordinate space.
	   * @desc The pyramids base is centered in its local coordinate system. For example, if you create a pyramid whose width, height and length are all 10.0, its apex is at the point {0, 10.0, 0}, and its base lies in the plane whose y-coordinate is 0.0, extending from -5.0 to 5.0 along both the x- and z-axes.
	   * @see https://developer.apple.com/reference/scenekit/scnpyramid/1523254-init
	   */
	  function SCNPyramid(width, height, length) {
	    _classCallCheck(this, SCNPyramid);

	    // Adjusting a Pyramids Dimensions

	    /**
	     * The extent of the pyramid along its x-axis. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnpyramid/1522613-width
	     */
	    var _this = _possibleConstructorReturn(this, (SCNPyramid.__proto__ || Object.getPrototypeOf(SCNPyramid)).call(this));

	    _this.width = 0;

	    /**
	     * The extent of the pyramid along its y-axis. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnpyramid/1522805-height
	     */
	    _this.height = 0;

	    /**
	     * The extent of the pyramid along its z-axis. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnpyramid/1524203-length
	     */
	    _this.length = 0;

	    // Adjusting Geometric Detail

	    /**
	     * The number of subdivisions in each face of the pyramid along its x-axis. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnpyramid/1523083-widthsegmentcount
	     */
	    _this.widthSegmentCount = 0;

	    /**
	     * The number of subdivisions in each face of the pyramid along its y-axis. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnpyramid/1524059-heightsegmentcount
	     */
	    _this.heightSegmentCount = 0;

	    /**
	     * The number of subdivisions in each face of the pyramid along its z-axis. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnpyramid/1524227-lengthsegmentcount
	     */
	    _this.lengthSegmentCount = 0;

	    return _this;
	  }

	  return SCNPyramid;
	}(_SCNGeometry3.default);

	exports.default = SCNPyramid;

/***/ },
/* 196 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * Options for when to load the reference nodes content, used by the loadingPolicy property.
	 * @typedef {Object} SCNReferenceLoadingPolicy
	 * @property {number} immediate - Load the nodes external content immediately when the reference node is unarchived.
	 * @property {number} onDemand - Load the nodes external comment only when the load() method is called.
	 * @see https://developer.apple.com/reference/scenekit/scnreferenceloadingpolicy
	 */

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var SCNReferenceLoadingPolicy = {
	  immediate: 0,
	  onDemand: 1
	};

	exports.default = SCNReferenceLoadingPolicy;

/***/ },
/* 197 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _SCNNode2 = __webpack_require__(65);

	var _SCNNode3 = _interopRequireDefault(_SCNNode2);

	var _SCNReferenceLoadingPolicy = __webpack_require__(196);

	var _SCNReferenceLoadingPolicy2 = _interopRequireDefault(_SCNReferenceLoadingPolicy);

	var _SCNScene = __webpack_require__(90);

	var _SCNScene2 = _interopRequireDefault(_SCNScene);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * A scene graph node that serves as a placeholder for content to be loaded from a separate scene file. 
	 * @access public
	 * @extends {SCNNode}
	 * @see https://developer.apple.com/reference/scenekit/scnreferencenode
	 */
	var SCNReferenceNode = function (_SCNNode) {
	  _inherits(SCNReferenceNode, _SCNNode);

	  _createClass(SCNReferenceNode, null, [{
	    key: '_propTypes',
	    get: function get() {
	      return {
	        paused: ['boolean', 'isPaused'],
	        scale: ['SCNVector3', '_scale'],
	        rotation: ['SCNVector4', '_rotation'],
	        position: ['SCNVector3', '_position'],
	        loadingPolicy: 'integer',
	        referenceURL: ['NSURL', function (obj, value) {
	          obj.referenceURL = value;
	          obj.load();
	        }],
	        opacity: 'float',
	        castsShadow: 'boolean',
	        categoryBitMask: 'integer',
	        hidden: ['boolean', 'isHidden'],
	        name: 'string',
	        renderingOrder: 'integer',
	        movabilityHint: 'integer'
	      };
	    }

	    // Creating a Reference Node

	    /**
	     * Initializes a node whose content is to be loaded from the referenced URL.
	     * @access public
	     * @constructor
	     * @param {string} referenceURL - The URL to a scene file from which to load the nodes content.
	     * @desc Using this initializer does not load the nodes content. To load content from the referenced URL, use the load() method.
	     * @see https://developer.apple.com/reference/scenekit/scnreferencenode/1523967-init
	     */

	  }]);

	  function SCNReferenceNode(referenceURL) {
	    _classCallCheck(this, SCNReferenceNode);

	    /**
	     * @access private
	     * @type {boolean}
	     */
	    var _this = _possibleConstructorReturn(this, (SCNReferenceNode.__proto__ || Object.getPrototypeOf(SCNReferenceNode)).call(this));

	    _this._isLoading = false;

	    /**
	     * @access private
	     * @type {boolean}
	     */
	    _this._isLoaded = false;

	    // Loading and Unloading a Reference Nodes Content

	    /**
	     * An option for whether to load the nodes content automatically.
	     * @type {SCNReferenceLoadingPolicy}
	     * @see https://developer.apple.com/reference/scenekit/scnreferencenode/1522996-loadingpolicy
	     */
	    _this.loadingPolicy = null;

	    /**
	     * The URL to a scene file from which to load content for the reference node.
	     * @type {string}
	     * @see https://developer.apple.com/reference/scenekit/scnreferencenode/1522733-referenceurl
	     */
	    _this._referenceURL = referenceURL;

	    _this._scene = null;

	    if (referenceURL) {
	      _this.load();
	    }
	    return _this;
	  }

	  // Loading and Unloading a Reference Nodes Content

	  /**
	   * Loads content into the node from its referenced external scene file.
	   * @access public
	   * @returns {void}
	   * @desc When SceneKit loads the referenced scene file, all children of the scene files root node become children of the reference node.If the node has already been loaded (either automatically, according to the loadingPolicy property, or through a previous call to this method), calling this method has no effect.
	   * @see https://developer.apple.com/reference/scenekit/scnreferencenode/1523204-load
	   */


	  _createClass(SCNReferenceNode, [{
	    key: 'load',
	    value: function load() {
	      var _this2 = this;

	      if (this._isLoaded || this._isLoading) {
	        return;
	      }
	      this._isLoading = true;

	      new _SCNScene2.default(this._referenceURL, null, function (scene) {
	        scene.rootNode.name = 'referenceRoot';
	        _get(SCNReferenceNode.prototype.__proto__ || Object.getPrototypeOf(SCNReferenceNode.prototype), 'addChildNode', _this2).call(_this2, scene.rootNode);
	        _this2._scene = scene;

	        _this2._isLoaded = true;
	        _this2._isLoading = false;
	      });
	    }

	    /**
	     * Removes the nodes children and marks the node as not loaded.
	     * @access public
	     * @returns {void}
	     * @desc Calling this method does not necessarily unload any content associated with the nodes child nodes from memoryit merely removes them from the scene graph. The unlinked nodes and their content are then subject to normal object memory management rules. Under ARC, those objects are deallocated if and only if they are not referenced from elsewhere in your program.
	     * @see https://developer.apple.com/reference/scenekit/scnreferencenode/1523566-unload
	     */

	  }, {
	    key: 'unload',
	    value: function unload() {
	      if (!this._isLoaded) {
	        return;
	      }
	      this.childNodes.forEach(function (child) {
	        child.removeFromParentNode();
	      });
	      this._isLoaded = false;
	    }

	    /**
	     * A Boolean value that indicates whether the reference node has already loaded its content.
	     * @type {boolean}
	     * @desc 
	     * @see https://developer.apple.com/reference/scenekit/scnreferencenode/1523906-isloaded
	     */

	  }, {
	    key: 'initCoder',


	    // Initializers

	    /**
	     * 
	     * @access public
	     * @param {NSCoder} aDecoder - 
	     * @returns {void}
	     * @see https://developer.apple.com/reference/scenekit/scnreferencenode/1524061-init
	     */
	    value: function initCoder(aDecoder) {}
	  }, {
	    key: 'addChildNode',
	    value: function addChildNode(child) {
	      throw new Error('cannot add a child node to SCNReferenceNode');
	    }
	  }, {
	    key: 'insertChildNodeAt',
	    value: function insertChildNodeAt(child, index) {
	      throw new Error('cannot add a child node to SCNReferenceNode');
	    }
	  }, {
	    key: 'replaceChildNodeWith',
	    value: function replaceChildNodeWith(oldChild, newChild) {
	      throw new Error('cannot add a child node to SCNReferenceNode');
	    }
	  }, {
	    key: 'isLoaded',
	    get: function get() {
	      return this._isLoaded;
	    }
	  }, {
	    key: 'referenceURL',
	    get: function get() {
	      return this._referenceURL;
	    },
	    set: function set(newValue) {
	      this.unload();
	      this._referenceURL = newValue;
	      if (this.loadingPolicy === _SCNReferenceLoadingPolicy2.default.immediate) {
	        this.load();
	      }
	    }
	  }, {
	    key: 'childNodes',
	    get: function get() {
	      // FIXME: needs synchronous loading
	      if (!this._isLoaded) {
	        this.load();
	      }
	      return this._childNodes.slice(0);
	    }
	  }]);

	  return SCNReferenceNode;
	}(_SCNNode3.default);

	exports.default = SCNReferenceNode;

/***/ },
/* 198 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _NSObject2 = __webpack_require__(2);

	var _NSObject3 = _interopRequireDefault(_NSObject2);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var SCNShadableHelper = function (_NSObject) {
	  _inherits(SCNShadableHelper, _NSObject);

	  _createClass(SCNShadableHelper, null, [{
	    key: '_propTypes',
	    get: function get() {
	      return {
	        owner: ['SCNGeometry', '_owner'],
	        shaderModifiers: ['NSDictionary', '_shaderModifiers']
	      };
	    }
	  }]);

	  function SCNShadableHelper() {
	    _classCallCheck(this, SCNShadableHelper);

	    var _this = _possibleConstructorReturn(this, (SCNShadableHelper.__proto__ || Object.getPrototypeOf(SCNShadableHelper)).call(this));

	    _this._owner = null;
	    _this._shaderModifiers = null;
	    return _this;
	  }

	  return SCNShadableHelper;
	}(_NSObject3.default);

	exports.default = SCNShadableHelper;

/***/ },
/* 199 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * 
	 * @typedef {Object} SCNShaderModifierEntryPoint
	 * @property {string} fragment - Use this entry point to change the color of a fragment after all other shading has been performed.
	 * @property {string} geometry - Use this entry point to deform a geometrys surface or alter its vertex attributes.
	 * @property {string} lightingModel - Use this entry point to provide a custom lighting equation.
	 * @property {string} surface - Use this entry point to modify the surface properties of a material before lighting is computed.
	 * @see https://developer.apple.com/reference/scenekit/scnshadermodifierentrypoint
	 */

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var SCNShaderModifierEntryPoint = {
	  fragment: 'SCNShaderModifierEntryPointFragment',
	  geometry: 'SCNShaderModifierEntryPointGeometry',
	  lightingModel: 'SCNShaderModifierEntryPointLightingModel',
	  surface: 'SCNShaderModifierEntryPointSurface'
	};

	exports.default = SCNShaderModifierEntryPoint;

/***/ },
/* 200 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _SCNGeometry2 = __webpack_require__(68);

	var _SCNGeometry3 = _interopRequireDefault(_SCNGeometry2);

	var _SCNChamferMode = __webpack_require__(169);

	var _SCNChamferMode2 = _interopRequireDefault(_SCNChamferMode);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * A geometry based on a two-dimensional path, optionally extruded to create a three-dimensional object.
	 * @access public
	 * @extends {SCNGeometry}
	 * @see https://developer.apple.com/reference/scenekit/scnshape
	 */
	var SCNShape = function (_SCNGeometry) {
	  _inherits(SCNShape, _SCNGeometry);

	  // Creating a Shape

	  /**
	   * Creates a shape geometry with the specified path and extrusion depth.
	   * @access public
	   * @constructor
	   * @param {?UIBezierPath} path - The two-dimensional path forming the basis of the shape.
	   * @param {number} extrusionDepth - The thickness of the extruded shape along the z-axis.
	   * @desc SceneKit determines the filled area of the path using the even-odd winding rule (see Winding Rules in Cocoa Drawing Guide) and extrudes this area to create a three-dimensional geometry. The result of extruding a self-intersecting path is undefined.The extruded shape is centered at the zero point of its z-axis. For example, an extrusion depth of 1.0 creates a shape that extends from -0.5 to 0.5 along the z-axis. An extrusion depth of zero creates a flat, one-sided shape.The paths flatness (see flatness in NSBezierPath) determines the level of detail SceneKit uses in building a three-dimensional shape from the path. A larger flatness value results in fewer polygons to render, increasing performance, and a smaller flatness value increases the smoothness of curves at a cost to performance.
	   * @see https://developer.apple.com/reference/scenekit/scnshape/1523432-init
	   */
	  function SCNShape(path, extrusionDepth) {
	    _classCallCheck(this, SCNShape);

	    // Modifying a Shape

	    /**
	     * The thickness of the extruded shape along the z-axis. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnshape/1523365-extrusiondepth
	     */
	    var _this = _possibleConstructorReturn(this, (SCNShape.__proto__ || Object.getPrototypeOf(SCNShape)).call(this));

	    _this.extrusionDepth = 0;

	    /**
	     * The two-dimensional path forming the basis of the shape.
	     * @type {?UIBezierPath}
	     * @see https://developer.apple.com/reference/scenekit/scnshape/1523434-path
	     */
	    _this.path = null;

	    // Chamfering a Shape

	    /**
	     * A constant specifying which ends of the extruded shapes profile are chamfered.
	     * @type {SCNChamferMode}
	     * @see https://developer.apple.com/reference/scenekit/scnshape/1523989-chamfermode
	     */
	    _this.chamferMode = null;

	    /**
	     * A path that determines the cross-sectional contour of each chamfered edge.
	     * @type {?UIBezierPath}
	     * @see https://developer.apple.com/reference/scenekit/scnshape/1522865-chamferprofile
	     */
	    _this.chamferProfile = null;

	    /**
	     * The width or depth of each chamfered edge. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnshape/1524145-chamferradius
	     */
	    _this.chamferRadius = 0;
	    return _this;
	  }

	  return SCNShape;
	}(_SCNGeometry3.default);

	exports.default = SCNShape;

/***/ },
/* 201 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _SCNGeometry2 = __webpack_require__(68);

	var _SCNGeometry3 = _interopRequireDefault(_SCNGeometry2);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * A sphere (or ball or globe) geometry.
	 * @access public
	 * @extends {SCNGeometry}
	 * @see https://developer.apple.com/reference/scenekit/scnsphere
	 */
	var SCNSphere = function (_SCNGeometry) {
	  _inherits(SCNSphere, _SCNGeometry);

	  _createClass(SCNSphere, null, [{
	    key: '_propTypes',
	    get: function get() {
	      return {
	        sphereradius: ['float', 'radius'],
	        spheregeodesic: ['boolean', 'isGeodesic'],
	        spheresegmentCount: ['integer', 'segmentCount'],
	        materials: 'NSArray',

	        name: 'string',
	        sphereradialSpan: ['float', '_sphereRadialSpan'],
	        spherehemispheric: ['boolean', '_isHemispheric'],
	        sphereprimitiveType: ['integer', '_spherePrimitiveType'],
	        subdivisionLevel: 'integer',
	        subdivisionSettings: ['bytes', null]
	      };
	    }

	    // Creating a Sphere

	    /**
	     * Creates a sphere geometry with the specified radius.
	     * @access public
	     * @constructor
	     * @param {number} radius - The radius of the sphere in its local coordinate space.
	     * @desc The sphere is centered in its local coordinate system. For example, if you create a sphere whose radius is 5.0, it extends from -5.0 to 5.0 along each of the the x, y, and z-axes.
	     * @see https://developer.apple.com/reference/scenekit/scnsphere/1522601-init
	     */

	  }]);

	  function SCNSphere(radius) {
	    _classCallCheck(this, SCNSphere);

	    // Adjusting a Spheres Dimensions

	    /**
	     * The radius of the sphere. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnsphere/1523787-radius
	     */
	    var _this = _possibleConstructorReturn(this, (SCNSphere.__proto__ || Object.getPrototypeOf(SCNSphere)).call(this));

	    _this.radius = radius;

	    // Adjusting Geometric Detail

	    /**
	     * A Boolean value specifying whether SceneKit uses a geodesic polygon mesh to render the sphere.
	     * @type {boolean}
	     * @see https://developer.apple.com/reference/scenekit/scnsphere/1523268-isgeodesic
	     */
	    _this.isGeodesic = false;

	    /**
	     * A number determining the detail of the polygon mesh SceneKit uses to render the sphere. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnsphere/1523912-segmentcount
	     */
	    _this.segmentCount = 0;

	    _this._sphereRadialSpan = 0;
	    _this._spherePrimitiveType = 0;
	    _this._isHemispheric = false;
	    return _this;
	  }

	  return SCNSphere;
	}(_SCNGeometry3.default);

	exports.default = SCNSphere;

/***/ },
/* 202 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _SCNGeometry2 = __webpack_require__(68);

	var _SCNGeometry3 = _interopRequireDefault(_SCNGeometry2);

	var _CGRect = __webpack_require__(8);

	var _CGRect2 = _interopRequireDefault(_CGRect);

	var _CGSize = __webpack_require__(9);

	var _CGSize2 = _interopRequireDefault(_CGSize);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * A geometry based on a string of text, optionally extruded to create a three-dimensional object. 
	 * @access public
	 * @extends {SCNGeometry}
	 * @see https://developer.apple.com/reference/scenekit/scntext
	 */
	var SCNText = function (_SCNGeometry) {
	  _inherits(SCNText, _SCNGeometry);

	  // Creating a Text Geometry

	  /**
	   * Creates a text geometry from a specified string, extruded with a specified depth.
	   * @access public
	   * @constructor
	   * @param {?Object} string - An NSString or NSAttributedString object containing text from which to create the geometry.
	   * @param {number} extrusionDepth - The extent of the text geometry in the Z dimension of its local coordinate space. Specify a depth of 0.0 to create 2D text confined to a plane.
	   * @desc In the local coordinate system of the text geometry, the origin corresponds to the lower left corner of the texts layout rectangle, with the text extending in the x- and y-axis dimensions. (SceneKit computes a layout rectangle automatically, or you can specify one using the containerFrame property.) The geometry is centered along its z-axis. For example, if its extrusionDepth property is 1.0, the geometry extends from -0.5 to 0.5 along the z-axis. An extrusion depth of zero creates a flat, one-sided shapethe geometry is confined to the plane whose z-coordinate is 0.0, and viewable only from its front unless its materials isDoubleSided property is true.
	   * @see https://developer.apple.com/reference/scenekit/scntext/1522734-init
	   */
	  function SCNText(string, extrusionDepth) {
	    _classCallCheck(this, SCNText);

	    // Managing the Geometrys Text Content

	    /**
	     * The string object whose text the geometry represents.
	     * @type {?Object}
	     * @see https://developer.apple.com/reference/scenekit/scntext/1523439-string
	     */
	    var _this = _possibleConstructorReturn(this, (SCNText.__proto__ || Object.getPrototypeOf(SCNText)).call(this));

	    _this.string = null;

	    /**
	     * The font that SceneKit uses to create geometry from the text.
	     * @type {!UIFont}
	     * @see https://developer.apple.com/reference/scenekit/scntext/1523273-font
	     */
	    _this.font = null;

	    // Managing Text Layout

	    /**
	     * A rectangle specifying the area in which SceneKit should lay out the text.
	     * @type {CGRect}
	     * @see https://developer.apple.com/reference/scenekit/scntext/1523654-containerframe
	     */
	    _this.containerFrame = null;

	    /**
	     * A Boolean value that specifies whether SceneKit wraps long lines of text.
	     * @type {boolean}
	     * @see https://developer.apple.com/reference/scenekit/scntext/1523585-iswrapped
	     */
	    _this.isWrapped = false;

	    /**
	     * A constant that specifies how SceneKit horizontally aligns each line of text within its container.
	     * @type {string}
	     * @see https://developer.apple.com/reference/scenekit/scntext/1523158-alignmentmode
	     */
	    _this.alignmentMode = '';

	    /**
	     * A constant that specifies how SceneKit truncates text that is too long to fit its container.
	     * @type {string}
	     * @see https://developer.apple.com/reference/scenekit/scntext/1523414-truncationmode
	     */
	    _this.truncationMode = '';

	    _this._textSize = null;

	    // Managing the Texts 3D Representation

	    /**
	     * A number that determines the accuracy or smoothness of the text geometry.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scntext/1524111-flatness
	     */
	    _this.flatness = 0;

	    /**
	     * The extent of the extruded text in the z-axis direction. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scntext/1522604-extrusiondepth
	     */
	    _this.extrusionDepth = 0;

	    /**
	     * The width or depth of each chamfered edge. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scntext/1522846-chamferradius
	     */
	    _this.chamferRadius = 0;

	    /**
	     * A path that determines the cross-sectional contour of each chamfered edge.
	     * @type {?UIBezierPath}
	     * @see https://developer.apple.com/reference/scenekit/scntext/1523334-chamferprofile
	     */
	    _this.chamferProfile = null;
	    return _this;
	  }

	  // Managing Text Layout

	  /**
	   * The two-dimensional extent of the text after layout.
	   * @type {CGSize}
	   * @desc This property reports the size of the smallest bounding rectangle containing the text. This size does not necessarily match that of the layout rectangle specified by the containerFrame property. A long body of text may overflow the layout rectangle, depending on the values of the isWrapped and truncationMode properties, and a short string of text may fit in an area smaller than the layout rectangle.
	   * @see https://developer.apple.com/reference/scenekit/scntext/1523680-textsize
	   */


	  _createClass(SCNText, [{
	    key: 'textSize',
	    get: function get() {
	      return this._textSize;
	    }
	  }]);

	  return SCNText;
	}(_SCNGeometry3.default);

	exports.default = SCNText;

/***/ },
/* 203 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _SCNGeometry2 = __webpack_require__(68);

	var _SCNGeometry3 = _interopRequireDefault(_SCNGeometry2);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * A torus, or ring-shaped geometry.
	 * @access public
	 * @extends {SCNGeometry}
	 * @see https://developer.apple.com/reference/scenekit/scntorus
	 */
	var SCNTorus = function (_SCNGeometry) {
	  _inherits(SCNTorus, _SCNGeometry);

	  // Creating a Torus

	  /**
	   * Creates a torus geometry with the specified ring radius and pipe radius.
	   * @access public
	   * @constructor
	   * @param {number} ringRadius - The major radius of the torus, defining its circular ring in the x- and z-axis dimensions of its local coordinate space.
	   * @param {number} pipeRadius - The minor radius of the torus, defining the pipe that encircles the ring.
	   * @desc The torus is centered in its local coordinate system. For example, if you create a torus whose ring radius is 5.0 and pipe radius is 1.0, it extends from -6.0 to 6.0 (with a hole through the center from -4.0 to 4.0) in the x- and z-axes and from -1.0 to 1.0 in the y-axis.
	   * @see https://developer.apple.com/reference/scenekit/scntorus/1523833-init
	   */
	  function SCNTorus(ringRadius, pipeRadius) {
	    _classCallCheck(this, SCNTorus);

	    // Adjusting a Torus Dimensions

	    /**
	     * The major radius of the torus, defining a circle in the x- and z-axis dimensions. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scntorus/1522906-ringradius
	     */
	    var _this = _possibleConstructorReturn(this, (SCNTorus.__proto__ || Object.getPrototypeOf(SCNTorus)).call(this));

	    _this.ringRadius = 0;

	    /**
	     * The minor radius of the torus, defining the pipe that encircles the torus ring. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scntorus/1522623-piperadius
	     */
	    _this.pipeRadius = 0;

	    // Configuring Torus Properties

	    /**
	     * The number of subdivisions around the torus ring. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scntorus/1523598-ringsegmentcount
	     */
	    _this.ringSegmentCount = 0;

	    /**
	     * The number of subdivisions around the torus pipe. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scntorus/1522807-pipesegmentcount
	     */
	    _this.pipeSegmentCount = 0;
	    return _this;
	  }

	  return SCNTorus;
	}(_SCNGeometry3.default);

	exports.default = SCNTorus;

/***/ },
/* 204 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _SCNConstraint2 = __webpack_require__(141);

	var _SCNConstraint3 = _interopRequireDefault(_SCNConstraint2);

	var _SCNNode = __webpack_require__(65);

	var _SCNNode2 = _interopRequireDefault(_SCNNode);

	var _SCNMatrix = __webpack_require__(46);

	var _SCNMatrix2 = _interopRequireDefault(_SCNMatrix);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * A constraint that runs a specified closure to compute a new transform (position, rotation, and scale) for each node that the constraint affects.
	 * @access public
	 * @extends {SCNConstraint}
	 * @see https://developer.apple.com/reference/scenekit/scntransformconstraint
	 */
	var SCNTransformConstraint = function (_SCNConstraint) {
	  _inherits(SCNTransformConstraint, _SCNConstraint);

	  function SCNTransformConstraint() {
	    _classCallCheck(this, SCNTransformConstraint);

	    return _possibleConstructorReturn(this, (SCNTransformConstraint.__proto__ || Object.getPrototypeOf(SCNTransformConstraint)).apply(this, arguments));
	  }

	  _createClass(SCNTransformConstraint, [{
	    key: 'init',


	    /**
	     * constructor
	     * @access public
	     * @returns {void}
	     */
	    value: function init() {}

	    // Creating a Transform Constraint

	    /**
	     * Creates a new transform constraint.
	     * @access public
	     * @param {boolean} world - true to evaluate the constraint in the scenes world coordinate space, or false to evaluate it relative to the local coordinate space of each constrained node.
	     * @param {function(arg1: SCNNode, arg2: SCNMatrix4): SCNMatrix4} block - A block to be called when Scene Kit evaluates the constraint.The block takes the following parameters:nodeThe constrained node.transformThe constrained nodes current presentation transformationthe value of the transform property of the constrained nodes presentation object. If the node is affected by an in-progress animation, this value reflects the currently visible state of the node during the animation (rather than its target state that will be visible when the animation completes).The block returns a transformation matrix, which Scene Kit then applies to the node. If you return the transform value passed to the block, your constraint has no effect on the node. 
	     * @returns {void}
	     * @desc The world parameter determines the coordinate space of the transformations passed to and returned by the block parameter.
	     * @see https://developer.apple.com/reference/scenekit/scntransformconstraint/1468679-init
	     */

	  }, {
	    key: 'initInWorldSpaceWith',
	    value: function initInWorldSpaceWith(world, block) {}
	  }]);

	  return SCNTransformConstraint;
	}(_SCNConstraint3.default);

	exports.default = SCNTransformConstraint;

/***/ },
/* 205 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _SCNGeometry2 = __webpack_require__(68);

	var _SCNGeometry3 = _interopRequireDefault(_SCNGeometry2);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * A tube or pipe geometrya right circular cylinder with a circular hole along its central axis.
	 * @access public
	 * @extends {SCNGeometry}
	 * @see https://developer.apple.com/reference/scenekit/scntube
	 */
	var SCNTube = function (_SCNGeometry) {
	  _inherits(SCNTube, _SCNGeometry);

	  // Creating a Tube

	  /**
	   * Creates a tube geometry with the specified inner radius, outer radius, and height.
	   * @access public
	   * @constructor
	   * @param {number} innerRadius - The radius of the tubes circular central hole in the x- and z-axes of its local coordinate space.
	   * @param {number} outerRadius - The radius of the tubes circular cross section in the x- and z-axes of its local coordinate space.
	   * @param {number} height - The height of the tube along the y-axis of its local coordinate space.
	   * @desc The tube is centered in its local coordinate system. For example, if you create a tube whose outer radius is 5.0, inner radius is 1.0, and height is 10.0, its circular cross section extends from -5.0 to 5.0 along the x- and z-axes, the y-coordinates of its base and top are -5.0 and 5.0, and the hole through its center extends from -0.5 to 0.5 along the x- and z-axes.
	   * @see https://developer.apple.com/reference/scenekit/scntube/1522843-init
	   */
	  function SCNTube(innerRadius, outerRadius, height) {
	    _classCallCheck(this, SCNTube);

	    // Adjusting a Tubes Dimensions

	    /**
	     * The radius of the tubes outer circular cross section. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scntube/1523270-outerradius
	     */
	    var _this = _possibleConstructorReturn(this, (SCNTube.__proto__ || Object.getPrototypeOf(SCNTube)).call(this));

	    _this.outerRadius = 0;

	    /**
	     * The radius of the circular hole through the tube. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scntube/1524070-innerradius
	     */
	    _this.innerRadius = 0;

	    /**
	     * The extent of the tube along its y-axis. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scntube/1522640-height
	     */
	    _this.height = 0;

	    // Adjusting Geometric Detail

	    /**
	     * The number of subdivisions around the circumference of the tube. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scntube/1523619-radialsegmentcount
	     */
	    _this.radialSegmentCount = 0;

	    /**
	     * The number of subdivisions in the inner and outer surfaces of the tube along its y-axis. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scntube/1523080-heightsegmentcount
	     */
	    _this.heightSegmentCount = 0;

	    return _this;
	  }

	  return SCNTube;
	}(_SCNGeometry3.default);

	exports.default = SCNTube;

/***/ },
/* 206 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _SCNVector = __webpack_require__(44);

	var _SCNVector2 = _interopRequireDefault(_SCNVector);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var _epsilon = 0.00001;

	/**
	 * Returns a Boolean value that indicates whether the corresponding components of two vectors are equal.
	 * @access public
	 * @param {SCNVector3} a - The first vector.
	 * @param {SCNVector3} b - The second vector.
	 * @returns {boolean} - 
	 * @desc This function performs a numeric (not bitwise) comparison of each pair of component values.
	 * @see https://developer.apple.com/reference/scenekit/1409643-scnvector3equaltovector3
	 */
	var SCNVector3EqualToVector3 = function SCNVector3EqualToVector3(a, b) {
	  return Math.abs(a.x - b.x) < _epsilon && Math.abs(a.y - b.y) < _epsilon && Math.abs(a.z - b.z) < _epsilon;
	};

	exports.default = SCNVector3EqualToVector3;

/***/ },
/* 207 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _SCNVector = __webpack_require__(44);

	var _SCNVector2 = _interopRequireDefault(_SCNVector);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * 
	 * @access public
	 * @param {number[]} v - 
	 * @returns {SCNVector3} - 
	 * @see https://developer.apple.com/reference/scenekit/1524143-scnvector3fromfloat3
	 */
	var SCNVector3FromFloat3 = function SCNVector3FromFloat3(v) {
	  return new _SCNVector2.default(v);
	};

	exports.default = SCNVector3FromFloat3;

/***/ },
/* 208 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _SCNVector = __webpack_require__(44);

	var _SCNVector2 = _interopRequireDefault(_SCNVector);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	//import GLKVector3 from '../undefined/GLKVector3'

	/**
	 * Returns a three-element SceneKit vector structure corresponding to a GLKit vector structure.
	 * @access public
	 * @param {GLKVector3} vector - A three-element GLKit vector structure.
	 * @returns {SCNVector3} - 
	 * @see https://developer.apple.com/reference/scenekit/1409692-scnvector3fromglkvector3
	 */
	var SCNVector3FromGLKVector3 = function SCNVector3FromGLKVector3(vector) {
	  return null;
	};

	exports.default = SCNVector3FromGLKVector3;

/***/ },
/* 209 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _SCNVector = __webpack_require__(44);

	var _SCNVector2 = _interopRequireDefault(_SCNVector);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Returns a new three-component vector created from individual component values.
	 * @access public
	 * @param {number} x - The first component of the vector.
	 * @param {number} y - The second component of the vector.
	 * @param {number} z - The third component of the vector.
	 * @returns {SCNVector3} - 
	 * @see https://developer.apple.com/reference/scenekit/1409705-scnvector3make
	 */
	var SCNVector3Make = function SCNVector3Make(x, y, z) {
	  return new _SCNVector2.default(x, y, z);
	};

	exports.default = SCNVector3Make;

/***/ },
/* 210 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _SCNVector = __webpack_require__(44);

	var _SCNVector2 = _interopRequireDefault(_SCNVector);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * 
	 * @access public
	 * @param {SCNVector3} v - 
	 * @returns {number[]} - 
	 * @see https://developer.apple.com/reference/scenekit/1523448-scnvector3tofloat3
	 */
	var SCNVector3ToFloat3 = function SCNVector3ToFloat3(v) {
	  return [v.x, v.y, v.z];
	};

	exports.default = SCNVector3ToFloat3;

/***/ },
/* 211 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	//import GLKVector3 from '../undefined/GLKVector3'

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _SCNVector = __webpack_require__(44);

	var _SCNVector2 = _interopRequireDefault(_SCNVector);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Returns a three-element GLKit vector structure corresponding to a SceneKit vector structure.
	 * @access public
	 * @param {SCNVector3} vector - A three-element SceneKit vector structure.
	 * @returns {GLKVector3} - 
	 * @see https://developer.apple.com/reference/scenekit/1409651-scnvector3toglkvector3
	 */
	var SCNVector3ToGLKVector3 = function SCNVector3ToGLKVector3(vector) {
	  return null;
	};exports.default = SCNVector3ToGLKVector3;

/***/ },
/* 212 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _SCNVector = __webpack_require__(44);

	var _SCNVector2 = _interopRequireDefault(_SCNVector);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var SCNVector3Zero = new _SCNVector2.default(0, 0, 0);

	exports.default = SCNVector3Zero;

/***/ },
/* 213 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _SCNVector = __webpack_require__(45);

	var _SCNVector2 = _interopRequireDefault(_SCNVector);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var _epsilon = 0.00001;

	/**
	 * Returns a Boolean value that indicates whether the corresponding components of two vectors are equal.
	 * @access public
	 * @param {SCNVector4} a - The first vector.
	 * @param {SCNVector4} b - The second vector.
	 * @returns {boolean} - 
	 * @desc This function performs a numeric (not bitwise) comparison of each pair of component values.
	 * @see https://developer.apple.com/reference/scenekit/1409707-scnvector4equaltovector4
	 */
	var SCNVector4EqualToVector4 = function SCNVector4EqualToVector4(a, b) {
	  return Math.abs(a.x - b.x) < _epsilon && Math.abs(a.y - b.y) < _epsilon && Math.abs(a.z - b.z) < _epsilon && Math.abs(a.w - b.w) < _epsilon;
	};

	exports.default = SCNVector4EqualToVector4;

/***/ },
/* 214 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _SCNVector = __webpack_require__(45);

	var _SCNVector2 = _interopRequireDefault(_SCNVector);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * 
	 * @access public
	 * @param {number[]} v - 
	 * @returns {SCNVector4} - 
	 * @see https://developer.apple.com/reference/scenekit/1523606-scnvector4fromfloat4
	 */
	var SCNVector4FromFloat4 = function SCNVector4FromFloat4(v) {
	  return new _SCNVector2.default(v);
	};

	exports.default = SCNVector4FromFloat4;

/***/ },
/* 215 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _SCNVector = __webpack_require__(45);

	var _SCNVector2 = _interopRequireDefault(_SCNVector);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	//import GLKVector4 from '../undefined/GLKVector4'

	/**
	 * Returns a four-element SceneKit vector structure corresponding to a GLKit vector structure.
	 * @access public
	 * @param {GLKVector4} vector - A four-element GLKit vector structure.
	 * @returns {SCNVector4} - 
	 * @see https://developer.apple.com/reference/scenekit/1409729-scnvector4fromglkvector4
	 */
	var SCNVector4FromGLKVector4 = function SCNVector4FromGLKVector4(vector) {
	  return null;
	};

	exports.default = SCNVector4FromGLKVector4;

/***/ },
/* 216 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _SCNVector = __webpack_require__(45);

	var _SCNVector2 = _interopRequireDefault(_SCNVector);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Returns a new four-component vector created from individual component values.
	 * @access public
	 * @param {number} x - The first component of the vector.
	 * @param {number} y - The second component of the vector.
	 * @param {number} z - The third component of the vector.
	 * @param {number} w - The fourth component of the vector.
	 * @returns {SCNVector4} - 
	 * @see https://developer.apple.com/reference/scenekit/1409677-scnvector4make
	 */
	var SCNVector4Make = function SCNVector4Make(x, y, z, w) {
	  return new SCNVector4Make(x, y, z, w);
	};

	exports.default = SCNVector4Make;

/***/ },
/* 217 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _SCNVector = __webpack_require__(45);

	var _SCNVector2 = _interopRequireDefault(_SCNVector);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * 
	 * @access public
	 * @param {SCNVector4} v - 
	 * @returns {number[]} - 
	 * @see https://developer.apple.com/reference/scenekit/1523001-scnvector4tofloat4
	 */
	var SCNVector4ToFloat4 = function SCNVector4ToFloat4(v) {
	  return [v.x, v.y, v.z, v.w];
	};

	exports.default = SCNVector4ToFloat4;

/***/ },
/* 218 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	//import GLKVector4 from '../undefined/GLKVector4'

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _SCNVector = __webpack_require__(45);

	var _SCNVector2 = _interopRequireDefault(_SCNVector);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Returns a four-element GLKit vector structure corresponding to a SceneKit vector structure.
	 * @access public
	 * @param {SCNVector4} vector - A four-element SceneKit vector structure.
	 * @returns {GLKVector4} - 
	 * @see https://developer.apple.com/reference/scenekit/1409663-scnvector4toglkvector4
	 */
	var SCNVector4ToGLKVector4 = function SCNVector4ToGLKVector4(vector) {
	  return null;
	};exports.default = SCNVector4ToGLKVector4;

/***/ },
/* 219 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	//import _HTMLCanvasElement from '../util/HTMLCanvasElement'

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _CGPoint = __webpack_require__(7);

	var _CGPoint2 = _interopRequireDefault(_CGPoint);

	var _CGRect = __webpack_require__(8);

	var _CGRect2 = _interopRequireDefault(_CGRect);

	var _CGSize = __webpack_require__(9);

	var _CGSize2 = _interopRequireDefault(_CGSize);

	var _SCNRenderer = __webpack_require__(88);

	var _SCNRenderer2 = _interopRequireDefault(_SCNRenderer);

	var _SCNTechniqueSupport = __webpack_require__(85);

	var _SCNTechniqueSupport2 = _interopRequireDefault(_SCNTechniqueSupport);

	var _SCNScene = __webpack_require__(90);

	var _SCNScene2 = _interopRequireDefault(_SCNScene);

	var _SCNRenderingAPI = __webpack_require__(121);

	var _SCNRenderingAPI2 = _interopRequireDefault(_SCNRenderingAPI);

	var _SCNAntialiasingMode = __webpack_require__(124);

	var _SCNAntialiasingMode2 = _interopRequireDefault(_SCNAntialiasingMode);

	var _SCNNode = __webpack_require__(65);

	var _SCNNode2 = _interopRequireDefault(_SCNNode);

	var _SCNCamera = __webpack_require__(130);

	var _SCNCamera2 = _interopRequireDefault(_SCNCamera);

	var _SCNMatrix = __webpack_require__(46);

	var _SCNMatrix2 = _interopRequireDefault(_SCNMatrix);

	var _SCNMatrix4MakeTranslation = __webpack_require__(78);

	var _SCNMatrix4MakeTranslation2 = _interopRequireDefault(_SCNMatrix4MakeTranslation);

	var _SCNVector = __webpack_require__(45);

	var _SCNVector2 = _interopRequireDefault(_SCNVector);

	var _SKColor = __webpack_require__(11);

	var _SKColor2 = _interopRequireDefault(_SKColor);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	/*global window*/

	var _Option = {
	  preferLowPowerDevice: 'SCNPreferLowPowerDeviceKey',
	  preferredDevice: 'SCNPreferredDeviceKey',
	  preferredRenderingAPI: 'SCNPreferredRenderingAPIKey'
	};

	/**
	 * A view for displaying 3D SceneKit content.
	 * @access public
	 * @implements {SCNSceneRenderer}
	 * @implements {SCNTechniqueSupport}
	 * @see https://developer.apple.com/reference/scenekit/scnview
	 */

	var SCNView = function () {

	  // Initializing a SceneKit View

	  /**
	   * Initializes and returns a newly allocated SceneKit view object with the specified frame rectangle and options.
	   * @access public
	   * @constructor
	   * @param {CGRect} frame - The frame rectangle for the view, measured in points and specified in the coordinate system of its superview.
	   * @param {?Map<string, Object>} [options = null] - Rendering options for the view. See SCNView.
	   * @returns {void}
	   * @see https://developer.apple.com/reference/scenekit/scnview/1524215-init
	   */
	  function SCNView(frame) {
	    var _this = this;

	    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

	    _classCallCheck(this, SCNView);

	    //super()

	    // Specifying a Scene

	    /**
	     * The scene to be displayed in the view.
	     * @access private
	     * @type {?SCNScene}
	     * @see https://developer.apple.com/reference/scenekit/scnview/1523904-scene
	     */
	    this._scene = null;

	    // Configuring a View

	    /**
	     * The background color of the view.
	     * @type {SKColor}
	     * @see https://developer.apple.com/reference/scenekit/scnview/1523088-backgroundcolor
	     */
	    this._backgroundColor = _SKColor2.default.white;

	    /**
	     * A Boolean value that determines whether the user can manipulate the current point of view that is used to render the scene. 
	     * @type {boolean}
	     * @see https://developer.apple.com/reference/scenekit/scnview/1523171-allowscameracontrol
	     */
	    this.allowsCameraControl = false;

	    /**
	     * The antialiasing mode used for rendering the views scene.
	     * @type {SCNAntialiasingMode}
	     * @see https://developer.apple.com/reference/scenekit/scnview/1524085-antialiasingmode
	     */
	    this.antialiasingMode = _SCNAntialiasingMode2.default.multisampling4X;

	    /**
	     * The animation frame rate that the view uses to render its scene.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnview/1621205-preferredframespersecond
	     */
	    this.preferredFramesPerSecond = 0;

	    // Working with a Views OpenGLES Context

	    /**
	     * The OpenGLES context that the view uses to render its contents.
	     * @type {?EAGLContext}
	     * @see https://developer.apple.com/reference/scenekit/scnview/1621072-eaglcontext
	     */
	    //this.eaglContext = null


	    // Working with a Views OpenGL Context

	    /**
	     * The OpenGL context that the view uses to render its contents.
	     * @type {?NSOpenGLContext}
	     * @see https://developer.apple.com/reference/scenekit/scnview/1522850-openglcontext
	     */
	    //this.openGLContext = null

	    /**
	     * @access private
	     * @type {WebGL2RenderingContext}
	     */
	    this._context = null;

	    /**
	     * The views OpenGL pixel format.
	     * @type {?NSOpenGLPixelFormat}
	     * @see https://developer.apple.com/reference/scenekit/scnview/1523612-pixelformat
	     */
	    this.pixelFormat = null;

	    ////////////////////////////////////////////////
	    // SCNSceneRenderer
	    ////////////////////////////////////////////////

	    /**
	     * Required. The graphics technology SceneKit uses to render the scene.
	     * @access private
	     * @type {SCNRenderingAPI}
	     */
	    this._renderingAPI = _SCNRenderingAPI2.default.webGL;

	    // Participating in the Scene Rendering Process

	    /**
	     * Required. A delegate object that receives messages about SceneKits rendering process.
	     * @access private
	     * @type {?SCNSceneRendererDelegate}
	     */
	    this._delegate = null;

	    // Customizing Scene Rendering with Metal

	    //this._currentRenderCommandEncoder = null
	    this._device = null; // MTLIGAccelDevice
	    //this._commandQueue = null // MTLIGAccessCommandQueue
	    //this._colorPixelFormat = null // MTLPixelFormat
	    //this._depthPixelFormat = null // MTLPixelFormat
	    //this._stencilPixelFormat = null // MTLPixelFormat

	    // Rendering Sprite Kit Content over a Scene

	    /**
	     * Required. A Sprite Kit scene to be rendered on top of the SceneKit content.
	     * @type {?SKScene}
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1524051-overlayskscene
	     */
	    //this.overlaySKScene = null

	    // Working With Positional Audio

	    /**
	     * Required. The node representing the listeners position in the scene for use with positional audio effects.
	     * @type {?SCNNode}
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1523747-audiolistener
	     */
	    //this.audioListener = null

	    //this._audioEnvironmentNode = null
	    //this._audioEngine = null

	    // Instance Properties

	    /**
	     * Required. 
	     * @type {number}
	     * @deprecated
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1522854-currenttime
	     */
	    //this.currentTime = 0


	    ////////////////////////////////////////////////
	    // SCNTechniqueSupport
	    ////////////////////////////////////////////////

	    // Specifying a Technique

	    /**
	     * Required. The technique SceneKit uses when rendering the object.
	     * @type {?SCNTechnique}
	     * @see https://developer.apple.com/reference/scenekit/scntechniquesupport/1520496-technique
	     */
	    this.technique = null;

	    // for JavaScript

	    /**
	     * @access private
	     * @type {CGRect}
	     */
	    this._frame = frame;

	    /**
	     * @access private
	     * @type {HTMLCanvasElement}
	     */
	    this._canvas = document.createElement('canvas');
	    this._canvas.tabIndex = 1; // to get keydown/up events, it needs to set tabIndex
	    if (typeof frame === 'undefined') {
	      frame = _CGRect2.default.rectWithXYWidthHeight(0, 0, 300, 300);
	    }
	    this._canvas.style.width = frame.width;
	    this._canvas.style.height = frame.height;

	    /**
	     * @access private
	     * @type {number}
	     */
	    this._canvasWidth = 0;

	    /**
	     * @access private
	     * @type {number}
	     */
	    this._canvasHeight = 0;

	    /**
	     * @access private
	     * @type {number}
	     */
	    this._currentSystemTime = 0;

	    /**
	     * @access private
	     * @type {number}
	     */
	    this._lastUpdate = 0;

	    /**
	     * @access private
	     * @type {SCNSceneRenderer}
	     */
	    this._renderer = new _SCNRenderer2.default();
	    //this._renderer.scene = this._scene
	    //if(this._scene !== null){
	    //  this._scene._physicsWorld._renderer = this._renderer
	    //}

	    /**
	     * @access private
	     * @type {function(function(timestamp: number))}
	     */
	    this._requestAnimationFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (callback) {
	      window.setTimeout(callback, 1000 / 60);
	    };

	    var preferLowPowerDevice = options ? options[SCNView.Option.preferLowPowerDevice] : null;
	    var preferredDevice = options ? options[SCNView.Option.preferredDevice] : null;
	    var preferredRenderingAPI = options ? options[SCNView.Option.preferredRenderingAPI] : null;
	    var opt = {
	      alpha: true,
	      depth: true,
	      stencil: true,
	      antialias: true,
	      premultipliedAlpha: true,
	      preserveDrawingBuffer: false,
	      preferLowPowerToHighPerformance: Boolean(preferLowPowerDevice),
	      failIfMajorPerformanceCaveat: false
	    };

	    //const contextNames = ['webgl2', 'webgl', 'webkit-3d', 'moz-webgl', 'experimental-webgl']
	    var contextNames = ['webgl2'];
	    var _iteratorNormalCompletion = true;
	    var _didIteratorError = false;
	    var _iteratorError = undefined;

	    try {
	      for (var _iterator = contextNames[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	        var name = _step.value;

	        try {
	          this._context = this._canvas.getContext(name, opt);
	        } catch (e) {/* just ignore and try the next name */}
	        if (this._context) {
	          break;
	        }
	      }
	    } catch (err) {
	      _didIteratorError = true;
	      _iteratorError = err;
	    } finally {
	      try {
	        if (!_iteratorNormalCompletion && _iterator.return) {
	          _iterator.return();
	        }
	      } finally {
	        if (_didIteratorError) {
	          throw _iteratorError;
	        }
	      }
	    }

	    if (!this._context) {
	      throw new Error('can\'t create WebGL context');
	    }
	    this._context.viewport(frame.minX, frame.minY, frame.width, frame.height);

	    this._renderer._setContext(this._context);
	    this._renderer._backgroundColor = this._backgroundColor;
	    this._renderer._viewRect = frame;

	    this._mouseIsDown = false;
	    this._mouseDownX = 0;
	    this._mouseDownY = 0;

	    // add event listeners
	    this._canvas.addEventListener('mousedown', function (e) {
	      var ev = _this._createEvent(e);
	      _this._mouseIsDown = true;
	      _this._mouseDownX = e.clientX;
	      _this._mouseDownY = e.clientY;
	      if (_this.allowsCameraControl) {
	        _this._baseCameraPosition = _this._renderer._getCameraPosition();
	        _this._baseCameraOrientation = _this._renderer._getCameraOrientation();
	        _this._baseCameraDistance = _this._renderer._getCameraDistance();
	      }
	      _this.mouseDownWith(ev);
	    });
	    this._canvas.addEventListener('mousemove', function (e) {
	      var ev = _this._createEvent(e);
	      _this.mouseMovedWith(ev);
	      if (_this._mouseIsDown) {
	        if (_this.allowsCameraControl) {
	          var mx = e.clientX;
	          var my = e.clientY;
	          var dx = mx - _this._mouseDownX;
	          var dy = my - _this._mouseDownY;
	          var d = Math.sqrt(dx * dx + dy * dy);
	          var rotScale = 0.01;
	          if (d > 0) {
	            var r = -d * 0.5 * rotScale;
	            var sinr = Math.sin(r) / d;
	            var q = new _SCNVector2.default(dy * sinr, dx * sinr, 0, Math.cos(r));
	            var orientation = _this._baseCameraOrientation.cross(q);
	            _this._renderer._setDefaultCameraOrientation(orientation);
	          }
	          _this._renderer._switchToDefaultCamera();
	        }
	        _this.mouseDraggedWith(ev);
	      }
	    });
	    document.addEventListener('mouseup', function (e) {
	      if (_this._mouseIsDown) {
	        _this._mouseIsDown = false;
	        var ev = _this._createEvent(e);
	        _this.mouseUpWith(ev);
	      }
	    });
	    this._canvas.addEventListener('mouseover', function (e) {
	      var ev = _this._createEvent(e);
	      _this.mouseEnteredWith(ev);
	    });
	    this._canvas.addEventListener('mouseout', function (e) {
	      var ev = _this._createEvent(e);
	      _this.mouseExitedWith(ev);
	    });
	    this._canvas.addEventListener('mousewheel', function (e) {
	      var ev = _this._createEvent(e);
	      _this.scrollWheelWith(ev);
	    });

	    this._canvas.addEventListener('keydown', function (e) {
	      //const ev = this._createEvent(e)
	      var ev = {
	        keyCode: 0,
	        isARepeat: false
	      };
	      switch (e.code) {
	        case 'ArrowDown':
	          ev.keyCode = 125;
	          break;
	        case 'ArrowUp':
	          ev.keyCode = 126;
	          break;
	        case 'ArrowLeft':
	          ev.keyCode = 123;
	          break;
	        case 'ArrowRight':
	          ev.keyCode = 124;
	          break;
	      }
	      if (typeof e.repeat !== 'undefined') {
	        ev.isARepeat = e.repeat;
	      }

	      _this.keyDownWith(ev);
	    });
	    this._canvas.addEventListener('keyup', function (e) {
	      //const ev = this._createEvent(e)
	      var ev = {
	        keyCode: 0,
	        isARepeat: false
	      };
	      switch (e.code) {
	        case 'ArrowDown':
	          ev.keyCode = 125;
	          break;
	        case 'ArrowUp':
	          ev.keyCode = 126;
	          break;
	        case 'ArrowLeft':
	          ev.keyCode = 123;
	          break;
	        case 'ArrowRight':
	          ev.keyCode = 124;
	          break;
	      }
	      _this.keyUpWith(ev);
	    });
	  }

	  _createClass(SCNView, [{
	    key: 'connectedCallback',
	    value: function connectedCallback() {}
	  }, {
	    key: 'disconnectedCallback',
	    value: function disconnectedCallback() {}
	  }, {
	    key: 'attributeChangedCallback',
	    value: function attributeChangedCallback() {}

	    /**
	     * @access private
	     * @returns {void}
	     */

	  }, {
	    key: '_resizeCanvas',
	    value: function _resizeCanvas() {
	      var w = this._canvas.clientWidth;
	      var h = this._canvas.clientHeight;
	      if (this._frame && this._frame.width === w && this._frame.height === h) {
	        return;
	      }

	      this._frame = _CGRect2.default.rectWithXYWidthHeight(0, 0, w, h);
	      this._canvas.width = w;
	      this._canvas.height = h;
	      this._context.viewport(0, 0, w, h);
	      this._renderer._viewRect = this._frame;

	      this.setFrameSize(this._frame.size);
	    }

	    /**
	     *
	     * @access public
	     * @param {HTMLElement} element - parent element to append this view
	     * @returns {void}
	     */

	  }, {
	    key: 'appendTo',
	    value: function appendTo(element) {
	      var _this2 = this;

	      element.appendChild(this._canvas);

	      // update canvas size
	      if (typeof this._frame === 'undefined') {
	        this._canvas.style.width = '100%';
	        this._canvas.style.height = '100%';
	        if (this._canvas.clientHeight <= 0) {
	          this._canvas.style.height = 300;
	        }
	      }
	      this._resizeCanvas();
	      if (typeof window !== 'undefined') {
	        window.addEventListener('resize', function () {
	          _this2._resizeCanvas();
	        });
	      }
	    }
	  }, {
	    key: 'pause',


	    // Playing Action and Animation in a Views Scene

	    /**
	     * Pauses playback of the views scene.
	     * @access public
	     * @param {?Object} sender - The object requesting the action (used when connecting a control in Interface Builder). SceneKit ignores this parameter.
	     * @returns {void}
	     * @desc This method has no effect if the scene is already paused.
	     * @see https://developer.apple.com/reference/scenekit/scnview/1522825-pause
	     */
	    value: function pause(sender) {
	      if (!this._isPlaying) {
	        return;
	      }
	      this._isPlaying = false;
	    }

	    /**
	     * Resumes playback of the views scene.
	     * @access public
	     * @param {?Object} sender - The object requesting the action (used when connecting a control in Interface Builder). SceneKit ignores this parameter.
	     * @returns {void}
	     * @desc This method has no effect if the scene is not paused.
	     * @see https://developer.apple.com/reference/scenekit/scnview/1523699-play
	     */

	  }, {
	    key: 'play',
	    value: function play(sender) {
	      if (this._isPlaying) {
	        return;
	      }
	      this._isPlaying = true;

	      this.__requestAnimationFrame();
	    }

	    /**
	     * Stops playback of the views scene and resets the scene time to its start time.
	     * @access public
	     * @param {?Object} sender - The object requesting the action (used when connecting a control in Interface Builder). SceneKit ignores this parameter.
	     * @returns {void}
	     * @see https://developer.apple.com/reference/scenekit/scnview/1524132-stop
	     */

	  }, {
	    key: 'stop',
	    value: function stop(sender) {
	      this._isPlaying = false;
	    }

	    // Capturing a View Snapshot

	    /**
	     * Renders the views scene into a new image object.
	     * @access public
	     * @returns {Image} - 
	     * @desc This method is thread-safe and may be called at any time.
	     * @see https://developer.apple.com/reference/scenekit/scnview/1524031-snapshot
	     */

	  }, {
	    key: 'snapshot',
	    value: function snapshot() {
	      return null;
	    }

	    // Structures
	    /**
	     * @type {Object} Option
	     * @property {string} preferLowPowerDevice An option for whether to select low-power-usage devices for Metal rendering.
	     * @property {string} preferredDevice The device to use for Metal rendering.
	     * @property {string} preferredRenderingAPI The rendering API to use for rendering the view (for example, Metal or OpenGL).
	     * @see https://developer.apple.com/reference/scenekit/scnview.option
	     */

	  }, {
	    key: 'presentWithIncomingPointOfView',


	    ////////////////////////////////////////////////
	    // SCNSceneRenderer
	    ////////////////////////////////////////////////

	    // Presenting a Scene

	    /**
	     * Required. Displays the specified scene with an animated transition.
	     * @access public
	     * @param {SCNScene} scene - The new scene to be displayed.
	     * @param {SKTransition} transition - An object that specifies the duration and style of the animated transition.
	     * @param {?SCNNode} pointOfView - The node to use as the pointOfView property when displaying the new scene.
	     * @param {?function(): void} [completionHandler = null] - A block that SceneKit calls after the transition animation has completed.This block takes no parameters and has no return value.
	     * @returns {void}
	     * @desc Use this method to change the scene displayed in a SceneKit view (or other renderer) with an animated transition. For details on transition styles, see SKTransition.
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1523028-present
	     */
	    value: function presentWithIncomingPointOfView(scene, transition, pointOfView) {
	      var completionHandler = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
	    }

	    // Managing Scene Display

	    /**
	     * Required. The node from which the scenes contents are viewed for rendering.
	     * @type {?SCNNode}
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1523982-pointofview
	     */

	  }, {
	    key: 'prepareShouldAbortBlock',


	    // Preloading Renderer Resources

	    /**
	     * Required. Prepares a SceneKit object for rendering.
	     * @access public
	     * @param {Object} object - An SCNScene, SCNNode, SCNGeometry, or SCNMaterial instance.
	     * @param {?function(): boolean} [block = null] - A block that SceneKit calls periodically while preparing the object. The block takes no parameters.Your block should return false to tell SceneKit to continue preparing the object, or true to cancel preparation.Pass nil for this parameter if you do not need an opportunity to cancel preparing the object.
	     * @returns {boolean} - 
	     * @desc By default, SceneKit lazily loads resources onto the GPU for rendering. This approach uses memory and GPU bandwidth efficiently, but can lead to stutters in an otherwise smooth frame rate when you add large amounts of new content to an animated scene. To avoid such issues, use this method to prepare content for drawing before adding it to the scene. You can call this method on a secondary thread to prepare content asynchronously. SceneKit prepares all content associated with the object parameter you provide. If you provide an SCNMaterial object, SceneKit loads any texture images assigned to its material properties. If you provide an SCNGeometry object, SceneKit loads all materials attached to the geometry, as well as its vertex data. If you provide an SCNNode or SCNScene object, SceneKit loads all geometries and materials associated with the node and all its child nodes, or with the entire node hierarchy of the scene.You can use the block parameter to cancel preparation if content is no longer needed. For example, in a game you might use this method to preload areas of the game world the player is soon to enter, but if the player character dies before entering those areas, you can return true from the block to cancel preloading.You can observe the progress of this operation with the Progress class. For details, see Progress.
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1522798-prepare
	     */
	    value: function prepareShouldAbortBlock(object) {
	      var block = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

	      return false;
	    }

	    /**
	     * Required. Prepares the specified SceneKit objects for rendering, using a background thread.
	     * @access public
	     * @param {Object[]} objects - An array of containing one or more SCNScene, SCNNode, SCNGeometry, or SCNMaterial instances.
	     * @param {?function(arg1: boolean): void} [completionHandler = null] - A block that SceneKit calls when object preparation fails or completes.The block takes the following parameter:successtrue if all content was successfully prepared for rendering; otherwise, false.
	     * @returns {void}
	     * @desc By default, SceneKit lazily loads resources onto the GPU for rendering. This approach uses memory and GPU bandwidth efficiently, but can lead to stutters in an otherwise smooth frame rate when you add large amounts of new content to an animated scene. To avoid such issues, use this method to prepare content for drawing before adding it to the scene. SceneKit uses a secondary thread to prepare content asynchronously.SceneKit prepares all content associated with the objects you provide. If you provide an SCNMaterial object, SceneKit loads any texture images assigned to its material properties. If you provide an SCNGeometry object, SceneKit loads all materials attached to the geometry, as well as its vertex data. If you provide an SCNNode or SCNScene object, SceneKit loads all geometries and materials associated with the node and all its child nodes, or with the entire node hierarchy of the scene.You can observe the progress of this operation with the Progress class. For details, see Progress.
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1523375-prepare
	     */

	  }, {
	    key: 'prepare',
	    value: function prepare(objects) {
	      var completionHandler = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
	    }

	    // Working With Projected Scene Contents

	    /**
	     * Required. Searches the renderers scene for objects corresponding to a point in the rendered image.
	     * @access public
	     * @param {CGPoint} point - 
	     * @param {?Map<SCNHitTestOption, Object>} [options = null] - A dictionary of options affecting the search. See Hit Testing Options Keys for acceptable values.
	     * @returns {SCNHitTestResult[]} - 
	     * @desc A 2D point in the rendered screen coordinate space can refer to any point along a line segment in the 3D scene coordinate space. Hit-testing is the process of finding elements of a scene located along this line segment. For example, you can use this method to find the geometry corresponding to a click event in a SceneKit view.
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1522929-hittest
	     */

	  }, {
	    key: 'hitTest',
	    value: function hitTest(point) {
	      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

	      var x = (point.x - this._frame.minX) / this._frame.width * 2.0 - 1.0;
	      var y = (point.y - this._frame.minY) / this._frame.height * 2.0 - 1.0;
	      return this._renderer.hitTest(new _CGPoint2.default(x, -y), options);
	    }

	    /**
	     * Required. Returns a Boolean value indicating whether a node might be visible from a specified point of view.
	     * @access public
	     * @param {SCNNode} node - The node whose visibility is to be tested.
	     * @param {SCNNode} pointOfView - A node defining a point of view, as used by the pointOfView property.
	     * @returns {boolean} - 
	     * @desc Any node containing a camera or spotlight may serve as a point of view (see the pointOfView property for details). Such a node defines a viewing frustuma portion of the scenes coordinate space, shaped like a truncated pyramid, that encloses all points visible from that point of view.Use this method to test whether a node lies within the viewing frustum defined by another node (which may or may not be the scene renderers current pointOfView node). For example, in a game scene containing multiple camera nodes, you could use this method to determine which camera is currently best for viewing a moving player character.Note that this method does not perform occlusion testing. That is, it returns true if the tested node lies within the specified viewing frustum regardless of whether that nodes contents are obscured by other geometry.
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1522647-isnode
	     */

	  }, {
	    key: 'isNodeInsideFrustumOf',
	    value: function isNodeInsideFrustumOf(node, pointOfView) {
	      return false;
	    }

	    /**
	     * Required. Returns all nodes that might be visible from a specified point of view.
	     * @access public
	     * @param {SCNNode} pointOfView - A node defining a point of view, as used by the pointOfView property.
	     * @returns {SCNNode[]} - 
	     * @desc Any node containing a camera or spotlight may serve as a point of view (see the pointOfView property for details). Such a node defines a viewing frustuma portion of the scenes coordinate space, shaped like a truncated pyramid, that encloses all points visible from that point of view.Use this method find all nodes whose content lies within the viewing frustum defined by another node (which may or may not be the scene renderers current pointOfView node).Note that this method does not perform occlusion testing. That is, the returned array includes any node that lies within the specified viewing frustum regardless of whether that nodes contents are obscured by other geometry.
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1522942-nodesinsidefrustum
	     */

	  }, {
	    key: 'nodesInsideFrustumOf',
	    value: function nodesInsideFrustumOf(pointOfView) {
	      return null;
	    }

	    /**
	     * Required. Projects a point from the 3D world coordinate system of the scene to the 2D pixel coordinate system of the renderer.
	     * @access public
	     * @param {SCNVector3} point - A point in the world coordinate system of the renderers scene.
	     * @returns {SCNVector3} - 
	     * @desc The z-coordinate of the returned point describes the depth of the projected point relative to the near and far clipping planes of the renderers viewing frustum (defined by its pointOfView node). Projecting a point on the near clipping plane returns a point whose z-coordinate is 0.0; projecting a point on the far clipping plane returns a point whose z-coordinate is 1.0.
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1524089-projectpoint
	     */

	  }, {
	    key: 'projectPoint',
	    value: function projectPoint(point) {
	      return null;
	    }

	    /**
	     * Required. Unprojects a point from the 2D pixel coordinate system of the renderer to the 3D world coordinate system of the scene.
	     * @access public
	     * @param {SCNVector3} point - A point in the screen-space (view, layer, or GPU viewport) coordinate system of the scene renderer.
	     * @returns {SCNVector3} - 
	     * @desc The z-coordinate of the point parameter describes the depth at which to unproject the point relative to the near and far clipping planes of the renderers viewing frustum (defined by its pointOfView node). Unprojecting a point whose z-coordinate is 0.0 returns a point on the near clipping plane; unprojecting a point whose z-coordinate is 1.0 returns a point on the far clipping plane.A 2D point in the rendered screen coordinate space can refer to any point along a line segment in the 3D scene coordinate space. To test for scene contents along this linefor example, to find the geometry corresponding to the location of a click event in a viewuse the hitTest(_:options:) method.
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1522631-unprojectpoint
	     */

	  }, {
	    key: 'unprojectPoint',
	    value: function unprojectPoint(point) {
	      return null;
	    }

	    // Customizing Scene Rendering with Metal

	    /**
	     * Required. The Metal render command encoder in use for the current SceneKit rendering pass.
	     * @type {?MTLRenderCommandEncoder}
	     * @desc Use this render command encoder to encode additional rendering commands before or after SceneKit draws its own content.This property is valid only during the SceneKit rendering loopthat is, within one of the methods defined in the SCNSceneRendererDelegate protocol. Accessing this property at any other time returns nil.
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1522609-currentrendercommandencoder
	     */

	  }, {
	    key: 'viewDidMoveToWindow',


	    ////////////////////////////////////////////////
	    // NSView/UIView
	    ////////////////////////////////////////////////
	    // TODO: implement NSView/UIView and extend it
	    value: function viewDidMoveToWindow() {}
	  }, {
	    key: 'setFrameSize',
	    value: function setFrameSize(newSize) {}

	    /**
	     * draw one frame
	     * @access private
	     * @param {number} time - current time
	     * @param {WebGLRenderingContext} context - context to draw frame
	     * @returns {void}
	     */

	  }, {
	    key: '_drawAtTimeWithContext',
	    value: function _drawAtTimeWithContext(time, context) {
	      this._renderer._time = time;

	      this._createPresentationNodes();
	      this._createSKPresentationNodes();

	      this._updateTransform();

	      if (this._delegate && this._delegate.rendererUpdateAtTime) {
	        this._delegate.rendererUpdateAtTime(this._renderer, time);
	      }

	      ///////////////////////////////
	      // runs actions & animations //
	      ///////////////////////////////
	      this._copyTransformToPresentationNodes();
	      this._copyTransformToPresentationSKNodes();
	      this._updateTransform();

	      this._runActions();
	      this._runAnimations();
	      this._runSKActions();

	      this._updateTransform();

	      if (this._delegate && this._delegate.rendererDidApplyAnimationsAtTime) {
	        this._delegate.rendererDidApplyAnimationsAtTime(this._renderer, time);
	      }

	      this._updateTransform();

	      ///////////////////////
	      // simulates physics //
	      ///////////////////////
	      if (this._scene._physicsWorld !== null) {
	        this._scene._physicsWorld._simulate(time);
	      }

	      if (this._delegate && this._delegate.rendererDidSimulatePhysicsAtTime) {
	        this._delegate.rendererDidSimulatePhysicsAtTime(this._renderer, time);
	      }

	      ///////////////////////////
	      // evaluates constraints //
	      ///////////////////////////

	      if (this._delegate && this._delegate.rendererWillRenderSceneAtTime) {
	        this._delegate.rendererWillRenderSceneAtTime(this._renderer, this._scene, time);
	      }

	      ///////////////////////
	      // renders the scene //
	      ///////////////////////
	      this._updateMorph();
	      this._updateParticles();

	      this._updateSKTransform();
	      this._renderer.render();

	      if (this._delegate && this._delegate.rendererDidRenderSceneAtTime) {
	        this._delegate.rendererDidRenderSceneAtTime(this._renderer, time);
	      }
	    }
	  }, {
	    key: '_createPresentationNodes',
	    value: function _createPresentationNodes() {
	      var arr = [this._scene.rootNode];

	      var _loop = function _loop() {
	        var node = arr.shift();
	        var p = node._presentation;
	        if (p === null) {
	          p = node.copy();
	          p._isPresentationInstance = true;
	          if (node.geometry !== null) {
	            p.geometry = node.geometry.copy();
	            p.geometry._isPresentationInstance = true;
	            p.geometry._geometryElements = [];
	            node.geometry._geometryElements.forEach(function (element) {
	              p.geometry._geometryElements.push(element.copy());
	            });
	            p.geometry._geometrySources = [];
	            node.geometry._geometrySources.forEach(function (source) {
	              p.geometry._geometrySources.push(source.copy());
	            });
	            node.geometry._presentation = p.geometry;
	          }
	          node._presentation = p;
	        }
	        //node._copyTransformToPresentation()

	        arr.push.apply(arr, _toConsumableArray(node.childNodes));
	      };

	      while (arr.length > 0) {
	        _loop();
	      }
	    }
	  }, {
	    key: '_copyTransformToPresentationNodes',
	    value: function _copyTransformToPresentationNodes() {
	      var arr = [this._scene.rootNode, this._scene._skyBox, this._renderer._defaultCameraPosNode, this._renderer._defaultLightNode];
	      while (arr.length > 0) {
	        var _node = arr.shift();
	        _node._copyTransformToPresentation();
	        _node._copyMaterialPropertiesToPresentation();
	        arr.push.apply(arr, _toConsumableArray(_node.childNodes));
	      }
	    }
	  }, {
	    key: '_createSKPresentationNodes',
	    value: function _createSKPresentationNodes() {
	      if (this.overlaySKScene === null) {
	        return;
	      }

	      var arr = [this.overlaySKScene];
	      while (arr.length > 0) {
	        var _node2 = arr.shift();
	        var _p = _node2.__presentation;
	        if (_p === null) {
	          _p = _node2.copy();
	          _p._isPresentationInstance = true;
	          _node2.__presentation = _p;
	        }
	        //node._copyTransformToPresentation()

	        arr.push.apply(arr, _toConsumableArray(_node2.children));
	      }
	    }
	  }, {
	    key: '_copyTransformToPresentationSKNodes',
	    value: function _copyTransformToPresentationSKNodes() {
	      if (this.overlaySKScene === null) {
	        return;
	      }

	      var arr = [this.overlaySKScene];
	      while (arr.length > 0) {
	        var _node3 = arr.shift();
	        _node3._copyTransformToPresentation();
	        arr.push.apply(arr, _toConsumableArray(_node3.children));
	      }
	    }

	    /**
	     * request animation frame repeatedly as long as isPlaying is true
	     * @access private
	     * @returns {void}
	     */

	  }, {
	    key: '__requestAnimationFrame',
	    value: function __requestAnimationFrame() {
	      var _this3 = this;

	      // Reflect.apply(this._requestAnimationFrame, window, () => {
	      this._requestAnimationFrame.call(window, function () {
	        _this3._currentSystemTime = Date.now() * 0.001;
	        _this3.currentTime = _this3._currentSystemTime;
	        _this3._drawAtTimeWithContext(_this3.currentTime, _this3._context);

	        if (_this3._isPlaying) {
	          _this3.__requestAnimationFrame();
	        }
	      });
	    }
	  }, {
	    key: '_updateTransform',
	    value: function _updateTransform(node, parentTransform) {
	      this._scene.rootNode._updateWorldTransform();
	      this._scene.rootNode._updateBoundingBox();
	    }
	  }, {
	    key: '_updateMorph',
	    value: function _updateMorph(node) {
	      var _this4 = this;

	      if (typeof node === 'undefined') {
	        this._updateMorph(this._scene.rootNode);
	        return;
	      }
	      if (node.morpher !== null) {
	        node.morpher._morph(node);
	      }
	      node.childNodes.forEach(function (child) {
	        _this4._updateMorph(child);
	      });
	    }
	  }, {
	    key: '_updateSKTransform',
	    value: function _updateSKTransform() {
	      if (this.overlaySKScene === null) {
	        return;
	      }
	      this.overlaySKScene._updateWorldTransform();
	    }
	  }, {
	    key: '_runActions',
	    value: function _runActions() {
	      this._runActionForNode(this._scene.rootNode);
	    }
	  }, {
	    key: '_runActionForNode',
	    value: function _runActionForNode(node) {
	      var _this5 = this;

	      this._runActionForObject(node);
	      node.childNodes.forEach(function (child) {
	        return _this5._runActionForNode(child);
	      });
	    }
	  }, {
	    key: '_runActionForObject',
	    value: function _runActionForObject(obj) {
	      var _this6 = this;

	      var deleteKeys = [];
	      obj._actions.forEach(function (action, key) {
	        action._applyAction(obj, _this6.currentTime);
	        if (action._finished) {
	          if (action._completionHandler) {
	            action._completionHandler();
	          }
	          deleteKeys.push(key);
	        }
	      });
	      deleteKeys.forEach(function (key) {
	        obj._actions.delete(key);
	      });
	    }
	  }, {
	    key: '_runSKActions',
	    value: function _runSKActions() {
	      if (this.overlaySKScene === null) {
	        return;
	      }
	      this._runSKActionForNode(this.overlaySKScene);
	    }
	  }, {
	    key: '_runSKActionForNode',
	    value: function _runSKActionForNode(node) {
	      var _this7 = this;

	      this._runSKActionForObject(node);
	      node.children.forEach(function (child) {
	        return _this7._runSKActionForNode(child);
	      });
	    }
	  }, {
	    key: '_runSKActionForObject',
	    value: function _runSKActionForObject(obj) {
	      var _this8 = this;

	      var deleteKeys = [];
	      obj._actions.forEach(function (action, key) {
	        action._applyAction(obj, _this8.currentTime);
	        if (action._finished) {
	          if (action._completionHandler) {
	            action._completionHandler();
	          }
	          deleteKeys.push(key);
	        }
	      });
	      deleteKeys.forEach(function (key) {
	        obj._actions.delete(key);
	      });
	    }
	  }, {
	    key: '_runAnimations',
	    value: function _runAnimations() {
	      this._runAnimationForNode(this._scene.rootNode);
	    }
	  }, {
	    key: '_runAnimationForNode',
	    value: function _runAnimationForNode(node) {
	      var _this9 = this;

	      node.childNodes.forEach(function (child) {
	        return _this9._runAnimationForNode(child);
	      });
	      this._runAnimationForObject(node);
	      // TODO: implement animations for all animatable objects:
	      //         SCNCamera, SCNConstraint, SCNGeometry, SCNLight, SCNMaterial, 
	      //         SCNMaterialProperty, SCNMorpher, SCNParticleSystem, SCNTechnique
	      if (node.geometry) {
	        this._runAnimationForObject(node.geometry);
	        node.geometry.materials.forEach(function (material) {
	          _this9._runAnimationForObject(material);
	          var properties = [material._diffuse, material._ambient, material._specular, material._normal, material._reflective, material._emission, material._transparent, material._multiply, material._ambientOcclusion, material._selfIllumination, material._metalness, material._roughness];
	          properties.forEach(function (prop) {
	            _this9._runAnimationForObject(prop);
	          });
	        });
	      }
	    }
	  }, {
	    key: '_runAnimationForObject',
	    value: function _runAnimationForObject(obj, time) {
	      var _this10 = this;

	      var deleteKeys = [];
	      obj._animations.forEach(function (animation, key) {
	        animation._applyAnimation(obj, _this10.currentTime);
	        if (animation._isFinished && animation.isRemovedOnCompletion) {
	          deleteKeys.push(key);
	        }
	      });
	      deleteKeys.forEach(function (key) {
	        obj._animations.delete(key);
	      });
	    }
	  }, {
	    key: '_updateParticles',
	    value: function _updateParticles() {
	      this._updateParticlesForScene();
	      this._updateParticlesForNode(this._scene.rootNode);
	    }
	  }, {
	    key: '_updateParticlesForScene',
	    value: function _updateParticlesForScene() {
	      if (this._scene._particleSystems === null) {
	        return;
	      }
	      var gravity = this._scene.physicsWorld ? this._scene.physicsWorld.gravity : null;
	      var len = this._scene._particleSystems.length;
	      for (var i = 0; i < len; i++) {
	        var system = this._scene._particleSystems[i];
	        var transform = this._scene._particleSystemsTransform[i];
	        system._updateParticles(transform, gravity, this.currentTime);
	      }
	      var _iteratorNormalCompletion2 = true;
	      var _didIteratorError2 = false;
	      var _iteratorError2 = undefined;

	      try {
	        for (var _iterator2 = this._scene._particleSystems[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
	          var _system = _step2.value;

	          if (_system._finished) {
	            this._scene.removeParticleSystem(_system);
	          }
	        }
	      } catch (err) {
	        _didIteratorError2 = true;
	        _iteratorError2 = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion2 && _iterator2.return) {
	            _iterator2.return();
	          }
	        } finally {
	          if (_didIteratorError2) {
	            throw _iteratorError2;
	          }
	        }
	      }
	    }
	  }, {
	    key: '_updateParticlesForNode',
	    value: function _updateParticlesForNode(node) {
	      var _this11 = this;

	      this._updateParticlesForObject(node);
	      node.childNodes.forEach(function (child) {
	        return _this11._updateParticlesForNode(child);
	      });
	    }
	  }, {
	    key: '_updateParticlesForObject',
	    value: function _updateParticlesForObject(obj) {
	      if (obj.particleSystems === null) {
	        return;
	      }
	      var gravity = this._scene.physicsWorld ? this._scene.physicsWorld.gravity : null;
	      var _iteratorNormalCompletion3 = true;
	      var _didIteratorError3 = false;
	      var _iteratorError3 = undefined;

	      try {
	        for (var _iterator3 = obj.particleSystems[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
	          var system = _step3.value;

	          system._updateParticles(obj.presentation.worldTransform, gravity, this.currentTime);
	        }
	      } catch (err) {
	        _didIteratorError3 = true;
	        _iteratorError3 = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion3 && _iterator3.return) {
	            _iterator3.return();
	          }
	        } finally {
	          if (_didIteratorError3) {
	            throw _iteratorError3;
	          }
	        }
	      }

	      var _iteratorNormalCompletion4 = true;
	      var _didIteratorError4 = false;
	      var _iteratorError4 = undefined;

	      try {
	        for (var _iterator4 = obj.particleSystems[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
	          var _system2 = _step4.value;

	          if (_system2._finished) {
	            obj.removeParticleSystem(_system2);
	          }
	        }
	      } catch (err) {
	        _didIteratorError4 = true;
	        _iteratorError4 = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion4 && _iterator4.return) {
	            _iterator4.return();
	          }
	        } finally {
	          if (_didIteratorError4) {
	            throw _iteratorError4;
	          }
	        }
	      }
	    }

	    // NSView

	    /**
	     * @access private
	     * @param {Event} e -
	     * @returns {NSEvent} -
	     */

	  }, {
	    key: '_createEvent',
	    value: function _createEvent(e) {
	      // TODO: implement
	      e.locationInWindow = new _CGPoint2.default(e.clientX, e.clientY);
	      return e;
	    }

	    /**
	     * @access public
	     * @param {NSEvent} theEvent -
	     * @returns {void}
	     */

	  }, {
	    key: 'mouseDownWith',
	    value: function mouseDownWith(theEvent) {}

	    /**
	     * @access public
	     * @param {NSEvent} theEvent -
	     * @returns {void}
	     */

	  }, {
	    key: 'mouseDraggedWith',
	    value: function mouseDraggedWith(theEvent) {}

	    /**
	     * @access public
	     * @param {NSEvent} theEvent -
	     * @returns {void}
	     */

	  }, {
	    key: 'mouseUpWith',
	    value: function mouseUpWith(theEvent) {}

	    /**
	     * @access public
	     * @param {NSEvent} theEvent -
	     * @returns {void}
	     */

	  }, {
	    key: 'mouseMovedWith',
	    value: function mouseMovedWith(theEvent) {}

	    /**
	     * @access public
	     * @param {NSEvent} theEvent -
	     * @returns {void}
	     */

	  }, {
	    key: 'mouseEnteredWith',
	    value: function mouseEnteredWith(theEvent) {}

	    /**
	     * @access public
	     * @param {NSEvent} theEvent -
	     * @returns {void}
	     */

	  }, {
	    key: 'mouseExitedWith',
	    value: function mouseExitedWith(theEvent) {}

	    /**
	     * @access public
	     * @param {NSEvent} theEvent -
	     * @returns {void}
	     */

	  }, {
	    key: 'rightMouseDraggedWith',
	    value: function rightMouseDraggedWith(theEvent) {}

	    /**
	     * @access public
	     * @param {NSEvent} theEvent -
	     * @returns {void}
	     */

	  }, {
	    key: 'rightMouseUpWith',
	    value: function rightMouseUpWith(theEvent) {}

	    /**
	     * @access public
	     * @param {NSEvent} theEvent -
	     * @returns {void}
	     */

	  }, {
	    key: 'otherMouseDownWith',
	    value: function otherMouseDownWith(theEvent) {}

	    /**
	     * @access public
	     * @param {NSEvent} theEvent -
	     * @returns {void}
	     */

	  }, {
	    key: 'otherMouseDraggedWith',
	    value: function otherMouseDraggedWith(theEvent) {}

	    /**
	     * @access public
	     * @param {NSEvent} theEvent -
	     * @returns {void}
	     */

	  }, {
	    key: 'otherMouseUpWith',
	    value: function otherMouseUpWith(theEvent) {}

	    /**
	     * @access public
	     * @param {NSEvent} theEvent -
	     * @returns {void}
	     */

	  }, {
	    key: 'scrollWheelWith',
	    value: function scrollWheelWith(theEvent) {}

	    /**
	     * @access public
	     * @param {NSEvent} theEvent -
	     * @returns {void}
	     */

	  }, {
	    key: 'keyDownWith',
	    value: function keyDownWith(theEvent) {}

	    /**
	     * @access public
	     * @param {NSEvent} theEvent -
	     * @returns {void}
	     */

	  }, {
	    key: 'keyUpWith',
	    value: function keyUpWith(theEvent) {}

	    /**
	     * @access public
	     * @param {NSEvent} theEvent -
	     * @returns {void}
	     */

	  }, {
	    key: 'flagsChangedWith',
	    value: function flagsChangedWith(theEvent) {}

	    /**
	     * @access public
	     * @param {NSEvent} theEvent -
	     * @returns {void}
	     */

	  }, {
	    key: 'tablePointWith',
	    value: function tablePointWith(theEvent) {}

	    /**
	     * @access public
	     * @param {NSEvent} theEvent -
	     * @returns {void}
	     */

	  }, {
	    key: 'tableProximityWith',
	    value: function tableProximityWith(theEvent) {}
	  }, {
	    key: 'convertFrom',
	    value: function convertFrom(point, view) {
	      var sx = 0;
	      var sy = 0;
	      if (view) {
	        // FIXME: add accessor functions to get the element position
	        sx = view._frame.origin.x;
	        sy = view._frame.origin.y;
	      }
	      // FIXME: add accessor functions to get the element position
	      var rect = this._canvas.getBoundingClientRect();
	      var dx = rect.left;
	      var dy = rect.top;

	      return new _CGPoint2.default(point.x + sx - dx, point.y + sy - dy);
	    }

	    /**
	     * @type {CGRect}
	     */

	  }, {
	    key: 'backgroundColor',
	    get: function get() {
	      return this._backgroundColor;
	    },
	    set: function set(newValue) {
	      this._backgroundColor = newValue;
	      //this._context.clearColor(newValue.r, newValue.g, newValue.b, newValue.a)
	      this._renderer._backgroundColor = newValue;
	    }

	    /**
	     * Required. A Boolean value that determines whether the scene is playing.
	     * @type {boolean}
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1523401-isplaying
	     */

	  }, {
	    key: 'isPlaying',
	    get: function get() {
	      return this._renderer.isPlaying;
	    }

	    /**
	     * Required. A Boolean value that determines whether the scene is playing.
	     * @type {boolean}
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1523401-isplaying
	     */
	    ,
	    set: function set(newValue) {
	      if (newValue) {
	        this.play();
	      } else {
	        this.pause();
	      }
	    }

	    // Specifying a Scene

	    /**
	     * The scene to be displayed in the view.
	     * @access private
	     * @type {?SCNScene}
	     * @see https://developer.apple.com/reference/scenekit/scnview/1523904-scene
	     */

	  }, {
	    key: 'scene',
	    get: function get() {
	      return this._scene;
	    }

	    /**
	     * The scene to be displayed in the view.
	     * @access private
	     * @type {?SCNScene}
	     * @see https://developer.apple.com/reference/scenekit/scnview/1523904-scene
	     */
	    ,
	    set: function set(newValue) {
	      // FIXME: it should not be changed while drawing
	      this._scene = newValue;
	      this._renderer.scene = this._scene;
	      if (this._scene !== null) {
	        this._scene._physicsWorld._renderer = this._renderer;
	      }
	    }
	  }, {
	    key: 'pointOfView',
	    get: function get() {
	      return this._renderer.pointOfView;
	    },
	    set: function set(newValue) {
	      this._renderer.pointOfView = newValue;
	    }

	    /**
	     * Required. A Boolean value that determines whether SceneKit automatically adds lights to a scene.
	     * @type {boolean}
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1523812-autoenablesdefaultlighting
	     */

	  }, {
	    key: 'autoenablesDefaultLighting',
	    get: function get() {
	      return this._renderer.autoenablesDefaultLighting;
	    },
	    set: function set(newValue) {
	      this._renderer.autoenablesDefaultLighting = newValue;
	    }

	    /**
	     * Required. A Boolean value that determines whether SceneKit applies jittering to reduce aliasing artifacts.
	     * @type {boolean}
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1524026-isjitteringenabled
	     */

	  }, {
	    key: 'isJitteringEnabled',
	    get: function get() {
	      return this._renderer.isJitteringEnabled;
	    },
	    set: function set(newValue) {
	      this._renderer.isJitteringEnabled = newValue;
	    }

	    /**
	     * Required. A Boolean value that determines whether SceneKit displays rendering performance statistics in an accessory view.
	     * @type {boolean}
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1522763-showsstatistics
	     */

	  }, {
	    key: 'showsStatistics',
	    get: function get() {
	      return this._renderer.showsStatistics;
	    },
	    set: function set(newValue) {
	      this._renderer.showsStatistics = newValue;
	    }

	    /**
	     * Required. Options for drawing overlay content in a scene that can aid debugging.
	     * @type {SCNDebugOptions}
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1523281-debugoptions
	     */

	  }, {
	    key: 'debugOptions',
	    get: function get() {
	      return this._renderer.debugOptions;
	    },
	    set: function set(newValue) {
	      this._renderer.debugOptions = newValue;
	    }

	    /**
	     * Required. The current scene time.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1522680-scenetime
	     */

	  }, {
	    key: 'sceneTime',
	    get: function get() {
	      return this._renderer.sceneTime;
	    },
	    set: function set(newValue) {
	      this._renderer.sceneTime = newValue;
	    }

	    /**
	     * Required. A Boolean value that determines whether SceneKit restarts the scene time after all animations in the scene have played.
	     * @type {boolean}
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1522878-loops
	     */

	  }, {
	    key: 'loops',
	    get: function get() {
	      return this._renderer.loops;
	    },
	    set: function set(newValue) {
	      this._renderer.loops = newValue;
	    }

	    /**
	     * Required. The graphics technology SceneKit uses to render the scene.
	     * @type {SCNRenderingAPI}
	     * @desc You choose a graphics technology when initializing a scene renderer:When initializing a SCNView object, use the init(frame:options:) initializer and the preferredRenderingAPI key. Alternatively, create a view in Interface Builder and use the Rendering API control in the inspector. During initialization, the view will attempt to use the preferred API, but will fall back to a different API if the preferred one is not supported on the current hardware.To create a SCNRenderer object that renders into your own OpenGL contect, use the init(context:options:) initializer. To create a renderer for use in your own Metal workflow, use the init(device:options:) initializer.The rendering technology used by a SCNLayer object is determined by Core Animation.After initializing a renderer, this property reflects the rendering technology in use.
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1522616-renderingapi
	     */

	  }, {
	    key: 'renderingAPI',
	    get: function get() {
	      return this._renderingAPI;
	    }

	    // Participating in the Scene Rendering Process

	    /**
	     * Required. A delegate object that receives messages about SceneKits rendering process.
	     * @type {?SCNSceneRendererDelegate}
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1522671-delegate
	     */

	  }, {
	    key: 'delegate',
	    get: function get() {
	      return this._delegate;
	    }

	    /**
	     * Required. A delegate object that receives messages about SceneKits rendering process.
	     * @type {?SCNSceneRendererDelegate}
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1522671-delegate
	     */
	    ,
	    set: function set(newValue) {
	      // FIXME: delegate should not be changed while drawing
	      this._delegate = newValue;
	    }
	  }, {
	    key: 'currentRenderCommandEncoder',
	    get: function get() {
	      return this._renderer.currentRenderCommandEncoder;
	    }

	    /**
	     * Required. The Metal device this renderer uses for rendering.
	     * @type {?MTLDevice}
	     * @desc Use this property to create or look up other Metal resources that use the same device as your SceneKit renderer.NoteThis property is valid only for scene renderers whose renderingAPI value is metal. You create a SceneKit view that renders using Metal with the preferredRenderingAPI initialization option or in Interface Builder, or an SCNRenderer that uses Metal with the init(device:options:) method. For OpenGL-based scene renderers, this propertys value is always nil.
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1523935-device
	     */

	  }, {
	    key: 'device',
	    get: function get() {
	      return this._device;
	    }

	    /**
	     * Required. The Metal command queue this renderer uses for rendering.
	     * @type {?MTLCommandQueue}
	     * @desc Use this property to schedule additional command buffers for the Metal device to execute as part of the render cycle. For example, you can use a compute command encoder to modify the vertex data in a Metal buffer for use by a SCNGeometrySource object.NoteThis property is valid only for scene renderers whose renderingAPI value is metal. You create a SceneKit view that renders using Metal with the preferredRenderingAPI initialization option or in Interface Builder, or an SCNRenderer that uses Metal with the init(device:options:) method. For OpenGL-based scene renderers, this propertys value is always nil.
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1523974-commandqueue
	     */

	  }, {
	    key: 'commandQueue',
	    get: function get() {
	      return this._renderer.commandQueue;
	    }

	    /**
	     * Required. The Metal pixel format for the renderers color output.
	     * @type {MTLPixelFormat}
	     * @desc Use this property, along with the depthPixelFormat and stencilPixelFormat properties, if you perform custom drawing with Metal (see the SCNSceneRendererDelegate and SCNNodeRendererDelegate classes) and need to create a new MTLRenderPipelineState object to change the GPU state as part of your rendering.NoteThis property is valid only for scene renderers whose renderingAPI value is metal. You create a SceneKit view that renders using Metal with the preferredRenderingAPI initialization option or in Interface Builder, or an SCNRenderer that uses Metal with the init(device:options:) method. For OpenGL-based scene renderers, this propertys value is always nil.
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1523701-colorpixelformat
	     */

	  }, {
	    key: 'colorPixelFormat',
	    get: function get() {
	      return this._renderer.colorPixelFormat;
	    }

	    /**
	     * Required. The Metal pixel format for the renderers depth buffer.
	     * @type {MTLPixelFormat}
	     * @desc Use this property, along with the colorPixelFormat and stencilPixelFormat properties, if you perform custom drawing with Metal (see the SCNSceneRendererDelegate and SCNNodeRendererDelegate classes) and need to create a new MTLRenderPipelineState object to change the GPU state as part of your rendering.NoteThis property is valid only for scene renderers whose renderingAPI value is metal. You create a SceneKit view that renders using Metal with the preferredRenderingAPI initialization option or in Interface Builder, or an SCNRenderer that uses Metal with the init(device:options:) method. For OpenGL-based scene renderers, this propertys value is always nil.
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1523780-depthpixelformat
	     */

	  }, {
	    key: 'depthPixelFormat',
	    get: function get() {
	      return this._renderer.depthPixelFormat;
	    }

	    /**
	     * Required. The Metal pixel format for the renderers stencil buffer.
	     * @type {MTLPixelFormat}
	     * @desc Use this property, along with the depthPixelFormat and colorPixelFormat properties, if you perform custom drawing with Metal (see the SCNSceneRendererDelegate and SCNNodeRendererDelegate classes) and need to create a new MTLRenderPipelineState object to change the GPU state as part of your rendering.NoteThis property is valid only for scene renderers whose renderingAPI value is metal. You create a SceneKit view that renders using Metal with the preferredRenderingAPI initialization option or in Interface Builder, or an SCNRenderer that uses Metal with the init(device:options:) method. For OpenGL-based scene renderers, this propertys value is always nil.
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1523315-stencilpixelformat
	     */

	  }, {
	    key: 'stencilPixelFormat',
	    get: function get() {
	      return this._renderer._stencilPixelFormat;
	    }

	    // Customizing Scene Rendering with OpenGL

	    /**
	     * Required. The OpenGL rendering context that SceneKit uses for rendering the scene.
	     * @type {?WebGLRenderingContext}
	     * @desc In macOS, the value of this property is a Core OpenGL cglContextObj object.In iOS, the value of this property is an EAGLContext object.
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1522840-context
	     */

	  }, {
	    key: 'context',
	    get: function get() {
	      return this._renderer.context;
	    }

	    // Rendering Sprite Kit Content over a Scene

	    /**
	     * Required. A Sprite Kit scene to be rendered on top of the SceneKit content.
	     * @type {?SKScene}
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1524051-overlayskscene
	     */

	  }, {
	    key: 'overlaySKScene',
	    get: function get() {
	      return this._renderer.overlaySKScene;
	    },
	    set: function set(newValue) {
	      this._renderer.overlaySKScene = newValue;
	    }

	    // Working With Positional Audio

	    /**
	     * Required. The node representing the listeners position in the scene for use with positional audio effects.
	     * @type {?SCNNode}
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1523747-audiolistener
	     */

	  }, {
	    key: 'audioListener',
	    get: function get() {
	      return this._renderer.audioListener;
	    },
	    set: function set(newValue) {
	      this._renderer.audioListener = newValue;
	    }

	    /**
	     * Required. The 3D audio mixing node SceneKit uses for positional audio effects.
	     * @type {AVAudioEnvironmentNode}
	     * @desc SceneKit uses this audio node to spatialize sounds from SCNAudioPlayer objects attached to nodes in the scene. You can use this object in conjunction with the audioEngine property to rearrange the audio graph to add other, non-spatialized audio sources or mix in audio processing effects.
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1523582-audioenvironmentnode
	     */

	  }, {
	    key: 'audioEnvironmentNode',
	    get: function get() {
	      return this._renderer.audioEnvironmentNode;
	    }

	    /**
	     * Required. The audio engine SceneKit uses for playing scene sounds.
	     * @type {AVAudioEngine}
	     * @desc SceneKit uses this audio engine to play sounds from SCNAudioPlayer objects attached to nodes in the scene. You can use this object directly to add other sound sources not related to scene contents, or to add other sound processing nodes or mixing nodes to the audio engine. To identify the node SceneKit uses for spatializing scene sounds when connecting other nodes, use the audioEnvironmentNode property.
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1522686-audioengine
	     */

	  }, {
	    key: 'audioEngine',
	    get: function get() {
	      return this._renderer.audioEngine;
	    }

	    // Instance Properties

	    /**
	     * Required. 
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1522854-currenttime
	     */

	  }, {
	    key: 'currentTime',
	    get: function get() {
	      return this._renderer.currentTime;
	    },
	    set: function set(newValue) {
	      this._renderer.currentTime = newValue;
	    }
	  }, {
	    key: 'bounds',
	    get: function get() {
	      var rect = this._canvas.getBoundingClientRect();
	      return new _CGRect2.default(new _CGPoint2.default(rect.left, rect.top), new _CGSize2.default(rect.width, rect.height));
	    }
	  }], [{
	    key: 'Option',
	    get: function get() {
	      return _Option;
	    }
	  }]);

	  return SCNView;
	}();

	// TODO: use extension of HTMLElement when it's supported.
	//if(customElements){
	//  customElements.define('scn-view', SCNView)
	//}


	exports.default = SCNView;

/***/ },
/* 220 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

	var _NSObject2 = __webpack_require__(2);

	var _NSObject3 = _interopRequireDefault(_NSObject2);

	var _SKActionTimingMode = __webpack_require__(221);

	var _SKActionTimingMode2 = _interopRequireDefault(_SKActionTimingMode);

	var _CGPoint = __webpack_require__(7);

	var _CGPoint2 = _interopRequireDefault(_CGPoint);

	var _CGSize = __webpack_require__(9);

	var _CGSize2 = _interopRequireDefault(_CGSize);

	var _CGRect = __webpack_require__(8);

	var _CGRect2 = _interopRequireDefault(_CGRect);

	var _SKColor = __webpack_require__(11);

	var _SKColor2 = _interopRequireDefault(_SKColor);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	//import CGVector from '../CoreGraphics/CGVector'

	//import CGPath from '../CoreGraphics/CGPath'


	//import SKTexture from './SKTexture'
	//import SKWarpGeometry from './SKWarpGeometry'
	//import SKNode from './SKNode'
	//import SKActionTimingFunction from './SKActionTimingFunction'


	/**
	 * An object that is executed by an SKNode to change its structure or content.
	 * @access public
	 * @extends {NSObject}
	 * @see https://developer.apple.com/reference/spritekit/skaction
	 */
	var SKAction = function (_NSObject) {
	  _inherits(SKAction, _NSObject);

	  // Creating Custom Actions

	  /**
	   * Creates an action of the given name from an action file with a new duration.
	   * @access public
	   * @constructor
	   * @param {string} name - The name of the action.
	   * @param {string} url - The URL of the file containing the action.
	   * @param {number} sec - The duration of the action, in seconds.
	   * @see https://developer.apple.com/reference/spritekit/skaction/1417754-init
	   */
	  function SKAction(name, url, sec) {
	    _classCallCheck(this, SKAction);

	    // Inspecting an Actions Animation Properties

	    /**
	     * A speed factor that modifies how fast an action runs.
	     * @type {number}
	     * @see https://developer.apple.com/reference/spritekit/skaction/1417718-speed
	     */
	    var _this = _possibleConstructorReturn(this, (SKAction.__proto__ || Object.getPrototypeOf(SKAction)).call(this));

	    _this._speed = 1.0;

	    /**
	     * The timing mode used to execute an action.
	     * @type {SKActionTimingMode}
	     * @see https://developer.apple.com/reference/spritekit/skaction/1417807-timingmode
	     */
	    _this._timingMode = _SKActionTimingMode2.default.linear;

	    /**
	     * A block used to customize the timing function.
	     * @type {SKActionTimingFunction}
	     * @see https://developer.apple.com/reference/spritekit/skaction/1417666-timingfunction
	     */
	    _this._timingFunction = null;

	    /**
	     * The duration required to complete an action.
	     * @type {number}
	     * @see https://developer.apple.com/reference/spritekit/skaction/1417790-duration
	     */
	    _this._duration = 0;

	    /**
	     * @access private
	     * @type {boolean}
	     */
	    _this._finished = false;

	    _this._beginTime = 0;
	    _this._isRunning = false;
	    _this._pausedTime = 0;
	    _this._completionHandler = null;

	    _this.__actionStartTime = null;
	    return _this;
	  }

	  /**
	   * A speed factor that modifies how fast an action runs.
	   * @type {number}
	   * @see https://developer.apple.com/reference/spritekit/skaction/1417718-speed
	   */


	  _createClass(SKAction, [{
	    key: 'copy',


	    /**
	     * @access public
	     * @returns {SKAction} -
	     */
	    value: function copy() {
	      var action = _get(SKAction.prototype.__proto__ || Object.getPrototypeOf(SKAction.prototype), 'copy', this).call(this);

	      action._beginTime = this._beginTime;
	      action._duration = this._duration;
	      action._speed = this.speed;
	      action._timingMode = this.timingMode;
	      action._timingFunction = this.timingFunction;
	      action._finished = this._finished;
	      //action._isRunning = this._isRunning
	      //action._pausedTime = this._pausedTime
	      //action._completionHandler = this._completionHandler

	      return action;
	    }

	    /**
	     * apply action to the given node.
	     * @access private
	     * @param {Object} obj - target object to apply this action.
	     * @param {number} time - active time
	     * @param {boolean} [needTimeConversion = true] -
	     * @returns {void}
	     */

	  }, {
	    key: '_applyAction',
	    value: function _applyAction(obj, time) {
	      var needTimeConversion = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

	      var t = this._getTime(time, needTimeConversion);
	      //this._handleEvents(obj, t)
	    }
	  }, {
	    key: '_getTime',
	    value: function _getTime(time, needTimeConversion) {
	      if (!needTimeConversion) {
	        if (time >= 1.0 && !this._finished) {
	          this._finished = true;
	        }
	        return time;
	      }

	      var baseTime = this._basetimeFromTime(time);
	      if (this.timingFunction === null) {
	        return baseTime;
	      }

	      return this.timingFunction._getValueAtTime(baseTime);
	    }

	    /**
	     * convert parent time to base time
	     * @access private
	     * @param {number} time - parent time
	     * @returns {number} - animation base time for the current frame (0-1 or null).
	     */

	  }, {
	    key: '_basetimeFromTime',
	    value: function _basetimeFromTime(time) {
	      var activeTime = time - this._actionStartTime;
	      return this._basetimeFromActivetime(activeTime);
	    }

	    /**
	     * convert parent time to active time
	     * @access private
	     * @param {number} time - parent time
	     * @returns {number} - animation active time for the current frame.
	     */

	  }, {
	    key: '_activetimeFromTime',
	    value: function _activetimeFromTime(time) {
	      return time - this._actionStartTime;
	    }

	    /**
	     * convert active time to base time
	     * @access private
	     * @param {number} time - active time
	     * @returns {number} - animation base time for the current frame (0-1 or null).
	     */

	  }, {
	    key: '_basetimeFromActivetime',
	    value: function _basetimeFromActivetime(time) {
	      var dt = time - this._beginTime;
	      //let dt = time
	      if (this.speed === 0) {
	        return 0;
	      }
	      if (this._duration === 0) {
	        return dt / Math.abs(this.speed);
	      }
	      var duration = this._duration / Math.abs(this.speed);
	      if (duration === 0) {
	        duration = 0.25;
	      }

	      if (dt >= duration) {
	        // the action is over.
	        if (!this._finished) {
	          this._finished = true;
	        }
	      }

	      return dt / duration;
	    }

	    /**
	     * @access private
	     * @param {Object} from -
	     * @param {Object} to -
	     * @param {number} t -
	     * @returns {Object} -
	     */

	  }, {
	    key: '_lerp',
	    value: function _lerp(from, to, t) {
	      if (t === null) {
	        // the action is over.
	        return to;
	      }
	      //if(from instanceof SCNVector4){
	      //  // TODO: slerp for Quaternion
	      //  return from.lerp(to, t)
	      //}else if(from instanceof SCNVector3){
	      //  return from.lerp(to, t)
	      //}else if(from instanceof CGSize){
	      if (from instanceof _CGSize2.default) {
	        return from._lerp(to, t);
	      } else if (from instanceof _CGPoint2.default) {
	        return from._lerp(to, t);
	      } else if (from instanceof _CGRect2.default) {
	        return from._lerp(to, t);
	      } else if (from instanceof _SKColor2.default) {
	        return from._lerp(to, t);
	      }
	      return from + (to - from) * t;
	    }

	    /**
	     * @access private
	     * @param {Object} from -
	     * @param {Object} to -
	     * @param {number} t -
	     * @returns {Object} -
	     */
	    //_slerp(from, to, t) {
	    //  if(!(from instanceof SCNVector4)){
	    //    throw new Error('SCNAction._slerp: object is not SCNVector4')
	    //  }
	    //  return from.slerp(to, t)
	    //}

	  }, {
	    key: '_resetFinished',
	    value: function _resetFinished() {
	      this._finished = false;
	    }

	    /**
	     * Creates an action of the given name from an action file.
	     * @access public
	     * @param {string} name - The name of the action.
	     * @returns {SKAction}
	     * @see https://developer.apple.com/reference/spritekit/skaction/1417814-init
	     */

	  }, {
	    key: 'reversed',


	    // Reversing an Action

	    /**
	     * Creates an action that reverses the behavior of another action.
	     * @access public
	     * @returns {SKAction} - 
	     * @desc This method always returns an action object; however, not all actions are reversible. When reversed, some actions return an object that either does nothing or that performs the same action as the original action. For details on how an action is reversed, see the description of the class method used to create that action.
	     * @see https://developer.apple.com/reference/spritekit/skaction/1417803-reversed
	     */
	    value: function reversed() {
	      return null;
	    }
	  }, {
	    key: 'speed',
	    get: function get() {
	      return this._speed;
	    },
	    set: function set(newValue) {
	      this._speed = newValue;
	    }

	    /**
	     * The timing mode used to execute an action.
	     * @type {SKActionTimingMode}
	     * @see https://developer.apple.com/reference/spritekit/skaction/1417807-timingmode
	     */

	  }, {
	    key: 'timingMode',
	    get: function get() {
	      return this._timingMode;
	    },
	    set: function set(newValue) {
	      this._timingMode = newValue;
	    }

	    /**
	     * A block used to customize the timing function.
	     * @type {SKActionTimingFunction}
	     * @see https://developer.apple.com/reference/spritekit/skaction/1417666-timingfunction
	     */

	  }, {
	    key: 'timingFunction',
	    get: function get() {
	      return this._timingFunction;
	    },
	    set: function set(newValue) {
	      this._timingFunction = newValue;
	    }

	    /**
	     * The duration required to complete an action.
	     * @type {number}
	     * @see https://developer.apple.com/reference/spritekit/skaction/1417790-duration
	     */

	  }, {
	    key: 'duration',
	    get: function get() {
	      return this._duration;
	    },
	    set: function set(newValue) {
	      this._duration = newValue;
	    }
	  }, {
	    key: '_actionStartTime',
	    get: function get() {
	      return this.__actionStartTime;
	    },
	    set: function set(newValue) {
	      this.__actionStartTime = newValue;
	    }
	  }], [{
	    key: 'actionWithName',
	    value: function actionWithName(name) {
	      return new SKAction(name, null, 0.25);
	    }

	    /**
	     * Creates an action of the given name from an action file with a new duration.
	     * @access public
	     * @param {string} name - The name of the action.
	     * @param {number} sec - The duration of the action.
	     * @returns {void}
	     * @see https://developer.apple.com/reference/spritekit/skaction/1417697-init
	     */

	  }, {
	    key: 'actionWithNamedDuration',
	    value: function actionWithNamedDuration(name, sec) {
	      return new SKAction(name, null, sec);
	    }

	    /**
	     * Creates an action of the given name from an action file.
	     * @access public
	     * @param {string} name - The name of the action.
	     * @param {string} url - The URL of the file containing the action.
	     * @returns {void}
	     * @see https://developer.apple.com/reference/spritekit/skaction/1417680-init
	     */

	  }, {
	    key: 'actionWithNamedFrom',
	    value: function actionWithNamedFrom(name, url) {
	      return new SKAction(name, url);
	    }

	    // Creating Actions That Move Nodes

	    /**
	     * Creates an action that moves a node relative to its current position.
	     * @access public
	     * @param {number} deltaX - The x-value, in points, to add to the nodes position.
	     * @param {number} deltaY - The y-value, in points, to add to the nodes position.
	     * @param {number} sec - The duration of the animation.
	     * @returns {SKAction} - 
	     * @desc When the action executes, the nodes position property animates from its current position to its new position.This action is reversible; the reverse is created as if the following code is executed:let negDelta = CGVector(dx: -deltaX, dy: -deltaY)
	    let action = SKAction.moveBy(x: -deltaX, y: -deltaX, duration: sec)
	    let negDelta = CGVector(dx: -deltaX, dy: -deltaY)
	    let action = SKAction.moveBy(x: -deltaX, y: -deltaX, duration: sec)
	      * @see https://developer.apple.com/reference/spritekit/skaction/1417722-moveby
	     */

	  }, {
	    key: 'moveByXYDuration',
	    value: function moveByXYDuration(deltaX, deltaY, sec) {
	      return null;
	    }

	    /**
	     * Creates an action that moves a node relative to its current position.
	     * @access public
	     * @param {CGVector} delta - A vector that describes the change to apply to the nodes position.
	     * @param {number} sec - The duration of the animation.
	     * @returns {SKAction} - 
	     * @desc When the action executes, the nodes position property animates from its current position to its new position.This action is reversible; the reverse is created as if the following code is executed:let negDelta = CGVector(dx: -deltaX, dy: -deltaY)
	    let action = SKAction.move(by: negDelta, duration: sec)
	    let negDelta = CGVector(dx: -deltaX, dy: -deltaY)
	    let action = SKAction.move(by: negDelta, duration: sec)
	      * @see https://developer.apple.com/reference/spritekit/skaction/1417739-move
	     */

	  }, {
	    key: 'moveByDuration',
	    value: function moveByDuration(delta, sec) {
	      return null;
	    }

	    /**
	     * Creates an action that moves a node to a new position.
	     * @access public
	     * @param {CGPoint} location - The coordinates for the nodes new position.
	     * @param {number} sec - The duration of the animation.
	     * @returns {SKAction} - 
	     * @desc When the action executes, the nodes position property animates from its current position to its new position.This action is not reversible; the reverse of this action has the same duration but does not move the node.
	     * @see https://developer.apple.com/reference/spritekit/skaction/1417768-move
	     */

	  }, {
	    key: 'moveToDuration',
	    value: function moveToDuration(location, sec) {
	      return null;
	    }

	    /**
	     * Creates an action that moves the node along a relative path, orienting the node to the path.
	     * @access public
	     * @param {CGPath} path - A Core Graphics path whose coordinates are relative to the nodes current position.
	     * @param {number} sec - The duration of the animation.
	     * @returns {SKAction} - 
	     * @desc Calling this method is equivalent to calling the follow(_:asOffset:orientToPath:duration:) method, passing in true to both the offset and orient parameters.This action is reversible; the resulting action creates and then follows a reversed path with the same duration.
	     * @see https://developer.apple.com/reference/spritekit/skaction/1417822-follow
	     */

	  }, {
	    key: 'followDuration',
	    value: function followDuration(path, sec) {
	      return null;
	    }

	    /**
	     * Creates an action that moves the node along a relative path at a specified speed, orienting the node to the path.
	     * @access public
	     * @param {CGPath} path - A Core Graphics path whose coordinates are relative to the nodes current position.
	     * @param {number} speed - The speed at which the node should move, in points per second.
	     * @returns {SKAction} - 
	     * @desc Calling this method is equivalent to calling the follow(_:asOffset:orientToPath:speed:) method, passing in true to both the offset and orient parameters.This action is reversible; the resulting action creates and then follows a reversed path with the same speed.
	     * @see https://developer.apple.com/reference/spritekit/skaction/1417786-follow
	     */

	  }, {
	    key: 'follow',
	    value: function follow(path, speed) {
	      return null;
	    }

	    /**
	     * Creates an action that moves the node along a path.
	     * @access public
	     * @param {CGPath} path - A path to follow.
	     * @param {boolean} offset - If true, the points in the path are relative offsets to the nodes starting position. If false, the points in the node are absolute coordinate values.
	     * @param {boolean} orient - If true, the nodes zRotation property animates so that the node turns to follow the path. If false, the zRotation property of the node is unchanged.
	     * @param {number} sec - The duration of the animation.
	     * @returns {SKAction} - 
	     * @desc When the action executes, the nodes position and zRotation properties are animated along the provided path.This action is reversible; the resulting action creates a reversed path and then follows it, with the same duration.
	     * @see https://developer.apple.com/reference/spritekit/skaction/1417662-follow
	     */

	  }, {
	    key: 'followAsOffsetOrientToPathDuration',
	    value: function followAsOffsetOrientToPathDuration(path, offset, orient, sec) {
	      return null;
	    }

	    /**
	     * Creates an action that moves the node at a specified speed along a path.
	     * @access public
	     * @param {CGPath} path - A path to follow.
	     * @param {boolean} offset - If true, the points in the path are relative offsets to the nodes starting position. If false, the points in the node are absolute coordinate values.
	     * @param {boolean} orient - If true, the nodes zRotation property animates so that the node turns to follow the path. If false, the zRotation property of the node is unchanged.
	     * @param {number} speed - The speed at which the node should move, in points per second.
	     * @returns {SKAction} - 
	     * @desc When the action executes, the nodes position and zRotation properties are animated along the provided path. The duration of the action is determined by the length of the path and the speed of the node.This action is reversible; the resulting action creates a reversed path and then follows it, with the same speed.
	     * @see https://developer.apple.com/reference/spritekit/skaction/1417798-follow
	     */

	  }, {
	    key: 'followAsOffsetOrientToPath',
	    value: function followAsOffsetOrientToPath(path, offset, orient, speed) {
	      return null;
	    }

	    // Creating Actions That Rotate Nodes

	    /**
	     * Creates an action that rotates the node by a relative value.
	     * @access public
	     * @param {number} radians - The amount to rotate the node, in radians.
	     * @param {number} sec - The duration of the animation.
	     * @returns {SKAction} - 
	     * @desc When the action executes, the nodes zRotation property animates to the new angle.This action is reversible; the reverse is created as if the following code is executed:let action = SKAction.rotate(byAngle: -radians, duration: sec)
	    let action = SKAction.rotate(byAngle: -radians, duration: sec)
	      * @see https://developer.apple.com/reference/spritekit/skaction/1417805-rotate
	     */

	  }, {
	    key: 'rotateByAngleDuration',
	    value: function rotateByAngleDuration(radians, sec) {
	      return null;
	    }

	    /**
	     * Creates an action that rotates the node counterclockwise to an absolute angle.
	     * @access public
	     * @param {number} radians - The angle to rotate the node to, in radians.
	     * @param {number} sec - The duration of the animation.
	     * @returns {SKAction} - 
	     * @desc When the action executes, the nodes zRotation property is interpolated to the new angle.This action is not reversible; the reverse of this action has the same duration but does not change anything.
	     * @see https://developer.apple.com/reference/spritekit/skaction/1417668-rotate
	     */

	  }, {
	    key: 'rotateToAngleDuration',
	    value: function rotateToAngleDuration(radians, sec) {
	      return null;
	    }

	    // Creating Actions That Change a Nodes Animation Speed

	    /**
	     * Creates an action that changes how fast the node executes actions by a relative value.
	     * @access public
	     * @param {number} speed - The amount to add to the nodes speed.
	     * @param {number} sec - The duration of the animation.
	     * @returns {SKAction} - 
	     * @desc When the action executes, the nodes speed property animates to the new value.This action is reversible; the reverse is created as if the following code is executed:let action = SKAction.speed(by: -speed, duration: sec)
	    let action = SKAction.speed(by: -speed, duration: sec)
	      * @see https://developer.apple.com/reference/spritekit/skaction/1417690-speed
	     */

	  }, {
	    key: 'speedByDuration',
	    value: function speedByDuration(speed, sec) {
	      return null;
	    }

	    /**
	     * Creates an action that changes how fast the node executes actions.
	     * @access public
	     * @param {number} speed - The new value for the nodes speed.
	     * @param {number} sec - The duration of the animation.
	     * @returns {SKAction} - 
	     * @desc When the action executes, the nodes speed property animates to the new value.This action is not reversible; the reverse of this action has the same duration but does not change anything.
	     * @see https://developer.apple.com/reference/spritekit/skaction/1417684-speed
	     */

	  }, {
	    key: 'speedToDuration',
	    value: function speedToDuration(speed, sec) {
	      return null;
	    }

	    // Creating Actions That Change a Nodes Scale

	    /**
	     * Creates an action that changes the x and y scale values of a node by a relative value.
	     * @access public
	     * @param {number} scale - The amount to add to the nodes x and y scale values.
	     * @param {number} sec - The duration of the animation.
	     * @returns {SKAction} - 
	     * @desc When the action executes, the nodes xScale and yScale properties are animated to the new value.This action is reversible; the reverse is created as if the following code is executed:let action = SKAction.scale(by: -scale, duration: sec)
	    let action = SKAction.scale(by: -scale, duration: sec)
	      * @see https://developer.apple.com/reference/spritekit/skaction/1417741-scale
	     */

	  }, {
	    key: 'scaleByDuration',
	    value: function scaleByDuration(scale, sec) {
	      return null;
	    }

	    /**
	     * Creates an action that changes the x and y scale values of a node to achieve 
	     * @access public
	     * @param {CGSize} size - The new size of the node.
	     * @param {number} sec - The duration of the animation.
	     * @returns {SKAction} - 
	     * @desc When the action executes, the nodes xScale and yScale properties are animated to achieve the specified size in its parent's coordinate space. This action is not reversible; the reverse of this action has the same duration but does not change anything.
	     * @see https://developer.apple.com/reference/spritekit/skaction/1643619-scale
	     */

	  }, {
	    key: 'scaleToDuration',
	    value: function scaleToDuration(size, sec) {
	      return null;
	    }

	    /**
	     * Creates an action that adds relative values to the x and y scale values of a node.
	     * @access public
	     * @param {number} xScale - The amount to add to the nodes x scale value.
	     * @param {number} yScale - The amount to add to the nodes y scale value.
	     * @param {number} sec - The duration of the animation.
	     * @returns {SKAction} - 
	     * @desc When the action executes, the nodes xScale and yScale properties are animated to the new value.This action is reversible; the reverse is created as if the following code is executed:let action = SKAction.scaleX(by: -scaleX, y: -scaleY, duration: sec)
	    let action = SKAction.scaleX(by: -scaleX, y: -scaleY, duration: sec)
	      * @see https://developer.apple.com/reference/spritekit/skaction/1417796-scalex
	     */

	  }, {
	    key: 'scaleXByYDuration',
	    value: function scaleXByYDuration(xScale, yScale, sec) {
	      return null;
	    }

	    /**
	     * Creates an action that changes the x and y scale values of a node.
	     * @access public
	     * @param {number} xScale - The new value for the nodes x scale value.
	     * @param {number} yScale - The new value for the nodes y scale value.
	     * @param {number} sec - The duration of the animation.
	     * @returns {SKAction} - 
	     * @desc When the action executes, the nodes xScale and yScale properties are animated to the new value.This action is not reversible; the reverse of this action has the same duration but does not change anything.
	     * @see https://developer.apple.com/reference/spritekit/skaction/1417728-scalex
	     */

	  }, {
	    key: 'scaleXToYDuration',
	    value: function scaleXToYDuration(xScale, yScale, sec) {
	      return null;
	    }

	    /**
	     * Creates an action that changes the x scale value of a node to a new value.
	     * @access public
	     * @param {number} scale - The new value for the nodes x scale value.
	     * @param {number} sec - The duration of the animation.
	     * @returns {SKAction} - 
	     * @desc When the action executes, the nodes xScale property animates to the new value.This action is not reversible; the reverse of this action has the same duration but does not change anything.
	     * @see https://developer.apple.com/reference/spritekit/skaction/1417699-scalex
	     */

	  }, {
	    key: 'scaleXToDuration',
	    value: function scaleXToDuration(scale, sec) {
	      return null;
	    }

	    /**
	     * Creates an action that changes the y scale value of a node to a new value.
	     * @access public
	     * @param {number} scale - The new value for the nodes y scale value.
	     * @param {number} sec - The duration of the animation.
	     * @returns {SKAction} - 
	     * @desc When the action executes, the nodes yScale property animates to the new value.This action is not reversible; the reverse of this action has the same duration but does not change anything.
	     * @see https://developer.apple.com/reference/spritekit/skaction/1417708-scaley
	     */

	  }, {
	    key: 'scaleYToDuration',
	    value: function scaleYToDuration(scale, sec) {
	      return null;
	    }

	    // Creating Actions to Show or Hide a Node

	    /**
	     * Creates an action that makes a node visible.
	     * @access public
	     * @returns {SKAction} - 
	     * @desc This action has an instantaneous duration. When the action executes, the nodes isHidden property is set to false.This action is reversible; the reversed action hides the node.
	     * @see https://developer.apple.com/reference/spritekit/skaction/1417660-unhide
	     */

	  }, {
	    key: 'unhide',
	    value: function unhide() {
	      return null;
	    }

	    /**
	     * Creates an action that hides a node.
	     * @access public
	     * @returns {SKAction} - 
	     * @desc This action has an instantaneous duration. When the action executes, the nodes isHidden property is set to true.This action is reversible; the reversed action shows the node.
	     * @see https://developer.apple.com/reference/spritekit/skaction/1417704-hide
	     */

	  }, {
	    key: 'hide',
	    value: function hide() {
	      return null;
	    }

	    // Creating Actions That Change a Nodes Transparency

	    /**
	     * Creates an action that changes the alpha value of the node to 1.0.
	     * @access public
	     * @param {number} sec - The duration of the animation.
	     * @returns {SKAction} - 
	     * @desc When the action executes, the nodes alpha property animates from its current value to 1.0.This action is reversible; the reverse is created as if the following code is executed:let action = SKAction.fadeOut(withDuration: sec)
	    let action = SKAction.fadeOut(withDuration: sec)
	      * @see https://developer.apple.com/reference/spritekit/skaction/1417818-fadein
	     */

	  }, {
	    key: 'fadeInWithDuration',
	    value: function fadeInWithDuration(sec) {
	      return null;
	    }

	    /**
	     * Creates an action that changes the alpha value of the node to 0.0.
	     * @access public
	     * @param {number} sec - The duration of the animation.
	     * @returns {SKAction} - 
	     * @desc When the action executes, the nodes alpha property animates from its current value to 0.0. This causes the node to disappear.This action is reversible; the reverse is created as if the following code is executed:let action = SKAction.fadeIn(withDuration: sec)
	    let action = SKAction.fadeIn(withDuration: sec)
	      * @see https://developer.apple.com/reference/spritekit/skaction/1417738-fadeout
	     */

	  }, {
	    key: 'fadeOutWithDuration',
	    value: function fadeOutWithDuration(sec) {
	      return null;
	    }

	    /**
	     * Creates an action that adjusts the alpha value of a node by a relative value.
	     * @access public
	     * @param {number} factor - The amount to add to the nodes alpha value.
	     * @param {number} sec - The duration of the animation.
	     * @returns {SKAction} - 
	     * @desc When the action executes, the nodes alpha property animates to its new value.This action is reversible; the reverse is created as if the following code is executed:let action = SKAction.fadeAlpha(by: -factor, duration: sec)
	    let action = SKAction.fadeAlpha(by: -factor, duration: sec)
	      * @see https://developer.apple.com/reference/spritekit/skaction/1417716-fadealpha
	     */

	  }, {
	    key: 'fadeAlphaByDuration',
	    value: function fadeAlphaByDuration(factor, sec) {
	      return null;
	    }

	    /**
	     * Creates an action that adjusts the alpha value of a node to a new value.
	     * @access public
	     * @param {number} alpha - The new value of the nodes alpha.
	     * @param {number} sec - The duration of the animation.
	     * @returns {SKAction} - 
	     * @desc When the action executes, the nodes alpha property animates to its new value.This action is not reversible; the reverse of this action has the same duration but does not change anything.
	     * @see https://developer.apple.com/reference/spritekit/skaction/1417673-fadealpha
	     */

	  }, {
	    key: 'fadeAlphaToDuration',
	    value: function fadeAlphaToDuration(alpha, sec) {
	      return null;
	    }

	    // Creating Actions That Change a Sprite Nodes Content

	    /**
	     * Creates an action that adjusts the size of a sprite.
	     * @access public
	     * @param {number} width - The amount to add to the sprites width.
	     * @param {number} height - The amount to add to the sprites height.
	     * @param {number} duration - The duration of the animation.
	     * @returns {SKAction} - 
	     * @desc This action can only be executed by a SKSpriteNode object. When the action executes, the sprites size property animates to its new value.This action is reversible; the reverse is created as if the following code is executed:let action = SKAction.resize(byWidth: -width, height: -height, duration: sec)
	    let action = SKAction.resize(byWidth: -width, height: -height, duration: sec)
	      * @see https://developer.apple.com/reference/spritekit/skaction/1417812-resize
	     */

	  }, {
	    key: 'resizeByWidth',
	    value: function resizeByWidth(width, height, duration) {
	      return null;
	    }

	    /**
	     * Creates an action that changes the height of a sprite to a new absolute value.
	     * @access public
	     * @param {number} height - The new height of the sprite.
	     * @param {number} duration - The duration of the animation.
	     * @returns {SKAction} - 
	     * @desc This action can only be executed by an SKSpriteNode object. When the action executes, the sprites size property animates to its new value.This action is not reversible; the reverse of this action has the same duration but does not change anything.
	     * @see https://developer.apple.com/reference/spritekit/skaction/1417825-resize
	     */

	  }, {
	    key: 'resizeToHeight',
	    value: function resizeToHeight(height, duration) {
	      return null;
	    }

	    /**
	     * Creates an action that changes the width of a sprite to a new absolute value.
	     * @access public
	     * @param {number} width - The new width of the sprite.
	     * @param {number} duration - The duration of the animation.
	     * @returns {SKAction} - 
	     * @desc This action can only be executed by an SKSpriteNode object. When the action executes, the sprites size property animates to its new value.This action is not reversible; the reverse of this action has the same duration but does not change anything.
	     * @see https://developer.apple.com/reference/spritekit/skaction/1417686-resize
	     */

	  }, {
	    key: 'resizeToWidth',
	    value: function resizeToWidth(width, duration) {
	      return null;
	    }

	    /**
	     * Creates an action that changes a sprites texture.
	     * @access public
	     * @param {SKTexture} texture - The new texture to use on the sprite.
	     * @returns {SKAction} - 
	     * @desc This action can only be executed by an SKSpriteNode object. When the action executes, the sprites texture property changes immediately to the new texture.This action is not reversible; the reverse of this action does nothing.
	     * @see https://developer.apple.com/reference/spritekit/skaction/1417784-settexture
	     */

	  }, {
	    key: 'setTexture',
	    value: function setTexture(texture) {
	      return null;
	    }

	    /**
	     * Creates an action that animates changes to a sprites texture.
	     * @access public
	     * @param {SKTexture[]} textures - An array of textures to use when animating a sprite.
	     * @param {number} sec - The duration, in seconds, that each texture is displayed. 
	     * @returns {SKAction} - 
	     * @desc This action can only be executed by an SKSpriteNode object. When the action executes, the sprites texture property animates through the array of textures. The sprites texture property is changed to the next texture in the array. The action then pauses for the specified time before continuing. The action continues until it has finished animating through all of the textures in the array. The total duration of the action is the number of textures multiplied by the frame interval.This action is reversible; the resulting action animates through the same textures from last to first.
	     * @see https://developer.apple.com/reference/spritekit/skaction/1417828-animate
	     */

	  }, {
	    key: 'animateWithTimePerFrame',
	    value: function animateWithTimePerFrame(textures, sec) {
	      return null;
	    }

	    /**
	     * Creates an action that changes a sprites normal texture.
	     * @access public
	     * @param {SKTexture} texture - The new texture to use on the sprite.
	     * @returns {SKAction} - 
	     * @desc This action can only be executed by an SKSpriteNode object. When the action executes, the sprites normalTexture property changes immediately to the new texture.This action is not reversible; the reverse of this action does nothing.
	     * @see https://developer.apple.com/reference/spritekit/skaction/1417706-setnormaltexture
	     */

	  }, {
	    key: 'setNormalTexture',
	    value: function setNormalTexture(texture) {
	      return null;
	    }

	    /**
	     * Creates an action that animates changes to a sprites normal texture.
	     * @access public
	     * @param {SKTexture[]} textures - An array of textures to use.
	     * @param {number} sec - The amount of time that each texture is displayed.
	     * @returns {SKAction} - 
	     * @desc This action can only be executed by an SKSpriteNode object. When the action executes, the sprites normalTexture property animates through the array of textures. The sprites normalTexture property is changed to the next texture in the array. The action then pauses for the specified time before continuing. The action continues until it has finished animating through all of the textures in the array. The total duration of the action is the number of textures multiplied by the frame interval.This action is reversible; the resulting action animates through the same textures from last to first.
	     * @see https://developer.apple.com/reference/spritekit/skaction/1417746-animate
	     */

	  }, {
	    key: 'animateWithNormalTexturesTimePerFrame',
	    value: function animateWithNormalTexturesTimePerFrame(textures, sec) {
	      return null;
	    }

	    /**
	     * Creates an animation that animates a sprites color and blend factor.
	     * @access public
	     * @param {CGColor} color - The new color for the sprite.
	     * @param {number} colorBlendFactor - The new blend factor for the sprite.
	     * @param {number} sec - The duration of the animation.
	     * @returns {SKAction} - 
	     * @desc This action can only be executed by an SKSpriteNode object. When the action executes, the sprites color and colorBlendFactor properties are animated to their new values.This action is not reversible; the reverse of this action does nothing.
	     * @see https://developer.apple.com/reference/spritekit/skaction/1417678-colorize
	     */

	  }, {
	    key: 'colorizeWithDuration',
	    value: function colorizeWithDuration(color, colorBlendFactor, sec) {
	      return null;
	    }

	    // Creating Physics Actions

	    /**
	     * Creates an action that applies a force to the center of gravity of a nodes physics body.
	     * @access public
	     * @param {CGVector} force - A vector that describes how much force is applied in each dimension. The force is measured in Newtons.
	     * @param {number} sec - The duration over which the force is applied to the physics body.
	     * @returns {SKAction} - 
	     * @desc When the action executes, the force is applied continuously to the physics body for the duration of the action. This action accelerates the body without imparting any angular acceleration to it.This action is reversible; it applies an equal force in the opposite direction.
	     * @see https://developer.apple.com/reference/spritekit/skaction/1417782-applyforce
	     */

	  }, {
	    key: 'applyForceDuration',
	    value: function applyForceDuration(force, sec) {
	      return null;
	    }

	    /**
	     * Creates an action that applies a torque to an nodes physics body.
	     * @access public
	     * @param {number} torque - The amount of torque, in Newton-meters.
	     * @param {number} sec - The duration over which the torque is applied to the physics body.
	     * @returns {SKAction} - 
	     * @desc When the action executes, the torque is applied continuously to the physics body for the duration of the action. This action generates an angular acceleration on the body without causing any linear acceleration.This action is reversible; it applies an equal torque in the opposite direction.
	     * @see https://developer.apple.com/reference/spritekit/skaction/1417756-applytorque
	     */

	  }, {
	    key: 'applyTorqueDuration',
	    value: function applyTorqueDuration(torque, sec) {
	      return null;
	    }

	    /**
	     * Creates an action that applies an force to a specific point on a nodes physics body.
	     * @access public
	     * @param {CGVector} force - A vector that describes how much force is applied in each dimension. The force is measured in Newtons.
	     * @param {CGPoint} point - A point in scene coordinates that defines where the force is applied to the physics body.
	     * @param {number} sec - The duration over which the force is applied to the physics body.
	     * @returns {SKAction} - 
	     * @desc When the action executes, the force is applied continuously to the physics body for the duration of the action. Because the force is applied to a specific point on the body, it may impart both linear acceleration and angular acceleration. This action is reversible; it applies an equal force in the opposite direction.
	     * @see https://developer.apple.com/reference/spritekit/skaction/1417823-applyforce
	     */

	  }, {
	    key: 'applyForceAtDuration',
	    value: function applyForceAtDuration(force, point, sec) {
	      return null;
	    }

	    /**
	     * Creates an action that applies an impulse to the center of gravity of a physics body.
	     * @access public
	     * @param {CGVector} impulse - A vector that describes how much momentum to impart to the body in each dimension over the duration of the action. The impulse is measured in Newton-seconds.
	     * @param {number} sec - The duration over which the total impulse should be applied to the physics body.
	     * @returns {SKAction} - 
	     * @desc When the action executes, applies a constant force to the physics body for the duration of the action. The force is calculated by dividing the impulse strength by the duration of the action. For example, if an impulse of 1 Newton-second is applied to the physics body, and the the duration is 10 seconds, then a force of 0.1 Newtons is applied to the physics body.This action is reversible; it applies an equal impulse in the opposite direction.
	     * @see https://developer.apple.com/reference/spritekit/skaction/1417770-applyimpulse
	     */

	  }, {
	    key: 'applyImpulseDuration',
	    value: function applyImpulseDuration(impulse, sec) {
	      return null;
	    }

	    /**
	     * Creates an action that applies an angular impulse to a nodes physics body.
	     * @access public
	     * @param {number} impulse - The total impulse to apply to the physics body. The impulse is measured in Newton-seconds.
	     * @param {number} sec - The number of seconds over which to apply the impulse. For example, if you specify a duration of four seconds, one quarter of the impulse will be applied each second.
	     * @returns {SKAction} - 
	     * @desc When the action executes, applies a constant torque to the physics body for the duration of the action. The torque is calculated by dividing the impulse strength by the duration of the action. This action affects the bodys angular velocity without changing the bodys linear velocity.This action is reversible; it applies an equal angular impulse in the opposite direction.
	     * @see https://developer.apple.com/reference/spritekit/skaction/1417775-applyangularimpulse
	     */

	  }, {
	    key: 'applyAngularImpulseDuration',
	    value: function applyAngularImpulseDuration(impulse, sec) {
	      return null;
	    }

	    /**
	     * Creates an action that applies an impulse to a specific point of a nodes physics body.
	     * @access public
	     * @param {CGVector} impulse - The total impulse to apply to the physics body. The impulse is measured in Newton-seconds.
	     * @param {CGPoint} point - A point in scene coordinates that defines where the impulse was applied to the physics body.
	     * @param {number} sec - A new action object.
	     * @returns {SKAction} - 
	     * @desc When the action executes, applies a constant force to the physics body for the duration of the action. The force is calculated by dividing the impulse strength by the duration of the action. For example, if an impulse of 1 Newton-second is applied to the physics body, and the the duration is 10 seconds, then a force of 0.1 Newtons is applied to the physics body. Because the force is applied to a specific point on the body, it may impart both linear acceleration and angular acceleration.This action is reversible; it applies an equal impulse in the opposite direction.
	     * @see https://developer.apple.com/reference/spritekit/skaction/1417732-applyimpulse
	     */

	  }, {
	    key: 'applyImpulseAtDuration',
	    value: function applyImpulseAtDuration(impulse, point, sec) {
	      return null;
	    }

	    /**
	     * Creates an action that changes the charge of a nodes physics body to a new value.
	     * @access public
	     * @param {number} v - The new charge of the physics body.
	     * @param {number} duration - The duration of the animation.
	     * @returns {SKAction} - 
	     * @desc When the action executes, the physics bodys charge property animates from its current value to its new value.This action is not reversible.
	     * @see https://developer.apple.com/reference/spritekit/skaction/1417752-changecharge
	     */

	  }, {
	    key: 'changeChargeTo',
	    value: function changeChargeTo(v, duration) {
	      return null;
	    }

	    /**
	     * Creates an action that changes the charge of a nodes physics body by a relative value.
	     * @access public
	     * @param {number} v - The amount to add to the physics bodys charge.
	     * @param {number} duration - The duration of the animation.
	     * @returns {SKAction} - 
	     * @desc When the action executes, the physics bodys charge property animates from its current value to its new value.This action is reversible; the reverse is created as if the following code is executed:let action = SKAction.changeCharge(by: -v, duration: sec)
	    let action = SKAction.changeCharge(by: -v, duration: sec)
	      * @see https://developer.apple.com/reference/spritekit/skaction/1417714-changecharge
	     */

	  }, {
	    key: 'changeChargeBy',
	    value: function changeChargeBy(v, duration) {
	      return null;
	    }

	    /**
	     * Creates an action that changes the mass of a nodes physics body to a new value.
	     * @access public
	     * @param {number} v - The new mass of the physics body.
	     * @param {number} duration - The duration of the animation.
	     * @returns {SKAction} - 
	     * @desc When the action executes, the physics bodys mass property animates from its current value to its new value.This action is not reversible.
	     * @see https://developer.apple.com/reference/spritekit/skaction/1417780-changemass
	     */

	  }, {
	    key: 'changeMassTo',
	    value: function changeMassTo(v, duration) {
	      return null;
	    }

	    /**
	     * Creates an action that changes the mass of a nodes physics body by a relative value.
	     * @access public
	     * @param {number} v - The amount to add to the physics bodys mass.
	     * @param {number} duration - The duration of the animation.
	     * @returns {SKAction} - 
	     * @desc When the action executes, the physics bodys mass property animates from its current value to its new value.This action is reversible; the reverse is created as if the following code is executed:let action = SKAction.changeMass(by: -v, duration: sec)
	    let action = SKAction.changeMass(by: -v, duration: sec)
	      * @see https://developer.apple.com/reference/spritekit/skaction/1417710-changemass
	     */

	  }, {
	    key: 'changeMassBy',
	    value: function changeMassBy(v, duration) {
	      return null;
	    }

	    /**
	     * Creates an action that animates a change of a physics fields strength.
	     * @access public
	     * @param {number} strength - The new strength for the field.
	     * @param {number} sec - The duration of the animation.
	     * @returns {SKAction} - 
	     * @desc When the action executes, the field nodes strength property animates from its current value to its new value.This action is not reversible; the reverse of this action has the same duration but does not do anything.
	     * @see https://developer.apple.com/reference/spritekit/skaction/1417815-strength
	     */

	  }, {
	    key: 'strengthToDuration',
	    value: function strengthToDuration(strength, sec) {
	      return null;
	    }

	    /**
	     * Creates an action that animates a change of a physics fields strength to a value relative to the existing value.
	     * @access public
	     * @param {number} strength - The value to add to the field.
	     * @param {number} sec - The duration of the animation.
	     * @returns {SKAction} - 
	     * @desc When the action executes, the field nodes strength property animates from its current value to its new value.This action is reversible; the reverse is created as if the following code is executed:let action = SKAction.strength(by: -strength, duration: sec)
	    let action = SKAction.strength(by: -strength, duration: sec)
	      * @see https://developer.apple.com/reference/spritekit/skaction/1417762-strength
	     */

	  }, {
	    key: 'strengthByDuration',
	    value: function strengthByDuration(strength, sec) {
	      return null;
	    }

	    /**
	     * Creates an action that animates a change of a physics fields falloff.
	     * @access public
	     * @param {number} falloff - The new falloff for the field.
	     * @param {number} sec - The duration of the animation, in seconds.
	     * @returns {SKAction} - 
	     * @desc When the action runs, the field nodes falloff property animates from its current value to its new value. This action is not reversible.
	     * @see https://developer.apple.com/reference/spritekit/skaction/1417758-falloff
	     */

	  }, {
	    key: 'falloffToDuration',
	    value: function falloffToDuration(falloff, sec) {
	      return null;
	    }

	    /**
	     * Creates an action that animates a change of a physics fields falloff to a value relative to the existing value.
	     * @access public
	     * @param {number} falloff - The value to add to the falloff.
	     * @param {number} sec - The duration of the animation, in seconds.
	     * @returns {SKAction} - 
	     * @desc When the action executes, the field nodes falloff property animates from its current value to its new value.This action is reversible; the reverse is created as if the following code is executed:let action = SKAction.falloff(by: -falloff, duration: sec)
	    let action = SKAction.falloff(by: -falloff, duration: sec)
	      * @see https://developer.apple.com/reference/spritekit/skaction/1417766-falloff
	     */

	  }, {
	    key: 'falloffByDuration',
	    value: function falloffByDuration(falloff, sec) {
	      return null;
	    }

	    // Creating Actions to Warp a Node

	    /**
	     * Creates an action to distort a node through a sequence of SKWarpGeometry objects.  
	     * @access public
	     * @param {SKWarpGeometry[]} warps - The sequence of warps to apply to the node.
	     * @param {number[]} times - The times at which each warp distortion in the sequence should complete.
	     * @returns {?SKAction} - 
	     * @desc The numberOfColumns and numberOfRows in each geometry in the sequence should match.
	     * @see https://developer.apple.com/reference/spritekit/skaction/1690937-animate
	     */

	  }, {
	    key: 'animateWithWarps',
	    value: function animateWithWarps(warps, times) {
	      return null;
	    }

	    /**
	     * Creates an action to distort a node based using an SKWarpGeometry object.  
	     * @access public
	     * @param {SKWarpGeometry} warp - The warp geometry to distort the node to.
	     * @param {number} duration - The duration of the animation.
	     * @returns {?SKAction} - 
	     * @desc The numberOfColumns and numberOfRows in the node's current geometry should match those of the specified geometry.
	     * @see https://developer.apple.com/reference/spritekit/skaction/1690951-warp
	     */

	  }, {
	    key: 'warpTo',
	    value: function warpTo(warp, duration) {
	      return null;
	    }

	    // Creating Audio Actions

	    /**
	     * Creates an action that plays a sound.
	     * @access public
	     * @param {string} soundFile - The name of a sound file in the apps bundle.
	     * @param {boolean} wait - If true, the duration of this action is the same as the length of the audio playback. If false, the action is considered to have completed immediately.
	     * @returns {SKAction} - 
	     * @desc Use SKAction playSoundFileNamed:waitForCompletion: only for short incidentals. Use AVAudioPlayer for long running background music. This action is not reversible; the reversed action is identical to the original action.
	     * @see https://developer.apple.com/reference/spritekit/skaction/1417664-playsoundfilenamed
	     */

	  }, {
	    key: 'playSoundFileNamedWaitForCompletion',
	    value: function playSoundFileNamedWaitForCompletion(soundFile, wait) {
	      return null;
	    }

	    /**
	     * Creates an action that tells an audio node to start playback.
	     * @access public
	     * @returns {SKAction} - 
	     * @desc This action may only be executed on an SKAudioNode object.This action is not reversible.
	     * @see https://developer.apple.com/reference/spritekit/skaction/1417730-play
	     */

	  }, {
	    key: 'play',
	    value: function play() {
	      return null;
	    }

	    /**
	     * Creates an action that tells an audio node to pause playback.
	     * @access public
	     * @returns {SKAction} - 
	     * @desc This action may only be executed on an SKAudioNode object. The audio is paused, and if restarted, resumes at where it was paused.This action is not reversible.
	     * @see https://developer.apple.com/reference/spritekit/skaction/1417820-pause
	     */

	  }, {
	    key: 'pause',
	    value: function pause() {
	      return null;
	    }

	    /**
	     * Creates an action that tells an audio node to stop playback.
	     * @access public
	     * @returns {SKAction} - 
	     * @desc This action may only be executed on an SKAudioNode object. The audio is stopped, and if restarted, begins at the beginning.This action is not reversible.
	     * @see https://developer.apple.com/reference/spritekit/skaction/1417794-stop
	     */

	  }, {
	    key: 'stop',
	    value: function stop() {
	      return null;
	    }

	    /**
	     * Creates an action that changes an audio nodes playback rate to a new value.
	     * @access public
	     * @param {number} v - The new value for the playback rate. A playback rate of 1.0 represents normal speed.
	     * @param {number} duration - The duration of the animation, in seconds.
	     * @returns {SKAction} - 
	     * @desc When the action executes, the audio nodes playback rate animates from its current value to its new value. For more information, see AVAudio3DMixing.This action is not reversible.
	     * @see https://developer.apple.com/reference/spritekit/skaction/1417808-changeplaybackrate
	     */

	  }, {
	    key: 'changePlaybackRateTo',
	    value: function changePlaybackRateTo(v, duration) {
	      return null;
	    }

	    /**
	     * Creates an action that changes an audio nodes playback rate by a relative amount.
	     * @access public
	     * @param {number} v - The amount to change the playback rate by. A playback rate of 1.0 represents normal speed.
	     * @param {number} duration - The duration of the animation, in seconds.
	     * @returns {SKAction} - 
	     * @desc When the action executes, the audio nodes playback rate animates from its current value to its new value. For more information, see AVAudio3DMixing.This action is reversible; the reverse is created as if the following code is executed:let action = SKAction.changePlaybackRate(by: -v, duration: sec)
	    let action = SKAction.changePlaybackRate(by: -v, duration: sec)
	      * @see https://developer.apple.com/reference/spritekit/skaction/1417670-changeplaybackrate
	     */

	  }, {
	    key: 'changePlaybackRateBy',
	    value: function changePlaybackRateBy(v, duration) {
	      return null;
	    }

	    /**
	     * Creates an action that changes an audio nodes volume to a new value.
	     * @access public
	     * @param {number} v - The new value for the volume. The value should be between 0.0 (silence) and 1.0 (maximum value for source audio), inclusive. 
	     * @param {number} duration - The duration of the animation, in seconds.
	     * @returns {SKAction} - 
	     * @desc When the action executes, the audio nodes volume animates from its current value to its new value. For more information, see AVAudio3DMixing.This action is not reversible.
	     * @see https://developer.apple.com/reference/spritekit/skaction/1417682-changevolume
	     */

	  }, {
	    key: 'changeVolumeTo',
	    value: function changeVolumeTo(v, duration) {
	      return null;
	    }

	    /**
	     * Creates an action that changes an audio nodes volume by a relative value.
	     * @access public
	     * @param {number} v - The amount to change the volume by. 
	     * @param {number} duration - The duration of the animation, in seconds.
	     * @returns {SKAction} - 
	     * @desc When the action executes, the audio nodes volume animates from its current value to its new value. For more information, see AVAudio3DMixing.This action is reversible; the reverse is created as if the following code is executed:let action = SKAction.changeVolume(by: -v, duration: sec)
	    let action = SKAction.changeVolume(by: -v, duration: sec)
	      * @see https://developer.apple.com/reference/spritekit/skaction/1417726-changevolume
	     */

	  }, {
	    key: 'changeVolumeBy',
	    value: function changeVolumeBy(v, duration) {
	      return null;
	    }

	    /**
	     * Creates an action that changes an audio nodes obstruction to a new value.
	     * @access public
	     * @param {number} v - The new value for the obstruction, in decibels.
	     * @param {number} duration - The duration of the animation, in seconds.
	     * @returns {SKAction} - 
	     * @desc When the action executes, the audio nodes obstruction animates from its current value to its new value. Passing this action a value of -100 yields the greatest reduction in volume. For more information, see AVAudio3DMixing.This action is not reversible.
	     * @see https://developer.apple.com/reference/spritekit/skaction/1519718-changeobstruction
	     */

	  }, {
	    key: 'changeObstructionTo',
	    value: function changeObstructionTo(v, duration) {
	      return null;
	    }

	    /**
	     * Creates an action that changes an audio nodes obstruction by a relative value.
	     * @access public
	     * @param {number} v - The amount to change the obstruction by, in decibels.
	     * @param {number} duration - The duration of the animation, in seconds.
	     * @returns {SKAction} - 
	     * @desc When the action executes, the audio nodes obstruction animates from its current value to its new value. For more information, see AVAudio3DMixing.This action is reversible; the reverse is created as if the following code is executed:let action = SKAction.changeObstruction(by: -v, duration: sec)
	    let action = SKAction.changeObstruction(by: -v, duration: sec)
	      * @see https://developer.apple.com/reference/spritekit/skaction/1520346-changeobstruction
	     */

	  }, {
	    key: 'changeObstructionBy',
	    value: function changeObstructionBy(v, duration) {
	      return null;
	    }

	    /**
	     * Creates an action that changes an audio nodes occlusion to a new value.
	     * @access public
	     * @param {number} v - The new value for the occlusion, in decibels.
	     * @param {number} duration - The duration of the animation, in seconds.
	     * @returns {SKAction} - 
	     * @desc When the action executes, the audio nodes occlusion animates from its current value to its new value. Passing this action a value of -100 yields the greatest reduction in volume. For more information, see AVAudio3DMixing.This action is not reversible.
	     * @see https://developer.apple.com/reference/spritekit/skaction/1520433-changeocclusion
	     */

	  }, {
	    key: 'changeOcclusionTo',
	    value: function changeOcclusionTo(v, duration) {
	      return null;
	    }

	    /**
	     * Creates an action that changes an audio nodes occlusion by a relative value.
	     * @access public
	     * @param {number} v - The amount to change the occlusion by, in decibels.
	     * @param {number} duration - The duration of the animation, in seconds.
	     * @returns {SKAction} - 
	     * @desc When the action executes, the audio nodes occlusion animates from its current value to its new value. For more information, see AVAudio3DMixing.This action is reversible; the reverse is created as if the following code is executed:let action = SKAction.changeOcclusion(by: -v, duration: sec)
	    let action = SKAction.changeOcclusion(by: -v, duration: sec)
	      * @see https://developer.apple.com/reference/spritekit/skaction/1520117-changeocclusion
	     */

	  }, {
	    key: 'changeOcclusionBy',
	    value: function changeOcclusionBy(v, duration) {
	      return null;
	    }

	    /**
	     * Creates an action that changes an audio nodes reverb to a new value.
	     * @access public
	     * @param {number} v - The new value for the reverb. The value should be between 0.0 and 1.0, inclusive.
	     * @param {number} duration - The duration of the animation, in seconds.
	     * @returns {SKAction} - 
	     * @desc When the action executes, the audio nodes reverb animates from its current value to its new value. For more information, see AVAudio3DMixing.This action is not reversible.
	     * @see https://developer.apple.com/reference/spritekit/skaction/1520320-changereverb
	     */

	  }, {
	    key: 'changeReverbTo',
	    value: function changeReverbTo(v, duration) {
	      return null;
	    }

	    /**
	     * Creates an action that changes an audio nodes reverb by a relative value.
	     * @access public
	     * @param {number} v - The amount to change the reverb by.
	     * @param {number} duration - The duration of the animation, in seconds.
	     * @returns {SKAction} - 
	     * @desc When the action executes, the audio nodes reverb animates from its current value to its new value. For more information, see AVAudio3DMixing.This action is reversible; the reverse is created as if the following code is executed:let action = SKAction.changeReverb(by: -v, duration: sec)
	    let action = SKAction.changeReverb(by: -v, duration: sec)
	      * @see https://developer.apple.com/reference/spritekit/skaction/1519568-changereverb
	     */

	  }, {
	    key: 'changeReverbBy',
	    value: function changeReverbBy(v, duration) {
	      return null;
	    }

	    /**
	     * Creates an action that changes an audio nodes stereo panning to a new value.
	     * @access public
	     * @param {number} v - The new value for stereo panning. The value must between -1.0 (left channel only) and 1.0 (right channel only), inclusive.
	     * @param {number} duration - The duration of the animation, in seconds.
	     * @returns {SKAction} - 
	     * @desc When the action executes, the audio nodes stereo panning animates from its current value to its new value. For more information, see AVAudio3DMixing.This action is not reversible.
	     * @see https://developer.apple.com/reference/spritekit/skaction/1519976-stereopan
	     */

	  }, {
	    key: 'stereoPanTo',
	    value: function stereoPanTo(v, duration) {
	      return null;
	    }

	    /**
	     * Creates an action that changes an audio nodes stereo panning by a relative value.
	     * @access public
	     * @param {number} v - The amount to change the stereo panning by. 
	     * @param {number} duration - The duration of the animation, in seconds.
	     * @returns {SKAction} - 
	     * @desc When the action executes, the audio nodes stereo panning animates from its current value to its new value. For more information, see AVAudio3DMixing.This action is reversible; the reverse is created as if the following code is executed:let action = SKAction.stereoPan(by: -v, duration: sec)
	    let action = SKAction.stereoPan(by: -v, duration: sec)
	      * @see https://developer.apple.com/reference/spritekit/skaction/1519713-stereopan
	     */

	  }, {
	    key: 'stereoPanBy',
	    value: function stereoPanBy(v, duration) {
	      return null;
	    }

	    // Removing Nodes from the Scene

	    /**
	     * Creates an action that removes the node from its parent.
	     * @access public
	     * @returns {SKAction} - 
	     * @desc When the action executes, the node is immediately removed from its parent.This action is not reversible; the reverse of this action is the same action.
	     * @see https://developer.apple.com/reference/spritekit/skaction/1417748-removefromparent
	     */

	  }, {
	    key: 'removeFromParent',
	    value: function removeFromParent() {
	      return null;
	    }

	    // Creating Actions That Perform Actions on a Nodes Child

	    /**
	     * Creates an action that runs an action on a named child object.
	     * @access public
	     * @param {SKAction} action - The action to execute.
	     * @param {string} name - The name of a child object. See the name property on the SKNode object.
	     * @returns {SKAction} - 
	     * @desc This action has an instantaneous duration, although the action executed on the child may have a duration of its own. When the action executes, it looks up an appropriate child node and calls its run(_:) method, passing in the action to execute. This action is reversible; it tells the child to execute the reverse of the action specified by the action parameter.
	     * @see https://developer.apple.com/reference/spritekit/skaction/1417671-run
	     */

	  }, {
	    key: 'runOnChildWithName',
	    value: function runOnChildWithName(action, name) {
	      return null;
	    }

	    // Creating Actions That Combine or Repeat Other Actions

	    /**
	     * Creates an action that runs a collection of actions in parallel.
	     * @access public
	     * @param {SKAction[]} actions - An array of SKAction objects.
	     * @returns {SKAction} - 
	     * @desc When the action executes, the actions that comprise the group all start immediately and run in parallel. The duration of the group action is the longest duration among the collection of actions. If an action in the group has a duration less than the groups duration, the action completes, then idles until the group completes the remaining actions. This matters most when creating a repeating action that repeats a group.This action is reversible; it creates a new group action that contains the reverse of each action specified in the group. 
	     * @see https://developer.apple.com/reference/spritekit/skaction/1417688-group
	     */

	  }, {
	    key: 'group',
	    value: function group(actions) {
	      return null;
	    }

	    /**
	     * Creates an action that runs a collection of actions sequentially.
	     * @access public
	     * @param {SKAction[]} actions - An array of SKAction objects.
	     * @returns {SKAction} - 
	     * @desc When the action executes, the first action in the sequence starts and runs to completion. Subsequent actions in the sequence run in a similar fashion until all of the actions in the sequence have executed. The duration of the sequence action is the sum of the durations of the actions in the sequence.This action is reversible; it creates a new sequence action that reverses the order of the actions. Each action in the reversed sequence is itself reversed. For example, if an action sequence is {1,2,3}, the reversed sequence would be {3R,2R,1R}.
	     * @see https://developer.apple.com/reference/spritekit/skaction/1417817-sequence
	     */

	  }, {
	    key: 'sequence',
	    value: function sequence(actions) {
	      return null;
	    }

	    /**
	     * Creates an action that repeats another action a specified number of times.
	     * @access public
	     * @param {SKAction} action - The action to execute.
	     * @param {number} count - The number of times to execute the action.
	     * @returns {SKAction} - 
	     * @desc When the action executes, the associated action runs to completion and then repeats, until the count is reached.This action is reversible; it creates a new action that is the reverse of the specified action and then repeats it the same number of times.
	     * @see https://developer.apple.com/reference/spritekit/skaction/1417750-repeat
	     */

	  }, {
	    key: 'repeat',
	    value: function repeat(action, count) {
	      return null;
	    }

	    /**
	     * Creates an action that repeats another action forever.
	     * @access public
	     * @param {SKAction} action - The action to execute.
	     * @returns {SKAction} - 
	     * @desc When the action executes, the associated action runs to completion and then repeats.This action is reversible; it creates a new action that is the reverse of the specified action and then repeats it forever.NoteThe action to be repeated must have a non-instantaneous duration.
	     * @see https://developer.apple.com/reference/spritekit/skaction/1417676-repeatforever
	     */

	  }, {
	    key: 'repeatForever',
	    value: function repeatForever(action) {
	      return null;
	    }

	    // Creating an Action to Introduce a Delay into a Sequence

	    /**
	     * Creates an action that idles for a specified period of time.
	     * @access public
	     * @param {number} sec - The amount of time to wait.
	     * @returns {SKAction} - 
	     * @desc When the action executes, the action waits for the specified amount of time, then ends. This is typically used as part of a sequence of actions to insert a delay between two other actions. You might also use it in conjunction with the run(_:completion:) method to trigger code that needs to run at a later time.This action is not reversible; the reverse of this action is the same action.
	     * @see https://developer.apple.com/reference/spritekit/skaction/1417788-wait
	     */

	  }, {
	    key: 'waitForDuration',
	    value: function waitForDuration(sec) {
	      return null;
	    }

	    /**
	     * Creates an action that idles for a randomized period of time.
	     * @access public
	     * @param {number} sec - The average amount of time to wait.
	     * @param {number} durationRange - The range of possible values for the duration.
	     * @returns {SKAction} - 
	     * @desc When the action executes, the action waits for the specified amount of time, then ends. This is typically used as part of a sequence of actions to insert a delay between two other actions. However, you might also use it in conjunction with the run(_:completion:) method to trigger code that needs to run at a later time.Each time the action is executed, the action computes a new random value for the duration. The duration may vary in either direction by up to half of the value of the durationRange parameter.This action is not reversible; the reverse of this action is the same action.
	     * @see https://developer.apple.com/reference/spritekit/skaction/1417760-wait
	     */

	  }, {
	    key: 'waitForDurationWithRange',
	    value: function waitForDurationWithRange(sec, durationRange) {
	      return null;
	    }

	    // Creating Actions to Perform Inverse Kinematic Calculations

	    /**
	     * Creates an action that performs an inverse kinematic reach.
	     * @access public
	     * @param {SKNode} node - The node whose position the current node should move closer to. 
	     * @param {SKNode} root - The highest level ancestor of the target node that should be rotated.
	     * @param {number} sec - The length of the animation.
	     * @returns {SKAction} - 
	     * @desc This action is typically used to implement character animation across a series of moving parts. When the action executes, it performs an inverse kinematic calculation to determine new rotation values for the target node and any of its ancestors up to and including the root node. Each node is rotated around its anchor point in an attempt to get the targeted nodes position closer to the intended destination. Each nodes rotation value is constrained by that nodes reachConstraints property. If the action cannot successfully reach the target position, it gets the node as close as it can to the target position.This action is not reversible; the reverse of this action is the same action.
	     * @see https://developer.apple.com/reference/spritekit/skaction/1417827-reach
	     */

	  }, {
	    key: 'reachToRootNodeDuration',
	    value: function reachToRootNodeDuration(node, root, sec) {
	      return null;
	    }

	    /**
	     * Creates an action that performs an inverse kinematic reach.
	     * @access public
	     * @param {CGPoint} position - The intended destination for the node, specified in the scenes coordinate system. 
	     * @param {SKNode} root - The highest level ancestor of the target node that should be rotated.
	     * @param {number} velocity - The maximum speed at which the node should move.
	     * @returns {SKAction} - 
	     * @desc This action is typically used to implement character animation across a series of moving parts. When the action executes, it performs an inverse kinematic calculation to determine new rotation values for the target node and any of its ancestors up to and including the root node. Each node is rotated around its anchor point in an attempt to get the targeted nodes position closer to the intended destination. Each nodes rotation value is constrained by that nodes reachConstraints property. If the action cannot successfully reach the target position, it gets the node as close as it can to the target position.The duration of the action is calculated implicitly based on the speed of movement and the distance that the node needs to travel.This action is not reversible; the reverse of this action is the same action.
	     * @see https://developer.apple.com/reference/spritekit/skaction/1417720-reach
	     */

	  }, {
	    key: 'reachToRootNode',
	    value: function reachToRootNode(position, root, velocity) {
	      return null;
	    }

	    /**
	     * Creates an action that executes a block over a duration.
	     * @access public
	     * @param {number} seconds - The duration of the action, in seconds.
	     * @param {function(arg1: SKNode, arg2: number): void} block - The block to run. The block takes the following parameters:nodeThe node on which the action is running.elapsedTimeThe amount of time that has passed in the animation.
	     * @returns {SKAction} - 
	     * @desc When the action executes, the block is called repeatedly until the actions duration expires. The elapsed time is computed and passed to the block whenever the block is called.This action is not reversible; the reverse action executes the same block.The following code shows how you can create a custom action to update an attribute of an SKShader attached to a sprite node. let customAction = SKAction.customAction(withDuration: 2.0) {
	      node, elapsedTime in
	      
	      if let node = node as? SKSpriteNode {
	          node.setValue(SKAttributeValue(float: Float(elapsedTime)),
	                                         forAttribute: "a_time")
	      }
	    }
	    let customAction = SKAction.customAction(withDuration: 2.0) {
	      node, elapsedTime in
	      
	      if let node = node as? SKSpriteNode {
	          node.setValue(SKAttributeValue(float: Float(elapsedTime)),
	                                         forAttribute: "a_time")
	      }
	    }
	      * @see https://developer.apple.com/reference/spritekit/skaction/1417745-customaction
	     */

	  }, {
	    key: 'customActionWithDurationActionBlock',
	    value: function customActionWithDurationActionBlock(seconds, block) {
	      return null;
	    }

	    /**
	     * Creates an action that calls a method on an object.
	     * @access public
	     * @param {function} selector - The selector of the method to call.
	     * @param {Object} target - The target object.
	     * @returns {SKAction} - 
	     * @desc The action object maintains a strong reference to the target object.When the action executes, the target objects method is called. This action occurs instantaneously.This action is not reversible; the reverse of this action calls the selector again.
	     * @see https://developer.apple.com/reference/spritekit/skaction/1417764-perform
	     */

	  }, {
	    key: 'performOnTarget',
	    value: function performOnTarget(selector, target) {
	      return null;
	    }

	    /**
	     * Creates an action that executes a block.
	     * @access public
	     * @param {function(): void} block - The block to run.
	     * @returns {SKAction} - 
	     * @desc When the action executes, the block is called. This action takes place instantaneously.This action is not reversible; the reverse action executes the same block.
	     * @see https://developer.apple.com/reference/spritekit/skaction/1417692-run
	     */

	  }, {
	    key: 'run',
	    value: function run(block) {
	      return null;
	    }
	  }]);

	  return SKAction;
	}(_NSObject3.default);

	exports.default = SKAction;

/***/ },
/* 221 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * The modes that an action can use to adjust the apparent timing of the action.
	 * @typedef {Object} SKActionTimingMode
	 * @property {number} linear - Specifies linear pacing. Linear pacing causes an animation to occur evenly over its duration.
	 * @property {number} easeIn - Specifies ease-in pacing. Ease-in pacing causes the animation to begin slowly and then speed up as it progresses.
	 * @property {number} easeOut - Specifies ease-out pacing. Ease-out pacing causes the animation to begin quickly and then slow as it completes.
	 * @property {number} easeInEaseOut - Specifies ease-in ease-out pacing. An ease-in ease-out animation begins slowly, accelerates through the middle of its duration, and then slows again before completing.
	 * @see https://developer.apple.com/reference/spritekit/skactiontimingmode
	 */

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var SKActionTimingMode = {
	  linear: 0,
	  easeIn: 1,
	  easeOut: 2,
	  easeInEaseOut: 3
	};

	exports.default = SKActionTimingMode;

/***/ },
/* 222 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _SKNode2 = __webpack_require__(133);

	var _SKNode3 = _interopRequireDefault(_SKNode2);

	var _SKBlendMode = __webpack_require__(132);

	var _SKBlendMode2 = _interopRequireDefault(_SKBlendMode);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	//import SKWarpable from './SKWarpable'


	//import SKShader from './SKShader'
	//import SKAttributeValue from './SKAttributeValue'


	/**
	 * A node that can apply Core Image filters or SKWarpGeometry distortions to its children.
	 * @access public
	 * @extends {SKNode}
	 * @implements {SKWarpable}
	 * @see https://developer.apple.com/reference/spritekit/skeffectnode
	 */
	var SKEffectNode = function (_SKNode) {
	  _inherits(SKEffectNode, _SKNode);

	  /**
	   * constructor
	   * @access public
	   * @constructor
	   */
	  function SKEffectNode() {
	    _classCallCheck(this, SKEffectNode);

	    // Enabling Filter Effects

	    /**
	     * A Boolean value that determines whether the effect node applies the filter to its children as they are drawn.
	     * @type {boolean}
	     * @see https://developer.apple.com/reference/spritekit/skeffectnode/1459385-shouldenableeffects
	     */
	    var _this = _possibleConstructorReturn(this, (SKEffectNode.__proto__ || Object.getPrototypeOf(SKEffectNode)).call(this));

	    _this.shouldEnableEffects = true;

	    // Configuring the Filter

	    /**
	     * The Core Image filter to apply.
	     * @type {?CIFilter}
	     * @see https://developer.apple.com/reference/spritekit/skeffectnode/1459392-filter
	     */
	    _this.filter = null;

	    /**
	     * A Boolean value that determines whether the effect node automatically sets the filters image center.
	     * @type {boolean}
	     * @see https://developer.apple.com/reference/spritekit/skeffectnode/1459390-shouldcenterfilter
	     */
	    _this.shouldCenterFilter = true;

	    // Blending the Results to the Framebuffer

	    /**
	     * The blend mode used to draw the filtered image into the parents framebuffer.
	     * @type {SKBlendMode}
	     * @see https://developer.apple.com/reference/spritekit/skeffectnode/1459386-blendmode
	     */
	    _this.blendMode = _SKBlendMode2.default.alpha;

	    // Working with Custom Shaders

	    /**
	     * A custom shader that is called when the effect node is blended into the parents framebuffer.
	     * @type {?SKShader}
	     * @see https://developer.apple.com/reference/spritekit/skeffectnode/1459388-shader
	     */
	    _this.shader = null;

	    /**
	     * The values of each attribute associated with the node's attached shader.
	     * @type {Map<string, SKAttributeValue>}
	     * @see https://developer.apple.com/reference/spritekit/skeffectnode/2715848-attributevalues
	     */
	    _this.attributeValues = new Map();

	    // Caching the Filter Results

	    /**
	     * A Boolean value that indicates whether the results of rendering the child nodes should be cached.
	     * @type {boolean}
	     * @see https://developer.apple.com/reference/spritekit/skeffectnode/1459381-shouldrasterize
	     */
	    _this.shouldRasterize = false;

	    return _this;
	  }

	  // Working with Custom Shaders

	  /**
	   * Sets an attribute value for an attached shader.
	   * @access public
	   * @param {SKAttributeValue} value - An attribute value object containing the scalar or vector value to set in the attached shader.
	   * @param {string} key - The attribute name.
	   * @returns {void}
	   * @see https://developer.apple.com/reference/spritekit/skeffectnode/2715853-setvalue
	   */
	  //setValueForAttribute(value, key) {
	  //}

	  /**
	   * The value of a shader attribute.
	   * @access public
	   * @param {string} key - The attribute name.
	   * @returns {?SKAttributeValue} - 
	   * @see https://developer.apple.com/reference/spritekit/skeffectnode/2715844-value
	   */
	  //valueForAttributeNamed(key) {
	  //  return null
	  //}


	  return SKEffectNode;
	}(_SKNode3.default);

	exports.default = SKEffectNode;

/***/ },
/* 223 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

	var _SKAction2 = __webpack_require__(220);

	var _SKAction3 = _interopRequireDefault(_SKAction2);

	var _SKActionTimingMode = __webpack_require__(221);

	var _SKActionTimingMode2 = _interopRequireDefault(_SKActionTimingMode);

	var _SKNode = __webpack_require__(133);

	var _SKNode2 = _interopRequireDefault(_SKNode);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var SKFade = function (_SKAction) {
	  _inherits(SKFade, _SKAction);

	  /**
	   * constructor
	   * @access public
	   * @constructor
	   */
	  function SKFade() {
	    _classCallCheck(this, SKFade);

	    var _this = _possibleConstructorReturn(this, (SKFade.__proto__ || Object.getPrototypeOf(SKFade)).call(this));

	    _this._actions = [];
	    _this._finished = false;
	    _this._duration = 0;
	    _this._timingMode = _SKActionTimingMode2.default.linear;
	    _this._beginTime = 0;
	    _this._isRunning = false;
	    _this._pausedTime = 0;

	    _this._toValue = null;
	    _this._byValue = null;
	    return _this;
	  }

	  /**
	   * Creates an action that changes the alpha value of the node to 1.0.
	   * @access public
	   * @param {number} sec - The duration of the animation.
	   * @returns {SKAction} - 
	   * @desc When the action executes, the nodes alpha property animates from its current value to 1.0.This action is reversible; the reverse is created as if the following code is executed:let action = SKAction.fadeOut(withDuration: sec)
	  let action = SKAction.fadeOut(withDuration: sec)
	    * @see https://developer.apple.com/reference/spritekit/skaction/1417818-fadein
	   */


	  _createClass(SKFade, [{
	    key: 'copy',


	    /**
	     * @access public
	     * @returns {SCNActionFade} -
	     */
	    value: function copy() {
	      var action = _get(SKFade.prototype.__proto__ || Object.getPrototypeOf(SKFade.prototype), 'copy', this).call(this);

	      action._toValue = this._toValue;
	      action._byValue = this._byValue;
	      action._duration = this._duration;

	      return action;
	    }

	    /**
	     * apply action to the given node.
	     * @access private
	     * @param {Object} obj - target object to apply this action.
	     * @param {number} time - active time
	     * @param {boolean} [needTimeConversion = true] -
	     * @returns {void}
	     */

	  }, {
	    key: '_applyAction',
	    value: function _applyAction(obj, time) {
	      var needTimeConversion = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

	      var t = this._getTime(time, needTimeConversion);
	      if (!(obj instanceof _SKNode2.default)) {
	        throw new Error('unsupported class for SKFade: ' + obj.constructor.name);
	      }

	      var baseValue = obj.alpha;
	      var toValue = 0;
	      if (this._toValue !== null) {
	        toValue = this._toValue;
	      } else if (this._byValue !== null) {
	        toValue = baseValue + this._byValue;
	      } else {
	        throw new Error('both toValue and byValue are null');
	      }

	      var value = this._lerp(baseValue, toValue, t);
	      obj._presentation.alpha = value;

	      if (this._finished) {
	        obj.alpha = toValue;
	      }
	    }
	  }], [{
	    key: 'fadeInWithDuration',
	    value: function fadeInWithDuration(sec) {
	      var action = new SKFade();
	      action._toValue = 1;
	      action._duration = sec;
	      return action;
	    }

	    /**
	     * Creates an action that changes the alpha value of the node to 0.0.
	     * @access public
	     * @param {number} sec - The duration of the animation.
	     * @returns {SKAction} - 
	     * @desc When the action executes, the nodes alpha property animates from its current value to 0.0. This causes the node to disappear.This action is reversible; the reverse is created as if the following code is executed:let action = SKAction.fadeIn(withDuration: sec)
	    let action = SKAction.fadeIn(withDuration: sec)
	      * @see https://developer.apple.com/reference/spritekit/skaction/1417738-fadeout
	     */

	  }, {
	    key: 'fadeOutWithDuration',
	    value: function fadeOutWithDuration(sec) {
	      var action = new SKFade();
	      action._toValue = 0;
	      action._duration = sec;
	      return action;
	    }

	    /**
	     * Creates an action that adjusts the alpha value of a node by a relative value.
	     * @access public
	     * @param {number} factor - The amount to add to the nodes alpha value.
	     * @param {number} sec - The duration of the animation.
	     * @returns {SKAction} - 
	     * @desc When the action executes, the nodes alpha property animates to its new value.This action is reversible; the reverse is created as if the following code is executed:let action = SKAction.fadeAlpha(by: -factor, duration: sec)
	    let action = SKAction.fadeAlpha(by: -factor, duration: sec)
	      * @see https://developer.apple.com/reference/spritekit/skaction/1417716-fadealpha
	     */

	  }, {
	    key: 'fadeAlphaByDuration',
	    value: function fadeAlphaByDuration(factor, sec) {
	      var action = new SKFade();
	      action._byValue = factor;
	      action._duration = sec;
	      return action;
	    }

	    /**
	     * Creates an action that adjusts the alpha value of a node to a new value.
	     * @access public
	     * @param {number} alpha - The new value of the nodes alpha.
	     * @param {number} sec - The duration of the animation.
	     * @returns {SKAction} - 
	     * @desc When the action executes, the nodes alpha property animates to its new value.This action is not reversible; the reverse of this action has the same duration but does not change anything.
	     * @see https://developer.apple.com/reference/spritekit/skaction/1417673-fadealpha
	     */

	  }, {
	    key: 'fadeAlphaToDuration',
	    value: function fadeAlphaToDuration(alpha, sec) {
	      var action = new SKFade();
	      action._toValue = alpha;
	      action._duration = sec;
	      return action;
	    }
	  }]);

	  return SKFade;
	}(_SKAction3.default);

	exports.default = SKFade;


	_SKAction3.default.fadeInWithDuration = SKFade.fadeInWithDuration;
	_SKAction3.default.fadeOutWithDuration = SKFade.fadeOutWithDuration;
	_SKAction3.default.fadeAlphaByDuration = SKFade.fadeAlphaByDuration;
	_SKAction3.default.fadeAlphaToDuration = SKFade.fadeAlphaToDuration;

/***/ },
/* 224 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

	var _SKAction2 = __webpack_require__(220);

	var _SKAction3 = _interopRequireDefault(_SKAction2);

	var _SKActionTimingMode = __webpack_require__(221);

	var _SKActionTimingMode2 = _interopRequireDefault(_SKActionTimingMode);

	var _SKNode = __webpack_require__(133);

	var _SKNode2 = _interopRequireDefault(_SKNode);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var SKGroup = function (_SKAction) {
	  _inherits(SKGroup, _SKAction);

	  /**
	   * constructor
	   * @access public
	   * @constructor
	   */
	  function SKGroup() {
	    _classCallCheck(this, SKGroup);

	    var _this = _possibleConstructorReturn(this, (SKGroup.__proto__ || Object.getPrototypeOf(SKGroup)).call(this));

	    _this._actions = [];
	    return _this;
	  }

	  /**
	   * Creates an action that runs a collection of actions in parallel.
	   * @access public
	   * @param {SKAction[]} actions - An array of SKAction objects.
	   * @returns {SKAction} - 
	   * @desc When the action executes, the actions that comprise the group all start immediately and run in parallel. The duration of the group action is the longest duration among the collection of actions. If an action in the group has a duration less than the groups duration, the action completes, then idles until the group completes the remaining actions. This matters most when creating a repeating action that repeats a group.This action is reversible; it creates a new group action that contains the reverse of each action specified in the group. 
	   * @see https://developer.apple.com/reference/spritekit/skaction/1417688-group
	   */


	  _createClass(SKGroup, [{
	    key: 'copy',


	    /**
	     * @access public
	     * @returns {SCNActionFade} -
	     */
	    value: function copy() {
	      var action = _get(SKGroup.prototype.__proto__ || Object.getPrototypeOf(SKGroup.prototype), 'copy', this).call(this);

	      action._actions = [];
	      this._actions.forEach(function (act) {
	        action._actions.push(act.copy());
	      });

	      return action;
	    }
	  }, {
	    key: '_applyAction',


	    /**
	     * apply action to the given node.
	     * @access private
	     * @param {Object} obj - target object to apply this action.
	     * @param {number} time - active time
	     * @param {boolean} [needTimeConversion = true] -
	     * @returns {void}
	     */
	    value: function _applyAction(obj, time) {
	      var needTimeConversion = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

	      var duration = this._activetimeFromTime(time);

	      var finished = true;
	      this._actions.forEach(function (action) {
	        if (!action._finished) {
	          action._applyAction(obj, duration, needTimeConversion);
	          if (!action._finished) {
	            finished = false;
	          }
	        }
	      });
	      this._finished = finished;
	    }
	  }, {
	    key: '_resetFinished',
	    value: function _resetFinished() {
	      this._actions.forEach(function (action) {
	        action._resetFinished();
	      });
	      this._finished = false;
	    }
	  }, {
	    key: 'duration',
	    get: function get() {
	      var d = 0;
	      this._actions.forEach(function (act) {
	        if (d < act.duration) {
	          d = act.duration;
	        }
	      });
	      return d;
	    }
	  }], [{
	    key: 'group',
	    value: function group(actions) {
	      var action = new SKGroup();
	      action._actions = actions;
	      return action;
	    }
	  }]);

	  return SKGroup;
	}(_SKAction3.default);

	exports.default = SKGroup;


	_SKAction3.default.group = SKGroup.group;

/***/ },
/* 225 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * Options for aligning text horizontally.
	 * @typedef {Object} SKLabelHorizontalAlignmentMode
	 * @property {number} center - Centers the text horizontally on the nodes origin.
	 * @property {number} left - Positions the text so that the left side of the text is on the nodes origin.
	 * @property {number} right - Positions the text so that the right side of the text is on the nodes origin.
	 * @see https://developer.apple.com/reference/spritekit/sklabelhorizontalalignmentmode
	 */

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var SKLabelHorizontalAlignmentMode = {
	  center: 0,
	  left: 1,
	  right: 2
	};

	exports.default = SKLabelHorizontalAlignmentMode;

/***/ },
/* 226 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

	var _SKColor = __webpack_require__(11);

	var _SKColor2 = _interopRequireDefault(_SKColor);

	var _SKNode2 = __webpack_require__(133);

	var _SKNode3 = _interopRequireDefault(_SKNode2);

	var _SKLabelVerticalAlignmentMode = __webpack_require__(227);

	var _SKLabelVerticalAlignmentMode2 = _interopRequireDefault(_SKLabelVerticalAlignmentMode);

	var _SKLabelHorizontalAlignmentMode = __webpack_require__(225);

	var _SKLabelHorizontalAlignmentMode2 = _interopRequireDefault(_SKLabelHorizontalAlignmentMode);

	var _SKBlendMode = __webpack_require__(132);

	var _SKBlendMode2 = _interopRequireDefault(_SKBlendMode);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * @access private
	 * @type {string}
	 */
	var _defaultVertexShader = '#version 300 es\n  precision mediump float;\n\n  in vec3 position;\n  in vec2 texcoord;\n\n  uniform float screenWidth;\n  uniform float screenHeight;\n\n  out vec2 v_texcoord;\n\n  void main() {\n    vec3 pos = position;\n    pos.x = (pos.x * 2.0 / screenWidth) - 1.0;\n    pos.y = (pos.y * 2.0 / screenHeight) - 1.0;\n    v_texcoord = texcoord;\n    gl_Position = vec4(pos, 1.0);\n  }\n';

	/**
	 * @access private
	 * @type {string}
	 */
	var _defaultFragmentShader = '#version 300 es\n  precision mediump float;\n\n  uniform sampler2D spriteTexture;\n  in vec2 v_texcoord;\n\n  out vec4 outColor;\n\n  void main() {\n    outColor = texture(spriteTexture, v_texcoord);\n  }\n';

	/**
	 * A node that displays a text label.
	 * @access public
	 * @extends {SKNode}
	 * @see https://developer.apple.com/reference/spritekit/sklabelnode
	 */

	var SKLabelNode = function (_SKNode) {
	  _inherits(SKLabelNode, _SKNode);

	  // Creating a New Label Node

	  /**
	   * Initializes a new label object with a text string.
	   * @access public
	   * @constructor
	   * @param {?string} text - The text to use to initialize the label node.
	   * @desc The label nodes font is set to Helvetica Neue Ultra Light, 32 point.
	   * @see https://developer.apple.com/reference/spritekit/sklabelnode/1519612-init
	   */
	  function SKLabelNode(text) {
	    _classCallCheck(this, SKLabelNode);

	    // Configuring the Label Message

	    /**
	     * The string that the label node displays.
	     * @access private
	     * @type {?string}
	     * @see https://developer.apple.com/reference/spritekit/sklabelnode/1519788-text
	     */
	    var _this = _possibleConstructorReturn(this, (SKLabelNode.__proto__ || Object.getPrototypeOf(SKLabelNode)).call(this));

	    _this._text = null;

	    // Configuring the Label Font

	    /**
	     * The color of the label.
	     * @access private
	     * @type {?CGColor}
	     * @see https://developer.apple.com/reference/spritekit/sklabelnode/1520057-fontcolor
	     */
	    _this._fontColor = new _SKColor2.default(1.0, 1.0, 1.0, 1.0);

	    /**
	     * The font used for the text in the label.
	     * @access private
	     * @type {?string}
	     * @see https://developer.apple.com/reference/spritekit/sklabelnode/1520129-fontname
	     */
	    _this._fontName = 'HelveticaNeue-UltraLight';

	    /**
	     * The size of the font used in the label.
	     * @access private
	     * @type {number}
	     * @see https://developer.apple.com/reference/spritekit/sklabelnode/1520208-fontsize
	     */
	    _this._fontSize = 32.0;

	    // Configuring the Labels Position

	    /**
	     * The vertical position of the text within the node.
	     * @access private
	     * @type {SKLabelVerticalAlignmentMode}
	     * @see https://developer.apple.com/reference/spritekit/sklabelnode/1519933-verticalalignmentmode
	     */
	    _this._verticalAlignmentMode = _SKLabelVerticalAlignmentMode2.default.baseline;

	    /**
	     * The horizontal position of the text within the node.
	     * @access private
	     * @type {SKLabelHorizontalAlignmentMode}
	     * @see https://developer.apple.com/reference/spritekit/sklabelnode/1519711-horizontalalignmentmode
	     */
	    _this._horizontalAlignmentMode = _SKLabelHorizontalAlignmentMode2.default.center;

	    // Performing Color Blending

	    /**
	     * The labels blend color.
	     * @type {?CGColor}
	     * @see https://developer.apple.com/reference/spritekit/sklabelnode/1519938-color
	     */
	    _this.color = new _SKColor2.default(1.0, 1.0, 1.0, 1.0);

	    /**
	     * A floating-point value that describes how the color is blended with the font color.
	     * @type {number}
	     * @see https://developer.apple.com/reference/spritekit/sklabelnode/1519724-colorblendfactor
	     */
	    _this.colorBlendFactor = 0.0;

	    // Blending the Label into the Framebuffer

	    /**
	     * The blend mode used to draw the label into the parents framebuffer.
	     * @type {SKBlendMode}
	     * @see https://developer.apple.com/reference/spritekit/sklabelnode/1519598-blendmode
	     */
	    _this.blendMode = _SKBlendMode2.default.alpha;

	    _this._canvas = document.createElement('canvas');
	    _this._context = _this._canvas.getContext('2d');
	    _this._glContext = null;
	    _this._texture = null;
	    _this._textureUpToDate = false;

	    /**
	     * @access private
	     * @type {WebGLProgram}
	     */
	    _this._program = null;

	    _this._vertexArrayObject = null;
	    _this._vertexBuffer = null;
	    _this._indexBuffer = null;

	    _this.text = text;
	    return _this;
	  }

	  /**
	   * Initializes a new label object with a specified font.
	   * @access public
	   * @param {?string} fontName - The name of the font used by the label.
	   * @returns {SKLabelNode} -
	   * @see https://developer.apple.com/reference/spritekit/sklabelnode/1519917-init
	   */


	  _createClass(SKLabelNode, [{
	    key: '_updateCanvas',
	    value: function _updateCanvas() {
	      this._context.font = this._fontSize + 'px ' + this._fontName;
	      var metrics = this._context.measureText(this._text);
	      this._canvas.width = metrics.width;
	      this._canvas.height = this._fontSize * 3;

	      this._context.font = this._fontSize + 'px ' + this._fontName;
	      this._context.fillStyle = this._fontColor.hexColor;

	      switch (this._verticalAlignmentMode) {
	        case _SKLabelVerticalAlignmentMode2.default.baseline:
	          this._context.textBaseline = 'alphabetic';
	          break;
	        case _SKLabelVerticalAlignmentMode2.default.center:
	          this._context.textBaseline = 'middle';
	          break;
	        case _SKLabelVerticalAlignmentMode2.default.top:
	          this._context.textBaseline = 'top';
	          break;
	        case _SKLabelVerticalAlignmentMode2.default.bottom:
	          this._context.textBaseline = 'bottom';
	          break;
	        default:
	          throw new Error('unknown vertical alignment mode: ' + this._verticalAlignmentMode);
	      }

	      //switch(this._horizontalAlignmentMode){
	      //  case SKLabelHorizontalAlignmentMode.center:
	      //    this._context.textAlign = 'center'
	      //    break
	      //  case SKLabelHorizontalAlignmentMode.left:
	      //    this._context.textAlign = 'left'
	      //    break
	      //  case SKLabelHorizontalAlignmentMode.right:
	      //    this._context.textAlign = 'right'
	      //    break
	      //  default:
	      //    throw new Error(`unknown horizontal alignment mode: ${this._horizontalAlignmentMode}`)
	      //}
	      this._context.textAlign = 'left';

	      this._context.clearRect(0, 0, this._canvas.width, this._canvas.height);
	      this._context.fillText(this._text, 0, this._canvas.height * 0.5);
	      this._textureUpToDate = false;
	    }

	    /**
	     * @access private
	     * @param {WebGLRenderingContext} gl -
	     * @returns {void}
	     */

	  }, {
	    key: '_render',
	    value: function _render(gl, viewRect) {
	      if (this._texture === null || this._glContext !== gl) {
	        this._glContext = gl;
	        this._texture = gl.createTexture();
	        this._textureUpToDate = false;
	      }
	      if (!this._textureUpToDate) {
	        gl.bindTexture(gl.TEXTURE_2D, this._texture);
	        // texImage2D(target, level, internalformat, width, height, border, format, type, source)
	        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this._canvas.width, this._canvas.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, this._canvas);
	        gl.generateMipmap(gl.TEXTURE_2D);
	        gl.bindTexture(gl.TEXTURE_2D, null);

	        this._textureUpToDate = true;
	      }
	      if (this._program === null) {
	        this._program = this._createProgram(gl);
	      }
	      var program = this._program;
	      gl.useProgram(program);

	      if (this._vertexArrayObject === null) {
	        this._createVertexArrayObject(gl, program);
	      }
	      gl.bindVertexArray(this._vertexArrayObject);

	      gl.uniform1f(gl.getUniformLocation(program, 'screenWidth'), viewRect.size.width);
	      gl.uniform1f(gl.getUniformLocation(program, 'screenHeight'), viewRect.size.height);

	      var data = this._createVertexData();
	      gl.bindBuffer(gl.ARRAY_BUFFER, this._vertexBuffer);
	      gl.bufferData(gl.ARRAY_BUFFER, data, gl.DYNAMIC_DRAW);

	      gl.uniform1i(gl.getUniformLocation(program, 'spriteTexture'), 0);
	      gl.activeTexture(gl.TEXTURE0);
	      gl.bindTexture(gl.TEXTURE_2D, this._texture);
	      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
	      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
	      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
	      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

	      gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_BYTE, 0);
	    }
	  }, {
	    key: '_createProgram',
	    value: function _createProgram(gl) {
	      var program = gl.createProgram();
	      var vsText = _defaultVertexShader;
	      var fsText = _defaultFragmentShader;

	      // initialize vertex shader
	      var vertexShader = gl.createShader(gl.VERTEX_SHADER);
	      gl.shaderSource(vertexShader, vsText);
	      gl.compileShader(vertexShader);
	      if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
	        var info = gl.getShaderInfoLog(vertexShader);
	        throw new Error('SKSpriteNode vertex shader compile error: ' + info);
	      }

	      // initialize fragment shader
	      var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
	      gl.shaderSource(fragmentShader, fsText);
	      gl.compileShader(fragmentShader);
	      if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
	        var _info = gl.getShaderInfoLog(fragmentShader);
	        throw new Error('particle fragment shader compile error: ' + _info);
	      }

	      gl.attachShader(program, vertexShader);
	      gl.attachShader(program, fragmentShader);

	      // link program object
	      gl.linkProgram(program);
	      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
	        var _info2 = gl.getProgramInfoLog(program);
	        throw new Error('program link error: ' + _info2);
	      }

	      //gl.useProgram(program)

	      return program;
	    }

	    /**
	     * @access private
	     * @param {WebGLRenderingContext} gl -
	     * @param {WebGLProgram} program -
	     * @returns {void}
	     */

	  }, {
	    key: '_createVertexArrayObject',
	    value: function _createVertexArrayObject(gl, program) {
	      this._vertexArrayObject = gl.createVertexArray();
	      gl.bindVertexArray(this._vertexArrayObject);

	      this._vertexBuffer = gl.createBuffer();
	      gl.bindBuffer(gl.ARRAY_BUFFER, this._vertexBuffer);

	      var positionLoc = gl.getAttribLocation(program, 'position');
	      gl.bindAttribLocation(program, positionLoc, 'position');
	      gl.enableVertexAttribArray(positionLoc);
	      // idx, size, type, norm, stride, offset
	      gl.vertexAttribPointer(positionLoc, 3, gl.FLOAT, false, 20, 0);

	      var texcoordLoc = gl.getAttribLocation(program, 'texcoord');
	      gl.bindAttribLocation(program, texcoordLoc, 'texcoord');
	      gl.enableVertexAttribArray(texcoordLoc);
	      // idx, size, type, norm, stride, offset
	      gl.vertexAttribPointer(texcoordLoc, 2, gl.FLOAT, false, 20, 12);

	      this._indexBuffer = gl.createBuffer();
	      var indexData = new Uint8Array([0, 3, 2, 0, 1, 3]);
	      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer);
	      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indexData, gl.STATIC_DRAW);
	    }
	  }, {
	    key: '_createVertexData',
	    value: function _createVertexData() {
	      var p = this.__presentation._worldPosition;
	      var w = this._canvas.width * this.__presentation.xScale;
	      var h = this._canvas.height * this.__presentation.yScale;
	      var left = p.x;
	      var right = p.x;
	      var top = p.y + h * 0.5;
	      var bottom = p.y - h * 0.5;
	      switch (this.__presentation._horizontalAlignmentMode) {
	        case _SKLabelHorizontalAlignmentMode2.default.center:
	          left -= w * 0.5;
	          right += w * 0.5;
	          break;
	        case _SKLabelHorizontalAlignmentMode2.default.left:
	          right += w;
	          break;
	        case _SKLabelHorizontalAlignmentMode2.default.right:
	          left -= w;
	          break;
	      }

	      var arr = [left, top, this.__presentation._worldZPosition, 0, 0, right, top, this.__presentation._worldZPosition, 1, 0, left, bottom, this.__presentation._worldZPosition, 0, 1, right, bottom, this.__presentation._worldZPosition, 1, 1];
	      return new Float32Array(arr);
	    }
	  }, {
	    key: 'copy',
	    value: function copy() {
	      var node = new SKLabelNode();
	      node._copyValue(this);
	      return node;
	    }
	  }, {
	    key: '_copyValue',
	    value: function _copyValue(src) {
	      _get(SKLabelNode.prototype.__proto__ || Object.getPrototypeOf(SKLabelNode.prototype), '_copyValue', this).call(this, src);
	      this._text = src._text;
	      this._fontColor = src._fontColor._copy();
	      this._fontName = src._fontName;
	      this._fontSize = src._fontSize;
	      this._verticalAlignmentMode = src._verticalAlignmentMode;
	      this._horizontalAlignmentMode = src._horizontalAlignmentMode;
	      this.color = src.color._copy();
	      this.colorBlendFactor = src.colorBlendFactor;
	      this.blendMode = src.blendMode;
	      this._canvas = src._canvas;
	      this._context = src._context;
	      //this._glContext = src._glContext
	      //this._texture = src._texture
	      //this._program = src._program
	      //this._vertexArrayObject = src._vertexArrayObject
	      //this._vertexBuffer = src._vertexBuffer
	      //this._indexBuffer = src._indexBuffer
	    }
	  }, {
	    key: 'text',
	    get: function get() {
	      return this._text;
	    },
	    set: function set(newValue) {
	      this._text = newValue;
	      this._updateCanvas();
	    }
	  }, {
	    key: 'fontColor',
	    get: function get() {
	      return this._fontColor;
	    },
	    set: function set(newValue) {
	      this._fontColor = newValue;
	      this._updateCanvas();
	    }
	  }, {
	    key: 'fontName',
	    get: function get() {
	      return this._fontName;
	    },
	    set: function set(newValue) {
	      this._fontName = newValue;
	      this._updateCanvas();
	    }
	  }, {
	    key: 'fontSize',
	    get: function get() {
	      return this._fontSize;
	    },
	    set: function set(newValue) {
	      this._fontSize = newValue;
	      this._updateCanvas();
	    }
	  }, {
	    key: 'verticalAlignmentMode',
	    get: function get() {
	      return this._verticalAlignmentMode;
	    },
	    set: function set(newValue) {
	      this._verticalAlignmentMode = newValue;
	      this._updateCanvas();
	    }
	  }, {
	    key: 'horizontalAlignmentMode',
	    get: function get() {
	      return this._horizontalAlignmentMode;
	    },
	    set: function set(newValue) {
	      this._horizontalAlignmentMode = newValue;
	      this._updateCanvas();
	    }
	  }], [{
	    key: 'labelWithFontNamed',
	    value: function labelWithFontNamed(fontName) {
	      var label = new SKLabelNode();
	      label.fontName = fontName;
	      return label;
	    }

	    /**
	     * Initializes a new label object with a text string.
	     * @access public
	     * @param {?string} text - The text to use to initialize the label node.
	     * @returns {SKLabelNode} -
	     * @desc The label nodes font is set to Helvetica Neue Ultra Light, 32 point.
	     * @see https://developer.apple.com/reference/spritekit/sklabelnode/1519612-init
	     */

	  }, {
	    key: 'labelWithText',
	    value: function labelWithText(text) {
	      return new SKLabelNode(text);
	    }
	  }]);

	  return SKLabelNode;
	}(_SKNode3.default);

	exports.default = SKLabelNode;

/***/ },
/* 227 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * Options for aligning text vertically. 
	 * @typedef {Object} SKLabelVerticalAlignmentMode
	 * @property {number} baseline - Positions the text so that the fonts baseline lies on the nodes origin.
	 * @property {number} center - Centers the text vertically on the nodes origin.
	 * @property {number} top - Positions the text so that the top of the text is on the nodes origin.
	 * @property {number} bottom - Positions the text so that the bottom of the text is on the nodes origin.
	 * @see https://developer.apple.com/reference/spritekit/sklabelverticalalignmentmode
	 */

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var SKLabelVerticalAlignmentMode = {
	  baseline: 0,
	  center: 1,
	  top: 2,
	  bottom: 3
	};

	exports.default = SKLabelVerticalAlignmentMode;

/***/ },
/* 228 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

	var _SKAction2 = __webpack_require__(220);

	var _SKAction3 = _interopRequireDefault(_SKAction2);

	var _SKActionTimingMode = __webpack_require__(221);

	var _SKActionTimingMode2 = _interopRequireDefault(_SKActionTimingMode);

	var _SKNode = __webpack_require__(133);

	var _SKNode2 = _interopRequireDefault(_SKNode);

	var _CGSize = __webpack_require__(9);

	var _CGSize2 = _interopRequireDefault(_CGSize);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var SKScale = function (_SKAction) {
	  _inherits(SKScale, _SKAction);

	  /**
	   * constructor
	   * @access public
	   * @constructor
	   */
	  function SKScale() {
	    _classCallCheck(this, SKScale);

	    var _this = _possibleConstructorReturn(this, (SKScale.__proto__ || Object.getPrototypeOf(SKScale)).call(this));

	    _this._actions = [];
	    _this._finished = false;
	    _this._duration = 0;
	    _this._timingMode = _SKActionTimingMode2.default.linear;
	    _this._beginTime = 0;
	    _this._isRunning = false;
	    _this._pausedTime = 0;

	    _this._scaleXTo = null;
	    _this._scaleXBy = null;
	    _this._scaleWidthTo = null;
	    _this._scaleYTo = null;
	    _this._scaleYBy = null;
	    _this._scaleHeightTo = null;
	    return _this;
	  }

	  /**
	   * Creates an action that changes the x and y scale values of a node by a relative value.
	   * @access public
	   * @param {number} scale - The amount to add to the nodes x and y scale values.
	   * @param {number} sec - The duration of the animation.
	   * @returns {SKAction} - 
	   * @desc When the action executes, the nodes xScale and yScale properties are animated to the new value.This action is reversible; the reverse is created as if the following code is executed:let action = SKAction.scale(by: -scale, duration: sec)
	  let action = SKAction.scale(by: -scale, duration: sec)
	    * @see https://developer.apple.com/reference/spritekit/skaction/1417741-scale
	   */


	  _createClass(SKScale, [{
	    key: 'copy',


	    /**
	     * @access public
	     * @returns {SCNActionFade} -
	     */
	    value: function copy() {
	      var action = _get(SKScale.prototype.__proto__ || Object.getPrototypeOf(SKScale.prototype), 'copy', this).call(this);

	      action._scaleXTo = this._scaleXTo;
	      action._scaleXBy = this._scaleXBy;
	      action._scaleWidthTo = this._scaleWidthTo;
	      action._scaleYTo = this._scaleYTo;
	      action._scaleYBy = this._scaleYBy;
	      action._scaleHeightTo = this._scaleHeightTo;

	      return action;
	    }

	    /**
	     * apply action to the given node.
	     * @access private
	     * @param {Object} obj - target object to apply this action.
	     * @param {number} time - active time
	     * @param {boolean} [needTimeConversion = true] -
	     * @returns {void}
	     */

	  }, {
	    key: '_applyAction',
	    value: function _applyAction(obj, time) {
	      var needTimeConversion = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

	      var t = this._getTime(time, needTimeConversion);
	      if (!(obj instanceof _SKNode2.default)) {
	        throw new Error('unsupported class for SKSequence: ' + obj.constructor.name);
	      }

	      var baseXValue = obj.xScale;
	      var toXValue = null;
	      if (this._scaleXTo !== null) {
	        toXValue = this._scaleXTo;
	      } else if (this._scaleXBy !== null) {
	        toXValue = baseXValue + this._scaleXBy;
	      } else if (this._scaleWidthTo !== null) {
	        toXValue = this._scaleWidthTo / this._frame.size.width;
	      }

	      var baseYValue = obj.yScale;
	      var toYValue = null;
	      if (this._scaleYTo !== null) {
	        toYValue = this._scaleYTo;
	      } else if (this._scaleYBy !== null) {
	        toYValue = baseYValue + this._scaleYBy;
	      } else if (this._scaleHeightTo !== null) {
	        toYValue = this._scaleHeightTo / this._frame.size.height;
	      }

	      if (toXValue === null && toYValue === null) {
	        throw new Error('both toXValue and toYValue are null');
	      }

	      if (toXValue !== null) {
	        var xValue = this._lerp(baseXValue, toXValue, t);
	        obj._presentation.xScale = xValue;
	      }
	      if (toYValue !== null) {
	        var yValue = this._lerp(baseYValue, toYValue, t);
	        obj._presentation.yScale = yValue;
	      }

	      if (this._finished) {
	        if (toXValue !== null) {
	          obj.xScale = toXValue;
	        }
	        if (toYValue !== null) {
	          obj.yScale = toYValue;
	        }
	      }
	    }
	  }], [{
	    key: 'scaleByDuration',
	    value: function scaleByDuration(scale, sec) {
	      var action = new SKScale();
	      action._scaleXBy = scale;
	      action._scaleYBy = scale;
	      action._duration = sec;
	      return action;
	    }

	    /**
	     * Creates an action that changes the x and y scale values of a node to achieve 
	     * @access public
	     * @param {number|CGSize} size - The new size of the node.
	     * @param {number} sec - The duration of the animation.
	     * @returns {SKAction} - 
	     * @desc When the action executes, the nodes xScale and yScale properties are animated to achieve the specified size in its parent's coordinate space. This action is not reversible; the reverse of this action has the same duration but does not change anything.
	     * @see https://developer.apple.com/reference/spritekit/skaction/1643619-scale
	     */

	  }, {
	    key: 'scaleToDuration',
	    value: function scaleToDuration(size, sec) {
	      var action = new SKScale();
	      if (size instanceof _CGSize2.default) {
	        action._scaleWidthTo = size.width;
	        action._scaleHeightTo = size.height;
	      } else if (typeof size === 'number') {
	        action._scaleXTo = size;
	        action._scaleYTo = size;
	      } else {
	        throw new Error('unsupported format');
	      }
	      action._duration = sec;
	      return action;
	    }

	    /**
	     * Creates an action that adds relative values to the x and y scale values of a node.
	     * @access public
	     * @param {number} xScale - The amount to add to the nodes x scale value.
	     * @param {number} yScale - The amount to add to the nodes y scale value.
	     * @param {number} sec - The duration of the animation.
	     * @returns {SKAction} - 
	     * @desc When the action executes, the nodes xScale and yScale properties are animated to the new value.This action is reversible; the reverse is created as if the following code is executed:let action = SKAction.scaleX(by: -scaleX, y: -scaleY, duration: sec)
	    let action = SKAction.scaleX(by: -scaleX, y: -scaleY, duration: sec)
	      * @see https://developer.apple.com/reference/spritekit/skaction/1417796-scalex
	     */

	  }, {
	    key: 'scaleXByYDuration',
	    value: function scaleXByYDuration(xScale, yScale, sec) {
	      var action = new SKScale();
	      action._scaleXBy = xScale;
	      action._scaleYBy = yScale;
	      action._duration = sec;
	      return action;
	    }

	    /**
	     * Creates an action that changes the x and y scale values of a node.
	     * @access public
	     * @param {number} xScale - The new value for the nodes x scale value.
	     * @param {number} yScale - The new value for the nodes y scale value.
	     * @param {number} sec - The duration of the animation.
	     * @returns {SKAction} - 
	     * @desc When the action executes, the nodes xScale and yScale properties are animated to the new value.This action is not reversible; the reverse of this action has the same duration but does not change anything.
	     * @see https://developer.apple.com/reference/spritekit/skaction/1417728-scalex
	     */

	  }, {
	    key: 'scaleXToYDuration',
	    value: function scaleXToYDuration(xScale, yScale, sec) {
	      var action = new SKScale();
	      action._scaleXTo = xScale;
	      action._scaleYTo = yScale;
	      action._duration = sec;
	      return action;
	    }

	    /**
	     * Creates an action that changes the x scale value of a node to a new value.
	     * @access public
	     * @param {number} scale - The new value for the nodes x scale value.
	     * @param {number} sec - The duration of the animation.
	     * @returns {SKAction} - 
	     * @desc When the action executes, the nodes xScale property animates to the new value.This action is not reversible; the reverse of this action has the same duration but does not change anything.
	     * @see https://developer.apple.com/reference/spritekit/skaction/1417699-scalex
	     */

	  }, {
	    key: 'scaleXToDuration',
	    value: function scaleXToDuration(scale, sec) {
	      var action = new SKScale();
	      action._scaleXTo = scale;
	      action._duration = sec;
	      return action;
	    }

	    /**
	     * Creates an action that changes the y scale value of a node to a new value.
	     * @access public
	     * @param {number} scale - The new value for the nodes y scale value.
	     * @param {number} sec - The duration of the animation.
	     * @returns {SKAction} - 
	     * @desc When the action executes, the nodes yScale property animates to the new value.This action is not reversible; the reverse of this action has the same duration but does not change anything.
	     * @see https://developer.apple.com/reference/spritekit/skaction/1417708-scaley
	     */

	  }, {
	    key: 'scaleYToDuration',
	    value: function scaleYToDuration(scale, sec) {
	      var action = new SKScale();
	      action._scaleYTo = scale;
	      action._duration = sec;
	      return action;
	    }
	  }]);

	  return SKScale;
	}(_SKAction3.default);

	exports.default = SKScale;


	_SKAction3.default.scaleByDuration = SKScale.scaleByDuration;
	_SKAction3.default.scaleToDuration = SKScale.scaleToDuration;
	_SKAction3.default.scaleXByYDuration = SKScale.scaleXByYDuration;
	_SKAction3.default.scaleXToYDuration = SKScale.scaleXToYDuration;
	_SKAction3.default.scaleXToDuration = SKScale.scaleXToDuration;
	_SKAction3.default.scaleYToDuration = SKScale.scaleYToDuration;

/***/ },
/* 229 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _CGPoint = __webpack_require__(7);

	var _CGPoint2 = _interopRequireDefault(_CGPoint);

	var _CGSize = __webpack_require__(9);

	var _CGSize2 = _interopRequireDefault(_CGSize);

	var _SKColor = __webpack_require__(11);

	var _SKColor2 = _interopRequireDefault(_SKColor);

	var _SKEffectNode2 = __webpack_require__(222);

	var _SKEffectNode3 = _interopRequireDefault(_SKEffectNode2);

	var _SKSceneScaleMode = __webpack_require__(230);

	var _SKSceneScaleMode2 = _interopRequireDefault(_SKSceneScaleMode);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	//import SKCameraNode from './SKCameraNode'
	//import SKView from './SKView'
	//import SKSceneDelegate from './SKSceneDelegate'
	//import SKPhysicsWorld from './SKPhysicsWorld'
	//import SKNode from './SKNode'


	/**
	 * The root node for all Sprite Kit objects displayed in a view. 
	 * @access public
	 * @extends {SKEffectNode}
	 * @see https://developer.apple.com/reference/spritekit/skscene
	 */
	var SKScene = function (_SKEffectNode) {
	  _inherits(SKScene, _SKEffectNode);

	  // Initializing a Scene

	  /**
	   * Initializes a new scene object.
	   * @access public
	   * @constructor
	   * @param {CGSize} size - The size of the scene in points.
	   * @desc This is the classs designated initializer method.
	   * @see https://developer.apple.com/reference/spritekit/skscene/1520435-init
	   */
	  function SKScene(size) {
	    _classCallCheck(this, SKScene);

	    // Determining What Portion of the Scene Is Visible in the View

	    /**
	     * The camera node in the scene that determines what part of the scenes coordinate space is visible in the view.
	     * @type {?SKCameraNode}
	     * @see https://developer.apple.com/reference/spritekit/skscene/1519696-camera
	     */
	    var _this = _possibleConstructorReturn(this, (SKScene.__proto__ || Object.getPrototypeOf(SKScene)).call(this));

	    _this.camera = null;

	    /**
	     * The point in the views frame that corresponds to the scenes origin.
	     * @type {CGPoint}
	     * @see https://developer.apple.com/reference/spritekit/skscene/1519864-anchorpoint
	     */
	    _this.anchorPoint = new _CGPoint2.default(0, 0);

	    /**
	     * The dimensions of the scene in points.
	     * @type {CGSize}
	     * @see https://developer.apple.com/reference/spritekit/skscene/1519831-size
	     */
	    _this.size = size | new _CGSize2.default(1, 1);

	    /**
	     * Defines how the scene is mapped to the view that presents it.
	     * @type {SKSceneScaleMode}
	     * @see https://developer.apple.com/reference/spritekit/skscene/1519562-scalemode
	     */
	    _this.scaleMode = _SKSceneScaleMode2.default.fill;

	    // Setting the Background Color of a Scene

	    /**
	     * The background color of the scene.
	     * @type {SKColor}
	     * @see https://developer.apple.com/reference/spritekit/skscene/1520278-backgroundcolor
	     */
	    _this.backgroundColor = new _SKColor2.default(0.15, 0.15, 0.15, 1.0);

	    // Presenting a Scene

	    _this._view = null;

	    // Executing the Animation Loop

	    /**
	     * A delegate to be called during the animation loop. 
	     * @type {?SKSceneDelegate}
	     * @see https://developer.apple.com/reference/spritekit/skscene/1520213-delegate
	     */
	    _this.delegate = null;

	    // Working with Physics in the Scene

	    //this._physicsWorld = new SKPhysicsWorld()
	    _this._physicsWorld = null;

	    // Working with Audio in the Scene

	    /**
	     * A node used to determine the position of the listener for positional audio in the scene.
	     * @type {?SKNode}
	     * @see https://developer.apple.com/reference/spritekit/skscene/1520363-listener
	     */
	    _this.listener = null;

	    //this._audioEngine = null
	    return _this;
	  }

	  // Determining What Portion of the Scene Is Visible in the View

	  /**
	   * Called whenever the scenes size changes.
	   * @access public
	   * @param {CGSize} oldSize - The old size of the scene, in points.
	   * @returns {void}
	   * @desc This method is intended to be overridden in a subclass. Typically, you use this method to adjust the positions of nodes in the scene.
	   * @see https://developer.apple.com/reference/spritekit/skscene/1519545-didchangesize
	   */


	  _createClass(SKScene, [{
	    key: 'didChangeSize',
	    value: function didChangeSize(oldSize) {}

	    // Converting Between View and Scene Coordinates

	    /**
	     * Converts a point from view coordinates to scene coordinates.
	     * @access public
	     * @param {CGPoint} point - A point in view coordinates.
	     * @returns {CGPoint} - 
	     * @desc The scene must be presented in a view before calling this method.
	     * @see https://developer.apple.com/reference/spritekit/skscene/1520395-convertpoint
	     */

	  }, {
	    key: 'convertPointFromView',
	    value: function convertPointFromView(point) {
	      return null;
	    }

	    /**
	     * Converts a point from scene coordinates to view coordinates.
	     * @access public
	     * @param {CGPoint} point - A point in scene coordinates.
	     * @returns {CGPoint} - 
	     * @desc The scene must be presented in a view before calling this method.
	     * @see https://developer.apple.com/reference/spritekit/skscene/1520082-convertpoint
	     */

	  }, {
	    key: 'convertPointToView',
	    value: function convertPointToView(point) {
	      return null;
	    }

	    // Presenting a Scene

	    /**
	     * Called immediately after the scene has been initialized or decoded.
	     * @access public
	     * @returns {void}
	     * @desc This method is intended to be overridden in a subclass. You can use this method to implement any custom behavior after it has been initialized or decoded.
	     * @see https://developer.apple.com/reference/spritekit/skscene/1645216-scenedidload
	     */

	  }, {
	    key: 'sceneDidLoad',
	    value: function sceneDidLoad() {}

	    /**
	     * Called immediately before a scene is removed from a view.
	     * @access public
	     * @param {SKView} view - The view that is presenting the scene.
	     * @returns {void}
	     * @desc This method is intended to be overridden in a subclass. You can use this method to implement any custom behavior for your scene when it is about to be removed from the view.
	     * @see https://developer.apple.com/reference/spritekit/skscene/1519703-willmove
	     */

	  }, {
	    key: 'willMoveFrom',
	    value: function willMoveFrom(view) {}

	    /**
	     * Called immediately after a scene is presented by a view.
	     * @access public
	     * @param {SKView} view - The view that is presenting the scene.
	     * @returns {void}
	     * @desc This method is intended to be overridden in a subclass. You can use this method to implement any custom behavior for your scene when it is about to be presented by a view. For example, you might use this method to create the scenes contents.
	     * @see https://developer.apple.com/reference/spritekit/skscene/1519607-didmove
	     */

	  }, {
	    key: 'didMoveTo',
	    value: function didMoveTo(view) {}
	    /**
	     * The view that is currently presenting the scene.
	     * @type {?SKView}
	     * @desc To present a scene, you call the presentScene(_:) method or presentScene(_:transition:) method on the SKView class. If the scene is not currently presented, this property holds nil.
	     * @see https://developer.apple.com/reference/spritekit/skscene/1519726-view
	     */

	  }, {
	    key: 'update',


	    // Executing the Animation Loop

	    /**
	     * Performs any scene-specific updates that need to occur before scene actions are evaluated.
	     * @access public
	     * @param {number} currentTime - The current system time.
	     * @returns {void}
	     * @desc Do not call this method directly; it is called exactly once per frame, so long as the scene is presented in a view and is not paused. By default, this method does nothing. Your scene subclass should override this method and perform any necessary updates to the scene.
	     * @see https://developer.apple.com/reference/spritekit/skscene/1519802-update
	     */
	    value: function update(currentTime) {}

	    /**
	     * Performs any scene-specific updates that need to occur after scene actions are evaluated.
	     * @access public
	     * @returns {void}
	     * @desc Do not call this method directly; it is called exactly once per frame, so long as the scene is presented in a view and is not paused. By default, this method does nothing. Your scene subclass should override this method and perform any necessary updates to the scene.
	     * @see https://developer.apple.com/reference/spritekit/skscene/1519903-didevaluateactions
	     */

	  }, {
	    key: 'didEvaluateActions',
	    value: function didEvaluateActions() {}

	    /**
	     * Performs any scene-specific updates that need to occur after physics simulations are performed.
	     * @access public
	     * @returns {void}
	     * @desc Do not call this method directly; it is called exactly once per frame, so long as the scene is presented in a view and is not paused. By default, this method does nothing. Your scene subclass should override this method and perform any necessary updates to the scene.
	     * @see https://developer.apple.com/reference/spritekit/skscene/1519965-didsimulatephysics
	     */

	  }, {
	    key: 'didSimulatePhysics',
	    value: function didSimulatePhysics() {}

	    /**
	     * Performs any scene-specific updates that need to occur after constraints are applied.
	     * @access public
	     * @returns {void}
	     * @desc Do not call this method directly; it is called exactly once per frame, so long as the scene is presented in a view and is not paused. By default, this method does nothing. Your scene subclass should override this method and perform any necessary updates to the scene.
	     * @see https://developer.apple.com/reference/spritekit/skscene/1520006-didapplyconstraints
	     */

	  }, {
	    key: 'didApplyConstraints',
	    value: function didApplyConstraints() {}

	    /**
	     * Called after the scene has finished all of the steps required to process animations.
	     * @access public
	     * @returns {void}
	     * @desc Do not call this method directly; it is called exactly once per frame, so long as the scene is presented in a view and is not paused. By default, this method does nothing. Your scene subclass should override this method and perform any necessary updates to the scene. This method is the last method to be called before the scene is rendered.
	     * @see https://developer.apple.com/reference/spritekit/skscene/1520269-didfinishupdate
	     */

	  }, {
	    key: 'didFinishUpdate',
	    value: function didFinishUpdate() {}

	    // Working with Physics in the Scene
	    /**
	     * The physics simulation associated with the scene.
	     * @type {SKPhysicsWorld}
	     * @desc Every scene automatically creates a physics world object to simulate physics on nodes in the scene. You use this property to access the scenes global physics properties, such as gravity. To add physics to a particular node, see physicsBody.
	     * @see https://developer.apple.com/reference/spritekit/skscene/1519584-physicsworld
	     */

	  }, {
	    key: 'view',
	    get: function get() {
	      return this._view;
	    }
	  }, {
	    key: 'physicsWorld',
	    get: function get() {
	      return this._physicsWorld;
	    }

	    // Working with Audio in the Scene
	    /**
	     * The AV Foundation audio engine used to play audio from audio nodes contained in the scene.
	     * @type {AVAudioEngine}
	     * @desc An audio engine instance is automatically created for you when the scene is created. You can use methods and properties on a scenes audio engine for overall control of all of its child audio nodes. The following code shows how a scenes overall volume can be reduced from its default of 1.0 down to 0.2 and then paused:let scene = SKScene()
	    scene.audioEngine.mainMixerNode.outputVolume = 0.2
	    scene.audioEngine.pause()
	    let scene = SKScene()
	    scene.audioEngine.mainMixerNode.outputVolume = 0.2
	    scene.audioEngine.pause()
	      * @see https://developer.apple.com/reference/spritekit/skscene/1519644-audioengine
	     */
	    //get audioEngine() {
	    //  return this._audioEngine
	    //}

	  }]);

	  return SKScene;
	}(_SKEffectNode3.default);

	exports.default = SKScene;

/***/ },
/* 230 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * The modes that determine how the scenes area is mapped to the view that presents it.
	 * @typedef {Object} SKSceneScaleMode
	 * @property {number} fill - Each axis of the scene is scaled independently so that each axis in the scene exactly maps to the length of that axis in the view.
	 * @property {number} aspectFill - The scaling factor of each dimension is calculated and the larger of the two is chosen. Each axis of the scene is scaled by the same scaling factor. This guarantees that the entire area of the view is filled but may cause parts of the scene to be cropped.
	 * @property {number} aspectFit - The scaling factor of each dimension is calculated and the smaller of the two is chosen. Each axis of the scene is scaled by the same scaling factor. This guarantees that the entire scene is visible but may require letterboxing in the view.
	 * @property {number} resizeFill - The scene is not scaled to match the view. Instead, the scene is automatically resized so that its dimensions always match those of the view.
	 * @see https://developer.apple.com/reference/spritekit/skscenescalemode
	 */

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var SKSceneScaleMode = {
	  fill: 0,
	  aspectFill: 1,
	  aspectFit: 2,
	  resizeFill: 3
	};

	exports.default = SKSceneScaleMode;

/***/ },
/* 231 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

	var _SKAction2 = __webpack_require__(220);

	var _SKAction3 = _interopRequireDefault(_SKAction2);

	var _SKActionTimingMode = __webpack_require__(221);

	var _SKActionTimingMode2 = _interopRequireDefault(_SKActionTimingMode);

	var _SKNode = __webpack_require__(133);

	var _SKNode2 = _interopRequireDefault(_SKNode);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var SKSequence = function (_SKAction) {
	  _inherits(SKSequence, _SKAction);

	  /**
	   * constructor
	   * @access public
	   * @constructor
	   */
	  function SKSequence() {
	    _classCallCheck(this, SKSequence);

	    var _this = _possibleConstructorReturn(this, (SKSequence.__proto__ || Object.getPrototypeOf(SKSequence)).call(this));

	    _this._actions = [];
	    _this._animIndex = 0;

	    _this._finished = false;
	    _this._duration = 0;
	    _this._timingMode = _SKActionTimingMode2.default.linear;
	    _this._beginTime = 0;
	    _this._isRunning = false;
	    _this._pausedTime = 0;
	    return _this;
	  }

	  /**
	   * Creates an action that runs a collection of actions sequentially.
	   * @access public
	   * @param {SKAction[]} actions - An array of SKAction objects.
	   * @returns {SKAction} - 
	   * @desc When the action executes, the first action in the sequence starts and runs to completion. Subsequent actions in the sequence run in a similar fashion until all of the actions in the sequence have executed. The duration of the sequence action is the sum of the durations of the actions in the sequence.This action is reversible; it creates a new sequence action that reverses the order of the actions. Each action in the reversed sequence is itself reversed. For example, if an action sequence is {1,2,3}, the reversed sequence would be {3R,2R,1R}.
	   * @see https://developer.apple.com/reference/spritekit/skaction/1417817-sequence
	   */


	  _createClass(SKSequence, [{
	    key: 'copy',


	    /**
	     * @access public
	     * @returns {SCNActionFade} -
	     */
	    value: function copy() {
	      var action = _get(SKSequence.prototype.__proto__ || Object.getPrototypeOf(SKSequence.prototype), 'copy', this).call(this);

	      action._actions = this._actions.slice(0);
	      action._animIndex = this._animIndex;

	      return action;
	    }

	    /**
	     * apply action to the given node.
	     * @access private
	     * @param {Object} obj - target object to apply this action.
	     * @param {number} time - active time
	     * @param {boolean} [needTimeConversion = true] -
	     * @returns {void}
	     */

	  }, {
	    key: '_applyAction',
	    value: function _applyAction(obj, time) {
	      var needTimeConversion = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

	      var total = this.duration;
	      var duration = 0;
	      if (total <= 0 || total === Infinity) {
	        duration = this._activetimeFromTime(time);
	      } else {
	        duration = this._getTime(time, needTimeConversion) * total;
	      }

	      for (var i = 0; i < this._animIndex; i++) {
	        duration -= this._actions[i].duration / this._actions[i].speed;
	      }
	      for (; this._animIndex < this._actions.length; this._animIndex++) {
	        var action = this._actions[this._animIndex];
	        action._applyAction(obj, duration, true);
	        duration -= action.duration / action.speed;
	        if (duration <= 0 || !action._finished) {
	          break;
	        }
	      }
	      if (this._animIndex >= this._actions.length) {
	        this._finished = true;
	      }
	    }
	  }, {
	    key: '_resetFinished',
	    value: function _resetFinished() {
	      this._actions.forEach(function (action) {
	        action._resetFinished();
	      });
	      this._finished = false;
	      this._animIndex = 0;
	    }
	  }, {
	    key: 'duration',
	    get: function get() {
	      var d = 0;
	      this._actions.forEach(function (act) {
	        if (act.speed > 0) {
	          d += act.duration / act.speed;
	        }
	      });
	      return d;
	    }
	  }], [{
	    key: 'sequence',
	    value: function sequence(actions) {
	      var action = new SKSequence();
	      action._actions = actions;
	      action._duration = 0;
	      return action;
	    }
	  }]);

	  return SKSequence;
	}(_SKAction3.default);

	exports.default = SKSequence;


	_SKAction3.default.sequence = SKSequence.sequence;

/***/ },
/* 232 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _CGLineCap = __webpack_require__(16);

	var _CGLineCap2 = _interopRequireDefault(_CGLineCap);

	var _CGLineJoin = __webpack_require__(17);

	var _CGLineJoin2 = _interopRequireDefault(_CGLineJoin);

	var _SKBlendMode = __webpack_require__(132);

	var _SKBlendMode2 = _interopRequireDefault(_SKBlendMode);

	var _SKColor = __webpack_require__(11);

	var _SKColor2 = _interopRequireDefault(_SKColor);

	var _SKNode2 = __webpack_require__(133);

	var _SKNode3 = _interopRequireDefault(_SKNode2);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	//import CGPath from '../CoreGraphics/CGPath'
	//import CGRect from '../CoreGraphics/CGRect'
	//import CGSize from '../CoreGraphics/CGSize'
	//import SKTexture from './SKTexture'
	//import SKShader from './SKShader'
	//import SKAttributeValue from './SKAttributeValue'


	/**
	 * A node that renders a shape defined by a Core Graphics path.
	 * @access public
	 * @extends {SKNode}
	 * @see https://developer.apple.com/reference/spritekit/skshapenode
	 */
	var SKShapeNode = function (_SKNode) {
	  _inherits(SKShapeNode, _SKNode);

	  /**
	   * constructor
	   * @access public
	   * @constructor
	   */
	  function SKShapeNode() {
	    _classCallCheck(this, SKShapeNode);

	    // Inspecting the Shape Nodes Path

	    /**
	     * The path that defines the shape.
	     * @type {?CGPath}
	     * @see https://developer.apple.com/reference/spritekit/skshapenode/1519741-path
	     */
	    var _this = _possibleConstructorReturn(this, (SKShapeNode.__proto__ || Object.getPrototypeOf(SKShapeNode)).call(this));

	    _this.path = null;

	    // Setting the Fill Properties

	    /**
	     * The color used to fill the shape.
	     * @type {SKColor}
	     * @see https://developer.apple.com/reference/spritekit/skshapenode/1520154-fillcolor
	     */
	    _this.fillColor = new _SKColor2.default(0, 0, 0, 0);

	    /**
	     * The texture used to fill the shape.
	     * @type {?SKTexture}
	     * @see https://developer.apple.com/reference/spritekit/skshapenode/1519956-filltexture
	     */
	    _this.fillTexture = null;

	    /**
	     * A custom shader used to determine the color of the filled portion of the shape node.
	     * @type {?SKShader}
	     * @see https://developer.apple.com/reference/spritekit/skshapenode/1519629-fillshader
	     */
	    _this.fillShader = null;

	    // Setting the Stroke Properties

	    /**
	     * The width used to stroke the path.
	     * @type {number}
	     * @see https://developer.apple.com/reference/spritekit/skshapenode/1519885-linewidth
	     */
	    _this.lineWidth = 1.0;

	    /**
	     * The glow that extends outward from the stroked line.
	     * @type {number}
	     * @see https://developer.apple.com/reference/spritekit/skshapenode/1520116-glowwidth
	     */
	    _this.glowWidth = 0;

	    /**
	     * A Boolean value that determines whether the stroked path is smoothed when drawn.
	     * @type {boolean}
	     * @see https://developer.apple.com/reference/spritekit/skshapenode/1519719-isantialiased
	     */
	    _this.isAntialiased = true;

	    /**
	     * The color used to stroke the shape.
	     * @type {SKColor}
	     * @see https://developer.apple.com/reference/spritekit/skshapenode/1519748-strokecolor
	     */
	    _this.strokeColor = new _SKColor2.default(1.0, 1.0, 1.0, 1.0);

	    /**
	     * The texture used to stroke the shape.
	     * @type {?SKTexture}
	     * @see https://developer.apple.com/reference/spritekit/skshapenode/1519824-stroketexture
	     */
	    _this.strokeTexture = null;

	    /**
	     * A custom shader used to determine the color of the stroked portion of the shape node.
	     * @type {?SKShader}
	     * @see https://developer.apple.com/reference/spritekit/skshapenode/1519784-strokeshader
	     */
	    _this.strokeShader = null;

	    /**
	     * The style used to render the endpoints of the stroked portion of the shape node.
	     * @type {CGLineCap}
	     * @see https://developer.apple.com/reference/spritekit/skshapenode/1520360-linecap
	     */
	    _this.lineCap = _CGLineCap2.default.butt;

	    /**
	     * The junction type used when the stroked portion of the shape node is rendered.
	     * @type {CGLineJoin}
	     * @see https://developer.apple.com/reference/spritekit/skshapenode/1520358-linejoin
	     */
	    _this.lineJoin = _CGLineJoin2.default.bevel;

	    /**
	     * The miter limit to use when the line is stroked using a miter join style.
	     * @type {number}
	     * @see https://developer.apple.com/reference/spritekit/skshapenode/1520240-miterlimit
	     */
	    _this.miterLimit = 0.5;

	    // Blending the Shape with the Framebuffer

	    /**
	     * The blend mode used to blend the shape into the parents framebuffer.
	     * @type {SKBlendMode}
	     * @see https://developer.apple.com/reference/spritekit/skshapenode/1520045-blendmode
	     */
	    _this.blendMode = _SKBlendMode2.default.alpha;

	    // Reading the Shape Nodes Properties

	    //this._lineLength = 0

	    // Working with Custom Shaders

	    /**
	     * The values of each attribute associated with the node's attached shader.
	     * @type {Map<string, SKAttributeValue>}
	     * @see https://developer.apple.com/reference/spritekit/skshapenode/2715841-attributevalues
	     */
	    _this.attributeValues = new Map();

	    // Instance Properties

	    _this._customPlaygroundQuickLook = null;
	    return _this;
	  }

	  // Creating a Shape Path

	  /**
	   * Creates a shape node from a Core Graphics path.
	   * @access public
	   * @param {CGPath} path - The Core Graphics path to use. The path is relative to the nodes origin.
	   * @returns {void}
	   * @see https://developer.apple.com/reference/spritekit/skshapenode/1520022-init
	   */


	  _createClass(SKShapeNode, [{
	    key: 'setValueForAttribute',


	    // Working with Custom Shaders

	    /**
	     * Sets an attribute value for an attached shader.
	     * @access public
	     * @param {SKAttributeValue} value - An attribute value object containing the scalar or vector value to set in the attached shader.
	     * @param {string} key - The attribute name.
	     * @returns {void}
	     * @see https://developer.apple.com/reference/spritekit/skshapenode/2715855-setvalue
	     */
	    value: function setValueForAttribute(value, key) {}

	    /**
	     * The value of a shader attribute.
	     * @access public
	     * @param {string} key - The attribute name.
	     * @returns {?SKAttributeValue} - 
	     * @see https://developer.apple.com/reference/spritekit/skshapenode/2715843-value
	     */

	  }, {
	    key: 'valueForAttributeNamed',
	    value: function valueForAttributeNamed(key) {
	      return null;
	    }

	    // Instance Properties
	    /**
	     * A custom playground quick look for this instance.
	     * @type {PlaygroundQuickLook}
	     * @desc 
	     * @see https://developer.apple.com/reference/spritekit/skshapenode/1645784-customplaygroundquicklook
	     */

	  }, {
	    key: '_render',


	    /**
	     * @access private
	     * @param {WebGLRenderingContext} gl -
	     * @returns {void}
	     */
	    value: function _render(gl) {}
	  }, {
	    key: 'lineLength',


	    // Reading the Shape Nodes Properties
	    /**
	     * The length of the line defined by the shape node.
	     * @type {number}
	     * @desc 
	     * @see https://developer.apple.com/reference/spritekit/skshapenode/1520398-linelength
	     */
	    get: function get() {
	      //return this._lineLength
	      // TODO: implement
	      return 0;
	    }
	  }, {
	    key: 'customPlaygroundQuickLook',
	    get: function get() {
	      return this._customPlaygroundQuickLook;
	    }
	  }], [{
	    key: 'node',
	    value: function node(path) {}

	    /**
	     * Creates a shape node with a rectangular path centered on the nodes origin.
	     * @access public
	     * @param {CGSize} size - The size of the rectangle.
	     * @returns {void}
	     * @see https://developer.apple.com/reference/spritekit/skshapenode/1520147-init
	     */

	  }, {
	    key: 'nodeWithRectOf',
	    value: function nodeWithRectOf(size) {}

	    /**
	     * Creates a shape node with a circular path centered on the nodes origin.
	     * @access public
	     * @param {number} radius - The radius of the circle.
	     * @returns {void}
	     * @see https://developer.apple.com/reference/spritekit/skshapenode/1519570-init
	     */

	  }, {
	    key: 'nodeWithCircleOfRadius',
	    value: function nodeWithCircleOfRadius(radius) {}

	    /**
	     * Creates a shape node with an elliptical path centered on the nodes origin.
	     * @access public
	     * @param {CGSize} size - The height and width of the ellipse.
	     * @returns {void}
	     * @see https://developer.apple.com/reference/spritekit/skshapenode/1519980-init
	     */

	  }, {
	    key: 'nodeWithEllipseOf',
	    value: function nodeWithEllipseOf(size) {}

	    /**
	     * Creates a shape node with an elliptical path that fills the specified rectangle.
	     * @access public
	     * @param {CGRect} rect - A rectangle, relative to the nodes origin.
	     * @returns {void}
	     * @see https://developer.apple.com/reference/spritekit/skshapenode/1520412-init
	     */

	  }, {
	    key: 'nodeWithEllipseIn',
	    value: function nodeWithEllipseIn(rect) {}

	    /**
	     * Creates a shape node from a series of points.
	     * @access public
	     * @param {UnsafeMutablePointer<CGPoint>} points - An array of Core Graphics points. The points are relative to the nodes origin.
	     * @param {number} numPoints - The number of points in the array.
	     * @returns {void}
	     * @see https://developer.apple.com/reference/spritekit/skshapenode/1520120-init
	     */

	  }, {
	    key: 'nodeWithPointsCount',
	    value: function nodeWithPointsCount(points, numPoints) {}

	    /**
	     * Creates a shape node from a series of spline points.
	     * @access public
	     * @param {UnsafeMutablePointer<CGPoint>} points - An array of Core Graphics points.
	     * @param {number} numPoints - The number of points in the array.
	     * @returns {void}
	     * @see https://developer.apple.com/reference/spritekit/skshapenode/1520140-init
	     */

	  }, {
	    key: 'nodeWithSplinePointsCount',
	    value: function nodeWithSplinePointsCount(points, numPoints) {}
	  }]);

	  return SKShapeNode;
	}(_SKNode3.default);

	exports.default = SKShapeNode;

/***/ },
/* 233 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _SKAction2 = __webpack_require__(220);

	var _SKAction3 = _interopRequireDefault(_SKAction2);

	var _SKActionTimingMode = __webpack_require__(221);

	var _SKActionTimingMode2 = _interopRequireDefault(_SKActionTimingMode);

	var _SKNode = __webpack_require__(133);

	var _SKNode2 = _interopRequireDefault(_SKNode);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var SKWait = function (_SKAction) {
	  _inherits(SKWait, _SKAction);

	  /**
	   * constructor
	   * @access public
	   * @constructor
	   */
	  function SKWait() {
	    _classCallCheck(this, SKWait);

	    var _this = _possibleConstructorReturn(this, (SKWait.__proto__ || Object.getPrototypeOf(SKWait)).call(this));

	    _this._actions = [];
	    _this._finished = false;
	    _this._duration = 0;
	    _this._timingMode = _SKActionTimingMode2.default.linear;
	    _this._beginTime = 0;
	    _this._isRunning = false;
	    _this._pausedTime = 0;
	    return _this;
	  }

	  /**
	   * Creates an action that idles for a specified period of time.
	   * @access public
	   * @param {number} sec - The amount of time to wait.
	   * @returns {SKAction} - 
	   * @desc When the action executes, the action waits for the specified amount of time, then ends. This is typically used as part of a sequence of actions to insert a delay between two other actions. You might also use it in conjunction with the run(_:completion:) method to trigger code that needs to run at a later time.This action is not reversible; the reverse of this action is the same action.
	   * @see https://developer.apple.com/reference/spritekit/skaction/1417788-wait
	   */


	  _createClass(SKWait, null, [{
	    key: 'waitForDuration',
	    value: function waitForDuration(sec) {
	      var action = new SKWait();
	      action._duration = sec;
	      return action;
	    }

	    /**
	     * Creates an action that idles for a randomized period of time.
	     * @access public
	     * @param {number} sec - The average amount of time to wait.
	     * @param {number} durationRange - The range of possible values for the duration.
	     * @returns {SKAction} - 
	     * @desc When the action executes, the action waits for the specified amount of time, then ends. This is typically used as part of a sequence of actions to insert a delay between two other actions. However, you might also use it in conjunction with the run(_:completion:) method to trigger code that needs to run at a later time.Each time the action is executed, the action computes a new random value for the duration. The duration may vary in either direction by up to half of the value of the durationRange parameter.This action is not reversible; the reverse of this action is the same action.
	     * @see https://developer.apple.com/reference/spritekit/skaction/1417760-wait
	     */

	  }, {
	    key: 'waitForDurationWithRange',
	    value: function waitForDurationWithRange(sec, durationRange) {
	      var duration = Math.max(0, sec + (Math.random() - 0.5) * durationRange);
	      var action = new SKWait();
	      action._duration = duration;
	      return action;
	    }
	  }]);

	  return SKWait;
	}(_SKAction3.default);

	exports.default = SKWait;


	_SKAction3.default.waitForDuration = SKWait.waitForDuration;
	_SKAction3.default.waitForDurationWithRange = SKWait.waitForDurationWithRange;

/***/ },
/* 234 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _BinaryParser = __webpack_require__(235);

	var _BinaryParser2 = _interopRequireDefault(_BinaryParser);

	var _ecl = __webpack_require__(37);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var _supportedEncoding = ['ascii', 'utf8', 'utf16le', 'ucs2', 'base64', 'latin1', 'binary', 'hex'];

	/*global Buffer*/
	var _Buffer = null;
	if (typeof Buffer !== 'undefined') {
	  _Buffer = Buffer;
	} else {
	  var allowException = true;
	  var _beParser = new _BinaryParser2.default(true, allowException);
	  var _leParser = new _BinaryParser2.default(false, allowException);

	  var _Buffer2 = function () {
	    function _Buffer2() {
	      _classCallCheck(this, _Buffer2);

	      this._data = null;
	    }

	    _createClass(_Buffer2, [{
	      key: 'readIntBE',
	      value: function readIntBE(offset, byteLength) {
	        var noAssert = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

	        switch (byteLength) {
	          case 1:
	            return this.readInt8(offset, noAssert);
	          case 2:
	            return this.readInt16BE(offset, noAssert);
	          case 4:
	            return this.readInt32BE(offset, noAssert);
	        }
	        var data = this.slice(offset, offset + byteLength)._data;
	        return _beParser.decodeInt(data, byteLength * 8, true);
	      }
	    }, {
	      key: 'readIntLE',
	      value: function readIntLE(offset, byteLength) {
	        var noAssert = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

	        switch (byteLength) {
	          case 1:
	            return this.readInt8(offset, noAssert);
	          case 2:
	            return this.readInt16LE(offset, noAssert);
	          case 4:
	            return this.readInt32LE(offset, noAssert);
	        }
	        var data = this.slice(offset, offset + byteLength)._data;
	        return _leParser.decodeInt(data, byteLength * 8, true);
	      }
	    }, {
	      key: 'readInt8',
	      value: function readInt8(offset) {
	        var noAssert = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

	        return this._data.getInt8(offset);
	      }
	    }, {
	      key: 'readInt16BE',
	      value: function readInt16BE(offset) {
	        var noAssert = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

	        return this._data.getInt16(offset, false);
	      }
	    }, {
	      key: 'readInt16LE',
	      value: function readInt16LE(offset) {
	        var noAssert = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

	        return this._data.getInt16(offset, true);
	      }
	    }, {
	      key: 'readInt32BE',
	      value: function readInt32BE(offset) {
	        var noAssert = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

	        return this._data.getInt32(offset, false);
	      }
	    }, {
	      key: 'readInt32LE',
	      value: function readInt32LE(offset) {
	        var noAssert = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

	        return this._data.getInt32(offset, true);
	      }
	    }, {
	      key: 'readUIntBE',
	      value: function readUIntBE(offset, byteLength) {
	        var noAssert = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

	        switch (byteLength) {
	          case 1:
	            return this.readUInt8(offset, noAssert);
	          case 2:
	            return this.readUInt16BE(offset, noAssert);
	          case 4:
	            return this.readUInt32BE(offset, noAssert);
	        }
	        var data = this.slice(offset, offset + byteLength)._data;
	        return _beParser.decodeInt(data, byteLength * 8, false);
	      }
	    }, {
	      key: 'readUIntLE',
	      value: function readUIntLE(offset, byteLength) {
	        var noAssert = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

	        switch (byteLength) {
	          case 1:
	            return this.readUInt8(offset, noAssert);
	          case 2:
	            return this.readUInt16LE(offset, noAssert);
	          case 4:
	            return this.readUInt32LE(offset, noAssert);
	        }
	        var data = this.slice(offset, offset + byteLength)._data;
	        return _leParser.decodeInt(data, byteLength * 8, false);
	      }
	    }, {
	      key: 'readUInt8',
	      value: function readUInt8(offset) {
	        var noAssert = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

	        return this._data.getUint8(offset);
	      }
	    }, {
	      key: 'readUInt16BE',
	      value: function readUInt16BE(offset) {
	        var noAssert = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

	        return this._data.getUint16(offset, false);
	      }
	    }, {
	      key: 'readUInt16LE',
	      value: function readUInt16LE(offset) {
	        var noAssert = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

	        return this._data.getUint16(offset, true);
	      }
	    }, {
	      key: 'readUInt32BE',
	      value: function readUInt32BE(offset) {
	        var noAssert = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

	        return this._data.getUint32(offset, false);
	      }
	    }, {
	      key: 'readUInt32LE',
	      value: function readUInt32LE(offset) {
	        var noAssert = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

	        return this._data.getUint32(offset, true);
	      }
	    }, {
	      key: 'readFloatBE',
	      value: function readFloatBE(offset) {
	        var noAssert = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

	        return this._data.getFloat32(offset, false);
	      }
	    }, {
	      key: 'readFloatLE',
	      value: function readFloatLE(offset) {
	        var noAssert = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

	        return this._data.getFloat32(offset, true);
	      }
	    }, {
	      key: 'readDoubleBE',
	      value: function readDoubleBE(offset) {
	        var noAssert = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

	        return this._data.getFloat64(offset, false);
	      }
	    }, {
	      key: 'readDoubleLE',
	      value: function readDoubleLE(offset) {
	        var noAssert = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

	        return this._data.getFloat64(offset, true);
	      }
	    }, {
	      key: 'slice',
	      value: function slice(start, end) {
	        return new _Buffer2(this._data.buffer.slice(start, end));
	      }
	    }, {
	      key: 'toString',
	      value: function toString(encoding, start, end) {
	        if (!_Buffer2.isEncoding(encoding)) {
	          throw new Error('unsupported encoding: ' + encoding);
	        }
	        var data = new Uint8Array(this._data.buffer);
	        if (encoding === 'binary') {
	          return String.fromCharCode.apply('', data);
	        } else if (encoding === 'ascii' || encoding === 'latin1') {
	          var len = data.indexOf(0);
	          var _data = data.slice(0, len);
	          return String.fromCharCode.apply('', _data);
	        } else if (encoding === 'hex') {
	          return this._hex(data, false);
	        } else if (encoding === 'base64') {
	          var _str = String.fromCharCode.apply('', data);
	          if (typeof atob === 'function') {
	            return atob(_str);
	          }
	          throw new Error('needs atob() function to convert to base64');
	        }

	        var str = this._hex(data, true);
	        if (encoding === 'utf8') {
	          return (0, _ecl.UnescapeUTF8)(str);
	        } else if (encoding === 'utf16le' || encoding === 'ucs2') {
	          return (0, _ecl.UnescapeUTF16LE)(str);
	        }
	        throw new Error('unsupported encoding: ' + encoding);
	      }
	    }, {
	      key: '_hex',
	      value: function _hex(data, usePercent) {
	        var hexArray = data.map(function (num) {
	          if (num < 16) {
	            return '0' + num.toString(16);
	          }
	          return num.toString(16);
	        });
	        var pad = '';
	        if (usePercent) {
	          pad = '%';
	        }
	        return hexArray.join(pad);
	      }
	    }, {
	      key: 'length',
	      get: function get() {
	        return this._data.byteLength;
	      }
	    }], [{
	      key: 'from',
	      value: function from(array) {
	        var byteOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
	        var length = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

	        var buf = new _Buffer2();
	        if (Array.isArray(array)) {
	          var ab = new ArrayBuffer(array);
	          buf._data = new DataView(ab.buffer, byteOffset, length);
	        } else if (array instanceof ArrayBuffer) {
	          buf._data = new DataView(array, byteOffset, length);
	        } else if (array.buffer instanceof ArrayBuffer) {
	          buf._data = new DataView(array.buffer, byteOffset, length);
	        }

	        if (buf._data === null) {
	          throw new Error('Buffer.from: unsupported data type: ' + array);
	        }

	        return buf;
	      }
	    }, {
	      key: 'isEncoding',
	      value: function isEncoding(encoding) {
	        return _supportedEncoding.indexOf(encoding) >= 0;
	      }
	    }]);

	    return _Buffer2;
	  }();

	  _Buffer = _Buffer2;
	}

	exports.default = _Buffer;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3).Buffer))

/***/ },
/* 235 */
/***/ function(module, exports) {

	"use strict";

	Object.defineProperty(exports, "__esModule", {
		value: true
	});
	//+ Jonas Raoni Soares Silva
	//@ http://jsfromhell.com/classes/binary-parser [rev. #1]

	var BinaryParser = function BinaryParser(bigEndian, allowExceptions) {
		this.bigEndian = bigEndian, this.allowExceptions = allowExceptions;
	};
	exports.default = BinaryParser;


	var p = BinaryParser.prototype;

	p.encodeFloat = function (number, precisionBits, exponentBits) {
		var bias = Math.pow(2, exponentBits - 1) - 1,
		    minExp = -bias + 1,
		    maxExp = bias,
		    minUnnormExp = minExp - precisionBits,
		    status = isNaN(n = parseFloat(number)) || n == -Infinity || n == +Infinity ? n : 0,
		    exp = 0,
		    len = 2 * bias + 1 + precisionBits + 3,
		    bin = new Array(len),
		    signal = (n = status !== 0 ? 0 : n) < 0,
		    n = Math.abs(n),
		    intPart = Math.floor(n),
		    floatPart = n - intPart,
		    i,
		    lastBit,
		    rounded,
		    j,
		    result;
		for (i = len; i; bin[--i] = 0) {}
		for (i = bias + 2; intPart && i; bin[--i] = intPart % 2, intPart = Math.floor(intPart / 2)) {}
		for (i = bias + 1; floatPart > 0 && i; (bin[++i] = ((floatPart *= 2) >= 1) - 0) && --floatPart) {}
		for (i = -1; ++i < len && !bin[i];) {}
		if (bin[(lastBit = precisionBits - 1 + (i = (exp = bias + 1 - i) >= minExp && exp <= maxExp ? i + 1 : bias + 1 - (exp = minExp - 1))) + 1]) {
			if (!(rounded = bin[lastBit])) for (j = lastBit + 2; !rounded && j < len; rounded = bin[j++]) {}
			for (j = lastBit + 1; rounded && --j >= 0; (bin[j] = !bin[j] - 0) && (rounded = 0)) {}
		}
		for (i = i - 2 < 0 ? -1 : i - 3; ++i < len && !bin[i];) {}

		(exp = bias + 1 - i) >= minExp && exp <= maxExp ? ++i : exp < minExp && (exp != bias + 1 - len && exp < minUnnormExp && this.warn("encodeFloat::float underflow"), i = bias + 1 - (exp = minExp - 1));
		(intPart || status !== 0) && (this.warn(intPart ? "encodeFloat::float overflow" : "encodeFloat::" + status), exp = maxExp + 1, i = bias + 2, status == -Infinity ? signal = 1 : isNaN(status) && (bin[i] = 1));
		for (n = Math.abs(exp + bias), j = exponentBits + 1, result = ""; --j; result = n % 2 + result, n = n >>= 1) {}
		for (n = 0, j = 0, i = (result = (signal ? "1" : "0") + result + bin.slice(i, i + precisionBits).join("")).length, r = []; i; n += (1 << j) * result.charAt(--i), j == 7 && (r[r.length] = String.fromCharCode(n), n = 0), j = (j + 1) % 8) {}
		r[r.length] = n ? String.fromCharCode(n) : "";
		return (this.bigEndian ? r.reverse() : r).join("");
	};
	p.encodeInt = function (number, bits, signed) {
		var max = Math.pow(2, bits),
		    r = [];
		(number >= max || number < -(max >> 1)) && this.warn("encodeInt::overflow") && (number = 0);
		number < 0 && (number += max);
		for (; number; r[r.length] = String.fromCharCode(number % 256), number = Math.floor(number / 256)) {}
		for (bits = -(-bits >> 3) - r.length; bits--; r[r.length] = "\0") {}
		return (this.bigEndian ? r.reverse() : r).join("");
	};
	p.decodeFloat = function (data, precisionBits, exponentBits) {
		var b = ((b = new this.Buffer(this.bigEndian, data)).checkBuffer(precisionBits + exponentBits + 1), b),
		    bias = Math.pow(2, exponentBits - 1) - 1,
		    signal = b.readBits(precisionBits + exponentBits, 1),
		    exponent = b.readBits(precisionBits, exponentBits),
		    significand = 0,
		    divisor = 2,
		    curByte = b.buffer.length + (-precisionBits >> 3) - 1,
		    byteValue,
		    startBit,
		    mask;
		do {
			for (byteValue = b.buffer[++curByte], startBit = precisionBits % 8 || 8, mask = 1 << startBit; mask >>= 1; byteValue & mask && (significand += 1 / divisor), divisor *= 2) {}
		} while (precisionBits -= startBit);
		return exponent == (bias << 1) + 1 ? significand ? NaN : signal ? -Infinity : +Infinity : (1 + signal * -2) * (exponent || significand ? !exponent ? Math.pow(2, -bias + 1) * significand : Math.pow(2, exponent - bias) * (1 + significand) : 0);
	};
	p.decodeInt = function (data, bits, signed) {
		var b = new this.Buffer(this.bigEndian, data),
		    x = b.readBits(0, bits),
		    max = Math.pow(2, bits);
		return signed && x >= max / 2 ? x - max : x;
	};

	var p2 = (p.Buffer = function (bigEndian, buffer) {
		this.bigEndian = bigEndian || 0, this.buffer = [], this.setBuffer(buffer);
	}).prototype;

	p2.readBits = function (start, length) {
		//shl fix: Henri Torgemane ~1996 (compressed by Jonas Raoni)
		function shl(a, b) {
			for (++b; --b; a = ((a %= 0x7fffffff + 1) & 0x40000000) == 0x40000000 ? a * 2 : (a - 0x40000000) * 2 + 0x7fffffff + 1) {}
			return a;
		}
		if (start < 0 || length <= 0) return 0;
		this.checkBuffer(start + length);
		for (var offsetLeft, offsetRight = start % 8, curByte = this.buffer.length - (start >> 3) - 1, lastByte = this.buffer.length + (-(start + length) >> 3), diff = curByte - lastByte, sum = (this.buffer[curByte] >> offsetRight & (1 << (diff ? 8 - offsetRight : length)) - 1) + (diff && (offsetLeft = (start + length) % 8) ? (this.buffer[lastByte++] & (1 << offsetLeft) - 1) << (diff-- << 3) - offsetRight : 0); diff; sum += shl(this.buffer[lastByte++], (diff-- << 3) - offsetRight)) {}
		return sum;
	};
	p2.setBuffer = function (data) {
		if (data) {
			for (var l, i = l = data.length, b = this.buffer = new Array(l); i; b[l - i] = data.charCodeAt(--i)) {}
			this.bigEndian && b.reverse();
		}
	};
	p2.hasNeededBits = function (neededBits) {
		return this.buffer.length >= -(-neededBits >> 3);
	};
	p2.checkBuffer = function (neededBits) {
		if (!this.hasNeededBits(neededBits)) throw new Error("checkBuffer::missing bytes");
	};

	p.warn = function (msg) {
		if (this.allowExceptions) throw new Error(msg);
		return 1;
	};
	p.toSmall = function (data) {
		return this.decodeInt(data, 8, true);
	};
	p.fromSmall = function (number) {
		return this.encodeInt(number, 8, true);
	};
	p.toByte = function (data) {
		return this.decodeInt(data, 8, false);
	};
	p.fromByte = function (number) {
		return this.encodeInt(number, 8, false);
	};
	p.toShort = function (data) {
		return this.decodeInt(data, 16, true);
	};
	p.fromShort = function (number) {
		return this.encodeInt(number, 16, true);
	};
	p.toWord = function (data) {
		return this.decodeInt(data, 16, false);
	};
	p.fromWord = function (number) {
		return this.encodeInt(number, 16, false);
	};
	p.toInt = function (data) {
		return this.decodeInt(data, 32, true);
	};
	p.fromInt = function (number) {
		return this.encodeInt(number, 32, true);
	};
	p.toDWord = function (data) {
		return this.decodeInt(data, 32, false);
	};
	p.fromDWord = function (number) {
		return this.encodeInt(number, 32, false);
	};
	p.toFloat = function (data) {
		return this.decodeFloat(data, 23, 8);
	};
	p.fromFloat = function (number) {
		return this.encodeFloat(number, 23, 8);
	};
	p.toDouble = function (data) {
		return this.decodeFloat(data, 52, 11);
	};
	p.fromDouble = function (number) {
		return this.encodeFloat(number, 52, 11);
	};

/***/ },
/* 236 */
/***/ function(module, exports) {

	'use strict';

	/*global HTMLCanvasElement*/

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var _HTMLCanvasElement = null;
	if (typeof HTMLCanvasElement !== 'undefined') {
	  _HTMLCanvasElement = HTMLCanvasElement;
	} else {
	  var _HTMLCanvasElement2 = function () {
	    function _HTMLCanvasElement2() {
	      _classCallCheck(this, _HTMLCanvasElement2);
	    }

	    _createClass(_HTMLCanvasElement2, [{
	      key: 'getContext',
	      value: function getContext(name, opt) {
	        throw new Error('getContext is not implemented');
	      }
	    }]);

	    return _HTMLCanvasElement2;
	  }();

	  _HTMLCanvasElement = _HTMLCanvasElement2;
	}
	exports.default = _HTMLCanvasElement;

/***/ }
/******/ ]);