module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _CGBlendMode = __webpack_require__(1);

	var _CGBlendMode2 = _interopRequireDefault(_CGBlendMode);

	var _CGLineCap = __webpack_require__(2);

	var _CGLineCap2 = _interopRequireDefault(_CGLineCap);

	var _CGLineJoin = __webpack_require__(3);

	var _CGLineJoin2 = _interopRequireDefault(_CGLineJoin);

	var _CGMutablePath = __webpack_require__(4);

	var _CGMutablePath2 = _interopRequireDefault(_CGMutablePath);

	var _CGPath = __webpack_require__(8);

	var _CGPath2 = _interopRequireDefault(_CGPath);

	var _CGPathApplierFunction = __webpack_require__(10);

	var _CGPathApplierFunction2 = _interopRequireDefault(_CGPathApplierFunction);

	var _CGPathFillRule = __webpack_require__(9);

	var _CGPathFillRule2 = _interopRequireDefault(_CGPathFillRule);

	var _CGPoint = __webpack_require__(5);

	var _CGPoint2 = _interopRequireDefault(_CGPoint);

	var _CGRect = __webpack_require__(6);

	var _CGRect2 = _interopRequireDefault(_CGRect);

	var _CGSize = __webpack_require__(7);

	var _CGSize2 = _interopRequireDefault(_CGSize);

	var _CGVector = __webpack_require__(11);

	var _CGVector2 = _interopRequireDefault(_CGVector);

	var _NSValue = __webpack_require__(12);

	var _NSValue2 = _interopRequireDefault(_NSValue);

	var _NSObject = __webpack_require__(13);

	var _NSObject2 = _interopRequireDefault(_NSObject);

	var _CAAction = __webpack_require__(18);

	var _CAAction2 = _interopRequireDefault(_CAAction);

	var _CAAnimation = __webpack_require__(19);

	var _CAAnimation2 = _interopRequireDefault(_CAAnimation);

	var _CAAnimationDelegate = __webpack_require__(23);

	var _CAAnimationDelegate2 = _interopRequireDefault(_CAAnimationDelegate);

	var _CAAnimationGroup = __webpack_require__(26);

	var _CAAnimationGroup2 = _interopRequireDefault(_CAAnimationGroup);

	var _CABasicAnimation = __webpack_require__(27);

	var _CABasicAnimation2 = _interopRequireDefault(_CABasicAnimation);

	var _CAKeyframeAnimation = __webpack_require__(30);

	var _CAKeyframeAnimation2 = _interopRequireDefault(_CAKeyframeAnimation);

	var _CAMediaTiming = __webpack_require__(21);

	var _CAMediaTiming2 = _interopRequireDefault(_CAMediaTiming);

	var _CAMediaTimingFunction = __webpack_require__(22);

	var _CAMediaTimingFunction2 = _interopRequireDefault(_CAMediaTimingFunction);

	var _CAPropertyAnimation = __webpack_require__(28);

	var _CAPropertyAnimation2 = _interopRequireDefault(_CAPropertyAnimation);

	var _CATransform3D = __webpack_require__(14);

	var _CATransform3D2 = _interopRequireDefault(_CATransform3D);

	var _SCNAction = __webpack_require__(31);

	var _SCNAction2 = _interopRequireDefault(_SCNAction);

	var _SCNActionable = __webpack_require__(34);

	var _SCNActionable2 = _interopRequireDefault(_SCNActionable);

	var _SCNActionTimingFunction = __webpack_require__(106);

	var _SCNActionTimingFunction2 = _interopRequireDefault(_SCNActionTimingFunction);

	var _SCNActionTimingMode = __webpack_require__(105);

	var _SCNActionTimingMode2 = _interopRequireDefault(_SCNActionTimingMode);

	var _SCNAnimatable = __webpack_require__(35);

	var _SCNAnimatable2 = _interopRequireDefault(_SCNAnimatable);

	var _SCNAnimationEvent = __webpack_require__(24);

	var _SCNAnimationEvent2 = _interopRequireDefault(_SCNAnimationEvent);

	var _SCNAnimationEventBlock = __webpack_require__(25);

	var _SCNAnimationEventBlock2 = _interopRequireDefault(_SCNAnimationEventBlock);

	var _SCNAntialiasingMode = __webpack_require__(79);

	var _SCNAntialiasingMode2 = _interopRequireDefault(_SCNAntialiasingMode);

	var _SCNAudioPlayer = __webpack_require__(104);

	var _SCNAudioPlayer2 = _interopRequireDefault(_SCNAudioPlayer);

	var _SCNAudioSource = __webpack_require__(32);

	var _SCNAudioSource2 = _interopRequireDefault(_SCNAudioSource);

	var _SCNBillboardAxis = __webpack_require__(107);

	var _SCNBillboardAxis2 = _interopRequireDefault(_SCNBillboardAxis);

	var _SCNBillboardConstraint = __webpack_require__(108);

	var _SCNBillboardConstraint2 = _interopRequireDefault(_SCNBillboardConstraint);

	var _SCNBindingBlock = __webpack_require__(78);

	var _SCNBindingBlock2 = _interopRequireDefault(_SCNBindingBlock);

	var _SCNBlendMode = __webpack_require__(94);

	var _SCNBlendMode2 = _interopRequireDefault(_SCNBlendMode);

	var _SCNBoundingVolume = __webpack_require__(36);

	var _SCNBoundingVolume2 = _interopRequireDefault(_SCNBoundingVolume);

	var _SCNBox = __webpack_require__(109);

	var _SCNBox2 = _interopRequireDefault(_SCNBox);

	var _SCNBufferBindingBlock = __webpack_require__(85);

	var _SCNBufferBindingBlock2 = _interopRequireDefault(_SCNBufferBindingBlock);

	var _SCNBufferFrequency = __webpack_require__(84);

	var _SCNBufferFrequency2 = _interopRequireDefault(_SCNBufferFrequency);

	var _SCNBufferStream = __webpack_require__(86);

	var _SCNBufferStream2 = _interopRequireDefault(_SCNBufferStream);

	var _SCNCamera = __webpack_require__(80);

	var _SCNCamera2 = _interopRequireDefault(_SCNCamera);

	var _SCNCapsule = __webpack_require__(110);

	var _SCNCapsule2 = _interopRequireDefault(_SCNCapsule);

	var _SCNChamferMode = __webpack_require__(111);

	var _SCNChamferMode2 = _interopRequireDefault(_SCNChamferMode);

	var _SCNCone = __webpack_require__(112);

	var _SCNCone2 = _interopRequireDefault(_SCNCone);

	var _SCNConstraint = __webpack_require__(98);

	var _SCNConstraint2 = _interopRequireDefault(_SCNConstraint);

	var _SCNCullMode = __webpack_require__(93);

	var _SCNCullMode2 = _interopRequireDefault(_SCNCullMode);

	var _SCNCylinder = __webpack_require__(113);

	var _SCNCylinder2 = _interopRequireDefault(_SCNCylinder);

	var _SCNDebugOptions = __webpack_require__(72);

	var _SCNDebugOptions2 = _interopRequireDefault(_SCNDebugOptions);

	var _SCNFieldForceEvaluator = __webpack_require__(102);

	var _SCNFieldForceEvaluator2 = _interopRequireDefault(_SCNFieldForceEvaluator);

	var _SCNFilterMode = __webpack_require__(47);

	var _SCNFilterMode2 = _interopRequireDefault(_SCNFilterMode);

	var _SCNFloor = __webpack_require__(114);

	var _SCNFloor2 = _interopRequireDefault(_SCNFloor);

	var _SCNGeometry = __webpack_require__(37);

	var _SCNGeometry2 = _interopRequireDefault(_SCNGeometry);

	var _SCNGeometryElement = __webpack_require__(88);

	var _SCNGeometryElement2 = _interopRequireDefault(_SCNGeometryElement);

	var _SCNGeometryPrimitiveType = __webpack_require__(89);

	var _SCNGeometryPrimitiveType2 = _interopRequireDefault(_SCNGeometryPrimitiveType);

	var _SCNGeometrySource = __webpack_require__(83);

	var _SCNGeometrySource2 = _interopRequireDefault(_SCNGeometrySource);

	var _SCNHitTestOption = __webpack_require__(74);

	var _SCNHitTestOption2 = _interopRequireDefault(_SCNHitTestOption);

	var _SCNHitTestResult = __webpack_require__(58);

	var _SCNHitTestResult2 = _interopRequireDefault(_SCNHitTestResult);

	var _SCNIKConstraint = __webpack_require__(115);

	var _SCNIKConstraint2 = _interopRequireDefault(_SCNIKConstraint);

	var _SCNLayer = __webpack_require__(116);

	var _SCNLayer2 = _interopRequireDefault(_SCNLayer);

	var _SCNLevelOfDetail = __webpack_require__(90);

	var _SCNLevelOfDetail2 = _interopRequireDefault(_SCNLevelOfDetail);

	var _SCNLight = __webpack_require__(81);

	var _SCNLight2 = _interopRequireDefault(_SCNLight);

	var _SCNLookAtConstraint = __webpack_require__(117);

	var _SCNLookAtConstraint2 = _interopRequireDefault(_SCNLookAtConstraint);

	var _SCNMaterial = __webpack_require__(91);

	var _SCNMaterial2 = _interopRequireDefault(_SCNMaterial);

	var _SCNMaterialProperty = __webpack_require__(44);

	var _SCNMaterialProperty2 = _interopRequireDefault(_SCNMaterialProperty);

	var _SCNMatrix = __webpack_require__(17);

	var _SCNMatrix2 = _interopRequireDefault(_SCNMatrix);

	var _SCNMatrix4EqualToMatrix = __webpack_require__(118);

	var _SCNMatrix4EqualToMatrix2 = _interopRequireDefault(_SCNMatrix4EqualToMatrix);

	var _SCNMatrix4FromGLKMatrix = __webpack_require__(119);

	var _SCNMatrix4FromGLKMatrix2 = _interopRequireDefault(_SCNMatrix4FromGLKMatrix);

	var _SCNMatrix4FromMat = __webpack_require__(120);

	var _SCNMatrix4FromMat2 = _interopRequireDefault(_SCNMatrix4FromMat);

	var _SCNMatrix4Invert = __webpack_require__(121);

	var _SCNMatrix4Invert2 = _interopRequireDefault(_SCNMatrix4Invert);

	var _SCNMatrix4IsIdentity = __webpack_require__(122);

	var _SCNMatrix4IsIdentity2 = _interopRequireDefault(_SCNMatrix4IsIdentity);

	var _SCNMatrix4MakeRotation = __webpack_require__(123);

	var _SCNMatrix4MakeRotation2 = _interopRequireDefault(_SCNMatrix4MakeRotation);

	var _SCNMatrix4MakeScale = __webpack_require__(124);

	var _SCNMatrix4MakeScale2 = _interopRequireDefault(_SCNMatrix4MakeScale);

	var _SCNMatrix4MakeTranslation = __webpack_require__(45);

	var _SCNMatrix4MakeTranslation2 = _interopRequireDefault(_SCNMatrix4MakeTranslation);

	var _SCNMatrix4Mult = __webpack_require__(125);

	var _SCNMatrix4Mult2 = _interopRequireDefault(_SCNMatrix4Mult);

	var _SCNMatrix4Rotate = __webpack_require__(126);

	var _SCNMatrix4Rotate2 = _interopRequireDefault(_SCNMatrix4Rotate);

	var _SCNMatrix4Scale = __webpack_require__(127);

	var _SCNMatrix4Scale2 = _interopRequireDefault(_SCNMatrix4Scale);

	var _SCNMatrix4ToGLKMatrix = __webpack_require__(128);

	var _SCNMatrix4ToGLKMatrix2 = _interopRequireDefault(_SCNMatrix4ToGLKMatrix);

	var _SCNMatrix4ToMat = __webpack_require__(129);

	var _SCNMatrix4ToMat2 = _interopRequireDefault(_SCNMatrix4ToMat);

	var _SCNMatrix4Translate = __webpack_require__(130);

	var _SCNMatrix4Translate2 = _interopRequireDefault(_SCNMatrix4Translate);

	var _SCNMorpher = __webpack_require__(95);

	var _SCNMorpher2 = _interopRequireDefault(_SCNMorpher);

	var _SCNMorpherCalculationMode = __webpack_require__(96);

	var _SCNMorpherCalculationMode2 = _interopRequireDefault(_SCNMorpherCalculationMode);

	var _SCNMovabilityHint = __webpack_require__(99);

	var _SCNMovabilityHint2 = _interopRequireDefault(_SCNMovabilityHint);

	var _SCNNode = __webpack_require__(33);

	var _SCNNode2 = _interopRequireDefault(_SCNNode);

	var _SCNNodeRendererDelegate = __webpack_require__(100);

	var _SCNNodeRendererDelegate2 = _interopRequireDefault(_SCNNodeRendererDelegate);

	var _SCNParticleBirthDirection = __webpack_require__(61);

	var _SCNParticleBirthDirection2 = _interopRequireDefault(_SCNParticleBirthDirection);

	var _SCNParticleBirthLocation = __webpack_require__(60);

	var _SCNParticleBirthLocation2 = _interopRequireDefault(_SCNParticleBirthLocation);

	var _SCNParticleBlendMode = __webpack_require__(63);

	var _SCNParticleBlendMode2 = _interopRequireDefault(_SCNParticleBlendMode);

	var _SCNParticleEvent = __webpack_require__(66);

	var _SCNParticleEvent2 = _interopRequireDefault(_SCNParticleEvent);

	var _SCNParticleEventBlock = __webpack_require__(67);

	var _SCNParticleEventBlock2 = _interopRequireDefault(_SCNParticleEventBlock);

	var _SCNParticleImageSequenceAnimationMode = __webpack_require__(62);

	var _SCNParticleImageSequenceAnimationMode2 = _interopRequireDefault(_SCNParticleImageSequenceAnimationMode);

	var _SCNParticleInputMode = __webpack_require__(69);

	var _SCNParticleInputMode2 = _interopRequireDefault(_SCNParticleInputMode);

	var _SCNParticleModifierBlock = __webpack_require__(71);

	var _SCNParticleModifierBlock2 = _interopRequireDefault(_SCNParticleModifierBlock);

	var _SCNParticleModifierStage = __webpack_require__(70);

	var _SCNParticleModifierStage2 = _interopRequireDefault(_SCNParticleModifierStage);

	var _SCNParticleOrientationMode = __webpack_require__(64);

	var _SCNParticleOrientationMode2 = _interopRequireDefault(_SCNParticleOrientationMode);

	var _SCNParticlePropertyController = __webpack_require__(68);

	var _SCNParticlePropertyController2 = _interopRequireDefault(_SCNParticlePropertyController);

	var _SCNParticleSortingMode = __webpack_require__(65);

	var _SCNParticleSortingMode2 = _interopRequireDefault(_SCNParticleSortingMode);

	var _SCNParticleSystem = __webpack_require__(59);

	var _SCNParticleSystem2 = _interopRequireDefault(_SCNParticleSystem);

	var _SCNPhysicsBallSocketJoint = __webpack_require__(131);

	var _SCNPhysicsBallSocketJoint2 = _interopRequireDefault(_SCNPhysicsBallSocketJoint);

	var _SCNPhysicsBehavior = __webpack_require__(52);

	var _SCNPhysicsBehavior2 = _interopRequireDefault(_SCNPhysicsBehavior);

	var _SCNPhysicsBody = __webpack_require__(55);

	var _SCNPhysicsBody2 = _interopRequireDefault(_SCNPhysicsBody);

	var _SCNPhysicsBodyType = __webpack_require__(56);

	var _SCNPhysicsBodyType2 = _interopRequireDefault(_SCNPhysicsBodyType);

	var _SCNPhysicsCollisionCategory = __webpack_require__(132);

	var _SCNPhysicsCollisionCategory2 = _interopRequireDefault(_SCNPhysicsCollisionCategory);

	var _SCNPhysicsContact = __webpack_require__(54);

	var _SCNPhysicsContact2 = _interopRequireDefault(_SCNPhysicsContact);

	var _SCNPhysicsContactDelegate = __webpack_require__(53);

	var _SCNPhysicsContactDelegate2 = _interopRequireDefault(_SCNPhysicsContactDelegate);

	var _SCNPhysicsField = __webpack_require__(101);

	var _SCNPhysicsField2 = _interopRequireDefault(_SCNPhysicsField);

	var _SCNPhysicsFieldScope = __webpack_require__(103);

	var _SCNPhysicsFieldScope2 = _interopRequireDefault(_SCNPhysicsFieldScope);

	var _SCNPhysicsHingeJoint = __webpack_require__(133);

	var _SCNPhysicsHingeJoint2 = _interopRequireDefault(_SCNPhysicsHingeJoint);

	var _SCNPhysicsShape = __webpack_require__(57);

	var _SCNPhysicsShape2 = _interopRequireDefault(_SCNPhysicsShape);

	var _SCNPhysicsSliderJoint = __webpack_require__(134);

	var _SCNPhysicsSliderJoint2 = _interopRequireDefault(_SCNPhysicsSliderJoint);

	var _SCNPhysicsVehicle = __webpack_require__(135);

	var _SCNPhysicsVehicle2 = _interopRequireDefault(_SCNPhysicsVehicle);

	var _SCNPhysicsVehicleWheel = __webpack_require__(136);

	var _SCNPhysicsVehicleWheel2 = _interopRequireDefault(_SCNPhysicsVehicleWheel);

	var _SCNPhysicsWorld = __webpack_require__(51);

	var _SCNPhysicsWorld2 = _interopRequireDefault(_SCNPhysicsWorld);

	var _SCNPlane = __webpack_require__(137);

	var _SCNPlane2 = _interopRequireDefault(_SCNPlane);

	var _SCNProgram = __webpack_require__(39);

	var _SCNProgram2 = _interopRequireDefault(_SCNProgram);

	var _SCNProgramDelegate = __webpack_require__(40);

	var _SCNProgramDelegate2 = _interopRequireDefault(_SCNProgramDelegate);

	var _SCNPyramid = __webpack_require__(138);

	var _SCNPyramid2 = _interopRequireDefault(_SCNPyramid);

	var _SCNQuaternion = __webpack_require__(29);

	var _SCNQuaternion2 = _interopRequireDefault(_SCNQuaternion);

	var _SCNReferenceLoadingPolicy = __webpack_require__(139);

	var _SCNReferenceLoadingPolicy2 = _interopRequireDefault(_SCNReferenceLoadingPolicy);

	var _SCNReferenceNode = __webpack_require__(140);

	var _SCNReferenceNode2 = _interopRequireDefault(_SCNReferenceNode);

	var _SCNRenderer = __webpack_require__(41);

	var _SCNRenderer2 = _interopRequireDefault(_SCNRenderer);

	var _SCNRenderingAPI = __webpack_require__(73);

	var _SCNRenderingAPI2 = _interopRequireDefault(_SCNRenderingAPI);

	var _SCNScene = __webpack_require__(43);

	var _SCNScene2 = _interopRequireDefault(_SCNScene);

	var _SCNSceneExportDelegate = __webpack_require__(49);

	var _SCNSceneExportDelegate2 = _interopRequireDefault(_SCNSceneExportDelegate);

	var _SCNSceneExportProgressHandler = __webpack_require__(50);

	var _SCNSceneExportProgressHandler2 = _interopRequireDefault(_SCNSceneExportProgressHandler);

	var _SCNSceneRenderer = __webpack_require__(42);

	var _SCNSceneRenderer2 = _interopRequireDefault(_SCNSceneRenderer);

	var _SCNSceneRendererDelegate = __webpack_require__(75);

	var _SCNSceneRendererDelegate2 = _interopRequireDefault(_SCNSceneRendererDelegate);

	var _SCNSceneSource = __webpack_require__(141);

	var _SCNSceneSource2 = _interopRequireDefault(_SCNSceneSource);

	var _SCNSceneSourceStatus = __webpack_require__(143);

	var _SCNSceneSourceStatus2 = _interopRequireDefault(_SCNSceneSourceStatus);

	var _SCNSceneSourceStatusHandler = __webpack_require__(142);

	var _SCNSceneSourceStatusHandler2 = _interopRequireDefault(_SCNSceneSourceStatusHandler);

	var _SCNShadable = __webpack_require__(38);

	var _SCNShadable2 = _interopRequireDefault(_SCNShadable);

	var _SCNShaderModifierEntryPoint = __webpack_require__(87);

	var _SCNShaderModifierEntryPoint2 = _interopRequireDefault(_SCNShaderModifierEntryPoint);

	var _SCNShadowMode = __webpack_require__(82);

	var _SCNShadowMode2 = _interopRequireDefault(_SCNShadowMode);

	var _SCNShape = __webpack_require__(144);

	var _SCNShape2 = _interopRequireDefault(_SCNShape);

	var _SCNSkinner = __webpack_require__(97);

	var _SCNSkinner2 = _interopRequireDefault(_SCNSkinner);

	var _SCNSphere = __webpack_require__(145);

	var _SCNSphere2 = _interopRequireDefault(_SCNSphere);

	var _SCNTechnique = __webpack_require__(77);

	var _SCNTechnique2 = _interopRequireDefault(_SCNTechnique);

	var _SCNTechniqueSupport = __webpack_require__(76);

	var _SCNTechniqueSupport2 = _interopRequireDefault(_SCNTechniqueSupport);

	var _SCNText = __webpack_require__(146);

	var _SCNText2 = _interopRequireDefault(_SCNText);

	var _SCNTorus = __webpack_require__(147);

	var _SCNTorus2 = _interopRequireDefault(_SCNTorus);

	var _SCNTransaction = __webpack_require__(148);

	var _SCNTransaction2 = _interopRequireDefault(_SCNTransaction);

	var _SCNTransformConstraint = __webpack_require__(149);

	var _SCNTransformConstraint2 = _interopRequireDefault(_SCNTransformConstraint);

	var _SCNTransparencyMode = __webpack_require__(92);

	var _SCNTransparencyMode2 = _interopRequireDefault(_SCNTransparencyMode);

	var _SCNTube = __webpack_require__(150);

	var _SCNTube2 = _interopRequireDefault(_SCNTube);

	var _SCNVector = __webpack_require__(15);

	var _SCNVector2 = _interopRequireDefault(_SCNVector);

	var _SCNVector3EqualToVector = __webpack_require__(151);

	var _SCNVector3EqualToVector2 = _interopRequireDefault(_SCNVector3EqualToVector);

	var _SCNVector3FromFloat = __webpack_require__(152);

	var _SCNVector3FromFloat2 = _interopRequireDefault(_SCNVector3FromFloat);

	var _SCNVector3FromGLKVector = __webpack_require__(153);

	var _SCNVector3FromGLKVector2 = _interopRequireDefault(_SCNVector3FromGLKVector);

	var _SCNVector3Make = __webpack_require__(154);

	var _SCNVector3Make2 = _interopRequireDefault(_SCNVector3Make);

	var _SCNVector3ToFloat = __webpack_require__(155);

	var _SCNVector3ToFloat2 = _interopRequireDefault(_SCNVector3ToFloat);

	var _SCNVector3ToGLKVector = __webpack_require__(156);

	var _SCNVector3ToGLKVector2 = _interopRequireDefault(_SCNVector3ToGLKVector);

	var _SCNVector3 = __webpack_require__(16);

	var _SCNVector4 = _interopRequireDefault(_SCNVector3);

	var _SCNVector4EqualToVector = __webpack_require__(157);

	var _SCNVector4EqualToVector2 = _interopRequireDefault(_SCNVector4EqualToVector);

	var _SCNVector4FromFloat = __webpack_require__(158);

	var _SCNVector4FromFloat2 = _interopRequireDefault(_SCNVector4FromFloat);

	var _SCNVector4FromGLKVector = __webpack_require__(159);

	var _SCNVector4FromGLKVector2 = _interopRequireDefault(_SCNVector4FromGLKVector);

	var _SCNVector4Make = __webpack_require__(160);

	var _SCNVector4Make2 = _interopRequireDefault(_SCNVector4Make);

	var _SCNVector4ToFloat = __webpack_require__(161);

	var _SCNVector4ToFloat2 = _interopRequireDefault(_SCNVector4ToFloat);

	var _SCNVector4ToGLKVector = __webpack_require__(162);

	var _SCNVector4ToGLKVector2 = _interopRequireDefault(_SCNVector4ToGLKVector);

	var _SCNView = __webpack_require__(163);

	var _SCNView2 = _interopRequireDefault(_SCNView);

	var _SCNWrapMode = __webpack_require__(46);

	var _SCNWrapMode2 = _interopRequireDefault(_SCNWrapMode);

	var _SKColor = __webpack_require__(48);

	var _SKColor2 = _interopRequireDefault(_SKColor);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/*global exports*/
	exports.CGBlendMode = _CGBlendMode2.default;
	exports.CGLineCap = _CGLineCap2.default;
	exports.CGLineJoin = _CGLineJoin2.default;
	exports.CGMutablePath = _CGMutablePath2.default;
	exports.CGPath = _CGPath2.default;
	exports.CGPathApplierFunction = _CGPathApplierFunction2.default;
	exports.CGPathFillRule = _CGPathFillRule2.default;
	exports.CGPoint = _CGPoint2.default;
	exports.CGRect = _CGRect2.default;
	exports.CGSize = _CGSize2.default;
	exports.CGVector = _CGVector2.default;
	exports.NSValue = _NSValue2.default;
	exports.NSObject = _NSObject2.default;
	exports.CAAction = _CAAction2.default;
	exports.CAAnimation = _CAAnimation2.default;
	exports.CAAnimationDelegate = _CAAnimationDelegate2.default;
	exports.CAAnimationGroup = _CAAnimationGroup2.default;
	exports.CABasicAnimation = _CABasicAnimation2.default;
	exports.CAKeyframeAnimation = _CAKeyframeAnimation2.default;
	exports.CAMediaTiming = _CAMediaTiming2.default;
	exports.CAMediaTimingFunction = _CAMediaTimingFunction2.default;
	exports.CAPropertyAnimation = _CAPropertyAnimation2.default;
	exports.CATransform3D = _CATransform3D2.default;
	exports.SCNAction = _SCNAction2.default;
	exports.SCNActionable = _SCNActionable2.default;
	exports.SCNActionTimingFunction = _SCNActionTimingFunction2.default;
	exports.SCNActionTimingMode = _SCNActionTimingMode2.default;
	exports.SCNAnimatable = _SCNAnimatable2.default;
	exports.SCNAnimationEvent = _SCNAnimationEvent2.default;
	exports.SCNAnimationEventBlock = _SCNAnimationEventBlock2.default;
	exports.SCNAntialiasingMode = _SCNAntialiasingMode2.default;
	exports.SCNAudioPlayer = _SCNAudioPlayer2.default;
	exports.SCNAudioSource = _SCNAudioSource2.default;
	exports.SCNBillboardAxis = _SCNBillboardAxis2.default;
	exports.SCNBillboardConstraint = _SCNBillboardConstraint2.default;
	exports.SCNBindingBlock = _SCNBindingBlock2.default;
	exports.SCNBlendMode = _SCNBlendMode2.default;
	exports.SCNBoundingVolume = _SCNBoundingVolume2.default;
	exports.SCNBox = _SCNBox2.default;
	exports.SCNBufferBindingBlock = _SCNBufferBindingBlock2.default;
	exports.SCNBufferFrequency = _SCNBufferFrequency2.default;
	exports.SCNBufferStream = _SCNBufferStream2.default;
	exports.SCNCamera = _SCNCamera2.default;
	exports.SCNCapsule = _SCNCapsule2.default;
	exports.SCNChamferMode = _SCNChamferMode2.default;
	exports.SCNCone = _SCNCone2.default;
	exports.SCNConstraint = _SCNConstraint2.default;
	exports.SCNCullMode = _SCNCullMode2.default;
	exports.SCNCylinder = _SCNCylinder2.default;
	exports.SCNDebugOptions = _SCNDebugOptions2.default;
	exports.SCNFieldForceEvaluator = _SCNFieldForceEvaluator2.default;
	exports.SCNFilterMode = _SCNFilterMode2.default;
	exports.SCNFloor = _SCNFloor2.default;
	exports.SCNGeometry = _SCNGeometry2.default;
	exports.SCNGeometryElement = _SCNGeometryElement2.default;
	exports.SCNGeometryPrimitiveType = _SCNGeometryPrimitiveType2.default;
	exports.SCNGeometrySource = _SCNGeometrySource2.default;
	exports.SCNHitTestOption = _SCNHitTestOption2.default;
	exports.SCNHitTestResult = _SCNHitTestResult2.default;
	exports.SCNIKConstraint = _SCNIKConstraint2.default;
	exports.SCNLayer = _SCNLayer2.default;
	exports.SCNLevelOfDetail = _SCNLevelOfDetail2.default;
	exports.SCNLight = _SCNLight2.default;
	exports.SCNLookAtConstraint = _SCNLookAtConstraint2.default;
	exports.SCNMaterial = _SCNMaterial2.default;
	exports.SCNMaterialProperty = _SCNMaterialProperty2.default;
	exports.SCNMatrix4 = _SCNMatrix2.default;
	exports.SCNMatrix4EqualToMatrix4 = _SCNMatrix4EqualToMatrix2.default;
	exports.SCNMatrix4FromGLKMatrix4 = _SCNMatrix4FromGLKMatrix2.default;
	exports.SCNMatrix4FromMat4 = _SCNMatrix4FromMat2.default;
	exports.SCNMatrix4Invert = _SCNMatrix4Invert2.default;
	exports.SCNMatrix4IsIdentity = _SCNMatrix4IsIdentity2.default;
	exports.SCNMatrix4MakeRotation = _SCNMatrix4MakeRotation2.default;
	exports.SCNMatrix4MakeScale = _SCNMatrix4MakeScale2.default;
	exports.SCNMatrix4MakeTranslation = _SCNMatrix4MakeTranslation2.default;
	exports.SCNMatrix4Mult = _SCNMatrix4Mult2.default;
	exports.SCNMatrix4Rotate = _SCNMatrix4Rotate2.default;
	exports.SCNMatrix4Scale = _SCNMatrix4Scale2.default;
	exports.SCNMatrix4ToGLKMatrix4 = _SCNMatrix4ToGLKMatrix2.default;
	exports.SCNMatrix4ToMat4 = _SCNMatrix4ToMat2.default;
	exports.SCNMatrix4Translate = _SCNMatrix4Translate2.default;
	exports.SCNMorpher = _SCNMorpher2.default;
	exports.SCNMorpherCalculationMode = _SCNMorpherCalculationMode2.default;
	exports.SCNMovabilityHint = _SCNMovabilityHint2.default;
	exports.SCNNode = _SCNNode2.default;
	exports.SCNNodeRendererDelegate = _SCNNodeRendererDelegate2.default;
	exports.SCNParticleBirthDirection = _SCNParticleBirthDirection2.default;
	exports.SCNParticleBirthLocation = _SCNParticleBirthLocation2.default;
	exports.SCNParticleBlendMode = _SCNParticleBlendMode2.default;
	exports.SCNParticleEvent = _SCNParticleEvent2.default;
	exports.SCNParticleEventBlock = _SCNParticleEventBlock2.default;
	exports.SCNParticleImageSequenceAnimationMode = _SCNParticleImageSequenceAnimationMode2.default;
	exports.SCNParticleInputMode = _SCNParticleInputMode2.default;
	exports.SCNParticleModifierBlock = _SCNParticleModifierBlock2.default;
	exports.SCNParticleModifierStage = _SCNParticleModifierStage2.default;
	exports.SCNParticleOrientationMode = _SCNParticleOrientationMode2.default;
	exports.SCNParticlePropertyController = _SCNParticlePropertyController2.default;
	exports.SCNParticleSortingMode = _SCNParticleSortingMode2.default;
	exports.SCNParticleSystem = _SCNParticleSystem2.default;
	exports.SCNPhysicsBallSocketJoint = _SCNPhysicsBallSocketJoint2.default;
	exports.SCNPhysicsBehavior = _SCNPhysicsBehavior2.default;
	exports.SCNPhysicsBody = _SCNPhysicsBody2.default;
	exports.SCNPhysicsBodyType = _SCNPhysicsBodyType2.default;
	exports.SCNPhysicsCollisionCategory = _SCNPhysicsCollisionCategory2.default;
	exports.SCNPhysicsContact = _SCNPhysicsContact2.default;
	exports.SCNPhysicsContactDelegate = _SCNPhysicsContactDelegate2.default;
	exports.SCNPhysicsField = _SCNPhysicsField2.default;
	exports.SCNPhysicsFieldScope = _SCNPhysicsFieldScope2.default;
	exports.SCNPhysicsHingeJoint = _SCNPhysicsHingeJoint2.default;
	exports.SCNPhysicsShape = _SCNPhysicsShape2.default;
	exports.SCNPhysicsSliderJoint = _SCNPhysicsSliderJoint2.default;
	exports.SCNPhysicsVehicle = _SCNPhysicsVehicle2.default;
	exports.SCNPhysicsVehicleWheel = _SCNPhysicsVehicleWheel2.default;
	exports.SCNPhysicsWorld = _SCNPhysicsWorld2.default;
	exports.SCNPlane = _SCNPlane2.default;
	exports.SCNProgram = _SCNProgram2.default;
	exports.SCNProgramDelegate = _SCNProgramDelegate2.default;
	exports.SCNPyramid = _SCNPyramid2.default;
	exports.SCNQuaternion = _SCNQuaternion2.default;
	exports.SCNReferenceLoadingPolicy = _SCNReferenceLoadingPolicy2.default;
	exports.SCNReferenceNode = _SCNReferenceNode2.default;
	exports.SCNRenderer = _SCNRenderer2.default;
	exports.SCNRenderingAPI = _SCNRenderingAPI2.default;
	exports.SCNScene = _SCNScene2.default;
	exports.SCNSceneExportDelegate = _SCNSceneExportDelegate2.default;
	exports.SCNSceneExportProgressHandler = _SCNSceneExportProgressHandler2.default;
	exports.SCNSceneRenderer = _SCNSceneRenderer2.default;
	exports.SCNSceneRendererDelegate = _SCNSceneRendererDelegate2.default;
	exports.SCNSceneSource = _SCNSceneSource2.default;
	exports.SCNSceneSourceStatus = _SCNSceneSourceStatus2.default;
	exports.SCNSceneSourceStatusHandler = _SCNSceneSourceStatusHandler2.default;
	exports.SCNShadable = _SCNShadable2.default;
	exports.SCNShaderModifierEntryPoint = _SCNShaderModifierEntryPoint2.default;
	exports.SCNShadowMode = _SCNShadowMode2.default;
	exports.SCNShape = _SCNShape2.default;
	exports.SCNSkinner = _SCNSkinner2.default;
	exports.SCNSphere = _SCNSphere2.default;
	exports.SCNTechnique = _SCNTechnique2.default;
	exports.SCNTechniqueSupport = _SCNTechniqueSupport2.default;
	exports.SCNText = _SCNText2.default;
	exports.SCNTorus = _SCNTorus2.default;
	exports.SCNTransaction = _SCNTransaction2.default;
	exports.SCNTransformConstraint = _SCNTransformConstraint2.default;
	exports.SCNTransparencyMode = _SCNTransparencyMode2.default;
	exports.SCNTube = _SCNTube2.default;
	exports.SCNVector3 = _SCNVector2.default;
	exports.SCNVector3EqualToVector3 = _SCNVector3EqualToVector2.default;
	exports.SCNVector3FromFloat3 = _SCNVector3FromFloat2.default;
	exports.SCNVector3FromGLKVector3 = _SCNVector3FromGLKVector2.default;
	exports.SCNVector3Make = _SCNVector3Make2.default;
	exports.SCNVector3ToFloat3 = _SCNVector3ToFloat2.default;
	exports.SCNVector3ToGLKVector3 = _SCNVector3ToGLKVector2.default;
	exports.SCNVector4 = _SCNVector4.default;
	exports.SCNVector4EqualToVector4 = _SCNVector4EqualToVector2.default;
	exports.SCNVector4FromFloat4 = _SCNVector4FromFloat2.default;
	exports.SCNVector4FromGLKVector4 = _SCNVector4FromGLKVector2.default;
	exports.SCNVector4Make = _SCNVector4Make2.default;
	exports.SCNVector4ToFloat4 = _SCNVector4ToFloat2.default;
	exports.SCNVector4ToGLKVector4 = _SCNVector4ToGLKVector2.default;
	exports.SCNView = _SCNView2.default;
	exports.SCNWrapMode = _SCNWrapMode2.default;
	exports.SKColor = _SKColor2.default;

	// constants
	/*global exports*/

	// 
	exports.kCAFillModeRemoved = 'removed';
	exports.kCAFillModeForwards = 'forwards';
	exports.kCAFillModeBackwards = 'backwards';
	exports.kCAFillModeBoth = 'both';

	// 
	exports.kCAMediaTimingFunctionLinear = 'linear';
	exports.kCAMediaTimingFunctionEaseIn = 'easeIn';
	exports.kCAMediaTimingFunctionEaseOut = 'easeOut';
	exports.kCAMediaTimingFunctionEaseInEaseOut = 'easeInEaseOut';
	exports.kCAMediaTimingFunctionDefault = 'default';

	// Value calculation modes
	exports.kCAAnimationLinear = 'linear';
	exports.kCAAnimationDiscrete = 'discrete';
	exports.kCAAnimationPaced = 'paced';
	exports.kCAAnimationCubic = 'cubic';
	exports.kCAAnimationCubicPaced = 'cubicPaced';

	// Rotation Mode Values
	exports.kCAAnimationRotateAuto = 'auto';
	exports.kCAAnimationRotateAutoReverse = 'autoReverse';

/***/ },
/* 1 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * Compositing operations for images.
	 * @typedef {Object} CGBlendMode
	 * @property {Symbol} normal - Paints the source image samples over the background image samples.
	 * @property {Symbol} multiply - Multiplies the source image samples with the background image samples. This results in colors that are at least as dark as either of the two contributing sample colors.
	 * @property {Symbol} screen - Multiplies  the inverse of the source image samples with the inverse of the background image samples. This results in colors that are at least as light as either of the two contributing sample colors.
	 * @property {Symbol} overlay - 
	 * @property {Symbol} darken - 
	 * @property {Symbol} lighten - 
	 * @property {Symbol} colorDodge - Brightens the background image samples to reflect the source image samples. Source image sample values that specify black do not produce a change.
	 * @property {Symbol} colorBurn - Darkens the background image samples to reflect the source image samples. Source image sample values that specify white do not produce a change.
	 * @property {Symbol} softLight - 
	 * @property {Symbol} hardLight - 
	 * @property {Symbol} difference - 
	 * @property {Symbol} exclusion - Produces an effect similar to that produced by difference, but with lower contrast. Source image sample values that are black don’t produce a change; white inverts the background color values.
	 * @property {Symbol} hue - Uses the luminance and saturation values of the background with the hue of the source image.
	 * @property {Symbol} saturation - Uses the luminance and hue values of the background with the saturation of the source image. Areas of the background that have no saturation (that is, pure gray areas) don’t produce a change.
	 * @property {Symbol} color - Uses the luminance values of the background with the hue and saturation values of the source image. This mode preserves the gray levels in the image. You can use this mode to color monochrome images or to tint color images.
	 * @property {Symbol} luminosity - Uses the hue and saturation of the background with the luminance of the source image. This mode creates an effect that is inverse to the effect created by color.
	 * @property {Symbol} clear - R = 0
	 * @property {Symbol} copy - R = S
	 * @property {Symbol} sourceIn - R = S*Da
	 * @property {Symbol} sourceOut - R = S*(1 - Da)
	 * @property {Symbol} sourceAtop - R = S*Da + D*(1 - Sa)
	 * @property {Symbol} destinationOver - R = S*(1 - Da) + D
	 * @property {Symbol} destinationIn - R = D*Sa
	 * @property {Symbol} destinationOut - R = D*(1 - Sa)
	 * @property {Symbol} destinationAtop - R = S*(1 - Da) + D*Sa
	 * @property {Symbol} xor - R = S*(1 - Da) + D*(1 - Sa). This XOR mode is only nominally related to the classical bitmap XOR operation, which is not supported by Core Graphics
	 * @property {Symbol} plusDarker - R = MAX(0, 1 - ((1 - D) + (1 - S)))
	 * @property {Symbol} plusLighter - R = MIN(1, S + D)
	 * @see https://developer.apple.com/reference/coregraphics/cgblendmode
	 */

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var CGBlendMode = {
	  normal: Symbol(),
	  multiply: Symbol(),
	  screen: Symbol(),
	  overlay: Symbol(),
	  darken: Symbol(),
	  lighten: Symbol(),
	  colorDodge: Symbol(),
	  colorBurn: Symbol(),
	  softLight: Symbol(),
	  hardLight: Symbol(),
	  difference: Symbol(),
	  exclusion: Symbol(),
	  hue: Symbol(),
	  saturation: Symbol(),
	  color: Symbol(),
	  luminosity: Symbol(),
	  clear: Symbol(),
	  copy: Symbol(),
	  sourceIn: Symbol(),
	  sourceOut: Symbol(),
	  sourceAtop: Symbol(),
	  destinationOver: Symbol(),
	  destinationIn: Symbol(),
	  destinationOut: Symbol(),
	  destinationAtop: Symbol(),
	  xor: Symbol(),
	  plusDarker: Symbol(),
	  plusLighter: Symbol()
	};

	exports.default = CGBlendMode;

/***/ },
/* 2 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * Styles for rendering the endpoint of a stroked line.
	 * @typedef {Object} CGLineCap
	 * @property {Symbol} butt - A line with a squared-off end. Core Graphics draws the line to extend only to the exact endpoint of the path. This is the default.
	 * @property {Symbol} round - A line with a rounded end. Core Graphics draws the line to extend beyond the endpoint of the path. The line ends with a semicircular arc with a radius of 1/2 the line’s width, centered on the endpoint.
	 * @property {Symbol} square - A line with a squared-off end. Core Graphics extends the line beyond the endpoint of the path for a distance equal to half the line width.
	 * @see https://developer.apple.com/reference/coregraphics/cglinecap
	 */

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var CGLineCap = {
	  butt: Symbol(),
	  round: Symbol(),
	  square: Symbol()
	};

	exports.default = CGLineCap;

/***/ },
/* 3 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * Junction types for stroked lines.
	 * @typedef {Object} CGLineJoin
	 * @property {Symbol} miter - 
	 * @property {Symbol} round - A join with a rounded end. Core Graphics draws the line to extend beyond the endpoint of the path. The line ends with a semicircular arc with a radius of 1/2 the line’s width, centered on the endpoint.
	 * @property {Symbol} bevel - A join with a squared-off end. Core Graphics draws the line to extend beyond the endpoint of the path, for a distance of 1/2 the line’s width.
	 * @see https://developer.apple.com/reference/coregraphics/cglinejoin
	 */

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var CGLineJoin = {
	  miter: Symbol(),
	  round: Symbol(),
	  bevel: Symbol()
	};

	exports.default = CGLineJoin;

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _CGPoint = __webpack_require__(5);

	var _CGPoint2 = _interopRequireDefault(_CGPoint);

	var _CGRect = __webpack_require__(6);

	var _CGRect2 = _interopRequireDefault(_CGRect);

	var _CGPath = __webpack_require__(8);

	var _CGPath2 = _interopRequireDefault(_CGPath);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	/**
	 * A mutable graphics path: a mathematical description of shapes or lines to be drawn in a graphics context.
	 * @access public
	 * @see https://developer.apple.com/reference/coregraphics/cgmutablepath
	 */
	var CGMutablePath = function () {
	  function CGMutablePath() {
	    _classCallCheck(this, CGMutablePath);
	  }

	  _createClass(CGMutablePath, [{
	    key: 'init',


	    // Creating Graphics Paths

	    /**
	     * Creates a mutable graphics path.
	     * @access public
	     * @returns {void}
	     * @see https://developer.apple.com/reference/coregraphics/cgmutablepath/1411209-init
	     */
	    value: function init() {}

	    // Copying a Graphics Path

	    /**
	     * Creates a mutable copy of an existing graphics path.
	     * @access public
	     * @returns {?CGMutablePath} - 
	     * @desc You can modify a mutable graphics path by calling the various path geometry functions, such as addArc(_:x:y:radius:startAngle:endAngle:clockwise:), addLineTo(_:x:y:), and moveTo(_:x:y:).
	     * @see https://developer.apple.com/reference/coregraphics/cgpath/1411196-mutablecopy
	     */

	  }, {
	    key: 'mutableCopy',
	    value: function mutableCopy() {
	      return null;
	    }

	    /**
	     * Creates a mutable copy of a graphics path transformed by a transformation matrix.
	     * @access public
	     * @param {?UnsafePointer<CGAffineTransform>} transform - A pointer to an affine transformation matrix, or NULL if no transformation is needed. If specified, Core Graphics applies the transformation to all elements of the new path.
	     * @returns {?CGMutablePath} - 
	     * @see https://developer.apple.com/reference/coregraphics/cgpath/1411150-mutablecopy
	     */

	  }, {
	    key: 'mutableCopyUsing',
	    value: function mutableCopyUsing(transform) {
	      return null;
	    }

	    // Constructing a Graphics Path

	    /**
	     * Begins a new subpath at the specified point.  
	     * @access public
	     * @param {CGPoint} point - The point, in user space coordinates, at which to start a new subpath.
	     * @param {CGAffineTransform} transform - An affine transform to apply to the point before adding to the path. Defaults to the identity transform if not specified.
	     * @returns {void}
	     * @desc The specified point becomes the start point of a new subpath. The current point is set to this start point.
	     * @see https://developer.apple.com/reference/coregraphics/cgmutablepath/2427143-move
	     */

	  }, {
	    key: 'moveTo',
	    value: function moveTo(point, transform) {}

	    /**
	     * Appends a straight line segment from the current point to the specified point. 
	     * @access public
	     * @param {CGPoint} point - The location, in user space coordinates, for the end of the new line segment.
	     * @param {CGAffineTransform} transform - An affine transform to apply to the point before adding to the path. Defaults to the identity transform if not specified.
	     * @returns {void}
	     * @desc After adding the line segment, the current point is set to the endpoint of the line segment.
	     * @see https://developer.apple.com/reference/coregraphics/cgmutablepath/2427121-addline
	     */

	  }, {
	    key: 'addLineTo',
	    value: function addLineTo(point, transform) {}

	    /**
	     * Adds a sequence of connected straight-line segments to the path. 
	     * @access public
	     * @param {CGPoint[]} points - An array of values that specify the start and end points of the line segments to draw. Each point in the array specifies a position in user space. The first point in the array specifies the initial starting point.
	     * @param {CGAffineTransform} transform - An affine transform to apply to the points before adding to the path. Defaults to the identity transform if not specified.
	     * @returns {void}
	     * @desc Calling this convenience method is equivalent to calling the move(to:transform:) method with the first value in the points array, then calling the addLine(to:transform:) method for each subsequent point until the array is exhausted. After calling this method, the path's current point is the last point in the array.
	     * @see https://developer.apple.com/reference/coregraphics/cgmutablepath/2427154-addlines
	     */

	  }, {
	    key: 'addLinesBetween',
	    value: function addLinesBetween(points, transform) {}

	    /**
	     * Adds a rectangular subpath to the path. 
	     * @access public
	     * @param {CGRect} rect - A rectangle, specified in user space coordinates.
	     * @param {CGAffineTransform} transform - An affine transform to apply to the rectangle before adding to the path. Defaults to the identity transform if not specified.
	     * @returns {void}
	     * @desc This is a convenience function that adds a rectangle to a path, starting by moving to the bottom left corner and then adding lines counter-clockwise to create a rectangle, closing the subpath.
	     * @see https://developer.apple.com/reference/coregraphics/cgmutablepath/2427119-addrect
	     */

	  }, {
	    key: 'addRect',
	    value: function addRect(rect, transform) {}

	    /**
	     * Adds a set of rectangular subpaths to the path. 
	     * @access public
	     * @param {CGRect[]} rects - An array of rectangles, specified in user space coordinates.
	     * @param {CGAffineTransform} transform - An affine transform to apply to the rectangles before adding to the path. Defaults to the identity transform if not specified.
	     * @returns {void}
	     * @desc Calling this convenience method is equivalent to repeatedly calling the addRect(_:transform:) method for each rectangle in the array.
	     * @see https://developer.apple.com/reference/coregraphics/cgmutablepath/2427131-addrects
	     */

	  }, {
	    key: 'addRects',
	    value: function addRects(rects, transform) {}

	    /**
	     * Adds an ellipse that fits inside the specified rectangle. 
	     * @access public
	     * @param {CGRect} rect - A rectangle that defines the area for the ellipse to fit in.
	     * @param {CGAffineTransform} transform - An affine transform to apply to the ellipse before adding to the path. Defaults to the identity transform if not specified.
	     * @returns {void}
	     * @desc The ellipse is approximated by a sequence of Bézier curves. Its center is the midpoint of the rectangle defined by the rect parameter. If the rectangle is square, then the ellipse is circular with a radius equal to one-half the width (or height) of the rectangle. If the rect parameter specifies a rectangular shape, then the major and minor axes of the ellipse are defined by the width and height of the rectangle.The ellipse forms a complete subpath of the path—that is, the ellipse drawing starts with a move-to operation and ends with a close-subpath operation, with all moves oriented in the clockwise direction.
	     * @see https://developer.apple.com/reference/coregraphics/cgmutablepath/2427120-addellipse
	     */

	  }, {
	    key: 'addEllipseIn',
	    value: function addEllipseIn(rect, transform) {}

	    /**
	     *  Adds a subpath to the path, in the shape of a rectangle with rounded corners.
	     * @access public
	     * @param {CGRect} rect - The rectangle to add, specified in user space coordinates.
	     * @param {number} cornerWidth - The horizontal size, in user space coordinates, for rounded corner sections.
	     * @param {number} cornerHeight - The vertical size, in user space coordinates, for rounded corner sections.
	     * @param {CGAffineTransform} transform - An affine transform to apply to the rectangle before adding to the path. Defaults to the identity transform if not specified.
	     * @returns {void}
	     * @desc This convenience method is equivalent to a move operation to start the subpath followed by a series of arc and line operations that construct the rounded rectangle. Each corner of the rounded rectangle is one-quarter of an ellipse with axes equal to the cornerWidth and cornerHeight parameters. The rounded rectangle forms a closed subpath oriented in the clockwise direction.
	     * @see https://developer.apple.com/reference/coregraphics/cgmutablepath/2427144-addroundedrect
	     */

	  }, {
	    key: 'addRoundedRectIn',
	    value: function addRoundedRectIn(rect, cornerWidth, cornerHeight, transform) {}

	    /**
	     * Adds an arc of a circle to the path, specified with a radius and angles. 
	     * @access public
	     * @param {CGPoint} center - The center of the arc, in user space coordinates.
	     * @param {number} radius - The radius of the arc, in user space coordinates.
	     * @param {number} startAngle - The angle to the starting point of the arc, measured in radians from the positive x-axis.
	     * @param {number} endAngle - The angle to the end point of the arc, measured in radians from the positive x-axis.
	     * @param {boolean} clockwise - true to make a clockwise arc; false to make a counterclockwise arc.
	     * @param {CGAffineTransform} transform - An affine transform to apply to the arc before adding to the path. Defaults to the identity transform if not specified.
	     * @returns {void}
	     * @desc This method calculates starting and ending points using the radius and angles you specify, uses a sequence of cubic Bézier curves to approximate a segment of a circle between those points, and then appends those curves to the path.The clockwise parameter determines the direction in which the arc is created; the actual direction of the final path is dependent on the transform parameter and the current transform of a context where the path is drawn. In a flipped coordinate system (the default for UIView drawing methods in iOS), specifying a clockwise arc results in a counterclockwise arc after the transformation is applied.If the path already contains a subpath, this method adds a line connecting the current point to the starting point of the arc. If the current path is empty, his method creates a new subpath whose starting point is the starting point of the arc. The ending point of the arc becomes the new current point of the path.
	     * @see https://developer.apple.com/reference/coregraphics/cgmutablepath/2427140-addarc
	     */

	  }, {
	    key: 'addArc',
	    value: function addArc(center, radius, startAngle, endAngle, clockwise, transform) {}

	    /**
	     * Adds an arc of a circle to the path, specified with a radius and a difference in angle.  
	     * @access public
	     * @param {CGPoint} center - The center of the arc, in user space coordinates.
	     * @param {number} radius - The radius of the arc, in user space coordinates.
	     * @param {number} startAngle - The angle to the starting point of the arc, measured in radians from the positive x-axis.
	     * @param {number} delta - The difference, measured in radians, between the starting angle and ending angle of the arc. A positive value creates a counter-clockwise arc (in user space coordinates), and vice versa.
	     * @param {CGAffineTransform} transform - An affine transform to apply to the arc before adding to the path. Defaults to the identity transform if not specified.
	     * @returns {void}
	     * @desc This method calculates starting and ending points using the radius and angles you specify, uses a sequence of cubic Bézier curves to approximate a segment of a circle between those points, and then appends those curves to the path.The delta parameter determines both the length of the arc the direction in which the arc is created; the actual direction of the final path is dependent on the transform parameter and the current transform of a context where the path is drawn. In a flipped coordinate system (the default for UIView drawing methods in iOS), specifying a clockwise arc results in a counterclockwise arc after the transformation is applied.If the path already contains a subpath, this method adds a line connecting the current point to the starting point of the arc. If the current path is empty, his method creates a new subpath whose starting point is the starting point of the arc. The ending point of the arc becomes the new current point of the path.
	     * @see https://developer.apple.com/reference/coregraphics/cgmutablepath/2427147-addrelativearc
	     */

	  }, {
	    key: 'addRelativeArc',
	    value: function addRelativeArc(center, radius, startAngle, delta, transform) {}

	    /**
	     * Adds a cubic Bézier curve to the path, with the specified end point and control points. 
	     * @access public
	     * @param {CGPoint} end - The point, in user space coordinates, at which to end the curve.
	     * @param {CGPoint} control1 - The first control point of the curve, in user space coordinates.
	     * @param {CGPoint} control2 - The second control point of the curve, in user space coordinates.
	     * @param {CGAffineTransform} transform - An affine transform to apply to the curve before adding to the path. Defaults to the identity transform if not specified.
	     * @returns {void}
	     * @desc This method constructs a curve starting from the path's current point and ending at the specified end point, with curvature defined by the two control points. After this method appends that curve to the current path, the end point of the curve becomes the path's current point.
	     * @see https://developer.apple.com/reference/coregraphics/cgmutablepath/2427158-addcurve
	     */

	  }, {
	    key: 'addCurveTo',
	    value: function addCurveTo(end, control1, control2, transform) {}

	    /**
	     * Adds a quadratic Bézier curve to the path, with the specified end point and control point. 
	     * @access public
	     * @param {CGPoint} end - The point, in user space coordinates, at which to end the curve.
	     * @param {CGPoint} control - The control point of the curve, in user space coordinates.
	     * @param {CGAffineTransform} transform - An affine transform to apply to the curve before adding to the path. Defaults to the identity transform if not specified.
	     * @returns {void}
	     * @desc This method constructs a curve starting from the path's current point and ending at the specified end point, with curvature defined by the control point. After this method appends that curve to the current path, the end point of the curve becomes the path's current point.
	     * @see https://developer.apple.com/reference/coregraphics/cgmutablepath/2427128-addquadcurve
	     */

	  }, {
	    key: 'addQuadCurveTo',
	    value: function addQuadCurveTo(end, control, transform) {}

	    /**
	     * Appends another path object to the path. 
	     * @access public
	     * @param {CGPath} path - The path to add.
	     * @param {CGAffineTransform} transform - An affine transform to apply to the path parameter before adding to this path. Defaults to the identity transform if not specified.
	     * @returns {void}
	     * @desc If the path parameter is a non-empty empty path, its path elements are appended in order to this path. Afterward, the start point and current point of this path are those of the last subpath in the path parameter.
	     * @see https://developer.apple.com/reference/coregraphics/cgmutablepath/2427150-addpath
	     */

	  }, {
	    key: 'addPath',
	    value: function addPath(path, transform) {}

	    /**
	     * Closes and completes a subpath in a mutable graphics path.
	     * @access public
	     * @returns {void}
	     * @desc Appends a line from the current point to the starting point of the current subpath and ends the subpath. After closing the subpath, your application can begin a new subpath without first calling moveTo(_:x:y:). In this case, a new subpath is implicitly created with a starting and current point equal to the previous subpath’s starting point.
	     * @see https://developer.apple.com/reference/coregraphics/cgmutablepath/1411188-closesubpath
	     */

	  }, {
	    key: 'closeSubpath',
	    value: function closeSubpath() {}
	  }]);

	  return CGMutablePath;
	}();

	exports.default = CGMutablePath;

/***/ },
/* 5 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * A structure that contains a point in a two-dimensional coordinate system.
	 * @access public
	 * @see https://developer.apple.com/reference/coregraphics/cgpoint
	 */

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var CGPoint = function () {
	  // Creating Point Values

	  /**
	   * Creates a point with coordinates specified as integer values.   
	   * @access public
	   * @constructor
	   * @param {number} x - 
	   * @param {number} y - 
	   * @see https://developer.apple.com/reference/coregraphics/cgpoint/1455965-init
	   */
	  function CGPoint(x, y) {
	    _classCallCheck(this, CGPoint);

	    // Geometric Properties
	    this.x = x;
	    this.y = y;
	  }

	  // Special Values

	  /**
	   * The point with location (0,0).
	   * @type {CGPoint}
	   * @desc 
	   * @see https://developer.apple.com/reference/coregraphics/cgpoint/1454433-zero
	   */


	  _createClass(CGPoint, [{
	    key: 'applying',


	    // Geometric Properties

	    // Transforming Points

	    /**
	     * Returns the point resulting from an affine transformation of an existing point.
	     * @access public
	     * @param {CGAffineTransform} t - The affine transform to apply. 
	     * @returns {CGPoint} - 
	     * @see https://developer.apple.com/reference/coregraphics/cgpoint/1454251-applying
	     */
	    value: function applying(t) {
	      return null;
	    }

	    // Alternate Representations

	    /**
	     * Creates a point from a canonical dictionary representation.
	     * @access public
	     * @param {Map} dict - A dictionary containing x and y values for the point to create, in the format used by the dictionaryRepresentation property.
	     * @returns {void}
	     * @see https://developer.apple.com/reference/coregraphics/cgpoint/2427118-init
	     */

	  }, {
	    key: 'equalTo',


	    // Comparing Points

	    /**
	     * Returns whether two points are equal. 
	     * @access public
	     * @param {CGPoint} point2 - 
	     * @returns {boolean} - 
	     * @see https://developer.apple.com/reference/coregraphics/cgpoint/1456179-equalto
	     */
	    value: function equalTo(point2) {
	      var epsilon = 0.00001;
	      return Math.abs(this.x - point2.x) < epsilon && Math.abs(this.y - point2.y) < epsilon;
	    }
	  }, {
	    key: 'copy',
	    value: function copy() {
	      return new CGPoint(this.x, this.y);
	    }
	  }, {
	    key: 'dictionaryRepresentation',


	    /**
	     * Returns a dictionary representation of the specified point.
	     * @type {Map}
	     * @desc 
	     * @see https://developer.apple.com/reference/coregraphics/cgpoint/1455382-dictionaryrepresentation
	     */
	    get: function get() {
	      var map = new Map();
	      map.set('x', this.x);
	      map.set('y', this.y);
	      return map;
	    }

	    /**
	     * A textual representation of the point's coordinate values. 
	     * @type {string}
	     * @desc 
	     * @see https://developer.apple.com/reference/coregraphics/cgpoint/1645825-debugdescription
	     */

	  }, {
	    key: 'debugDescription',
	    get: function get() {
	      return '{x: ' + this.x + ', y: ' + this.y + '}';
	    }

	    /**
	     * A representation of the point's structure and display style for use in debugging.
	     * @type {Mirror}
	     * @desc Mirrors are used by playgrounds and the debugger.
	     * @see https://developer.apple.com/reference/coregraphics/cgpoint/1645834-custommirror
	     */

	  }, {
	    key: 'customMirror',
	    get: function get() {
	      return null;
	    }

	    /**
	     * A representation of the point for use in Playgrounds.
	     * @type {PlaygroundQuickLook}
	     * @desc 
	     * @see https://developer.apple.com/reference/coregraphics/cgpoint/1645835-customplaygroundquicklook
	     */

	  }, {
	    key: 'customPlaygroundQuickLook',
	    get: function get() {
	      return null;
	    }
	  }], [{
	    key: 'pointWithDictionaryRepresentation',
	    value: function pointWithDictionaryRepresentation(dict) {
	      return new CGPoint(dict.get('x'), dict.get('y'));
	    }
	  }, {
	    key: 'zero',
	    get: function get() {
	      return new CGPoint(0, 0);
	    }
	  }]);

	  return CGPoint;
	}();

	exports.default = CGPoint;

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _CGPoint = __webpack_require__(5);

	var _CGPoint2 = _interopRequireDefault(_CGPoint);

	var _CGSize = __webpack_require__(7);

	var _CGSize2 = _interopRequireDefault(_CGSize);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	/**
	 * A structure that contains the location and dimensions of a rectangle.
	 * @access public
	 * @see https://developer.apple.com/reference/coregraphics/cgrect
	 */
	var CGRect = function () {
	  // Creating Rectangle Values

	  /**
	   * Creates a rectangle with the specified origin and size.
	   * @access public
	   * @constructor
	   * @param {CGPoint} origin - 
	   * @param {CGSize} size - 
	   * @see https://developer.apple.com/reference/coregraphics/cgrect/1454856-init
	   */
	  function CGRect(origin, size) {
	    _classCallCheck(this, CGRect);

	    // Basic Geometric Properties
	    this.origin = origin.copy();
	    this.size = size.copy();

	    // Calculated Geometric Properties
	    /*
	    this._height = size.height
	    this._width = size.width
	    this._minX = 0
	    this._midX = 0
	    this._maxX = 0
	    this._minY = 0
	    this._midY = 0
	    this._maxY = 0
	     // Creating Derived Rectangles
	     this._standardized = null
	    this._integral = null
	     // Checking Characteristics
	     this._isEmpty = false
	    this._isInfinite = false
	    this._isNull = false
	     // Alternate Representations
	     this._dictionaryRepresentation = null
	    this._debugDescription = ''
	    this._customMirror = null
	    this._customPlaygroundQuickLook = null
	    */
	  }

	  // Special Values

	  /**
	   * The rectangle whose origin and size are both zero.
	   * @type {CGRect}
	   * @desc The zero rectangle is equivalent to one created by calling CGRect(x: 0, y: 0, width: 0, height: 0).
	   * @see https://developer.apple.com/reference/coregraphics/cgrect/1455437-zero
	   */


	  _createClass(CGRect, [{
	    key: 'applying',


	    // Creating Derived Rectangles

	    /**
	     * Applies an affine transform to a rectangle.
	     * @access public
	     * @param {CGAffineTransform} t - The affine transform to apply to the rect parameter.
	     * @returns {CGRect} - 
	     * @desc Because affine transforms do not preserve rectangles in general, this function returns the smallest rectangle that contains the transformed corner points of the rect parameter. If the affine transform t consists solely of scaling and translation operations, then the returned rectangle coincides with the rectangle constructed from the four transformed corners.
	     * @see https://developer.apple.com/reference/coregraphics/cgrect/1455875-applying
	     */
	    value: function applying(t) {
	      return null;
	    }

	    /**
	     * Returns a rectangle that is smaller or larger than the source rectangle, with the same center point.
	     * @access public
	     * @param {number} dx - The x-coordinate value to use for adjusting the source rectangle. To create an inset rectangle, specify a positive value. To create a larger, encompassing rectangle, specify a negative value.
	     * @param {number} dy - The y-coordinate value to use for adjusting the source rectangle. To create an inset rectangle, specify a positive value. To create a larger, encompassing rectangle, specify a negative value.
	     * @returns {CGRect} - 
	     * @desc The rectangle is standardized and then the inset parameters are applied. If the resulting rectangle would have a negative height or width, a null rectangle is returned.
	     * @see https://developer.apple.com/reference/coregraphics/cgrect/1454218-insetby
	     */

	  }, {
	    key: 'insetBy',
	    value: function insetBy(dx, dy) {
	      var newX = this.minX + dx;
	      var newY = this.minY + dy;
	      var newWidth = this.size.width - dx * 2;
	      var newHeight = this.size.height - dy * 2;
	      return new CGRect(new _CGPoint2.default(newX, newY), new _CGSize2.default(newWidth, newHeight));
	    }

	    /**
	     * Returns a rectangle with an origin that is offset from that of the source rectangle.
	     * @access public
	     * @param {number} dx - The offset value for the x-coordinate.
	     * @param {number} dy - The offset value for the  y-coordinate.
	     * @returns {CGRect} - 
	     * @see https://developer.apple.com/reference/coregraphics/cgrect/1454841-offsetby
	     */

	  }, {
	    key: 'offsetBy',
	    value: function offsetBy(dx, dy) {
	      return new CGRect(new _CGPoint2.default(this.origin.x + dx, this.origin.y + dy), this.size);
	    }

	    /**
	     * Returns the smallest rectangle that contains the two source rectangles.
	     * @access public
	     * @param {CGRect} r2 - Another rectangle to be combined with this rectangle.
	     * @returns {CGRect} - 
	     * @desc Both rectangles are standardized prior to calculating the union. If either of the rectangles is a null rectangle, a copy of the other rectangle is returned (resulting in a null rectangle if both rectangles are null). Otherwise a rectangle that completely contains the source rectangles is returned.
	     * @see https://developer.apple.com/reference/coregraphics/cgrect/1455837-union
	     */

	  }, {
	    key: 'union',
	    value: function union(r2) {
	      return null;
	    }

	    /**
	     * Returns the intersection of two rectangles.
	     * @access public
	     * @param {CGRect} r2 - Another rectangle to intersect with this rectangle.
	     * @returns {CGRect} - 
	     * @desc Both rectangles are standardized prior to calculating the intersection.
	     * @see https://developer.apple.com/reference/coregraphics/cgrect/1455346-intersection
	     */

	  }, {
	    key: 'intersection',
	    value: function intersection(r2) {
	      return null;
	    }

	    /**
	     * Creates two rectangles by dividing the original rectangle. 
	     * @access public
	     * @param {number} atDistance - A distance from the rectangle side specified in the fromEdge parameter, defining the line along which to divide the rectangle.
	     * @param {CGRectEdge} fromEdge - The side of the rectangle from which to measure the atDistance parameter, defining the line along which to divide the rectangle.
	     * @returns {{slice: CGRect, remainder: CGRect}} - 
	     * @desc Together the fromEdge and atDistance parameters define a line (parallel to the specified edge of the rectangle and at the specified distance from that edge) that divides the rectangle into two component rectangles.
	     * @see https://developer.apple.com/reference/coregraphics/cgrect/2299988-divided
	     */

	  }, {
	    key: 'dividedFrom',
	    value: function dividedFrom(atDistance, fromEdge) {
	      return null;
	    }
	    /**
	     * Returns a rectangle with a positive width and height.
	     * @type {CGRect}
	     * @desc 
	     * @see https://developer.apple.com/reference/coregraphics/cgrect/1456432-standardized
	     */

	  }, {
	    key: 'intersects',


	    // Checking Characteristics

	    /**
	     * Returns whether two rectangles intersect.
	     * @access public
	     * @param {CGRect} rect2 - The rectangle to test for intersection with this rectangle.
	     * @returns {boolean} - 
	     * @see https://developer.apple.com/reference/coregraphics/cgrect/1454747-intersects
	     */
	    value: function intersects(rect2) {
	      return false;
	    }

	    /**
	     * Returns whether a rectangle contains a specified point.
	     * @access public
	     * @param {CGPoint} point - The point to examine. 
	     * @returns {boolean} - 
	     * @desc A point is considered inside the rectangle if its coordinates lie inside the rectangle or on the minimum X or minimum Y edge.
	     * @see https://developer.apple.com/reference/coregraphics/cgrect/1456316-contains
	     */

	  }, {
	    key: 'contains',
	    value: function contains(point) {
	      return point.x >= this.minX && point.x <= this.maxX && point.y >= this.minY && point.y <= this.maxY;
	    }

	    /**
	     * Returns whether a rectangle has zero width or height, or is a null rectangle.
	     * @type {boolean}
	     * @desc An empty rectangle is either a null rectangle or a valid rectangle with zero height or width.
	     * @see https://developer.apple.com/reference/coregraphics/cgrect/1454917-isempty
	     */

	  }, {
	    key: 'initDictionaryRepresentation',


	    // Alternate Representations

	    /**
	     * Creates a rectangle from a canonical dictionary representation. 
	     * @access public
	     * @param {Map} dict - A dictionary containing x, y, width, and height values for the rectangle to create, in the format used by the dictionaryRepresentation property.
	     * @returns {void}
	     * @see https://developer.apple.com/reference/coregraphics/cgrect/2427139-init
	     */
	    value: function initDictionaryRepresentation(dict) {
	      // Basic Geometric Properties
	      this.origin = dict.get('origin');
	      this.size = dict.get('size');
	    }

	    /**
	     * Returns a dictionary representation of the provided rectangle.
	     * @type {Map}
	     * @desc 
	     * @see https://developer.apple.com/reference/coregraphics/cgrect/1455760-dictionaryrepresentation
	     */

	  }, {
	    key: 'equalTo',


	    // Comparing Rectangles

	    /**
	     * Returns whether two rectangles are equal in size and position.
	     * @access public
	     * @param {CGRect} rect2 - The rectangle to compare this rectangle with.
	     * @returns {boolean} - 
	     * @see https://developer.apple.com/reference/coregraphics/cgrect/1456516-equalto
	     */
	    value: function equalTo(rect2) {
	      if (this.origin === null || rect2.origin === null) {
	        return false;
	      }
	      if (this.size === null || rect2.size === null) {
	        return false;
	      }

	      return this.origin.equalTo(rect2.origin) && this.size.equalTo(rect2.size);
	    }
	  }, {
	    key: 'copy',
	    value: function copy() {
	      return new CGRect(this.origin, this.size);
	    }

	    /**
	     * @access public
	     * @param {number} x -
	     * @param {number} y -
	     * @param {number} width -
	     * @param {number} height -
	     * @returns {CGRect} -
	     */

	  }, {
	    key: 'height',


	    // Basic Geometric Properties

	    // Calculated Geometric Properties
	    /**
	     * Returns the height of a rectangle.
	     * @type {number}
	     * @desc Regardless of whether the height is stored in the CGRect data structure as a positive or negative number, this function returns the height as if the rectangle were standardized. That is, the result is never a negative number.
	     * @see https://developer.apple.com/reference/coregraphics/cgrect/1455645-height
	     */
	    get: function get() {
	      return this.size.height;
	    }
	    /**
	     * Returns the width of a rectangle.
	     * @type {number}
	     * @desc Regardless of whether the width is stored in the CGRect data structure as a positive or negative number, this function returns the width as if the rectangle were standardized.  That is, the result is never a negative number.
	     * @see https://developer.apple.com/reference/coregraphics/cgrect/1454758-width
	     */

	  }, {
	    key: 'width',
	    get: function get() {
	      return this.size.width;
	    }

	    /**
	     * Returns the smallest value for the x-coordinate of the rectangle.
	     * @type {number}
	     * @desc 
	     * @see https://developer.apple.com/reference/coregraphics/cgrect/1455948-minx
	     */

	  }, {
	    key: 'minX',
	    get: function get() {
	      if (this.size.width < 0) {
	        return this.origin.x + this.size.width;
	      }
	      return this.origin.x;
	    }

	    /**
	     * Returns the x- coordinate that establishes the center of a rectangle.
	     * @type {number}
	     * @desc 
	     * @see https://developer.apple.com/reference/coregraphics/cgrect/1456175-midx
	     */

	  }, {
	    key: 'midX',
	    get: function get() {
	      return this.origin.x + this.size.width * 0.5;
	    }

	    /**
	     * Returns the largest value of the x-coordinate for the rectangle.
	     * @type {number}
	     * @desc 
	     * @see https://developer.apple.com/reference/coregraphics/cgrect/1454334-maxx
	     */

	  }, {
	    key: 'maxX',
	    get: function get() {
	      if (this.size.width > 0) {
	        return this.origin.x + this.size.width;
	      }
	      return this.origin.x;
	    }

	    /**
	     * Returns the smallest value for the y-coordinate of the rectangle.
	     * @type {number}
	     * @desc 
	     * @see https://developer.apple.com/reference/coregraphics/cgrect/1454832-miny
	     */

	  }, {
	    key: 'minY',
	    get: function get() {
	      if (this.size.height < 0) {
	        return this.origin.y + this.size.height;
	      }
	      return this.origin.y;
	    }

	    /**
	     * Returns the y-coordinate that establishes the center of the rectangle.
	     * @type {number}
	     * @desc 
	     * @see https://developer.apple.com/reference/coregraphics/cgrect/1456550-midy
	     */

	  }, {
	    key: 'midY',
	    get: function get() {
	      return this.origin.y + this.size.height * 0.5;
	    }

	    /**
	     * Returns the largest value for the y-coordinate of the rectangle.
	     * @type {number}
	     * @desc 
	     * @see https://developer.apple.com/reference/coregraphics/cgrect/1454060-maxy
	     */

	  }, {
	    key: 'maxY',
	    get: function get() {
	      if (this.size.height > 0) {
	        return this.origin.y + this.size.height;
	      }
	      return this.origin.y;
	    }
	  }, {
	    key: 'standardized',
	    get: function get() {
	      return this._standardized;
	    }
	    /**
	     * Returns the smallest rectangle that results from converting the source rectangle values to integers.
	     * @type {CGRect}
	     * @desc 
	     * @see https://developer.apple.com/reference/coregraphics/cgrect/1456348-integral
	     */

	  }, {
	    key: 'integral',
	    get: function get() {
	      return this._integral;
	    }
	  }, {
	    key: 'isEmpty',
	    get: function get() {
	      return this.isNull || this.size.height === 0 || this.size.width === 0;
	    }

	    /**
	     * Returns whether a rectangle is infinite.
	     * @type {boolean}
	     * @desc An infinite rectangle is one that has no defined bounds. Infinite rectangles can be created as output from a tiling filter. For example, the Core Image framework perspective tile filter creates an image whose extent is described by an infinite rectangle.
	     * @see https://developer.apple.com/reference/coregraphics/cgrect/1455008-isinfinite
	     */

	  }, {
	    key: 'isInfinite',
	    get: function get() {
	      return this.size.width === Infinity && this.size.height === Infinity;
	    }

	    /**
	     * Returns whether the rectangle is equal to the null rectangle.
	     * @type {boolean}
	     * @desc A null rectangle is the equivalent of an empty set. For example, the result of intersecting two disjoint rectangles is a null rectangle. A null rectangle cannot be drawn and interacts with other rectangles in special ways.
	     * @see https://developer.apple.com/reference/coregraphics/cgrect/1455471-isnull
	     */

	  }, {
	    key: 'isNull',
	    get: function get() {
	      return this.size === null;
	    }
	  }, {
	    key: 'dictionaryRepresentation',
	    get: function get() {
	      var map = new Map();
	      map.set('origin', this.origin);
	      map.set('size', this.size);
	      return map;
	    }

	    /**
	     * 
	     * @type {string}
	     * @desc A textual representation of the rectangle's origin and size values. 
	     * @see https://developer.apple.com/reference/coregraphics/cgrect/1645823-debugdescription
	     */

	  }, {
	    key: 'debugDescription',
	    get: function get() {
	      if (this.size === null) {
	        return '{null}';
	      }
	      var origin = this.origin ? this.origin.debugDescription() : '{null}';
	      var size = this.size ? this.size.debugDescription() : '{null}';

	      return '{origin:' + origin + ', size:' + size + '}';
	    }

	    /**
	     * A representation of the rectangle's structure and display style for use in debugging. 
	     * @type {Mirror}
	     * @desc 
	     * @see https://developer.apple.com/reference/coregraphics/cgrect/1645833-custommirror
	     */

	  }, {
	    key: 'customMirror',
	    get: function get() {
	      return null;
	    }

	    /**
	     * A representation of the rectangle for use in Playgrounds. 
	     * @type {PlaygroundQuickLook}
	     * @desc 
	     * @see https://developer.apple.com/reference/coregraphics/cgrect/1645827-customplaygroundquicklook
	     */

	  }, {
	    key: 'customPlaygroundQuickLook',
	    get: function get() {
	      return null;
	    }
	  }], [{
	    key: 'rectWithXYWidthHeight',
	    value: function rectWithXYWidthHeight(x, y, width, height) {
	      var point = new _CGPoint2.default(x, y);
	      var size = new _CGSize2.default(width, height);
	      return new CGRect(point, size);
	    }
	  }, {
	    key: 'zero',
	    get: function get() {
	      return new CGRect(new _CGPoint2.default(0, 0), new _CGSize2.default(0, 0));
	    }
	  }]);

	  return CGRect;
	}();

	exports.default = CGRect;

/***/ },
/* 7 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * A structure that contains width and height values.
	 * @access public
	 * @see https://developer.apple.com/reference/coregraphics/cgsize
	 */

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var CGSize = function () {

	  // Initializers

	  /**
	   * Creates a size with dimensions specified as floating-point values.    
	   * @access public
	   * @constructor
	   * @param {number} width - 
	   * @param {number} height - 
	   * @see https://developer.apple.com/reference/coregraphics/cgsize/1454915-init
	   */
	  function CGSize(width, height) {
	    _classCallCheck(this, CGSize);

	    // Geometric Properties
	    this.width = width;
	    this.height = height;
	  }

	  // Geometric Properties

	  // Special Values
	  /**
	   * The size whose width and height are both zero.
	   * @type {CGSize}
	   * @desc 
	   * @see https://developer.apple.com/reference/coregraphics/cgsize/1455512-zero
	   */


	  _createClass(CGSize, [{
	    key: 'applying',


	    // Transforming Sizes

	    /**
	     * Returns the height and width resulting from a transformation of an existing height and width.
	     * @access public
	     * @param {CGAffineTransform} t - The affine transform to apply. 
	     * @returns {CGSize} - 
	     * @see https://developer.apple.com/reference/coregraphics/cgsize/1454806-applying
	     */
	    value: function applying(t) {
	      return null;
	    }

	    // Alternate Representations

	    /**
	     * Creates a size from a canonical dictionary representation. 
	     * @access public
	     * @param {Map} dict - A dictionary containing width and height values for the size to create, in the format used by the dictionaryRepresentation property.
	     * @returns {void}
	     * @see https://developer.apple.com/reference/coregraphics/cgsize/2427155-init
	     */

	  }, {
	    key: 'equalTo',


	    // Comparing Sizes

	    /**
	     * Returns whether two sizes are equal. 
	     * @access public
	     * @param {CGSize} size2 - 
	     * @returns {boolean} - 
	     * @see https://developer.apple.com/reference/coregraphics/cgsize/1455176-equalto
	     */
	    value: function equalTo(size2) {
	      var epsilon = 0.00001;
	      return Math.abs(this.width - size2.width) < epsilon && Math.abs(this.height - size2.height) < epsilon;
	    }
	  }, {
	    key: 'copy',
	    value: function copy() {
	      return new CGSize(this.width, this.height);
	    }
	  }, {
	    key: 'dictionaryRepresentation',


	    /**
	     * Returns a dictionary representation of the specified size.
	     * @type {Map}
	     * @desc 
	     * @see https://developer.apple.com/reference/coregraphics/cgsize/1455274-dictionaryrepresentation
	     */
	    get: function get() {
	      var map = new Map();
	      map.set('width', this.width);
	      map.set('height', this.height);
	      return map;
	    }

	    /**
	     * A textual representation of the size's dimensions.  
	     * @type {string}
	     * @desc 
	     * @see https://developer.apple.com/reference/coregraphics/cgsize/1645822-debugdescription
	     */

	  }, {
	    key: 'debugDescription',
	    get: function get() {
	      return '{width: ' + this.width + ', height: ' + this.height + '}';
	    }

	    /**
	     * A representation of the size's structure and display style for use in debugging. 
	     * @type {Mirror}
	     * @desc 
	     * @see https://developer.apple.com/reference/coregraphics/cgsize/1645828-custommirror
	     */

	  }, {
	    key: 'customMirror',
	    get: function get() {
	      return null;
	    }
	    /**
	     * A representation of the size for use in Playgrounds. 
	     * @type {PlaygroundQuickLook}
	     * @desc 
	     * @see https://developer.apple.com/reference/coregraphics/cgsize/1645830-customplaygroundquicklook
	     */

	  }, {
	    key: 'customPlaygroundQuickLook',
	    get: function get() {
	      return null;
	    }
	  }], [{
	    key: 'sizeWithDictionaryRepresentation',
	    value: function sizeWithDictionaryRepresentation(dict) {
	      return new CGSize(dict.get('width'), dict.get('height'));
	    }
	  }, {
	    key: 'zero',
	    get: function get() {
	      return new CGSize(0, 0);
	    }
	  }]);

	  return CGSize;
	}();

	exports.default = CGSize;

/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _CGRect = __webpack_require__(6);

	var _CGRect2 = _interopRequireDefault(_CGRect);

	var _CGLineCap = __webpack_require__(2);

	var _CGLineCap2 = _interopRequireDefault(_CGLineCap);

	var _CGLineJoin = __webpack_require__(3);

	var _CGLineJoin2 = _interopRequireDefault(_CGLineJoin);

	var _CGMutablePath = __webpack_require__(4);

	var _CGMutablePath2 = _interopRequireDefault(_CGMutablePath);

	var _CGPoint = __webpack_require__(5);

	var _CGPoint2 = _interopRequireDefault(_CGPoint);

	var _CGPathFillRule = __webpack_require__(9);

	var _CGPathFillRule2 = _interopRequireDefault(_CGPathFillRule);

	var _CGPathApplierFunction = __webpack_require__(10);

	var _CGPathApplierFunction2 = _interopRequireDefault(_CGPathApplierFunction);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var _typeID = null;

	/**
	 * An immutable graphics path: a mathematical description of shapes or lines to be drawn in a graphics context.
	 * @access public
	 * @see https://developer.apple.com/reference/coregraphics/cgpath
	 */

	var CGPath = function () {
	  function CGPath() {
	    _classCallCheck(this, CGPath);
	  }

	  _createClass(CGPath, [{
	    key: 'init',


	    // Creating Graphics Paths

	    /**
	     * Create an immutable path of a rectangle.
	     * @access public
	     * @param {CGRect} rect - The rectangle to add.
	     * @param {?UnsafePointer<CGAffineTransform>} transform - A pointer to an affine transformation matrix, or NULL if no transformation is needed. If specified, Core Graphics applies the transformation to the rectangle before it is added to the path.
	     * @returns {void}
	     * @desc This is a convenience function that creates a path of an rectangle. Using this convenience function is more efficient than creating a mutable path and adding an rectangle to it.Calling this function is equivalent to using minX and related functions to find the corners of the rectangle, then using the moveTo(_:x:y:), addLineTo(_:x:y:), and closeSubpath() functions to draw the rectangle. 
	     * @see https://developer.apple.com/reference/coregraphics/cgpath/1411155-init
	     */
	    value: function init(rect, transform) {

	      // Examining a Graphics Path

	      this._boundingBox = null;
	      this._boundingBoxOfPath = null;
	      this._currentPoint = null;
	      this._isEmpty = false;
	    }

	    /**
	     * Create an immutable path of an ellipse.
	     * @access public
	     * @param {CGRect} rect - The rectangle that bounds the ellipse.
	     * @param {?UnsafePointer<CGAffineTransform>} transform - A pointer to an affine transformation matrix, or NULL if no transformation is needed. If specified, Core Graphics applies the transformation to the ellipse before it is added to the path.
	     * @returns {void}
	     * @desc This is a convenience function that creates a path of an ellipse. Using this convenience function is more efficient than creating a mutable path and adding an ellipse to it.The ellipse is approximated by a sequence of Bézier curves. Its center is the midpoint of the rectangle defined by the rect parameter. If the rectangle is square, then the ellipse is circular with a radius equal to one-half the width (or height) of the rectangle. If the rect parameter specifies a rectangular shape, then the major and minor axes of the ellipse are defined by the width and height of the rectangle. The ellipse forms a complete subpath of the path—that is, the ellipse drawing starts with a move-to operation and ends with a close-subpath operation, with all moves oriented in the clockwise direction. If you supply an affine transform, then the constructed Bézier curves that define the ellipse are transformed before they are added to the path.
	     * @see https://developer.apple.com/reference/coregraphics/cgpath/1411177-init
	     */

	  }, {
	    key: 'initEllipseIn',
	    value: function initEllipseIn(rect, transform) {

	      // Examining a Graphics Path

	      this._boundingBox = null;
	      this._boundingBoxOfPath = null;
	      this._currentPoint = null;
	      this._isEmpty = false;
	    }

	    /**
	     * Create an immutable path of a rounded rectangle.
	     * @access public
	     * @param {CGRect} rect - The rectangle to add.
	     * @param {number} cornerWidth - The width of the rounded corner sections.
	     * @param {number} cornerHeight - The height of the rounded corner sections.
	     * @param {?UnsafePointer<CGAffineTransform>} transform - A pointer to an affine transformation matrix, or NULL if no transformation is needed. If specified, Core Graphics applies the transformation to the rectangle before it is added to the path.
	     * @returns {void}
	     * @desc This is a convenience function that creates a path of an rounded rectangle. Using this convenience function is more efficient than creating a mutable path and adding an rectangle to it.Each corner of the rounded rectangle is one-quarter of an ellipse with axes equal to the cornerWidth and cornerHeight parameters. The rounded rectangle forms a complete subpath and is oriented in the clockwise direction.
	     * @see https://developer.apple.com/reference/coregraphics/cgpath/1411218-init
	     */

	  }, {
	    key: 'initRoundedRect',
	    value: function initRoundedRect(rect, cornerWidth, cornerHeight, transform) {

	      // Examining a Graphics Path

	      this._boundingBox = null;
	      this._boundingBoxOfPath = null;
	      this._currentPoint = null;
	      this._isEmpty = false;
	    }

	    // Copying a Graphics Path

	    /**
	     * Creates an immutable copy of a graphics path.
	     * @access public
	     * @returns {?CGPath} - 
	     * @see https://developer.apple.com/reference/coregraphics/cgpath/1411211-copy
	     */

	  }, {
	    key: 'copy',
	    value: function copy() {
	      return null;
	    }

	    /**
	     * Creates an immutable copy of a graphics path transformed by a transformation matrix.
	     * @access public
	     * @param {?UnsafePointer<CGAffineTransform>} transform - A pointer to an affine transformation matrix, or NULL if no transformation is needed. If specified, Core Graphics applies the transformation to all elements of the new path.
	     * @returns {?CGPath} - 
	     * @see https://developer.apple.com/reference/coregraphics/cgpath/1411161-copy
	     */

	  }, {
	    key: 'copyUsing',
	    value: function copyUsing(transform) {
	      return null;
	    }

	    /**
	     * Returns a new path equivalent to the results of drawing the path with a dashed stroke.
	     * @access public
	     * @param {number} phase - A value that specifies how far into the dash pattern the line starts, in units of the user space. For example, a value of 0 draws a line starting with the beginning of a dash pattern, and a value of 3 means the line is drawn with the dash pattern starting at three units from its beginning. 
	     * @param {number[]} lengths - An array of values that specify the lengths, in user space coordinates, of the painted and unpainted segments  of the dash pattern.For example, the array [2,3] sets a dash pattern that alternates between a 2-unit-long painted segment and a 3-unit-long unpainted segment. The array [1,3,4,2] sets the pattern to a 1-unit painted segment, a 3-unit unpainted segment, a 4-unit painted segment, and a 2-unit unpainted segment.Pass an empty array to clear the dash pattern so that all stroke drawing in the context uses solid lines.
	     * @param {CGAffineTransform} transform - An affine transform to apply to the path before dashing. Defaults to the identity transform if not specified.
	     * @returns {CGPath} - 
	     * @desc The new path is created so that filling the new path draws the same pixels as stroking the original path with the specified dash parameters.
	     * @see https://developer.apple.com/reference/coregraphics/cgpath/2427137-copy
	     */

	  }, {
	    key: 'copyDashingWithPhase',
	    value: function copyDashingWithPhase(phase, lengths, transform) {
	      return null;
	    }

	    /**
	     * Returns a new path equivalent to the results of drawing the path with a solid stroke. 
	     * @access public
	     * @param {number} lineWidth - The line width to use, in user space units. The value must be greater than 0.
	     * @param {CGLineCap} lineCap - The line cap style to render. (For equivalent CGContext drawing methods, the default style is butt.) 
	     * @param {CGLineJoin} lineJoin - The line join style to render. (For equivalent CGContext drawing methods, the default style is miter.) 
	     * @param {number} miterLimit - A value that limits how sharp individual corners in the path can be when using the miter line join style. When the ratio of a the length required for a mitered corner to the line width exceeds this value, that corner uses the bevel style instead.
	     * @param {CGAffineTransform} transform - An affine transform to apply to the path before dashing. Defaults to the identity transform if not specified.
	     * @returns {CGPath} - 
	     * @desc The new path is created so that filling the new path draws the same pixels as stroking the original path with the specified line style.
	     * @see https://developer.apple.com/reference/coregraphics/cgpath/2427133-copy
	     */

	  }, {
	    key: 'copyStrokingWithWidth',
	    value: function copyStrokingWithWidth(lineWidth, lineCap, lineJoin, miterLimit, transform) {
	      return null;
	    }

	    /**
	     * Creates a mutable copy of an existing graphics path.
	     * @access public
	     * @returns {?CGMutablePath} - 
	     * @desc You can modify a mutable graphics path by calling the various path geometry functions, such as addArc(_:x:y:radius:startAngle:endAngle:clockwise:), addLineTo(_:x:y:), and moveTo(_:x:y:).
	     * @see https://developer.apple.com/reference/coregraphics/cgpath/1411196-mutablecopy
	     */

	  }, {
	    key: 'mutableCopy',
	    value: function mutableCopy() {
	      return null;
	    }

	    /**
	     * Creates a mutable copy of a graphics path transformed by a transformation matrix.
	     * @access public
	     * @param {?UnsafePointer<CGAffineTransform>} transform - A pointer to an affine transformation matrix, or NULL if no transformation is needed. If specified, Core Graphics applies the transformation to all elements of the new path.
	     * @returns {?CGMutablePath} - 
	     * @see https://developer.apple.com/reference/coregraphics/cgpath/1411150-mutablecopy
	     */

	  }, {
	    key: 'mutableCopyUsing',
	    value: function mutableCopyUsing(transform) {
	      return null;
	    }

	    // Examining a Graphics Path

	    /**
	     * Returns whether the specified point is interior to the path.
	     * @access public
	     * @param {CGPoint} point - The point to check.
	     * @param {CGPathFillRule} rule - The rule for determining which areas to treat as the interior of the path. Defaults to the winding rule if not specified.
	     * @param {CGAffineTransform} transform - An affine transform to apply to the point before checking for containment in the path. Defaults to the identity transform if not specified.
	     * @returns {boolean} - 
	     * @desc A point is contained in a path if it would be inside the painted region when the path is filled.
	     * @see https://developer.apple.com/reference/coregraphics/cgpath/2427117-contains
	     */

	  }, {
	    key: 'containsUsing',
	    value: function containsUsing(point, rule, transform) {
	      return false;
	    }

	    /**
	     * Indicates whether or not a graphics path represents a rectangle.
	     * @access public
	     * @param {?UnsafeMutablePointer<CGRect>} rect - On input, a pointer to an uninitialized rectangle. If the specified path represents a rectangle, on return contains a copy of the rectangle. 
	     * @returns {boolean} - 
	     * @see https://developer.apple.com/reference/coregraphics/cgpath/1411163-isrect
	     */

	  }, {
	    key: 'isRect',
	    value: function isRect(rect) {
	      return false;
	    }
	    /**
	     * Returns the bounding box containing all points in a graphics path.
	     * @type {CGRect}
	     * @desc The bounding box is the smallest rectangle completely enclosing all points in the path, including control points for Bézier and quadratic curves. 
	     * @see https://developer.apple.com/reference/coregraphics/cgpath/1411165-boundingbox
	     */

	  }, {
	    key: 'apply',


	    // Applying a Function to the Elements of a Path

	    /**
	     * For each element in a graphics path, calls a custom applier function.
	     * @access public
	     * @param {?Object} info - A pointer to the user data that Core Graphics will pass to the function being applied, or NULL.
	     * @param {CGPathApplierFunction} _function - 
	     * @returns {void}
	     * @desc For each element in the specified path, Core Graphics calls the applier function, which can examine (but not modify) the element.
	     * @see https://developer.apple.com/reference/coregraphics/cgpath/1411203-apply
	     */
	    value: function apply(info, _function) {}

	    // Working with Core Foundation Types
	    /**
	     * Returns the Core Foundation type identifier for Core Graphics graphics paths.
	     * @type {CFTypeID}
	     * @desc 
	     * @see https://developer.apple.com/reference/coregraphics/cgpath/1411192-typeid
	     */

	  }, {
	    key: 'init__byDashing',


	    // Initializers

	    /**
	     * Creates a dashed copy of another path.
	     * @access public
	     * @param {CGPath} path - The path to copy.
	     * @param {?UnsafePointer<CGAffineTransform>} transform - A pointer to an affine transformation matrix, or NULL if no transformation is needed. If specified, Core Graphics applies the transformation to elements of the converted path before adding them to the new path.
	     * @param {number} phase - A value that specifies how far into the dash pattern the line starts, in units of the user space. For example, passing a value of 3 means the line is drawn with the dash pattern starting at three units from its beginning. Passing a value of 0 draws a line starting with the beginning of a dash pattern.
	     * @param {?UnsafePointer<CGFloat>} lengths - An array of values that specify the lengths of the painted segments and unpainted segments, respectively, of the dash pattern—or NULL for no dash pattern.For example, passing an array with the values [2,3] sets a dash pattern that alternates between a 2-user-space-unit-long painted segment and a 3-user-space-unit-long unpainted segment. Passing the values [1,3,4,2] sets the pattern to a 1-unit painted segment, a 3-unit unpainted segment, a 4-unit painted segment, and a 2-unit unpainted segment.
	     * @param {number} count - If the lengths parameter specifies an array, pass the number of elements in the array. Otherwise, pass 0.
	     * @returns {void}
	     * @desc The new path is created so that filling the new path draws the same pixels as stroking the original path with the specified dash parameters.
	     * @see https://developer.apple.com/reference/coregraphics/cgpath/1411134-init
	     */
	    value: function init__byDashing(path, transform, phase, lengths, count) {

	      // Examining a Graphics Path

	      this._boundingBox = null;
	      this._boundingBoxOfPath = null;
	      this._currentPoint = null;
	      this._isEmpty = false;
	    }

	    /**
	     * Creates a stroked copy of another path.
	     * @access public
	     * @param {CGPath} path - The path to copy.
	     * @param {?UnsafePointer<CGAffineTransform>} transform - A pointer to an affine transformation matrix, or NULL if no transformation is needed. If specified, Core Graphics applies the transformation to elements of the converted path before adding them to the new path.
	     * @param {number} lineWidth - The line width to use, in user space units. The value must be greater than 0.
	     * @param {CGLineCap} lineCap - A line cap style constant—butt (the default), round, or square. 
	     * @param {CGLineJoin} lineJoin - A line join value—miter (the default), round, or bevel. 
	     * @param {number} miterLimit - The miter limit to use.
	     * @returns {void}
	     * @desc The new path is created so that filling the new path draws the same pixels as stroking the original path.If the line join style is set to kCGLineJoinMiter, Core Graphics uses the miter limit to determine whether the lines should be joined with a bevel instead of a miter. Core Graphics divides the length of the miter by the line width. If the result is greater than the miter limit, Core Graphics converts the style to a bevel. 
	     * @see https://developer.apple.com/reference/coregraphics/cgpath/1411128-init
	     */

	  }, {
	    key: 'init__byStroking',
	    value: function init__byStroking(path, transform, lineWidth, lineCap, lineJoin, miterLimit) {

	      // Examining a Graphics Path

	      this._boundingBox = null;
	      this._boundingBoxOfPath = null;
	      this._currentPoint = null;
	      this._isEmpty = false;
	    }
	  }, {
	    key: 'boundingBox',
	    get: function get() {
	      return this._boundingBox;
	    }
	    /**
	     * Returns the bounding box of a graphics path.
	     * @type {CGRect}
	     * @desc The path bounding box is the smallest rectangle completely enclosing all points in the path but not including control points for Bézier and quadratic curves. 
	     * @see https://developer.apple.com/reference/coregraphics/cgpath/1411200-boundingboxofpath
	     */

	  }, {
	    key: 'boundingBoxOfPath',
	    get: function get() {
	      return this._boundingBoxOfPath;
	    }
	    /**
	     * Returns the current point in a graphics path.
	     * @type {CGPoint}
	     * @desc If the path is empty—that is, if it has no elements—this function returns CGPointZero (see CGGeometry). To determine whether a path is empty, use isEmpty.
	     * @see https://developer.apple.com/reference/coregraphics/cgpath/1411132-currentpoint
	     */

	  }, {
	    key: 'currentPoint',
	    get: function get() {
	      return this._currentPoint;
	    }
	    /**
	     * Indicates whether or not a graphics path is empty.
	     * @type {boolean}
	     * @desc An empty path contains no elements.
	     * @see https://developer.apple.com/reference/coregraphics/cgpath/1411149-isempty
	     */

	  }, {
	    key: 'isEmpty',
	    get: function get() {
	      return this._isEmpty;
	    }
	  }], [{
	    key: 'typeID',
	    get: function get() {
	      return _typeID;
	    }
	  }]);

	  return CGPath;
	}();

	exports.default = CGPath;

/***/ },
/* 9 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * Rules for determining which regions are interior to a path, used by the fillPath(using:) and clip(using:) methods.
	 * @typedef {Object} CGPathFillRule
	 * @property {Symbol} evenOdd - A rule that considers a region to be interior to a path based on the number of times it is enclosed by path elements.
	 * @property {Symbol} winding - A rule that considers a region to be interior to a path if the winding number for that region is nonzero.
	 * @see https://developer.apple.com/reference/coregraphics/cgpathfillrule
	 */

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var CGPathFillRule = {
	  evenOdd: Symbol(),
	  winding: Symbol()
	};

	exports.default = CGPathFillRule;

/***/ },
/* 10 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * Defines a callback function that can view an element in a graphics path.
	 * @type {function(): void}
	 * @returns {void}
	 * @see https://developer.apple.com/reference/coregraphics/cgpathapplierfunction
	 */

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var CGPathApplierFunction = function CGPathApplierFunction() {};

	exports.default = CGPathApplierFunction;

/***/ },
/* 11 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * A structure that contains a two-dimensional vector.
	 * @access public
	 * @see https://developer.apple.com/reference/coregraphics/cgvector
	 */

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var CGVector = function () {
	  function CGVector() {
	    _classCallCheck(this, CGVector);
	  }

	  _createClass(CGVector, [{
	    key: 'init',


	    // Initializers

	    /**
	     * Creates a vector with components specified as integer values.
	     * @access public
	     * @param {number} dx - 
	     * @param {number} dy - 
	     * @returns {void}
	     * @see https://developer.apple.com/reference/coregraphics/cgvector/1456249-init
	     */
	    value: function init(dx, dy) {

	      // Special Values

	      this._zero = null;

	      // Geometric Properties

	      this._dx = 0;
	      this._dy = 0;
	    }

	    // Special Values
	    /**
	     * The vector whose components are both zero.
	     * @type {CGVector}
	     * @desc 
	     * @see https://developer.apple.com/reference/coregraphics/cgvector/1454067-zero
	     */

	  }, {
	    key: 'zero',
	    get: function get() {
	      return this._zero;
	    }

	    // Geometric Properties

	  }]);

	  return CGVector;
	}();

	exports.default = CGVector;

/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _NSObject2 = __webpack_require__(13);

	var _NSObject3 = _interopRequireDefault(_NSObject2);

	var _CGPoint = __webpack_require__(5);

	var _CGPoint2 = _interopRequireDefault(_CGPoint);

	var _CGVector = __webpack_require__(11);

	var _CGVector2 = _interopRequireDefault(_CGVector);

	var _CGSize = __webpack_require__(7);

	var _CGSize2 = _interopRequireDefault(_CGSize);

	var _CGRect = __webpack_require__(6);

	var _CGRect2 = _interopRequireDefault(_CGRect);

	var _CATransform3D = __webpack_require__(14);

	var _CATransform3D2 = _interopRequireDefault(_CATransform3D);

	var _SCNVector = __webpack_require__(15);

	var _SCNVector2 = _interopRequireDefault(_SCNVector);

	var _SCNVector3 = __webpack_require__(16);

	var _SCNVector4 = _interopRequireDefault(_SCNVector3);

	var _SCNMatrix = __webpack_require__(17);

	var _SCNMatrix2 = _interopRequireDefault(_SCNMatrix);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * An NSValue object is a simple container for a single C or Objective-C data item. It can hold any of the scalar types such as int, float, and char, as well as pointers, structures, and object id references. Use this class to work with such data types in collections (such as NSArray and NSSet), Key-value coding, and other APIs that require Objective-C objects. NSValue objects are always immutable.
	 * @access public
	 * @extends {NSObject}
	 * @see https://developer.apple.com/reference/foundation/nsvalue
	 */
	var NSValue = function (_NSObject) {
	  _inherits(NSValue, _NSObject);

	  function NSValue() {
	    _classCallCheck(this, NSValue);

	    return _possibleConstructorReturn(this, (NSValue.__proto__ || Object.getPrototypeOf(NSValue)).apply(this, arguments));
	  }

	  _createClass(NSValue, [{
	    key: 'initBytesObjCType',


	    // Working with Raw Values

	    /**
	     * Initializes a value object to contain the specified value, interpreted with the specified Objective-C type.
	     * @access public
	     * @param {UnsafeRawPointer} value - A pointer to data to be stored in the new value object.
	     * @param {UnsafePointer<Int8>} type - The Objective-C type of value, as provided by the @encode() compiler directive. Do not hard-code this parameter as a C string. 
	     * @returns {void}
	     * @desc See Number and Value Programming Topics for other considerations in creating a value object.This is the designated initializer for the NSValue class.
	     * @see https://developer.apple.com/reference/foundation/nsvalue/1411621-init
	     */
	    value: function initBytesObjCType(value, type) {

	      // Working with Raw Values

	      this._objCType = null;

	      // Working with Pointer and Object Values

	      this._pointerValue = null;
	      this._nonretainedObjectValue = null;

	      // Working with Range Values

	      this._rangeValue = null;

	      // Working with Foundation Geometry Values

	      this._pointValue = null;
	      this._sizeValue = null;
	      this._rectValue = null;

	      // Working with CoreGraphics Geometry Values

	      this._cgPointValue = null;
	      this._cgVectorValue = null;
	      this._cgSizeValue = null;
	      this._cgRectValue = null;
	      this._cgAffineTransformValue = null;

	      // Working with UIKit Geometry Values

	      this._uiEdgeInsetsValue = null;
	      this._uiOffsetValue = null;

	      // Working with CoreAnimation Transform Values

	      this._caTransform3DValue = null;

	      // Working with Media Time Values

	      this._timeValue = null;
	      this._timeRangeValue = null;
	      this._timeMappingValue = null;

	      // Working with Geographic Coordinate Values

	      this._mkCoordinateValue = null;
	      this._mkCoordinateSpanValue = null;

	      // Working with SceneKit Vector and Matrix Values

	      this._scnVector3Value = null;
	      this._scnVector4Value = null;
	      this._scnMatrix4Value = null;

	      // Instance Properties

	      this._edgeInsetsValue = null;
	    }

	    /**
	     * Creates a value object containing the specified value, interpreted with the specified Objective-C type.
	     * @access public
	     * @param {UnsafeRawPointer} value - A pointer to data to be stored in the new value object.
	     * @param {UnsafePointer<Int8>} type - The Objective-C type of value, as provided by the @encode() compiler directive. Do not hard-code this parameter as a C string. 
	     * @returns {void}
	     * @desc This method has the same effect as valueWithBytes:objCType: and may be deprecated in a future release. You should use valueWithBytes:objCType: instead.
	     * @see https://developer.apple.com/reference/foundation/nsvalue/1417400-init
	     */

	  }, {
	    key: 'initWithObjCType',
	    value: function initWithObjCType(value, type) {

	      // Working with Raw Values

	      this._objCType = null;

	      // Working with Pointer and Object Values

	      this._pointerValue = null;
	      this._nonretainedObjectValue = null;

	      // Working with Range Values

	      this._rangeValue = null;

	      // Working with Foundation Geometry Values

	      this._pointValue = null;
	      this._sizeValue = null;
	      this._rectValue = null;

	      // Working with CoreGraphics Geometry Values

	      this._cgPointValue = null;
	      this._cgVectorValue = null;
	      this._cgSizeValue = null;
	      this._cgRectValue = null;
	      this._cgAffineTransformValue = null;

	      // Working with UIKit Geometry Values

	      this._uiEdgeInsetsValue = null;
	      this._uiOffsetValue = null;

	      // Working with CoreAnimation Transform Values

	      this._caTransform3DValue = null;

	      // Working with Media Time Values

	      this._timeValue = null;
	      this._timeRangeValue = null;
	      this._timeMappingValue = null;

	      // Working with Geographic Coordinate Values

	      this._mkCoordinateValue = null;
	      this._mkCoordinateSpanValue = null;

	      // Working with SceneKit Vector and Matrix Values

	      this._scnVector3Value = null;
	      this._scnVector4Value = null;
	      this._scnMatrix4Value = null;

	      // Instance Properties

	      this._edgeInsetsValue = null;
	    }

	    /**
	     * Copies the value into the specified buffer.
	     * @access public
	     * @param {Object} value - 
	     * @returns {void}
	     * @see https://developer.apple.com/reference/foundation/nsvalue/1415141-getvalue
	     */

	  }, {
	    key: 'getValue',
	    value: function getValue(value) {}
	    /**
	     * A C string containing the Objective-C type of the data contained in the value object.
	     * @type {UnsafePointer<Int8>}
	     * @desc This property provides the same string produced by the @encode() compiler directive.
	     * @see https://developer.apple.com/reference/foundation/nsvalue/1412365-objctype
	     */

	  }, {
	    key: 'init',


	    // Working with Pointer and Object Values

	    /**
	     * Creates a value object containing the specified pointer.
	     * @access public
	     * @param {?UnsafeRawPointer} pointer - 
	     * @returns {void}
	     * @desc This method is equivalent to invoking init(_:withObjCType:) in this manner:NSValue *theValue = [NSValue value:&aPointer withObjCType:@encode(void *)];
	    This method does not copy the contents of aPointer, so you must not to free the memory at the pointer destination while the NSValue object exists. NSData objects may be more suited for arbitrary pointers than NSValue objects.NSValue *theValue = [NSValue value:&aPointer withObjCType:@encode(void *)];
	      * @see https://developer.apple.com/reference/foundation/nsvalue/1415975-init
	     */
	    value: function init(pointer) {

	      // Working with Raw Values

	      this._objCType = null;

	      // Working with Pointer and Object Values

	      this._pointerValue = null;
	      this._nonretainedObjectValue = null;

	      // Working with Range Values

	      this._rangeValue = null;

	      // Working with Foundation Geometry Values

	      this._pointValue = null;
	      this._sizeValue = null;
	      this._rectValue = null;

	      // Working with CoreGraphics Geometry Values

	      this._cgPointValue = null;
	      this._cgVectorValue = null;
	      this._cgSizeValue = null;
	      this._cgRectValue = null;
	      this._cgAffineTransformValue = null;

	      // Working with UIKit Geometry Values

	      this._uiEdgeInsetsValue = null;
	      this._uiOffsetValue = null;

	      // Working with CoreAnimation Transform Values

	      this._caTransform3DValue = null;

	      // Working with Media Time Values

	      this._timeValue = null;
	      this._timeRangeValue = null;
	      this._timeMappingValue = null;

	      // Working with Geographic Coordinate Values

	      this._mkCoordinateValue = null;
	      this._mkCoordinateSpanValue = null;

	      // Working with SceneKit Vector and Matrix Values

	      this._scnVector3Value = null;
	      this._scnVector4Value = null;
	      this._scnMatrix4Value = null;

	      // Instance Properties

	      this._edgeInsetsValue = null;
	    }

	    /**
	     * Creates a value object containing the specified object.
	     * @access public
	     * @param {?Object} anObject - The value for the new object.
	     * @returns {void}
	     * @desc  This method is equivalent to invoking init(_:withObjCType:) in this manner:NSValue *theValue = [NSValue value:&anObject withObjCType:@encode(void *)];
	    This method is useful if you want to add an object to a Collection but don’t want the collection to create a strong reference to it.NSValue *theValue = [NSValue value:&anObject withObjCType:@encode(void *)];
	      * @see https://developer.apple.com/reference/foundation/nsvalue/1408098-init
	     */

	  }, {
	    key: 'initNonretainedObject',
	    value: function initNonretainedObject(anObject) {

	      // Working with Raw Values

	      this._objCType = null;

	      // Working with Pointer and Object Values

	      this._pointerValue = null;
	      this._nonretainedObjectValue = null;

	      // Working with Range Values

	      this._rangeValue = null;

	      // Working with Foundation Geometry Values

	      this._pointValue = null;
	      this._sizeValue = null;
	      this._rectValue = null;

	      // Working with CoreGraphics Geometry Values

	      this._cgPointValue = null;
	      this._cgVectorValue = null;
	      this._cgSizeValue = null;
	      this._cgRectValue = null;
	      this._cgAffineTransformValue = null;

	      // Working with UIKit Geometry Values

	      this._uiEdgeInsetsValue = null;
	      this._uiOffsetValue = null;

	      // Working with CoreAnimation Transform Values

	      this._caTransform3DValue = null;

	      // Working with Media Time Values

	      this._timeValue = null;
	      this._timeRangeValue = null;
	      this._timeMappingValue = null;

	      // Working with Geographic Coordinate Values

	      this._mkCoordinateValue = null;
	      this._mkCoordinateSpanValue = null;

	      // Working with SceneKit Vector and Matrix Values

	      this._scnVector3Value = null;
	      this._scnVector4Value = null;
	      this._scnMatrix4Value = null;

	      // Instance Properties

	      this._edgeInsetsValue = null;
	    }
	    /**
	     * Returns the value as an untyped pointer.
	     * @type {?Object}
	     * @desc 
	     * @see https://developer.apple.com/reference/foundation/nsvalue/1410668-pointervalue
	     */

	  }, {
	    key: 'initCgPoint',


	    // Working with CoreGraphics Geometry Values

	    /**
	     * Creates a new value object containing the specified CoreGraphics point structure.
	     * @access public
	     * @param {CGPoint} point - The value for the new object.
	     * @returns {void}
	     * @see https://developer.apple.com/reference/foundation/nsvalue/1624531-init
	     */
	    value: function initCgPoint(point) {

	      // Working with Raw Values

	      this._objCType = null;

	      // Working with Pointer and Object Values

	      this._pointerValue = null;
	      this._nonretainedObjectValue = null;

	      // Working with Range Values

	      this._rangeValue = null;

	      // Working with Foundation Geometry Values

	      this._pointValue = null;
	      this._sizeValue = null;
	      this._rectValue = null;

	      // Working with CoreGraphics Geometry Values

	      this._cgPointValue = null;
	      this._cgVectorValue = null;
	      this._cgSizeValue = null;
	      this._cgRectValue = null;
	      this._cgAffineTransformValue = null;

	      // Working with UIKit Geometry Values

	      this._uiEdgeInsetsValue = null;
	      this._uiOffsetValue = null;

	      // Working with CoreAnimation Transform Values

	      this._caTransform3DValue = null;

	      // Working with Media Time Values

	      this._timeValue = null;
	      this._timeRangeValue = null;
	      this._timeMappingValue = null;

	      // Working with Geographic Coordinate Values

	      this._mkCoordinateValue = null;
	      this._mkCoordinateSpanValue = null;

	      // Working with SceneKit Vector and Matrix Values

	      this._scnVector3Value = null;
	      this._scnVector4Value = null;
	      this._scnMatrix4Value = null;

	      // Instance Properties

	      this._edgeInsetsValue = null;
	    }

	    /**
	     * Creates a new value object containing the specified CoreGraphics vector structure.
	     * @access public
	     * @param {CGVector} vector - The value for the new object.
	     * @returns {void}
	     * @see https://developer.apple.com/reference/foundation/nsvalue/1624493-init
	     */

	  }, {
	    key: 'initCgVector',
	    value: function initCgVector(vector) {

	      // Working with Raw Values

	      this._objCType = null;

	      // Working with Pointer and Object Values

	      this._pointerValue = null;
	      this._nonretainedObjectValue = null;

	      // Working with Range Values

	      this._rangeValue = null;

	      // Working with Foundation Geometry Values

	      this._pointValue = null;
	      this._sizeValue = null;
	      this._rectValue = null;

	      // Working with CoreGraphics Geometry Values

	      this._cgPointValue = null;
	      this._cgVectorValue = null;
	      this._cgSizeValue = null;
	      this._cgRectValue = null;
	      this._cgAffineTransformValue = null;

	      // Working with UIKit Geometry Values

	      this._uiEdgeInsetsValue = null;
	      this._uiOffsetValue = null;

	      // Working with CoreAnimation Transform Values

	      this._caTransform3DValue = null;

	      // Working with Media Time Values

	      this._timeValue = null;
	      this._timeRangeValue = null;
	      this._timeMappingValue = null;

	      // Working with Geographic Coordinate Values

	      this._mkCoordinateValue = null;
	      this._mkCoordinateSpanValue = null;

	      // Working with SceneKit Vector and Matrix Values

	      this._scnVector3Value = null;
	      this._scnVector4Value = null;
	      this._scnMatrix4Value = null;

	      // Instance Properties

	      this._edgeInsetsValue = null;
	    }

	    /**
	     * Creates a new value object containing the specified CoreGraphics size structure.
	     * @access public
	     * @param {CGSize} size - The value for the new object.
	     * @returns {void}
	     * @see https://developer.apple.com/reference/foundation/nsvalue/1624511-init
	     */

	  }, {
	    key: 'initCgSize',
	    value: function initCgSize(size) {

	      // Working with Raw Values

	      this._objCType = null;

	      // Working with Pointer and Object Values

	      this._pointerValue = null;
	      this._nonretainedObjectValue = null;

	      // Working with Range Values

	      this._rangeValue = null;

	      // Working with Foundation Geometry Values

	      this._pointValue = null;
	      this._sizeValue = null;
	      this._rectValue = null;

	      // Working with CoreGraphics Geometry Values

	      this._cgPointValue = null;
	      this._cgVectorValue = null;
	      this._cgSizeValue = null;
	      this._cgRectValue = null;
	      this._cgAffineTransformValue = null;

	      // Working with UIKit Geometry Values

	      this._uiEdgeInsetsValue = null;
	      this._uiOffsetValue = null;

	      // Working with CoreAnimation Transform Values

	      this._caTransform3DValue = null;

	      // Working with Media Time Values

	      this._timeValue = null;
	      this._timeRangeValue = null;
	      this._timeMappingValue = null;

	      // Working with Geographic Coordinate Values

	      this._mkCoordinateValue = null;
	      this._mkCoordinateSpanValue = null;

	      // Working with SceneKit Vector and Matrix Values

	      this._scnVector3Value = null;
	      this._scnVector4Value = null;
	      this._scnMatrix4Value = null;

	      // Instance Properties

	      this._edgeInsetsValue = null;
	    }

	    /**
	     * Creates a new value object containing the specified CoreGraphics rectangle structure.
	     * @access public
	     * @param {CGRect} rect - The value for the new object.
	     * @returns {void}
	     * @see https://developer.apple.com/reference/foundation/nsvalue/1624529-init
	     */

	  }, {
	    key: 'initCgRect',
	    value: function initCgRect(rect) {

	      // Working with Raw Values

	      this._objCType = null;

	      // Working with Pointer and Object Values

	      this._pointerValue = null;
	      this._nonretainedObjectValue = null;

	      // Working with Range Values

	      this._rangeValue = null;

	      // Working with Foundation Geometry Values

	      this._pointValue = null;
	      this._sizeValue = null;
	      this._rectValue = null;

	      // Working with CoreGraphics Geometry Values

	      this._cgPointValue = null;
	      this._cgVectorValue = null;
	      this._cgSizeValue = null;
	      this._cgRectValue = null;
	      this._cgAffineTransformValue = null;

	      // Working with UIKit Geometry Values

	      this._uiEdgeInsetsValue = null;
	      this._uiOffsetValue = null;

	      // Working with CoreAnimation Transform Values

	      this._caTransform3DValue = null;

	      // Working with Media Time Values

	      this._timeValue = null;
	      this._timeRangeValue = null;
	      this._timeMappingValue = null;

	      // Working with Geographic Coordinate Values

	      this._mkCoordinateValue = null;
	      this._mkCoordinateSpanValue = null;

	      // Working with SceneKit Vector and Matrix Values

	      this._scnVector3Value = null;
	      this._scnVector4Value = null;
	      this._scnMatrix4Value = null;

	      // Instance Properties

	      this._edgeInsetsValue = null;
	    }

	    /**
	     * Creates a new value object containing the specified CoreGraphics affine transform structure.
	     * @access public
	     * @param {CGAffineTransform} transform - The value for the new object.
	     * @returns {void}
	     * @see https://developer.apple.com/reference/foundation/nsvalue/1624503-init
	     */

	  }, {
	    key: 'initCgAffineTransform',
	    value: function initCgAffineTransform(transform) {

	      // Working with Raw Values

	      this._objCType = null;

	      // Working with Pointer and Object Values

	      this._pointerValue = null;
	      this._nonretainedObjectValue = null;

	      // Working with Range Values

	      this._rangeValue = null;

	      // Working with Foundation Geometry Values

	      this._pointValue = null;
	      this._sizeValue = null;
	      this._rectValue = null;

	      // Working with CoreGraphics Geometry Values

	      this._cgPointValue = null;
	      this._cgVectorValue = null;
	      this._cgSizeValue = null;
	      this._cgRectValue = null;
	      this._cgAffineTransformValue = null;

	      // Working with UIKit Geometry Values

	      this._uiEdgeInsetsValue = null;
	      this._uiOffsetValue = null;

	      // Working with CoreAnimation Transform Values

	      this._caTransform3DValue = null;

	      // Working with Media Time Values

	      this._timeValue = null;
	      this._timeRangeValue = null;
	      this._timeMappingValue = null;

	      // Working with Geographic Coordinate Values

	      this._mkCoordinateValue = null;
	      this._mkCoordinateSpanValue = null;

	      // Working with SceneKit Vector and Matrix Values

	      this._scnVector3Value = null;
	      this._scnVector4Value = null;
	      this._scnMatrix4Value = null;

	      // Instance Properties

	      this._edgeInsetsValue = null;
	    }
	    /**
	     * Returns the CoreGraphics point structure representation of the value.
	     * @type {CGPoint}
	     * @desc 
	     * @see https://developer.apple.com/reference/foundation/nsvalue/1624534-cgpointvalue
	     */

	  }, {
	    key: 'initUiEdgeInsets',


	    // Working with UIKit Geometry Values

	    /**
	     * Creates a new value object containing the specified UIKit edge insets structure.
	     * @access public
	     * @param {UIEdgeInsets} insets - The value for the new object.
	     * @returns {void}
	     * @see https://developer.apple.com/reference/foundation/nsvalue/1624485-init
	     */
	    value: function initUiEdgeInsets(insets) {

	      // Working with Raw Values

	      this._objCType = null;

	      // Working with Pointer and Object Values

	      this._pointerValue = null;
	      this._nonretainedObjectValue = null;

	      // Working with Range Values

	      this._rangeValue = null;

	      // Working with Foundation Geometry Values

	      this._pointValue = null;
	      this._sizeValue = null;
	      this._rectValue = null;

	      // Working with CoreGraphics Geometry Values

	      this._cgPointValue = null;
	      this._cgVectorValue = null;
	      this._cgSizeValue = null;
	      this._cgRectValue = null;
	      this._cgAffineTransformValue = null;

	      // Working with UIKit Geometry Values

	      this._uiEdgeInsetsValue = null;
	      this._uiOffsetValue = null;

	      // Working with CoreAnimation Transform Values

	      this._caTransform3DValue = null;

	      // Working with Media Time Values

	      this._timeValue = null;
	      this._timeRangeValue = null;
	      this._timeMappingValue = null;

	      // Working with Geographic Coordinate Values

	      this._mkCoordinateValue = null;
	      this._mkCoordinateSpanValue = null;

	      // Working with SceneKit Vector and Matrix Values

	      this._scnVector3Value = null;
	      this._scnVector4Value = null;
	      this._scnMatrix4Value = null;

	      // Instance Properties

	      this._edgeInsetsValue = null;
	    }

	    /**
	     * Creates a new value object containing the specified UIKit offset structure.
	     * @access public
	     * @param {UIOffset} insets - The value for the new object.
	     * @returns {void}
	     * @see https://developer.apple.com/reference/foundation/nsvalue/1624530-init
	     */

	  }, {
	    key: 'initUiOffset',
	    value: function initUiOffset(insets) {

	      // Working with Raw Values

	      this._objCType = null;

	      // Working with Pointer and Object Values

	      this._pointerValue = null;
	      this._nonretainedObjectValue = null;

	      // Working with Range Values

	      this._rangeValue = null;

	      // Working with Foundation Geometry Values

	      this._pointValue = null;
	      this._sizeValue = null;
	      this._rectValue = null;

	      // Working with CoreGraphics Geometry Values

	      this._cgPointValue = null;
	      this._cgVectorValue = null;
	      this._cgSizeValue = null;
	      this._cgRectValue = null;
	      this._cgAffineTransformValue = null;

	      // Working with UIKit Geometry Values

	      this._uiEdgeInsetsValue = null;
	      this._uiOffsetValue = null;

	      // Working with CoreAnimation Transform Values

	      this._caTransform3DValue = null;

	      // Working with Media Time Values

	      this._timeValue = null;
	      this._timeRangeValue = null;
	      this._timeMappingValue = null;

	      // Working with Geographic Coordinate Values

	      this._mkCoordinateValue = null;
	      this._mkCoordinateSpanValue = null;

	      // Working with SceneKit Vector and Matrix Values

	      this._scnVector3Value = null;
	      this._scnVector4Value = null;
	      this._scnMatrix4Value = null;

	      // Instance Properties

	      this._edgeInsetsValue = null;
	    }
	    /**
	     * Returns the UIKit edge insets structure representation of the value.
	     * @type {UIEdgeInsets}
	     * @desc 
	     * @see https://developer.apple.com/reference/foundation/nsvalue/1624517-uiedgeinsetsvalue
	     */

	  }, {
	    key: 'initCaTransform3D',


	    // Working with CoreAnimation Transform Values

	    /**
	     * Creates a new value object containing the specified CoreAnimation transform structure.
	     * @access public
	     * @param {CATransform3D} t - 
	     * @returns {void}
	     * @see https://developer.apple.com/reference/foundation/nsvalue/1436556-init
	     */
	    value: function initCaTransform3D(t) {

	      // Working with Raw Values

	      this._objCType = null;

	      // Working with Pointer and Object Values

	      this._pointerValue = null;
	      this._nonretainedObjectValue = null;

	      // Working with Range Values

	      this._rangeValue = null;

	      // Working with Foundation Geometry Values

	      this._pointValue = null;
	      this._sizeValue = null;
	      this._rectValue = null;

	      // Working with CoreGraphics Geometry Values

	      this._cgPointValue = null;
	      this._cgVectorValue = null;
	      this._cgSizeValue = null;
	      this._cgRectValue = null;
	      this._cgAffineTransformValue = null;

	      // Working with UIKit Geometry Values

	      this._uiEdgeInsetsValue = null;
	      this._uiOffsetValue = null;

	      // Working with CoreAnimation Transform Values

	      this._caTransform3DValue = null;

	      // Working with Media Time Values

	      this._timeValue = null;
	      this._timeRangeValue = null;
	      this._timeMappingValue = null;

	      // Working with Geographic Coordinate Values

	      this._mkCoordinateValue = null;
	      this._mkCoordinateSpanValue = null;

	      // Working with SceneKit Vector and Matrix Values

	      this._scnVector3Value = null;
	      this._scnVector4Value = null;
	      this._scnMatrix4Value = null;

	      // Instance Properties

	      this._edgeInsetsValue = null;
	    }
	    /**
	     * The CoreAnimation transform structure representation of the value.
	     * @type {CATransform3D}
	     * @desc 
	     * @see https://developer.apple.com/reference/foundation/nsvalue/1436572-catransform3dvalue
	     */

	  }, {
	    key: 'initMkCoordinate',


	    // Working with Geographic Coordinate Values

	    /**
	     * Creates a new value object containing the specified CoreLocation geographic coordinate structure.
	     * @access public
	     * @param {CLLocationCoordinate2D} coordinate - The value for the new object.
	     * @returns {void}
	     * @see https://developer.apple.com/reference/foundation/nsvalue/1452193-init
	     */
	    value: function initMkCoordinate(coordinate) {

	      // Working with Raw Values

	      this._objCType = null;

	      // Working with Pointer and Object Values

	      this._pointerValue = null;
	      this._nonretainedObjectValue = null;

	      // Working with Range Values

	      this._rangeValue = null;

	      // Working with Foundation Geometry Values

	      this._pointValue = null;
	      this._sizeValue = null;
	      this._rectValue = null;

	      // Working with CoreGraphics Geometry Values

	      this._cgPointValue = null;
	      this._cgVectorValue = null;
	      this._cgSizeValue = null;
	      this._cgRectValue = null;
	      this._cgAffineTransformValue = null;

	      // Working with UIKit Geometry Values

	      this._uiEdgeInsetsValue = null;
	      this._uiOffsetValue = null;

	      // Working with CoreAnimation Transform Values

	      this._caTransform3DValue = null;

	      // Working with Media Time Values

	      this._timeValue = null;
	      this._timeRangeValue = null;
	      this._timeMappingValue = null;

	      // Working with Geographic Coordinate Values

	      this._mkCoordinateValue = null;
	      this._mkCoordinateSpanValue = null;

	      // Working with SceneKit Vector and Matrix Values

	      this._scnVector3Value = null;
	      this._scnVector4Value = null;
	      this._scnMatrix4Value = null;

	      // Instance Properties

	      this._edgeInsetsValue = null;
	    }

	    /**
	     * Creates a new value object containing the specified MapKit coordinate span structure.
	     * @access public
	     * @param {MKCoordinateSpan} span - The value for the new object.
	     * @returns {void}
	     * @see https://developer.apple.com/reference/foundation/nsvalue/1452333-init
	     */

	  }, {
	    key: 'initMkCoordinateSpan',
	    value: function initMkCoordinateSpan(span) {

	      // Working with Raw Values

	      this._objCType = null;

	      // Working with Pointer and Object Values

	      this._pointerValue = null;
	      this._nonretainedObjectValue = null;

	      // Working with Range Values

	      this._rangeValue = null;

	      // Working with Foundation Geometry Values

	      this._pointValue = null;
	      this._sizeValue = null;
	      this._rectValue = null;

	      // Working with CoreGraphics Geometry Values

	      this._cgPointValue = null;
	      this._cgVectorValue = null;
	      this._cgSizeValue = null;
	      this._cgRectValue = null;
	      this._cgAffineTransformValue = null;

	      // Working with UIKit Geometry Values

	      this._uiEdgeInsetsValue = null;
	      this._uiOffsetValue = null;

	      // Working with CoreAnimation Transform Values

	      this._caTransform3DValue = null;

	      // Working with Media Time Values

	      this._timeValue = null;
	      this._timeRangeValue = null;
	      this._timeMappingValue = null;

	      // Working with Geographic Coordinate Values

	      this._mkCoordinateValue = null;
	      this._mkCoordinateSpanValue = null;

	      // Working with SceneKit Vector and Matrix Values

	      this._scnVector3Value = null;
	      this._scnVector4Value = null;
	      this._scnMatrix4Value = null;

	      // Instance Properties

	      this._edgeInsetsValue = null;
	    }
	    /**
	     * The CoreLocation geographic coordinate structure representation of the value.
	     * @type {CLLocationCoordinate2D}
	     * @desc 
	     * @see https://developer.apple.com/reference/foundation/nsvalue/1452495-mkcoordinatevalue
	     */

	  }, {
	    key: 'initScnVector3',


	    // Working with SceneKit Vector and Matrix Values

	    /**
	     * Creates a value object that contains the specified three-element SceneKit vector.
	     * @access public
	     * @param {SCNVector3} v - 
	     * @returns {void}
	     * @see https://developer.apple.com/reference/foundation/nsvalue/1409671-init
	     */
	    value: function initScnVector3(v) {

	      // Working with Raw Values

	      this._objCType = null;

	      // Working with Pointer and Object Values

	      this._pointerValue = null;
	      this._nonretainedObjectValue = null;

	      // Working with Range Values

	      this._rangeValue = null;

	      // Working with Foundation Geometry Values

	      this._pointValue = null;
	      this._sizeValue = null;
	      this._rectValue = null;

	      // Working with CoreGraphics Geometry Values

	      this._cgPointValue = null;
	      this._cgVectorValue = null;
	      this._cgSizeValue = null;
	      this._cgRectValue = null;
	      this._cgAffineTransformValue = null;

	      // Working with UIKit Geometry Values

	      this._uiEdgeInsetsValue = null;
	      this._uiOffsetValue = null;

	      // Working with CoreAnimation Transform Values

	      this._caTransform3DValue = null;

	      // Working with Media Time Values

	      this._timeValue = null;
	      this._timeRangeValue = null;
	      this._timeMappingValue = null;

	      // Working with Geographic Coordinate Values

	      this._mkCoordinateValue = null;
	      this._mkCoordinateSpanValue = null;

	      // Working with SceneKit Vector and Matrix Values

	      this._scnVector3Value = null;
	      this._scnVector4Value = null;
	      this._scnMatrix4Value = null;

	      // Instance Properties

	      this._edgeInsetsValue = null;
	    }

	    /**
	     * Creates a value object that contains the specified four-element SceneKit vector.
	     * @access public
	     * @param {SCNVector4} v - 
	     * @returns {void}
	     * @see https://developer.apple.com/reference/foundation/nsvalue/1409688-init
	     */

	  }, {
	    key: 'initScnVector4',
	    value: function initScnVector4(v) {

	      // Working with Raw Values

	      this._objCType = null;

	      // Working with Pointer and Object Values

	      this._pointerValue = null;
	      this._nonretainedObjectValue = null;

	      // Working with Range Values

	      this._rangeValue = null;

	      // Working with Foundation Geometry Values

	      this._pointValue = null;
	      this._sizeValue = null;
	      this._rectValue = null;

	      // Working with CoreGraphics Geometry Values

	      this._cgPointValue = null;
	      this._cgVectorValue = null;
	      this._cgSizeValue = null;
	      this._cgRectValue = null;
	      this._cgAffineTransformValue = null;

	      // Working with UIKit Geometry Values

	      this._uiEdgeInsetsValue = null;
	      this._uiOffsetValue = null;

	      // Working with CoreAnimation Transform Values

	      this._caTransform3DValue = null;

	      // Working with Media Time Values

	      this._timeValue = null;
	      this._timeRangeValue = null;
	      this._timeMappingValue = null;

	      // Working with Geographic Coordinate Values

	      this._mkCoordinateValue = null;
	      this._mkCoordinateSpanValue = null;

	      // Working with SceneKit Vector and Matrix Values

	      this._scnVector3Value = null;
	      this._scnVector4Value = null;
	      this._scnMatrix4Value = null;

	      // Instance Properties

	      this._edgeInsetsValue = null;
	    }

	    /**
	     * Creates a value object that contains the specified SceneKit 4 x 4 matrix.
	     * @access public
	     * @param {SCNMatrix4} v - The value for the new object.
	     * @returns {void}
	     * @see https://developer.apple.com/reference/foundation/nsvalue/1409680-init
	     */

	  }, {
	    key: 'initScnMatrix4',
	    value: function initScnMatrix4(v) {

	      // Working with Raw Values

	      this._objCType = null;

	      // Working with Pointer and Object Values

	      this._pointerValue = null;
	      this._nonretainedObjectValue = null;

	      // Working with Range Values

	      this._rangeValue = null;

	      // Working with Foundation Geometry Values

	      this._pointValue = null;
	      this._sizeValue = null;
	      this._rectValue = null;

	      // Working with CoreGraphics Geometry Values

	      this._cgPointValue = null;
	      this._cgVectorValue = null;
	      this._cgSizeValue = null;
	      this._cgRectValue = null;
	      this._cgAffineTransformValue = null;

	      // Working with UIKit Geometry Values

	      this._uiEdgeInsetsValue = null;
	      this._uiOffsetValue = null;

	      // Working with CoreAnimation Transform Values

	      this._caTransform3DValue = null;

	      // Working with Media Time Values

	      this._timeValue = null;
	      this._timeRangeValue = null;
	      this._timeMappingValue = null;

	      // Working with Geographic Coordinate Values

	      this._mkCoordinateValue = null;
	      this._mkCoordinateSpanValue = null;

	      // Working with SceneKit Vector and Matrix Values

	      this._scnVector3Value = null;
	      this._scnVector4Value = null;
	      this._scnMatrix4Value = null;

	      // Instance Properties

	      this._edgeInsetsValue = null;
	    }
	    /**
	     * The three-element Scene Kit vector representation of the value.
	     * @type {SCNVector3}
	     * @desc 
	     * @see https://developer.apple.com/reference/foundation/nsvalue/1409669-scnvector3value
	     */

	  }, {
	    key: 'isEqualTo',


	    // Comparing Value Objects

	    /**
	     * Returns a Boolean value that indicates whether the value object and another value object are equal.
	     * @access public
	     * @param {NSValue} value - 
	     * @returns {boolean} - 
	     * @desc The NSValue class compares the type and contents of each value object to determine equality.
	     * @see https://developer.apple.com/reference/foundation/nsvalue/1409038-isequal
	     */
	    value: function isEqualTo(value) {
	      return false;
	    }

	    // Initializers

	    /**
	     * 
	     * @access public
	     * @param {NSCoder} aDecoder - 
	     * @returns {void}
	     * @see https://developer.apple.com/reference/foundation/nsvalue/1417896-init
	     */

	  }, {
	    key: 'initCoder',
	    value: function initCoder(aDecoder) {

	      // Working with Raw Values

	      this._objCType = null;

	      // Working with Pointer and Object Values

	      this._pointerValue = null;
	      this._nonretainedObjectValue = null;

	      // Working with Range Values

	      this._rangeValue = null;

	      // Working with Foundation Geometry Values

	      this._pointValue = null;
	      this._sizeValue = null;
	      this._rectValue = null;

	      // Working with CoreGraphics Geometry Values

	      this._cgPointValue = null;
	      this._cgVectorValue = null;
	      this._cgSizeValue = null;
	      this._cgRectValue = null;
	      this._cgAffineTransformValue = null;

	      // Working with UIKit Geometry Values

	      this._uiEdgeInsetsValue = null;
	      this._uiOffsetValue = null;

	      // Working with CoreAnimation Transform Values

	      this._caTransform3DValue = null;

	      // Working with Media Time Values

	      this._timeValue = null;
	      this._timeRangeValue = null;
	      this._timeMappingValue = null;

	      // Working with Geographic Coordinate Values

	      this._mkCoordinateValue = null;
	      this._mkCoordinateSpanValue = null;

	      // Working with SceneKit Vector and Matrix Values

	      this._scnVector3Value = null;
	      this._scnVector4Value = null;
	      this._scnMatrix4Value = null;

	      // Instance Properties

	      this._edgeInsetsValue = null;
	    }

	    /**
	     * 
	     * @access public
	     * @param {EdgeInsets} insets - 
	     * @returns {void}
	     * @see https://developer.apple.com/reference/foundation/nsvalue/1391181-init
	     */

	  }, {
	    key: 'initEdgeInsets',
	    value: function initEdgeInsets(insets) {

	      // Working with Raw Values

	      this._objCType = null;

	      // Working with Pointer and Object Values

	      this._pointerValue = null;
	      this._nonretainedObjectValue = null;

	      // Working with Range Values

	      this._rangeValue = null;

	      // Working with Foundation Geometry Values

	      this._pointValue = null;
	      this._sizeValue = null;
	      this._rectValue = null;

	      // Working with CoreGraphics Geometry Values

	      this._cgPointValue = null;
	      this._cgVectorValue = null;
	      this._cgSizeValue = null;
	      this._cgRectValue = null;
	      this._cgAffineTransformValue = null;

	      // Working with UIKit Geometry Values

	      this._uiEdgeInsetsValue = null;
	      this._uiOffsetValue = null;

	      // Working with CoreAnimation Transform Values

	      this._caTransform3DValue = null;

	      // Working with Media Time Values

	      this._timeValue = null;
	      this._timeRangeValue = null;
	      this._timeMappingValue = null;

	      // Working with Geographic Coordinate Values

	      this._mkCoordinateValue = null;
	      this._mkCoordinateSpanValue = null;

	      // Working with SceneKit Vector and Matrix Values

	      this._scnVector3Value = null;
	      this._scnVector4Value = null;
	      this._scnMatrix4Value = null;

	      // Instance Properties

	      this._edgeInsetsValue = null;
	    }

	    // Instance Properties
	    /**
	     * 
	     * @type {EdgeInsets}
	     * @desc 
	     * @see https://developer.apple.com/reference/foundation/nsvalue/1391123-edgeinsetsvalue
	     */

	  }, {
	    key: 'objCType',
	    get: function get() {
	      return this._objCType;
	    }
	  }, {
	    key: 'pointerValue',
	    get: function get() {
	      return this._pointerValue;
	    }
	    /**
	     * The value as a non-retained pointer to an object.
	     * @type {?Object}
	     * @desc If the value was not created to hold a pointer-sized data item, the result is undefined.
	     * @see https://developer.apple.com/reference/foundation/nsvalue/1412287-nonretainedobjectvalue
	     */

	  }, {
	    key: 'nonretainedObjectValue',
	    get: function get() {
	      return this._nonretainedObjectValue;
	    }

	    // Working with Range Values
	    /**
	     * The Foundation range structure representation of the value.
	     * @type {NSRange}
	     * @desc 
	     * @see https://developer.apple.com/reference/foundation/nsvalue/1413902-rangevalue
	     */

	  }, {
	    key: 'rangeValue',
	    get: function get() {
	      return this._rangeValue;
	    }

	    // Working with Foundation Geometry Values
	    /**
	     * The Foundation point structure representation of the value.
	     * @type {CGPoint}
	     * @desc 
	     * @see https://developer.apple.com/reference/foundation/nsvalue/1391255-pointvalue
	     */

	  }, {
	    key: 'pointValue',
	    get: function get() {
	      return this._pointValue;
	    }
	    /**
	     * The Foundation size structure representation of the value.
	     * @type {CGSize}
	     * @desc 
	     * @see https://developer.apple.com/reference/foundation/nsvalue/1391301-sizevalue
	     */

	  }, {
	    key: 'sizeValue',
	    get: function get() {
	      return this._sizeValue;
	    }
	    /**
	     * The Foundation rectangle structure representation of the value.
	     * @type {CGRect}
	     * @desc 
	     * @see https://developer.apple.com/reference/foundation/nsvalue/1391171-rectvalue
	     */

	  }, {
	    key: 'rectValue',
	    get: function get() {
	      return this._rectValue;
	    }
	  }, {
	    key: 'cgPointValue',
	    get: function get() {
	      return this._cgPointValue;
	    }
	    /**
	     * Returns the CoreGraphics vector structure representation of the value.
	     * @type {CGVector}
	     * @desc 
	     * @see https://developer.apple.com/reference/foundation/nsvalue/1624486-cgvectorvalue
	     */

	  }, {
	    key: 'cgVectorValue',
	    get: function get() {
	      return this._cgVectorValue;
	    }
	    /**
	     * Returns the CoreGraphics size structure representation of the value.
	     * @type {CGSize}
	     * @desc 
	     * @see https://developer.apple.com/reference/foundation/nsvalue/1624489-cgsizevalue
	     */

	  }, {
	    key: 'cgSizeValue',
	    get: function get() {
	      return this._cgSizeValue;
	    }
	    /**
	     * Returns the CoreGraphics rectangle structure representation of the value.
	     * @type {CGRect}
	     * @desc 
	     * @see https://developer.apple.com/reference/foundation/nsvalue/1624506-cgrectvalue
	     */

	  }, {
	    key: 'cgRectValue',
	    get: function get() {
	      return this._cgRectValue;
	    }
	    /**
	     * Returns the CoreGraphics affine transform representation of the value.
	     * @type {CGAffineTransform}
	     * @desc 
	     * @see https://developer.apple.com/reference/foundation/nsvalue/1624512-cgaffinetransformvalue
	     */

	  }, {
	    key: 'cgAffineTransformValue',
	    get: function get() {
	      return this._cgAffineTransformValue;
	    }
	  }, {
	    key: 'uiEdgeInsetsValue',
	    get: function get() {
	      return this._uiEdgeInsetsValue;
	    }
	    /**
	     * Returns the UIKit offset structure representation of the value.
	     * @type {UIOffset}
	     * @desc 
	     * @see https://developer.apple.com/reference/foundation/nsvalue/1624526-uioffsetvalue
	     */

	  }, {
	    key: 'uiOffsetValue',
	    get: function get() {
	      return this._uiOffsetValue;
	    }
	  }, {
	    key: 'caTransform3DValue',
	    get: function get() {
	      return this._caTransform3DValue;
	    }

	    // Working with Media Time Values
	    /**
	     * The CoreMedia time structure representation of the value.
	     * @type {CMTime}
	     * @desc 
	     * @see https://developer.apple.com/reference/foundation/nsvalue/1388151-timevalue
	     */

	  }, {
	    key: 'timeValue',
	    get: function get() {
	      return this._timeValue;
	    }
	    /**
	     * The CoreMedia time range structure representation of the value.
	     * @type {CMTimeRange}
	     * @desc 
	     * @see https://developer.apple.com/reference/foundation/nsvalue/1385930-timerangevalue
	     */

	  }, {
	    key: 'timeRangeValue',
	    get: function get() {
	      return this._timeRangeValue;
	    }
	    /**
	     * The CoreMedia time mapping structure representation of the value.
	     * @type {CMTimeMapping}
	     * @desc 
	     * @see https://developer.apple.com/reference/foundation/nsvalue/1387277-timemappingvalue
	     */

	  }, {
	    key: 'timeMappingValue',
	    get: function get() {
	      return this._timeMappingValue;
	    }
	  }, {
	    key: 'mkCoordinateValue',
	    get: function get() {
	      return this._mkCoordinateValue;
	    }
	    /**
	     * The MapKit coordinate span structure representation of the value.
	     * @type {MKCoordinateSpan}
	     * @desc 
	     * @see https://developer.apple.com/reference/foundation/nsvalue/1452516-mkcoordinatespanvalue
	     */

	  }, {
	    key: 'mkCoordinateSpanValue',
	    get: function get() {
	      return this._mkCoordinateSpanValue;
	    }
	  }, {
	    key: 'scnVector3Value',
	    get: function get() {
	      return this._scnVector3Value;
	    }
	    /**
	     * The four-element Scene Kit vector representation of the value.
	     * @type {SCNVector4}
	     * @desc 
	     * @see https://developer.apple.com/reference/foundation/nsvalue/1409725-scnvector4value
	     */

	  }, {
	    key: 'scnVector4Value',
	    get: function get() {
	      return this._scnVector4Value;
	    }
	    /**
	     * The Scene Kit 4 x 4 matrix representation of the value.
	     * @type {SCNMatrix4}
	     * @desc 
	     * @see https://developer.apple.com/reference/foundation/nsvalue/1409684-scnmatrix4value
	     */

	  }, {
	    key: 'scnMatrix4Value',
	    get: function get() {
	      return this._scnMatrix4Value;
	    }
	  }, {
	    key: 'edgeInsetsValue',
	    get: function get() {
	      return this._edgeInsetsValue;
	    }
	  }]);

	  return NSValue;
	}(_NSObject3.default);

	exports.default = NSValue;

/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _CGPoint = __webpack_require__(5);

	var _CGPoint2 = _interopRequireDefault(_CGPoint);

	var _CGRect = __webpack_require__(6);

	var _CGRect2 = _interopRequireDefault(_CGRect);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	/**
	 * The root class of most Objective-C class hierarchies, from which subclasses inherit a basic interface to the runtime system and the ability to behave as Objective-C objects.
	 * @access public
	 * @see https://developer.apple.com/reference/objectivec/nsobject
	 */
	var NSObject = function () {
	  _createClass(NSObject, null, [{
	    key: 'initialize',


	    // Initializing a Class

	    /**
	     * Initializes the class before it receives its first message.
	     * @access public
	     * @returns {void}
	     * @desc The runtime sends initialize() to each class in a program just before the class, or any class that inherits from it, is sent its first message from within the program. Superclasses receive this message before their subclasses.The runtime sends the initialize() message to classes in a thread-safe manner. That is, initialize() is run by the first thread to send a message to a class, and any other thread that tries to send a message to that class will block until initialize() completes.The superclass implementation may be called multiple times if subclasses do not implement initialize()—the runtime will call the inherited implementation—or if subclasses explicitly call [super initialize]. If you want to protect yourself from being run multiple times, you can structure your implementation along these lines:+ (void)initialize {
	    if (self == [ClassName self]) {
	      // ... do the initialization ...
	    }
	    }
	    Because initialize() is called in a blocking manner, it’s important to limit method implementations to the minimum amount of work necessary possible. Specifically, any code that takes locks that might be required by other classes in their initialize() methods is liable to lead to deadlocks. Therefore, you should not rely on initialize() for complex initialization, and should instead limit it to straightforward, class local initialization.Special Considerationsinitialize() is invoked only once per class. If you want to perform independent initialization for the class and for categories of the class, you should implement load() methods.+ (void)initialize {
	    if (self == [ClassName self]) {
	      // ... do the initialization ...
	    }
	    }
	      * @see https://developer.apple.com/reference/objectivec/nsobject/1418639-initialize
	     */
	    value: function initialize() {}

	    /**
	     * Invoked whenever a class or category is added to the Objective-C runtime; implement this method to perform class-specific behavior upon loading.
	     * @access public
	     * @returns {void}
	     * @desc The load() message is sent to classes and categories that are both dynamically loaded and statically linked, but only if the newly loaded class or category implements a method that can respond.The order of initialization is as follows:All initializers in any framework you link to.All +load methods in your image.All C++ static initializers and C/C++ __attribute__(constructor) functions in your image.All initializers in frameworks that link to you.In addition:A class’s +load method is called after all of its superclasses’ +load methods.A category +load method is called after the class’s own +load method.In a custom implementation of load() you can therefore safely message other unrelated classes from the same image, but any load() methods implemented by those classes may not have run yet.ImportantCustom implementations of the load method for Swift classes bridged to Objective-C are not called automatically.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1418815-load
	     */

	  }, {
	    key: 'load',
	    value: function load() {}

	    // Creating, Copying, and Deallocating Objects

	    /**
	     * Implemented by subclasses to initialize a new object (the receiver) immediately after memory for it has been allocated.
	     * @access public
	     * @constructor
	     * @desc An init() message is coupled with an alloc (or allocWithZone:) message in the same line of code:SomeClass *object = [[SomeClass alloc] init];
	    An object isn’t ready to be used until it has been initialized.The init() method defined in the NSObject class does no initialization; it simply returns self. In terms of nullability, callers can assume that the NSObject implemetation of init() does not return nil.In a custom implementation of this method, you must invoke super’s Initialization then initialize and return the new object. If the new object can’t be initialized, the method should return nil. For example, a hypothetical BuiltInCamera class might return nil from its init method if run on a device that has no camera.- (instancetype)init {
	      self = [super init];
	      if (self) {
	          // Initialize self
	      }
	      return self;
	    }
	    In some cases, a custom implementation of the init() method might return a substitute object. You must therefore always use the object returned by init(), and not the one returned by alloc or allocWithZone:, in subsequent code.SomeClass *object = [[SomeClass alloc] init];
	    - (instancetype)init {
	      self = [super init];
	      if (self) {
	          // Initialize self
	      }
	      return self;
	    }
	      * @see https://developer.apple.com/reference/objectivec/nsobject/1418641-init
	     */

	  }]);

	  function NSObject() {
	    _classCallCheck(this, NSObject);

	    // Discardable Content Proxy Support

	    this._autoContentAccessingProxy = null;

	    // Archiving

	    this._classForArchiver = null;
	    this._classForCoder = null;
	    this._classForKeyedArchiver = null;

	    // Working with Class Descriptions

	    this._attributeKeys = null;
	    this._classDescription = null;
	    this._toManyRelationshipKeys = null;
	    this._toOneRelationshipKeys = null;

	    // Scripting

	    /**
	     * An NSString-keyed dictionary of the receiver's scriptable properties.
	     * @type {?Map<string, Object>}
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1417254-scriptingproperties
	     */
	    this.scriptingProperties = null;

	    this._classCode = 0;
	    this._className = '';

	    // Instance Properties

	    /**
	     * Returns a pointer that identifies information about all of the observers that are registered with the observed object.
	     * @type {?Object}
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1414009-observationinfo
	     */
	    this.observationInfo = null;

	    /**
	     * The activation point for the accessibility element, in screen coordinates.
	     * @type {CGPoint}
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1615179-accessibilityactivationpoint
	     */
	    this.accessibilityActivationPoint = null;

	    /**
	     * An array of custom actions to display along with the built-in actions.
	     * @type {?UIAccessibilityCustomAction[]}
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1615150-accessibilitycustomactions
	     */
	    this.accessibilityCustomActions = null;

	    /**
	     * 
	     * @type {?UIAccessibilityCustomRotor[]}
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1649788-accessibilitycustomrotors
	     */
	    this.accessibilityCustomRotors = null;

	    /**
	     * An array of the accessibility elements in the container. 
	     * @type {?Object[]}
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1615147-accessibilityelements
	     */
	    this.accessibilityElements = null;

	    /**
	     * A Boolean value indicating whether the accessibility elements contained within this accessibility element are hidden.
	     * @type {boolean}
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1615080-accessibilityelementshidden
	     */
	    this.accessibilityElementsHidden = false;

	    /**
	     * The frame of the accessibility element, in screen coordinates.
	     * @type {CGRect}
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1615111-accessibilityframe
	     */
	    this.accessibilityFrame = null;

	    /**
	     * 
	     * @type {?Object[]}
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1627578-accessibilityheaderelements
	     */
	    this.accessibilityHeaderElements = null;

	    /**
	     * A brief description of the result of performing an action on the accessibility element, in a localized string.
	     * @type {?string}
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1615093-accessibilityhint
	     */
	    this.accessibilityHint = null;

	    /**
	     * A succinct label that identifies the accessibility element, in a localized string.
	     * @type {?string}
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1615181-accessibilitylabel
	     */
	    this.accessibilityLabel = null;

	    /**
	     * The language in which to speak the accessibility element's label, value, and hint.
	     * @type {?string}
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1615192-accessibilitylanguage
	     */
	    this.accessibilityLanguage = null;

	    /**
	     * The navigation style to apply to the object and its elements.
	     * @type {UIAccessibilityNavigationStyle}
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1615200-accessibilitynavigationstyle
	     */
	    this.accessibilityNavigationStyle = null;

	    /**
	     * The path of the element, in screen coordinates.
	     * @type {?UIBezierPath}
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1615159-accessibilitypath
	     */
	    this.accessibilityPath = null;

	    /**
	     * The combination of accessibility traits that best characterize the accessibility element. 
	     * @type {UIAccessibilityTraits}
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1615202-accessibilitytraits
	     */
	    this.accessibilityTraits = null;

	    /**
	     * The value of the accessibility element, in a localized string.
	     * @type {?string}
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1615117-accessibilityvalue
	     */
	    this.accessibilityValue = null;

	    /**
	     * A Boolean value indicating whether VoiceOver should ignore the elements within views that are siblings of the receiver.
	     * @type {boolean}
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1615089-accessibilityviewismodal
	     */
	    this.accessibilityViewIsModal = false;

	    /**
	     * A Boolean value indicating whether the receiver is an accessibility element that an assistive application can access.
	     * @type {boolean}
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1615141-isaccessibilityelement
	     */
	    this.isAccessibilityElement = false;

	    /**
	     * A Boolean value indicating whether VoiceOver should group together the elements that are children of the receiver, regardless of their positions on the screen.
	     * @type {boolean}
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1615143-shouldgroupaccessibilitychildren
	     */
	    this.shouldGroupAccessibilityChildren = false;

	    this._hashValue = 0;
	    this._accessibilityFocusedUIElement = null;
	    this._accessibilityNotifiesWhenDestroyed = false;
	    this._exposedBindings = null;
	    this._objectForWebScript = null;
	    this._objectSpecifier = null;
	    this._webFrame = null;
	    this._webPlugInContainerSelectionColor = null;
	    this._isSelectable = false;
	  }

	  /**
	   * Returns the object returned by copy(with:).
	   * @access public
	   * @returns {Object} - 
	   * @desc This is a convenience method for classes that adopt the NSCopying protocol. An exception is raised if there is no implementation for copy(with:).NSObject does not itself support the NSCopying protocol. Subclasses must support the protocol and implement the copy(with:) method. A subclass version of the copy(with:) method should send the message to super first, to incorporate its implementation, unless the subclass descends directly from NSObject.
	   * @see https://developer.apple.com/reference/objectivec/nsobject/1418807-copy
	   */


	  _createClass(NSObject, [{
	    key: 'copy',
	    value: function copy() {
	      var obj = new this.constructor();
	      // TODO: copy variables
	      return obj;
	    }

	    /**
	     * Returns the object returned by mutableCopy(with:) where the zone is nil.
	     * @access public
	     * @returns {Object} - 
	     * @desc This is a convenience method for classes that adopt the NSMutableCopying protocol. An exception is raised if there is no implementation for mutableCopy(with:).
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1418978-mutablecopy
	     */

	  }, {
	    key: 'mutableCopy',
	    value: function mutableCopy() {
	      return null;
	    }

	    // Identifying Classes

	    /**
	     * Returns the class object for the receiver’s superclass.
	     * @access public
	     * @returns {?Object} - 
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1418803-superclass
	     */

	  }, {
	    key: 'methodFor',


	    // Obtaining Information About Methods

	    /**
	     * Locates and returns the address of the receiver’s implementation of a method so it can be called as a function.
	     * @access public
	     * @param {!function} aSelector - A Selector that identifies the method for which to return the implementation address. The selector must be a valid and non-NULL. If in doubt, use the responds(to:) method to check before passing the selector to method(for:).
	     * @returns {!function} - 
	     * @desc If the receiver is an instance, aSelector should refer to an instance method; if the receiver is a class, it should refer to a class method.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1418863-method
	     */
	    value: function methodFor(aSelector) {
	      return null;
	    }

	    /**
	     * Locates and returns the address of the implementation of the instance method identified by a given selector.
	     * @access public
	     * @param {!function} aSelector - A Selector that identifies the method for which to return the implementation address. The selector must be non-NULL and valid for the receiver. If in doubt, use the responds(to:) method to check before passing the selector to method(for:).
	     * @returns {!function} - 
	     * @desc An error is generated if instances of the receiver can’t respond to aSelector messages.Use this method to ask the class object for the implementation of instance methods only. To ask the class for the implementation of a class method, send the method(for:) instance method to the class instead.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1418713-instancemethod
	     */

	  }, {
	    key: 'performWithAfterDelay',


	    // Sending Messages

	    /**
	     * Invokes a method of the receiver on the current thread using the default mode after a delay.
	     * @access public
	     * @param {function} aSelector - A Selector that identifies the method to invoke. The method should not have a significant return value and should take a single argument of type id, or no arguments.
	     * @param {?Object} anArgument - The argument to pass to the method when it is invoked. Pass nil if the method does not take an argument. 
	     * @param {number} delay - The minimum time before which the message is sent. Specifying a delay of 0 does not necessarily cause the selector to be performed immediately. The selector is still queued on the thread’s run loop and performed as soon as possible.
	     * @returns {void}
	     * @desc This method sets up a timer to perform the aSelector message on the current thread’s run loop. The timer is configured to run in the default mode (NSDefaultRunLoopMode). When the timer fires, the thread attempts to dequeue the message from the run loop and perform the selector. It succeeds if the run loop is running and in the default mode; otherwise, the timer waits until the run loop is in the default mode. If you want the message to be dequeued when the run loop is in a mode other than the default mode, use the perform(_:with:afterDelay:inModes:) method instead. If you are not sure whether the current thread is the main thread, you can use the performSelector(onMainThread:with:waitUntilDone:) or performSelector(onMainThread:with:waitUntilDone:modes:) method to guarantee that your selector executes on the main thread. To cancel a queued message, use the cancelPreviousPerformRequests(withTarget:) or cancelPreviousPerformRequests(withTarget:selector:object:) method. Special ConsiderationsThis method registers with the runloop of its current context, and depends on that runloop being run on a regular basis to perform correctly. One common context where you might call this method and end up registering with a runloop that is not automatically run on a regular basis is when being invoked by a dispatch queue. If you need this type of functionality when running on a dispatch queue, you should use dispatch_after(_:_:_:) and related methods to get the behavior you want.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1416176-perform
	     */
	    value: function performWithAfterDelay(aSelector, anArgument, delay) {}

	    /**
	     * Invokes a method of the receiver on the current thread using the specified modes after a delay.
	     * @access public
	     * @param {function} aSelector - A Selector that identifies the method to invoke. The method should not have a significant return value and should take a single argument of type id, or no arguments.
	     * @param {?Object} anArgument - The argument to pass to the method when it is invoked. Pass nil if the method does not take an argument. 
	     * @param {number} delay - The minimum time before which the message is sent. Specifying a delay of 0 does not necessarily cause the selector to be performed immediately. The selector is still queued on the thread’s run loop and performed as soon as possible.
	     * @param {RunLoopMode[]} modes - An array of strings that identify the modes to associate with the timer that performs the selector. This array must contain at least one string. If you specify nil or an empty array for this parameter, this method returns without performing the specified selector. For information about run loop modes, see Run Loops in Threading Programming Guide.
	     * @returns {void}
	     * @desc This method sets up a timer to perform the aSelector message on the current thread’s run loop. The timer is configured to run in the modes specified by the modes parameter. When the timer fires, the thread attempts to dequeue the message from the run loop and perform the selector. It succeeds if the run loop is running and in one of the specified modes; otherwise, the timer waits until the run loop is in one of those modes. If you want the message to be dequeued when the run loop is in a mode other than the default mode, use the perform(_:with:afterDelay:inModes:) method instead. If you are not sure whether the current thread is the main thread, you can use the performSelector(onMainThread:with:waitUntilDone:) or performSelector(onMainThread:with:waitUntilDone:modes:) method to guarantee that your selector executes on the main thread. To cancel a queued message, use the cancelPreviousPerformRequests(withTarget:) or cancelPreviousPerformRequests(withTarget:selector:object:) method. Special ConsiderationsThis method registers with the runloop of its current context, and depends on that runloop being run on a regular basis to perform correctly. One common context where you might call this method and end up registering with a runloop that is not automatically run on a regular basis is when being invoked by a dispatch queue. If you need this type of functionality when running on a dispatch queue, you should use dispatch_after(_:_:_:) and related methods to get the behavior you want.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1415652-perform
	     */

	  }, {
	    key: 'performWithAfterDelayInModes',
	    value: function performWithAfterDelayInModes(aSelector, anArgument, delay, modes) {}

	    /**
	     * Invokes a method of the receiver on the main thread using the default mode.
	     * @access public
	     * @param {function} aSelector - A Selector that identifies the method to invoke. The method should not have a significant return value and should take a single argument of type id, or no arguments.
	     * @param {?Object} arg - The argument to pass to the method when it is invoked. Pass nil if the method does not take an argument.
	     * @param {boolean} wait - A Boolean that specifies whether the current thread blocks until after the specified selector is performed on the receiver on the main thread. Specify true to block this thread; otherwise, specify false to have this method return immediately.If the current thread is also the main thread, and you specify true for this parameter, the message is delivered and processed immediately. 
	     * @returns {void}
	     * @desc You can use this method to deliver messages to the main thread of your application. The main thread encompasses the application’s main run loop, and is where the NSApplication object receives events. The message in this case is a method of the current object that you want to execute on the thread. This method queues the message on the run loop of the main thread using the common run loop modes—that is, the modes associated with the commonModes constant. As part of its normal run loop processing, the main thread dequeues the message (assuming it is running in one of the common run loop modes) and invokes the desired method. Multiple calls to this method from the same thread cause the corresponding selectors to be queued and performed in the same same order in which the calls were made.You cannot cancel messages queued using this method. If you want the option of canceling a message on the current thread, you must use either the perform(_:with:afterDelay:) or perform(_:with:afterDelay:inModes:) method.Special ConsiderationsThis method registers with the runloop of its current context, and depends on that runloop being run on a regular basis to perform correctly. One common context where you might call this method and end up registering with a runloop that is not automatically run on a regular basis is when being invoked by a dispatch queue. If you need this type of functionality when running on a dispatch queue, you should use dispatch_after(_:_:_:) and related methods to get the behavior you want.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1414900-performselector
	     */

	  }, {
	    key: 'performSelectorOnMainThreadWithWaitUntilDone',
	    value: function performSelectorOnMainThreadWithWaitUntilDone(aSelector, arg, wait) {}

	    /**
	     * Invokes a method of the receiver on the main thread using the specified modes.
	     * @access public
	     * @param {function} aSelector - A Selector that identifies the method to invoke. The method should not have a significant return value and should take a single argument of type id, or no arguments.
	     * @param {?Object} arg - The argument to pass to the method when it is invoked. Pass nil if the method does not take an argument.
	     * @param {boolean} wait - A Boolean that specifies whether the current thread blocks until after the specified selector is performed on the receiver on the main thread. Specify true to block this thread; otherwise, specify false to have this method return immediately.If the current thread is also the main thread, and you pass true, the message is performed immediately, otherwise the perform is queued to run the next time through the run loop.
	     * @param {?string[]} array - An array of strings that identifies the modes in which it is permissible to perform the specified selector. This array must contain at least one string. If you specify nil or an empty array for this parameter, this method returns without performing the specified selector. For information about run loop modes, see Run Loops in Threading Programming Guide.
	     * @returns {void}
	     * @desc You can use this method to deliver messages to the main thread of your application. The main thread encompasses the application’s mai run loop, and is where the NSApplication object receives events. The message in this case is a method of the current object that you want to execute on the thread. This method queues the message on the run loop of the main thread using the run loop modes specified in the array parameter. As part of its normal run loop processing, the main thread dequeues the message (assuming it is running in one of the specified modes) and invokes the desired method. Multiple calls to this method from the same thread cause the corresponding selectors to be queued and performed in the same same order in which the calls were made, assuming the associated run loop modes for each selector are the same. If you specify different modes for each selector, any selectors whose associated mode does not match the current run loop mode are skipped until the run loop subsequently executes in that mode.You cannot cancel messages queued using this method. If you want the option of canceling a message on the current thread, you must use either the perform(_:with:afterDelay:) or perform(_:with:afterDelay:inModes:) method.Special ConsiderationsThis method registers with the runloop of its current context, and depends on that runloop being run on a regular basis to perform correctly. One common context where you might call this method and end up registering with a runloop that is not automatically run on a regular basis is when being invoked by a dispatch queue. If you need this type of functionality when running on a dispatch queue, you should use dispatch_after(_:_:_:) and related methods to get the behavior you want.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1411637-performselector
	     */

	  }, {
	    key: 'performSelectorOnMainThreadWithWaitUntilDoneModes',
	    value: function performSelectorOnMainThreadWithWaitUntilDoneModes(aSelector, arg, wait, array) {}

	    /**
	     * Invokes a method of the receiver on the specified thread using the default mode.
	     * @access public
	     * @param {function} aSelector - A Selector that identifies the method to invoke. The method should not have a significant return value and should take a single argument of type id, or no arguments.
	     * @param {Thread} thr - 
	     * @param {?Object} arg - The argument to pass to the method when it is invoked. Pass nil if the method does not take an argument.
	     * @param {boolean} wait - A Boolean that specifies whether the current thread blocks until after the specified selector is performed on the receiver on the specified thread. Specify true to block this thread; otherwise, specify false to have this method return immediately.If the current thread and target thread are the same, and you specify true for this parameter, the selector is performed immediately on the current thread. If you specify false, this method queues the message on the thread’s run loop and returns, just like it does for other threads. The current thread must then dequeue and process the message when it has an opportunity to do so.
	     * @returns {void}
	     * @desc You can use this method to deliver messages to other threads in your application. The message in this case is a method of the current object that you want to execute on the target thread. This method queues the message on the run loop of the target thread using the default run loop modes—that is, the modes associated with the commonModes constant. As part of its normal run loop processing, the target thread dequeues the message (assuming it is running in one of the default run loop modes) and invokes the desired method.You cannot cancel messages queued using this method. If you want the option of canceling a message on the current thread, you must use either the perform(_:with:afterDelay:) or perform(_:with:afterDelay:inModes:) method.Special ConsiderationsThis method registers with the runloop of its current context, and depends on that runloop being run on a regular basis to perform correctly. One common context where you might call this method and end up registering with a runloop that is not automatically run on a regular basis is when being invoked by a dispatch queue. If you need this type of functionality when running on a dispatch queue, you should use dispatch_after(_:_:_:) and related methods to get the behavior you want.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1414476-perform
	     */

	  }, {
	    key: 'performOnWithWaitUntilDone',
	    value: function performOnWithWaitUntilDone(aSelector, thr, arg, wait) {}

	    /**
	     * Invokes a method of the receiver on the specified thread using the specified modes.
	     * @access public
	     * @param {function} aSelector - A Selector that identifies the method to invoke. It should not have a significant return value and should take a single argument of type id, or no arguments.
	     * @param {Thread} thr - 
	     * @param {?Object} arg - The argument to pass to the method when it is invoked. Pass nil if the method does not take an argument.
	     * @param {boolean} wait - A Boolean that specifies whether the current thread blocks until after the specified selector is performed on the receiver on the specified thread. Specify true to block this thread; otherwise, specify false to have this method return immediately. If the current thread and target thread are the same, and you specify true for this parameter, the selector is performed immediately. If you specify false, this method queues the message and returns immediately, regardless of whether the threads are the same or different.
	     * @param {?string[]} array - An array of strings that identifies the modes in which it is permissible to perform the specified selector. This array must contain at least one string. If you specify nil or an empty array for this parameter, this method returns without performing the specified selector. For information about run loop modes, see Run Loops in Threading Programming Guide.
	     * @returns {void}
	     * @desc You can use this method to deliver messages to other threads in your application. The message in this case is a method of the current object that you want to execute on the target thread. This method queues the message on the run loop of the target thread using the run loop modes specified in the array parameter. As part of its normal run loop processing, the target thread dequeues the message (assuming it is running in one of the specified modes) and invokes the desired method. You cannot cancel messages queued using this method. If you want the option of canceling a message on the current thread, you must use either the perform(_:with:afterDelay:) or perform(_:with:afterDelay:inModes:) method instead. Special ConsiderationsThis method registers with the runloop of its current context, and depends on that runloop being run on a regular basis to perform correctly. One common context where you might call this method and end up registering with a runloop that is not automatically run on a regular basis is when being invoked by a dispatch queue. If you need this type of functionality when running on a dispatch queue, you should use dispatch_after(_:_:_:) and related methods to get the behavior you want.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1417922-perform
	     */

	  }, {
	    key: 'performOnWithWaitUntilDoneModes',
	    value: function performOnWithWaitUntilDoneModes(aSelector, thr, arg, wait, array) {}

	    /**
	     * Invokes a method of the receiver on a new background thread.
	     * @access public
	     * @param {function} aSelector - A Selector that identifies the method to invoke. The method should not have a significant return value and should take a single argument of type id, or no arguments.
	     * @param {?Object} arg - The argument to pass to the method when it is invoked. Pass nil if the method does not take an argument.
	     * @returns {void}
	     * @desc This method creates a new thread in your application, putting your application into multithreaded mode if it was not already. The method represented by aSelector must set up the thread environment just as you would for any other new thread in your program. For more information about how to configure and run threads, see Threading Programming Guide. 
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1412390-performselector
	     */

	  }, {
	    key: 'performSelectorInBackgroundWith',
	    value: function performSelectorInBackgroundWith(aSelector, arg) {}

	    /**
	     * Cancels perform requests previously registered with the perform(_:with:afterDelay:) instance method.
	     * @access public
	     * @param {Object} aTarget - The target for requests previously registered with the perform(_:with:afterDelay:) instance method.
	     * @returns {void}
	     * @desc All perform requests having the same target aTarget are canceled. This method removes perform requests only in the current run loop, not all run loops.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1417611-cancelpreviousperformrequests
	     */

	  }, {
	    key: 'forwardingTargetFor',


	    // Forwarding Messages

	    /**
	     * Returns the object to which unrecognized messages should first be directed.
	     * @access public
	     * @param {!function} aSelector - A Selector for a method that the receiver does not implement.
	     * @returns {?Object} - 
	     * @desc If an object implements (or inherits) this method, and returns a non-nil (and non-self) result, that returned object is used as the new receiver object and the message dispatch resumes to that new object. (Obviously if you return self from this method, the code would just fall into an infinite loop.)If you implement this method in a non-root class, if your class has nothing to return for the given selector then you should return the result of invoking super’s implementation. This method gives an object a chance to redirect an unknown message sent to it before the much more expensive forwardInvocation: machinery takes over. This is useful when you simply want to redirect messages to another object and can be an order of magnitude faster than regular forwarding. It is not useful where the goal of the forwarding is to capture the NSInvocation, or manipulate the arguments or return value during the forwarding.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1418855-forwardingtarget
	     */
	    value: function forwardingTargetFor(aSelector) {
	      return null;
	    }

	    // Dynamically Resolving Methods

	    /**
	     * Dynamically provides an implementation for a given selector for a class method.
	     * @access public
	     * @param {!function} sel - 
	     * @returns {boolean} - 
	     * @desc This method allows you to dynamically provide an implementation for a given selector. See resolveInstanceMethod(_:) for further discussion.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1418889-resolveclassmethod
	     */

	  }, {
	    key: 'doesNotRecognizeSelector',


	    // Error Handling

	    /**
	     * Handles messages the receiver doesn’t recognize.
	     * @access public
	     * @param {!function} aSelector - A Selector that identifies a method not implemented or recognized by the receiver.
	     * @returns {void}
	     * @desc The runtime system invokes this method whenever an object receives an aSelector message it can’t respond to or forward. This method, in turn, raises an NSInvalidArgumentException, and generates an error message. Any doesNotRecognizeSelector(_:) messages are generally sent only by the runtime system. However, they can be used in program code to prevent a method from being inherited. For example, an NSObject subclass might renounce the copy() or init() method by re-implementing it to include a doesNotRecognizeSelector(_:) message as follows:- (id)copy
	    {
	      [self doesNotRecognizeSelector:_cmd];
	    }
	    The _cmd variable is a hidden argument passed to every method that is the current selector; in this example, it identifies the selector for the copy method. This code prevents instances of the subclass from responding to copy messages or superclasses from forwarding copy messages—although responds(to:) will still report that the receiver has access to a copy method.If you override this method, you must call super or raise an invalidArgumentException exception at the end of your implementation. In other words, this method must not return normally; it must always result in an exception being thrown. - (id)copy
	    {
	      [self doesNotRecognizeSelector:_cmd];
	    }
	      * @see https://developer.apple.com/reference/objectivec/nsobject/1418637-doesnotrecognizeselector
	     */
	    value: function doesNotRecognizeSelector(aSelector) {}

	    // Archiving

	    /**
	     * Overridden by subclasses to substitute another object in place of the object that was decoded and subsequently received this message.
	     * @access public
	     * @param {NSCoder} aDecoder - The decoder used to decode the receiver.
	     * @returns {?Object} - 
	     * @desc You can use this method to eliminate redundant objects created by the coder. For example, if after decoding an object you discover that an equivalent object already exists, you can return the existing object. If a replacement is returned, your overriding method is responsible for releasing the receiver. This method is invoked by NSCoder. NSObject’s implementation simply returns self.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1417074-awakeafter
	     */

	  }, {
	    key: 'awakeAfterUsing',
	    value: function awakeAfterUsing(aDecoder) {
	      return null;
	    }

	    /**
	     * Overridden to return the names of classes that can be used to decode objects if their class is unavailable.
	     * @access public
	     * @returns {string[]} - 
	     * @desc NSKeyedArchiver calls this method and stores the result inside the archive. If the actual class of an object doesn’t exist at the time of unarchiving, NSKeyedUnarchiver goes through the stored list of classes and uses the first one that does exists as a substitute class for decoding the object. The default implementation of this method returns nil.You can use this method if you introduce a new class into your application to provide some backwards compatibility in case the archive will be read on a system that does not have that class. Sometimes there may be another class which may work nearly as well as a substitute for the new class, and the archive keys and archived state for the new class can be carefully chosen (or compatibility written out) so that the object can be unarchived as the substitute class if necessary.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1411048-classfallbacksforkeyedarchiver
	     */

	  }, {
	    key: 'replacementObjectFor',


	    /**
	     * Overridden by subclasses to substitute another object for itself during encoding.
	     * @access public
	     * @param {NSCoder} aCoder - The coder encoding the receiver.
	     * @returns {?Object} - 
	     * @desc An object might encode itself into an archive, but encode a proxy for itself if it’s being encoded for distribution. This method is invoked by NSCoder. NSObject’s implementation returns self.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1416843-replacementobject
	     */
	    value: function replacementObjectFor(aCoder) {
	      return null;
	    }

	    /**
	     * Sets the receiver's version number.
	     * @access public
	     * @param {number} aVersion - The version number for the receiver.
	     * @returns {void}
	     * @desc The version number is helpful when instances of the class are to be archived and reused later. The default version is 0.Special ConsiderationsThe version number applies to NSArchiver/NSUnarchiver, but not to NSKeyedArchiver/NSKeyedUnarchiver.  A keyed archiver does not encode class version numbers.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1416538-setversion
	     */

	  }, {
	    key: 'inverseForRelationshipKey',


	    // Working with Class Descriptions

	    /**
	     * For a given key that defines the name of the relationship from the receiver’s class to another class, returns the name of the relationship from the other class to the receiver’s class.
	     * @access public
	     * @param {string} relationshipKey - The name of the relationship from the receiver’s class to another class.
	     * @returns {?string} - 
	     * @desc NSObject’s implementation of inverseForRelationshipKey: simply invokes [[self classDescription] inverseForRelationshipKey:relationshipKey].  To make use of the default implementation, you must therefore implement and register a suitable class description—see NSClassDescription.For example, suppose an Employee class has a relationship named department to a Department class, and that Department has a relationship called employees to Employee. The statement:employee inverseForRelationshipKey:@"department"];
	    returns the string employees.employee inverseForRelationshipKey:@"department"];
	      * @see https://developer.apple.com/reference/objectivec/nsobject/1411046-inverse
	     */
	    value: function inverseForRelationshipKey(relationshipKey) {
	      return null;
	    }
	    /**
	     * An array of NSString objects containing the names of immutable values that instances of the receiver's class contain.
	     * @type {string[]}
	     * @desc NSObject’s implementation of attributeKeys simply calls [[self classDescription] attributeKeys]. To make use of the default implementation, you must therefore implement and register a suitable class description—see NSClassDescription. 
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1415656-attributekeys
	     */

	  }, {
	    key: 'copyScriptingValueForKeyWithProperties',


	    // Scripting

	    /**
	     * Creates and returns one or more scripting objects to be inserted into the specified relationship by copying the passed-in value and setting the properties in the copied object or objects.
	     * @access public
	     * @param {Object} value - An object or objects to be copied. The type must match the type of the property identified by key. (See also the Discussion section.)For example, if the property is a to-many relationship, value will always be an array of objects to be copied, and this method must therefore return an array of objects.
	     * @param {string} key - A key that identifies the relationship into which to insert the copied object or objects.
	     * @param {Map<string, Object>} properties - The properties to be set in the copied object or objects.  Derived from the "with properties" parameter of a duplicate command. (See also the Discussion section.)
	     * @returns {?Object} - 
	     * @desc You can override the copyScriptingValue method to take more control when your application is sent a duplicate command. This method is invoked on the prospective container of the copied object or objects. The properties are derived from the with properties parameter of the duplicate command. The returned objects or objects are then inserted into the container using key-value coding. When this method is invoked by Cocoa, neither the value nor the properties will have yet been coerced using the NSScriptKeyValueCoding method coerceValue(_:forKey:). For sdef-declared scriptability, however, the types of the passed-in objects reliably match the relevant sdef declarations.The default implementation of this method copies scripting objects by sending copyWithZone: to the object or objects specified by value. You override this method for situations where this is not sufficient, such as in Core Data applications, in which new objects must be initialized with [NSManagedObject initWithEntity:insertIntoManagedObjectContext:].
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1410291-copyscriptingvalue
	     */
	    value: function copyScriptingValueForKeyWithProperties(value, key, properties) {
	      return null;
	    }

	    /**
	     * Creates and returns an instance of a scriptable class, setting its contents and properties, for insertion into the relationship identified by the key.
	     * @access public
	     * @param {Object} objectClass - 
	     * @param {string} key - A key that identifies the relationship into which the new class object will be inserted.
	     * @param {?Object} contentsValue - Specifies the contents of the object to be created. This may be nil. (See also the Discussion section.)
	     * @param {Map<string, Object>} properties - The properties to be set in the new object. (See also the Discussion section.)
	     * @returns {?Object} - 
	     * @desc You can override the newScriptingObjectOfClass method to take more control when your application is sent a make command. This method is invoked on the prospective container of the new object. The contentsValue and properties are derived from the with contents and with properties parameters of the make command. The returned objects or objects are then inserted into the container using key-value coding.When this method is invoked by Cocoa, neither the contents value nor the properties will have yet been coerced using the NSScriptKeyValueCoding method coerceValue(_:forKey:). For sdef-declared scriptability, however, the types of the passed-in objects reliably match the relevant sdef declarations.The default implementation of this method creates new scripting objects by sending alloc to a class and init to the resulting object. You override this method for situations where this is not sufficient, such as in Core Data applications, in which new objects must be initialized with [NSManagedObject initWithEntity:insertIntoManagedObjectContext:].
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1418458-newscriptingobject
	     */

	  }, {
	    key: 'newScriptingObjectOfForValueForKeyWithContentsValue',
	    value: function newScriptingObjectOfForValueForKeyWithContentsValue(objectClass, key, contentsValue, properties) {
	      return null;
	    }

	    /**
	     * Given an object specifier, returns the specified object or objects in the receiving container.
	     * @access public
	     * @param {NSScriptObjectSpecifier} objectSpecifier - An object specifier to be evaluated.
	     * @returns {?Object} - 
	     * @desc You can override this method to customize the evaluation of object specifiers without requiring that the scripting container make up indexes for contained objects that don't naturally have indexes (as can be the case if you implement indicesOfObjects(byEvaluatingObjectSpecifier:) instead).Your override of this method doesn't need to also invoke any of the NSScriptCommand error signaling methods, though it can, to record very specific information. The NSUnknownKeySpecifierError and NSInvalidIndexSpecifierError numbers are special, in that Cocoa may continue evaluating an outer specifier if they're encountered, for the convenience of scripters.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1409268-scriptingvalue
	     */

	  }, {
	    key: 'scriptingValueFor',
	    value: function scriptingValueFor(objectSpecifier) {
	      return null;
	    }
	    /**
	     * The receiver's Apple event type code, as stored in the NSScriptClassDescription object for the object’s class.
	     * @type {number}
	     * @desc This property is used by Cocoa’s scripting support classes.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1413991-classcode
	     */

	  }, {
	    key: 'finalize',


	    // Deprecated Methods

	    /**
	     * The garbage collector invokes this method on the receiver before disposing of the memory it uses.
	     * @deprecated
	     * @access public
	     * @returns {void}
	     * @desc The garbage collector invokes this method on the receiver before disposing of the memory it uses. When garbage collection is enabled, this method is invoked instead of dealloc.You can override this method to relinquish resources the receiver has obtained, as shown in the following example:- (void)finalize {
	      if (log_file != NULL) {
	          fclose(log_file);
	          log_file = NULL;
	      }
	      [super finalize];
	    }
	    Typically, however, you are encouraged to relinquish resources prior to finalization if at all possible. For more details, see Implementing a finalize Method.Special ConsiderationsIt is an error to store self into a new or existing live object (colloquially known as “resurrection”), which implies that this method will be called only once. However, the receiver may be messaged after finalization by other objects also being finalized at this time, so your override should guard against future use of resources that have been reclaimed, as shown by the log_file = NULL statement in the example. The finalize method itself will never be invoked more than once for a given object.Importantfinalize methods must be thread-safe.- (void)finalize {
	      if (log_file != NULL) {
	          fclose(log_file);
	          log_file = NULL;
	      }
	      [super finalize];
	    }
	      * @see https://developer.apple.com/reference/objectivec/nsobject/1418513-finalize
	     */
	    value: function finalize() {}

	    // Instance Properties
	    /**
	     * 
	     * @type {number}
	     * @desc 
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1418615-hashvalue
	     */

	  }, {
	    key: 'addObserverForKeyPath',


	    // Instance Methods

	    /**
	     * Registers the observer object to receive KVO notifications for the key path relative to the object receiving this message.
	     * @access public
	     * @param {NSObject} observer - The object to register for KVO notifications. The observer must implement the key-value observing method observeValue(forKeyPath:of:change:context:).
	     * @param {string} keyPath - The key path, relative to the object receiving this message, of the property to observe. This value must not be nil.
	     * @param {NSKeyValueObservingOptions} [options = []] - A combination of the NSKeyValueObservingOptions values that specifies what is included in observation notifications. For possible values, see NSKeyValueObservingOptions.
	     * @param {?Object} context - Arbitrary data that is passed to observer in observeValue(forKeyPath:of:change:context:).
	     * @returns {void}
	     * @desc Neither the object receiving this message, nor observer, are retained. An object that calls this method must also eventually call either the removeObserver(_:forKeyPath:) or removeObserver(_:forKeyPath:context:) method to unregister the observer when participating in KVO.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1412787-addobserver
	     */
	    value: function addObserverForKeyPath(observer, keyPath) {
	      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
	      var context = arguments[3];
	    }

	    /**
	     * Implemented to attempt a recovery from an error noted in an application-modal dialog.
	     * @access public
	     * @param {Error} error - An NSError object that describes the error, including error recovery options.
	     * @param {number} recoveryOptionIndex - The index of the user selected recovery option in error's localized recovery array.
	     * @returns {boolean} - 
	     * @desc Invoked when an error alert is been presented to the user in an application-modal dialog, and the user has selected an error recovery option specified by error.  
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1416402-attemptrecovery
	     */

	  }, {
	    key: 'attemptRecoveryFromErrorOptionIndex',
	    value: function attemptRecoveryFromErrorOptionIndex(error, recoveryOptionIndex) {
	      return false;
	    }

	    /**
	     * Returns a dictionary containing the property values identified by each of the keys in a given array.
	     * @access public
	     * @param {string[]} keys - An array containing NSString objects that identify properties of the receiver.
	     * @returns {Map<string, Object>} - 
	     * @desc The default implementation invokes value(forKey:) for each key in keys and substitutes NSNull values in the dictionary for returned nil values.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1411319-dictionarywithvalues
	     */

	  }, {
	    key: 'dictionaryWithValuesForKeys',
	    value: function dictionaryWithValuesForKeys(keys) {
	      return null;
	    }

	    /**
	     * Informs the observed object that the specified change has occurred on the indexes for a specified ordered to-many relationship.
	     * @access public
	     * @param {NSKeyValueChange} changeKind - 
	     * @param {Set} indexes - The indexes of the to-many relationship that were affected by the change.
	     * @param {string} key - The name of a property that is an ordered to-many relationship.
	     * @returns {void}
	     * @desc Use this method when implementing key-value-observing compliance manually.Special ConsiderationsYou rarely need to override this method in subclasses, but if you do, be sure to call super. Calls to this method are always paired with a matching call to willChange(_:valuesAt:forKey:).
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1415349-didchange
	     */

	  }, {
	    key: 'didChangeValuesAtForKey',
	    value: function didChangeValuesAtForKey(changeKind, indexes, key) {}

	    /**
	     * Informs the observed object that the value of a given property has changed.
	     * @access public
	     * @param {string} key - The name of the property that changed.
	     * @returns {void}
	     * @desc Use this method when implementing key-value observer compliance manually to inform the observed object that the value at key has just changed. Calls to this method are always paired with a matching call to willChangeValue(forKey:).Special ConsiderationsYou rarely need to override this method in subclasses, but if you do, be sure to call super.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1411809-didchangevalue
	     */

	  }, {
	    key: 'didChangeValueForKey',
	    value: function didChangeValueForKey(key) {}

	    /**
	     * Informs the observed object that the specified change was made to a specified unordered to-many relationship.
	     * @access public
	     * @param {string} key - The name of a property that is an unordered to-many relationship
	     * @param {NSKeyValueSetMutationKind} mutationKind - The type of change that was made.
	     * @param {Set<AnyHashable>} objects - The objects that were involved in the change (see NSKeyValueSetMutationKind).
	     * @returns {void}
	     * @desc Use this method when implementing key-value observer compliance manually. Calls to this method are always paired with a matching call to willChangeValue(forKey:withSetMutation:using:).Special ConsiderationsYou rarely need to override this method in subclasses, but if you do, be sure to call super.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1410539-didchangevalue
	     */

	  }, {
	    key: 'didChangeValueForKeyWithSetMutationUsing',
	    value: function didChangeValueForKeyWithSetMutationUsing(key, mutationKind, objects) {}

	    /**
	     * An NSFileManager object sends this message to its handler for each error it encounters when copying, moving, removing, or linking files or directories. 
	     * @deprecated
	     * @access public
	     * @param {FileManager} fm - 
	     * @param {Map<AnyHashable, Object>} errorInfo - A dictionary that contains two or three pieces of information (all NSString objects) related to the error:KeyValue@"Path"The path related to the error (usually the source path)@"Error"A description of the error@"ToPath" The destination path (not all errors)
	     * @returns {boolean} - 
	     * @desc An NSFileManager object, manager, sends this message for each error it encounters when copying, moving, removing, or linking files or directories. The return value is passed back to the invoker of copyPath:toPath:handler:, movePath:toPath:handler:, removeFileAtPath:handler:, or linkPath:toPath:handler:. If an error occurs and your handler has not implemented this method, the invoking method automatically returns false.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1557005-filemanager
	     */

	  }, {
	    key: 'fileManagerShouldProceedAfterError',
	    value: function fileManagerShouldProceedAfterError(fm, errorInfo) {
	      return false;
	    }

	    /**
	     * An NSFileManager object sends this message to a handler immediately before attempting to move, copy, rename, or delete, or before attempting to link to a given path.
	     * @deprecated
	     * @access public
	     * @param {FileManager} fm - 
	     * @param {string} path - The path or a file or directory that manager is about to attempt to move, copy, rename, delete, or link to.
	     * @returns {void}
	     * @desc You can implement this method in your handler to monitor file operations.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1557002-filemanager
	     */

	  }, {
	    key: 'fileManagerWillProcessPath',
	    value: function fileManagerWillProcessPath(fm, path) {}

	    /**
	     * Returns a mutable array proxy that provides read-write access to an ordered to-many relationship specified by a given key.
	     * @access public
	     * @param {string} key - The name of an ordered to-many relationship.
	     * @returns {Array} - 
	     * @desc Objects added to the mutable array become related to the receiver, and objects removed from the mutable array become unrelated. The default implementation recognizes the same simple accessor methods and array accessor methods as value(forKey:), and follows the same direct instance variable access policies, but always returns a mutable collection proxy object instead of the immutable collection that value(forKey:) would return. The search pattern that mutableArrayValueForKey: uses is described in Accessor Search Patterns in Key-Value Coding Programming Guide.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1416339-mutablearrayvalue
	     */

	  }, {
	    key: 'mutableArrayValueForKey',
	    value: function mutableArrayValueForKey(key) {
	      return null;
	    }

	    /**
	     * Returns a mutable array that provides read-write access to the ordered to-many relationship specified by a given key path.
	     * @access public
	     * @param {string} keyPath - A key path, relative to the receiver, to an ordered to-many relationship.
	     * @returns {Array} - 
	     * @desc See mutableArrayValue(forKey:) for additional details.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1414937-mutablearrayvalue
	     */

	  }, {
	    key: 'mutableArrayValueForKeyPath',
	    value: function mutableArrayValueForKeyPath(keyPath) {
	      return null;
	    }

	    /**
	     * Returns a mutable ordered set that provides read-write access to the uniquing ordered to-many relationship specified by a given key.
	     * @access public
	     * @param {string} key - The name of a uniquing ordered to-many relationship.
	     * @returns {Set} - 
	     * @desc Objects added to the mutable set proxy become related to the receiver, and objects removed from the mutable set become unrelated. The default implementation recognizes the same simple accessor methods and set accessor methods as value(forKey:), and follows the same direct instance variable access policies, but always returns a mutable collection proxy object instead of the immutable collection that value(forKey:) would return. The search pattern that mutableOrderedSetValueForKey: uses is described in Accessor Search Patterns in Key-Value Coding Programming Guide.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1415479-mutableorderedsetvalue
	     */

	  }, {
	    key: 'mutableOrderedSetValueForKey',
	    value: function mutableOrderedSetValueForKey(key) {
	      return null;
	    }

	    /**
	     * Returns a mutable ordered set that provides read-write access to the uniquing ordered to-many relationship specified by a given key path.
	     * @access public
	     * @param {string} keyPath - A key path, relative to the receiver, to a uniquing ordered to-many relationship represented by a set.
	     * @returns {Set} - 
	     * @desc See mutableOrderedSetValue(forKey:) for additional details.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1407188-mutableorderedsetvalue
	     */

	  }, {
	    key: 'mutableOrderedSetValueForKeyPath',
	    value: function mutableOrderedSetValueForKeyPath(keyPath) {
	      return null;
	    }

	    /**
	     * Returns a mutable set proxy that provides read-write access to the unordered to-many relationship specified by a given key.
	     * @access public
	     * @param {string} key - The name of an unordered to-many relationship.
	     * @returns {Set} - 
	     * @desc Objects added to the mutable set proxy become related to the receiver, and objects removed from the mutable set become unrelated. The default implementation recognizes the same simple accessor methods and set accessor methods as value(forKey:), and follows the same direct instance variable access policies, but always returns a mutable collection proxy object instead of the immutable collection that value(forKey:) would return. The search pattern that mutableSetValueForKey: uses is described in Accessor Search Patterns in Key-Value Coding Programming Guide.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1415105-mutablesetvalue
	     */

	  }, {
	    key: 'mutableSetValueForKey',
	    value: function mutableSetValueForKey(key) {
	      return null;
	    }

	    /**
	     * Returns a mutable set that provides read-write access to the unordered to-many relationship specified by a given key path.
	     * @access public
	     * @param {string} keyPath - A key path, relative to the receiver, to an unordered to-many relationship.
	     * @returns {Set} - 
	     * @desc See mutableSetValue(forKey:) for additional details.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1408115-mutablesetvalue
	     */

	  }, {
	    key: 'mutableSetValueForKeyPath',
	    value: function mutableSetValueForKeyPath(keyPath) {
	      return null;
	    }

	    /**
	     * Informs the observing object when the value at the specified key path relative to the observed object has changed.
	     * @access public
	     * @param {?string} keyPath - The key path, relative to object, to the value that has changed.
	     * @param {?Object} object - The source object of the key path keyPath. 
	     * @param {?Map<NSKeyValueChangeKey, Object>} change - A dictionary that describes the changes that have been made to the value of the property at the key path keyPath relative to object. Entries are described in Change Dictionary Keys.
	     * @param {?Object} context - The value that was provided when the observer was registered to receive key-value observation notifications.
	     * @returns {void}
	     * @desc For an object to begin sending change notification messages for the value at keyPath, you send it an addObserver(_:forKeyPath:options:context:) message, naming the observing object that should receive the messages. When you are done observing, and in particular before the observing object is deallocated, you send the observed object a removeObserver(_:forKeyPath:) or removeObserver(_:forKeyPath:context:) message to unregister the observer, and stop sending change notification messages.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1416553-observevalue
	     */

	  }, {
	    key: 'observeValueForKeyPathOf',
	    value: function observeValueForKeyPathOf(keyPath, object, change, context) {}

	    /**
	     * Stops the observer object from receiving change notifications for the property specified by the key path relative to the object receiving this message.
	     * @access public
	     * @param {NSObject} observer - The object to remove as an observer.
	     * @param {string} keyPath - A key-path, relative to the object receiving this message, for which observer is registered to receive KVO change notifications.
	     * @returns {void}
	     * @desc It is an error to call removeObserver(_:forKeyPath:) for an object that has not previously been registered as an observer.Be sure to invoke this method (or removeObserver(_:forKeyPath:context:)) before any object specified in addObserver(_:forKeyPath:options:context:) is deallocated.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1408054-removeobserver
	     */

	  }, {
	    key: 'removeObserverForKeyPath',
	    value: function removeObserverForKeyPath(observer, keyPath) {}

	    /**
	     * Invoked by setValue(_:forKey:) when it’s given a nil value for a scalar value (such as an int or float).
	     * @access public
	     * @param {string} key - The name of one of the receiver's properties.
	     * @returns {void}
	     * @desc Subclasses can override this method to handle the request in some other way, such as by substituting 0 or a sentinel value for nil and invoking setValue(_:forKey:) again or setting the variable directly. The default implementation raises an NSInvalidArgumentException. 
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1415174-setnilvalueforkey
	     */

	  }, {
	    key: 'setNilValueForKey',
	    value: function setNilValueForKey(key) {}

	    /**
	     * Sets the property of the receiver specified by a given key to a given value.
	     * @access public
	     * @param {?Object} value - The value for the property identified by key.
	     * @param {string} key - The name of one of the receiver's properties.
	     * @returns {void}
	     * @desc If key identifies a to-one relationship, relate the object specified by value to the receiver, unrelating the previously related object if there was one. Given a collection object and a key that identifies a to-many relationship, relate the objects contained in the collection to the receiver, unrelating previously related objects if there were any.  The search pattern that setValue:forKey: uses is described in Accessor Search Patterns in Key-Value Coding Programming Guide.In a reference-counted environment, if the instance variable is accessed directly, value is retained.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1415969-setvalue
	     */

	  }, {
	    key: 'setValueForKey',
	    value: function setValueForKey(value, key) {}

	    /**
	     * Sets the value for the property identified by a given key path to a given value.
	     * @access public
	     * @param {?Object} value - The value for the property identified by keyPath.
	     * @param {string} keyPath - A key path of the form relationship.property (with one or more relationships): for example “department.name” or “department.manager.lastName.” 
	     * @returns {void}
	     * @desc The default implementation of this method gets the destination object for each relationship using value(forKey:), and sends the final object a setValue(_:forKey:) message.Special ConsiderationsWhen using this method, and the destination object does not implement an accessor for the value, the default behavior is for that object to retain value rather than copy or assign value.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1418139-setvalue
	     */

	  }, {
	    key: 'setValueForKeyPath',
	    value: function setValueForKeyPath(value, keyPath) {
	      //console.log('NSObject.setValueForKeyPath: ' + keyPath)
	      if (typeof keyPath !== 'string') {
	        throw new Error('setValueForKeyPath: keyPath should be string');
	      }
	      var paths = keyPath.split('.');
	      var key = paths.shift();
	      if (paths.length === 0) {
	        this.setValueForKey(value, key);
	        return;
	      }
	      var target = this.valueForKey(key);
	      //console.log(`NSObject.setValueForKeyPath: ${keyPath}: key ${key} target ${target}`)
	      target.setValueForKeyPath(value, paths.join('.'));
	    }

	    /**
	     * Invoked by setValue(_:forKey:) when it finds no property for a given key.
	     * @access public
	     * @param {?Object} value - The value for the key identified by key.
	     * @param {string} key - A string that is not equal to the name of any of the receiver's properties.
	     * @returns {void}
	     * @desc Subclasses can override this method to handle the request in some other way. The default implementation raises an NSUndefinedKeyException.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1413490-setvalue
	     */

	  }, {
	    key: 'setValueForUndefinedKey',
	    value: function setValueForUndefinedKey(value, key) {
	      throw new Error('setValueForKey: undefined key: ' + key);
	    }

	    /**
	     * Sets properties of the receiver with values from a given dictionary, using its keys to identify the properties.
	     * @access public
	     * @param {Map<string, Object>} keyedValues - A dictionary whose keys identify properties in the receiver. The values of the properties in the receiver are set to the corresponding values in the dictionary.
	     * @returns {void}
	     * @desc The default implementation invokes setValue(_:forKey:) for each key-value pair, substituting nil for NSNull values in keyedValues.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1417515-setvaluesforkeys
	     */

	  }, {
	    key: 'setValuesForKeys',
	    value: function setValuesForKeys(keyedValues) {}

	    /**
	     * Returns a Boolean value that indicates whether the value specified by a given pointer is valid for the property identified by a given key.
	     * @access public
	     * @param {AutoreleasingUnsafeMutablePointer<AnyObject?>} ioValue - A pointer to a new value for the property identified by key. This method may modify or replace the value in order to make it valid.
	     * @param {string} inKey - 
	     * @returns {void}
	     * @throws {Error}
	     * @desc The default implementation of this method searches the class of the receiver for a validation method whose name matches the pattern validate<Key>:error:. If such a method is found it is invoked and the result is returned. If no such method is found, true is returned.The sender of the message is never given responsibility for releasing ioValue or outError. See Adding Validation for more information.Handling Errors in Swift:
	    In Swift, this method returns Void and is marked with the throws keyword to indicate that it throws an error in cases of failure.
	    You call this method in a try expression and handle any errors in the catch clauses of a do statement, as described in Error Handling in The Swift Programming Language (Swift 3.1) and Error Handling in Using Swift with Cocoa and Objective-C (Swift 3.1).
	      * @see https://developer.apple.com/reference/objectivec/nsobject/1416754-validatevalue
	     */

	  }, {
	    key: 'validateValueForKey',
	    value: function validateValueForKey(ioValue, inKey) {}

	    /**
	     * Returns a Boolean value that indicates whether the value specified by a given pointer is valid for a given key path relative to the receiver. 
	     * @access public
	     * @param {AutoreleasingUnsafeMutablePointer<AnyObject?>} ioValue - A pointer to a new value for the property identified by keyPath. This method may modify or replace the value in order to make it valid.
	     * @param {string} inKeyPath - 
	     * @returns {void}
	     * @throws {Error}
	     * @desc The default implementation gets the destination object for each relationship using value(forKey:) and returns the result of a validateValue(_:forKey:) message to the final object.Handling Errors in Swift:
	    In Swift, this method returns Void and is marked with the throws keyword to indicate that it throws an error in cases of failure.
	    You call this method in a try expression and handle any errors in the catch clauses of a do statement, as described in Error Handling in The Swift Programming Language (Swift 3.1) and Error Handling in Using Swift with Cocoa and Objective-C (Swift 3.1).
	      * @see https://developer.apple.com/reference/objectivec/nsobject/1416245-validatevalue
	     */

	  }, {
	    key: 'validateValueForKeyPath',
	    value: function validateValueForKeyPath(ioValue, inKeyPath) {}

	    /**
	     * Returns the value for the property identified by a given key.
	     * @access public
	     * @param {string} key - The name of one of the receiver's properties.
	     * @returns {?Object} - 
	     * @desc The search pattern that valueForKey: uses to find the correct value to return is described in Accessor Search Patterns in Key-Value Coding Programming Guide.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1412591-value
	     */

	  }, {
	    key: 'valueForKey',
	    value: function valueForKey(key) {
	      if (typeof key !== 'string') {
	        throw new Error('error: valueForKey(key): key should be string');
	      }
	      if (typeof this[key] === 'undefined') {
	        //console.log('valueForUndefinedKey func: ' + this.valueForUndefinedKey)
	        return this.valueForUndefinedKey(key);
	      }
	      return this[key];
	    }

	    /**
	     * Returns the value for the derived property identified by a given key path.
	     * @access public
	     * @param {string} keyPath - A key path of the form relationship.property (with one or more relationships); for example “department.name” or “department.manager.lastName”.
	     * @returns {?Object} - 
	     * @desc The default implementation gets the destination object for each relationship using value(forKey:) and returns the result of a value(forKey:) message to the final object.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1416468-value
	     */

	  }, {
	    key: 'valueForKeyPath',
	    value: function valueForKeyPath(keyPath) {
	      if (typeof keyPath !== 'string') {
	        throw new Error('valueForKeyPath(keyPath): keyPath should be string');
	      }
	      var paths = keyPath.split('.');
	      var key = paths.shift();
	      var value = this.valueForKey(key);
	      if (paths.length === 0) {
	        return value;
	      }
	      return value.valueForKeyPath(paths.join('.'));
	    }

	    /**
	     * Invoked by value(forKey:) when it finds no property corresponding to a given key.
	     * @access public
	     * @param {string} key - A string that is not equal to the name of any of the receiver's properties.
	     * @returns {?Object} - 
	     * @desc Subclasses can override this method to return an alternate value for undefined keys. The default implementation raises an NSUndefinedKeyException.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1413457-value
	     */

	  }, {
	    key: 'valueForUndefinedKey',
	    value: function valueForUndefinedKey(key) {
	      throw new Error('valueForKey: undefined key: ' + key);
	    }

	    /**
	     * Informs the observed object that the specified change is about to be executed at given indexes for a specified ordered to-many relationship.
	     * @access public
	     * @param {NSKeyValueChange} changeKind - 
	     * @param {Set} indexes - The indexes of the to-many relationship that will be affected by the change.
	     * @param {string} key - The name of a property that is an ordered to-many relationship.
	     * @returns {void}
	     * @desc Use this method when implementing key-value-observing compliance manually.ImportantAfter the values have been changed, a corresponding didChange(_:valuesAt:forKey:) must be invoked with the same parameters.Special ConsiderationsYou rarely need to override this method in subclasses, but if you do, be sure to call super.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1412271-willchange
	     */

	  }, {
	    key: 'willChangeValuesAtForKey',
	    value: function willChangeValuesAtForKey(changeKind, indexes, key) {}

	    /**
	     * Informs the observed object that the value of a given property is about to change.
	     * @access public
	     * @param {string} key - The name of the property that will change.
	     * @returns {void}
	     * @desc Use this method when implementing key-value observer compliance manually to inform the observed object that the value at key is about to change.The change type of this method is NSKeyValueChangeSetting.ImportantAfter the values have been changed, a corresponding didChangeValue(forKey:) must be invoked with the same parameter. Special ConsiderationsYou rarely need to override this method in subclasses, but if you do, be sure to call super.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1416222-willchangevalue
	     */

	  }, {
	    key: 'willChangeValueForKey',
	    value: function willChangeValueForKey(key) {}

	    /**
	     * Informs the observed object that the specified change is about to be made to a specified unordered to-many relationship.
	     * @access public
	     * @param {string} key - The name of a property that is an unordered to-many relationship
	     * @param {NSKeyValueSetMutationKind} mutationKind - The type of change that will be made.
	     * @param {Set<AnyHashable>} objects - The objects that are involved in the change (see NSKeyValueSetMutationKind).
	     * @returns {void}
	     * @desc Use this method when implementing key-value observer compliance manually.ImportantAfter the values have been changed, a corresponding didChangeValue(forKey:withSetMutation:using:) must be invoked with the same parameters.Special ConsiderationsYou rarely need to override this method in subclasses, but if you do, be sure to call super.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1412323-willchangevalue
	     */

	  }, {
	    key: 'willChangeValueForKeyWithSetMutationUsing',
	    value: function willChangeValueForKeyWithSetMutationUsing(key, mutationKind, objects) {}

	    /**
	     * 
	     * @access public
	     * @param {!QLPreviewPanel} panel - 
	     * @returns {boolean} - 
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1504653-acceptspreviewpanelcontrol
	     */

	  }, {
	    key: 'acceptsPreviewPanelControl',
	    value: function acceptsPreviewPanelControl(panel) {
	      return false;
	    }

	    /**
	     * Returns a localized description of the specified action.
	     * @deprecated
	     * @access public
	     * @param {string} action - The action attribute.
	     * @returns {?string} - 
	     * @desc User interface classes must implement this method to return descriptions for all actions returned from accessibilityActionNames(). A button, for example, might return the string "press” for the NSAccessibilityPressAction action. Subclasses should invoke the superclass's implementation, if it exists, to obtain the descriptions of any inherited actions.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1533500-accessibilityactiondescription
	     */

	  }, {
	    key: 'accessibilityActionDescription',
	    value: function accessibilityActionDescription(action) {
	      return null;
	    }

	    /**
	     * Returns an array of action names supported by the accessibility element.
	     * @deprecated
	     * @access public
	     * @returns {Object[]} - 
	     * @desc User interface classes must implement this method. Subclasses should invoke the superclass's implementation, if it exists, and append additional action names or remove unsupported actions. See Constants for some common action names.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1527905-accessibilityactionnames
	     */

	  }, {
	    key: 'accessibilityActionNames',
	    value: function accessibilityActionNames() {
	      return null;
	    }

	    /**
	     * Returns the count of the specified accessibility array attribute.
	     * @access public
	     * @param {string} attribute - The accessibility array attribute.
	     * @returns {number} - 
	     * @desc If attribute is not an array, an exception is raised.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1527138-accessibilityarrayattributecount
	     */

	  }, {
	    key: 'accessibilityArrayAttributeCount',
	    value: function accessibilityArrayAttributeCount(attribute) {
	      return 0;
	    }

	    /**
	     * Returns a subarray of values of an accessibility array attribute.
	     * @access public
	     * @param {string} attribute - The accessibility array attribute.
	     * @param {number} index - The starting index.
	     * @param {number} maxCount - The maximum desired number of items requested.
	     * @returns {Object[]} - 
	     * @desc Note that this method does not take a range. The maximum count is the maximum desired number of items requested by an accessibility client. This number may be beyond the bounds of your array.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1535909-accessibilityarrayattributevalue
	     */

	  }, {
	    key: 'accessibilityArrayAttributeValues',
	    value: function accessibilityArrayAttributeValues(attribute, index, maxCount) {
	      return null;
	    }

	    /**
	     * Returns an array of attribute names supported by the receiver.
	     * @deprecated
	     * @access public
	     * @returns {Object[]} - 
	     * @desc User interface classes must implement this method. Subclasses should invoke the superclass's implementation, if it exists, and append additional attributes or remove unsupported attributes. See Constants for lists of attribute names.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1525181-accessibilityattributenames
	     */

	  }, {
	    key: 'accessibilityAttributeNames',
	    value: function accessibilityAttributeNames() {
	      return null;
	    }

	    /**
	     * Returns the value of the specified attribute in the receiver.
	     * @deprecated
	     * @access public
	     * @param {string} attribute - The name of the attribute. See Constants for lists of attribute names.
	     * @returns {?Object} - 
	     * @desc User interface classes must implement this method. Subclasses should invoke the superclass's implementation, if it exists, if attribute is not implemented in the subclass.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1532465-accessibilityattributevalue
	     */

	  }, {
	    key: 'accessibilityAttributeValue',
	    value: function accessibilityAttributeValue(attribute) {
	      return null;
	    }

	    /**
	     * Returns the value of the receiver's parameterized attribute corresponding to the specified attribute name and parameter.
	     * @deprecated
	     * @access public
	     * @param {string} attribute - The name of the attribute. See Constants for lists of attribute names.
	     * @param {?Object} parameter - The parameter.
	     * @returns {?Object} - 
	     * @desc If you implement this method, also implement accessibilityParameterizedAttributeNames().
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1524809-accessibilityattributevalue
	     */

	  }, {
	    key: 'accessibilityAttributeValueForParameter',
	    value: function accessibilityAttributeValueForParameter(attribute, parameter) {
	      return null;
	    }

	    /**
	     * Returns the deepest descendant of the accessibility hierarchy that contains the specified point.
	     * @access public
	     * @param {CGPoint} point - The point being hit-tested, in lower-left relative screen coordinates.
	     * @returns {?Object} - 
	     * @desc You can assume that the specified point has already been determined to lie within the accessibility element's frame. Override this method to do deeper hit-testing by identifying which child element, if any, contains the point. NSMatrix, for example, identifies which of its cells contains the point and propagates the hit-test to it. If the specified point is not contained within one of the accessibility element's children, either return self or, if available, invoke the superclass's implementation. The default NSView and NSCell implementations test whether the accessibility element is an ignored element and, if it is, return the receiver's first unignored parent; otherwise they return self.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1526136-accessibilityhittest
	     */

	  }, {
	    key: 'accessibilityHitTest',
	    value: function accessibilityHitTest(point) {
	      return null;
	    }

	    /**
	     * Returns the index of the specified accessibility child in the parent.
	     * @access public
	     * @param {Object} child - The accessibility child of an object.
	     * @returns {number} - 
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1533558-accessibilityindex
	     */

	  }, {
	    key: 'accessibilityIndexOfChild',
	    value: function accessibilityIndexOfChild(child) {
	      return 0;
	    }

	    /**
	     * Returns a Boolean value that indicates whether the value for the specified attribute in the receiver can be set.
	     * @deprecated
	     * @access public
	     * @param {string} attribute - The name of the attribute. See Constants for lists of attribute names.
	     * @returns {boolean} - 
	     * @desc User interface classes must implement this method. Subclasses should invoke the superclass's implementation, if it exists, if attribute is not implemented in the subclass.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1529207-accessibilityisattributesettable
	     */

	  }, {
	    key: 'accessibilityIsAttributeSettable',
	    value: function accessibilityIsAttributeSettable(attribute) {
	      return false;
	    }

	    /**
	     * Returns a Boolean value indicating whether the receiver should be ignored in the parent-child accessibility hierarchy.
	     * @deprecated
	     * @access public
	     * @returns {boolean} - 
	     * @desc When asking for an object's children, do not include ignored children; instead, replace the ignored children with their own unignored children. The same applies when asking for an object's parent: skip the ignored parent and treat the first unignored ancestor as the real parent.  Likewise, when a hit-test or focus test is satisfied by an ignored element, use the element's first unignored ancestor (or descendant in certain cases, such as single-celled controls) instead.Ignored elements let you provide a simplified version of the view and object ownership hierarchies. Accessibility clients can bypass intermediate objects, letting users access the real user interface objects more quickly. For example, NSControl objects are ignored when they are single-celled; the visible parent-child relationship is between the control's parent (or a higher ancestor if the parent is ignored, too) and the control's cell.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1526439-accessibilityisignored
	     */

	  }, {
	    key: 'accessibilityIsIgnored',
	    value: function accessibilityIsIgnored() {
	      return false;
	    }

	    /**
	     * Returns a list of parameterized attribute names supported by the receiver.
	     * @deprecated
	     * @access public
	     * @returns {Object[]} - 
	     * @desc If you implement this method, also implement accessibilityAttributeValue(_:forParameter:).
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1525455-accessibilityparameterizedattrib
	     */

	  }, {
	    key: 'accessibilityParameterizedAttributeNames',
	    value: function accessibilityParameterizedAttributeNames() {
	      return null;
	    }

	    /**
	     * Performs the action associated with the specified action.
	     * @deprecated
	     * @access public
	     * @param {string} action - The action to perform.
	     * @returns {void}
	     * @desc User interface classes must implement this method to handle all the actions returned from accessibilityActionNames(). Subclasses should invoke the superclass's implementation, if it exists, if action is not implemented in the subclass.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1533528-accessibilityperformaction
	     */

	  }, {
	    key: 'accessibilityPerformAction',
	    value: function accessibilityPerformAction(action) {}

	    /**
	     * Overrides the specified attribute in the receiver or adds it if it does not exist, and sets its value to the specified value.
	     * @deprecated
	     * @access public
	     * @param {?Object} value - The attribute value to be set. 
	     * @param {string} attribute - The name of the attribute. See Constants for lists of attribute names.
	     * @returns {boolean} - 
	     * @desc This method is for changing the set of attributes on an instance, as an alternative to subclassing.This method works only on objects whose class already implements the NSAccessibility protocol. If the specified attribute is already supported by the object, the value specified by this method wins.If the specified attribute does not exist, it is created outside the NSAccessibility protocol, so accessibilityAttributeNames still returns the old list, which does not contain the new attribute. Likewise, accessibilityAttributeValue does not return attributes created by the override process nor does it return their overridden values.The values of overridden attributes are not settable by accessibility clients.If you need to undo the effect of using this method, call it again, passing nil for the value.Ensure that you invoke this method on the actual object that represents the user interface element. For example, for NSButton, use the underlying NSButtonCell object. NSButton itself is ignored by accessibility.This method works only on an object representing a single user interface element. So, for example, you cannot use it when a single object represents multiple user interface elements, as with NSSegmentedCell, which has only a single object but provides user interface elements for each segment.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1535843-accessibilitysetoverridevalue
	     */

	  }, {
	    key: 'accessibilitySetOverrideValueForAttribute',
	    value: function accessibilitySetOverrideValueForAttribute(value, attribute) {
	      return false;
	    }

	    /**
	     * Sets the value of the specified attribute in the receiver to the specified value.
	     * @deprecated
	     * @access public
	     * @param {?Object} value - The attribute value to be set.
	     * @param {string} attribute - The name of the attribute. See Constants for lists of attribute names.
	     * @returns {void}
	     * @desc User interface classes must implement this method if any of its attributes are settable. Subclasses should invoke the superclass's implementation, if it exists, if attribute is not implemented in the subclass.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1528477-accessibilitysetvalue
	     */

	  }, {
	    key: 'accessibilitySetValueForAttribute',
	    value: function accessibilitySetValueForAttribute(value, attribute) {}

	    /**
	     * Sent to the delegate to request the property the action applies to.
	     * @access public
	     * @returns {!string} - 
	     * @desc See Table 1The documentation for property-list constants for the properties for person and group records.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1411302-actionproperty
	     */

	  }, {
	    key: 'actionProperty',
	    value: function actionProperty() {
	      return null;
	    }

	    /**
	     * Sent by Cocoa’s built-in scripting support during execution of get or set script commands to find out if the delegate can handle operations on the specified key-value key.
	     * @access public
	     * @param {NSApplication} sender - The app object associated with the delegate. 
	     * @param {string} key - The key to be handled.
	     * @returns {boolean} - 
	     * @desc The method should return true if the delegate for the app sender handles the key specified by key, which means it can get or set the scriptable property or element that corresponds to that key. The app implements methods for each of the keys that it handles, where the method name matches the key.For example, a scriptable app that doesn’t use Cocoa’s document-based app architecture can implement this method to supply its own document ordering. Such an app might want to do this because the standard app delegate expects to work with a document-based app. The TextEdit app (whose source is distributed with macOS developer tools) provides the following implementation:return [key isEqualToString:@"orderedDocuments"];
	    TextEdit then implements the orderedDocuments method in its controller class to return an ordered list of documents. An app with its own window ordering might add a test for the key orderedWindows so that its delegate can provide its own version of orderedWindows.ImportantCocoa scripting does not invoke this method for script commands other than get or set. For information on working with other commands, see Script Commands in Cocoa Scripting Guide.return [key isEqualToString:@"orderedDocuments"];
	      * @see https://developer.apple.com/reference/objectivec/nsobject/1494285-application
	     */

	  }, {
	    key: 'applicationDelegateHandlesKey',
	    value: function applicationDelegateHandlesKey(sender, key) {
	      return false;
	    }

	    /**
	     * Sent to the delegate to indicate the authorization object has been created or changed. If you have saved a copy of the authorization object for your own purposes, you should discard it and call authorization for a new authorization object.
	     * @access public
	     * @param {!SFAuthorizationView} view - 
	     * @returns {void}
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1411010-authorizationviewcreatedauthoriz
	     */

	  }, {
	    key: 'authorizationViewCreatedAuthorization',
	    value: function authorizationViewCreatedAuthorization(view) {}

	    /**
	     * Sent to the delegate to indicate the user was authorized and the authorization view was changed to unlocked.
	     * @access public
	     * @param {!SFAuthorizationView} view - 
	     * @returns {void}
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1411002-authorizationviewdidauthorize
	     */

	  }, {
	    key: 'authorizationViewDidAuthorize',
	    value: function authorizationViewDidAuthorize(view) {}

	    /**
	     * Sent to the delegate to indicate the user was deauthorized and the authorization view was changed to locked.
	     * @access public
	     * @param {!SFAuthorizationView} view - 
	     * @returns {void}
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1411017-authorizationviewdiddeauthorize
	     */

	  }, {
	    key: 'authorizationViewDidDeauthorize',
	    value: function authorizationViewDidDeauthorize(view) {}

	    /**
	     * Sent to the delegate to indicate that the view’s visibility has changed.
	     * @access public
	     * @param {!SFAuthorizationView} view - 
	     * @returns {void}
	     * @desc This delegate method, if present, is called whenever the isHidden method is called to show or hide the view.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1411034-authorizationviewdidhide
	     */

	  }, {
	    key: 'authorizationViewDidHide',
	    value: function authorizationViewDidHide(view) {}

	    /**
	     * Sent to the delegate to indicate that deauthorization is about to occur.
	     * @access public
	     * @param {!SFAuthorizationView} view - 
	     * @returns {void}
	     * @desc This method is called after deauthorization has been approved (either you called the deauthorize: method, or the user clicked an open lock icon and the authorizationViewShouldDeauthorize: delegate method did not cancel the operation), and before the user is deauthorized (that is, before the authorizationViewDidDeauthorize: delegate method is called). 
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1410992-authorizationviewreleasedauthori
	     */

	  }, {
	    key: 'authorizationViewReleasedAuthorization',
	    value: function authorizationViewReleasedAuthorization(view) {}

	    /**
	     * Sent to the delegate when a user clicks the open lock icon.
	     * @access public
	     * @param {!SFAuthorizationView} view - 
	     * @returns {number} - 
	     * @desc  The delegate can react to this before deauthorization happens and avoid it by returning false. This delegate method is not called when you call the deauthorize: method.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1411006-authorizationviewshoulddeauthori
	     */

	  }, {
	    key: 'authorizationViewShouldDeauthorize',
	    value: function authorizationViewShouldDeauthorize(view) {
	      return 0;
	    }

	    /**
	     * Prepares the receiver for service after it has been loaded from an Interface Builder archive, or nib file.
	     * @access public
	     * @returns {void}
	     * @desc The nib-loading infrastructure sends an awakeFromNib message to each object recreated from a nib archive, but only after all the objects in the archive have been loaded and initialized. When an object receives an awakeFromNib message, it is guaranteed to have all its outlet and action connections already established.You must call the super implementation of awakeFromNib to give parent classes the opportunity to perform any additional initialization they require. Although the default implementation of this method does nothing, many UIKit classes provide non-empty implementations. You may call the super implementation at any point during your own awakeFromNib method.NoteDuring Interface Builder’s test mode, this message is also sent to objects instantiated from loaded Interface Builder plug-ins. Because plug-ins link against the framework containing the object definition code, Interface Builder is able to call their awakeFromNib method when present. The same is not true for custom objects that you create for your Xcode projects. Interface Builder knows only about the defined outlets and actions of those objects; it does not have access to the actual code for them.During the instantiation process, each object in the archive is unarchived and then initialized with the method befitting its type. Objects that conform to the NSCoding protocol (including all subclasses of UIView and UIViewController) are initialized using their initWithCoder: method. All objects that do not conform to the NSCoding protocol are initialized using their init method. After all objects have been instantiated and initialized, the nib-loading code reestablishes the outlet and action connections for all of those objects. It then calls the awakeFromNib method of the objects. For more detailed information about the steps followed during the nib-loading process, see Nib Files in Resource Programming Guide.ImportantBecause the order in which objects are instantiated from an archive is not guaranteed, your initialization methods should not send messages to other objects in the hierarchy. Messages to other objects can be sent safely from within an awakeFromNib method. Typically, you implement awakeFromNib for objects that require additional set up that cannot be done at design time. For example, you might use this method to customize the default configuration of any controls to match user preferences or the values in other controls. You might also use it to restore individual controls to some previous state of your application. 
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1402907-awakefromnib
	     */

	  }, {
	    key: 'awakeFromNib',
	    value: function awakeFromNib() {}

	    /**
	     * 
	     * @access public
	     * @param {!QLPreviewPanel} panel - 
	     * @returns {void}
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1504204-beginpreviewpanelcontrol
	     */

	  }, {
	    key: 'beginPreviewPanelControl',
	    value: function beginPreviewPanelControl(panel) {}

	    /**
	     * Establishes a binding between a given property of the receiver and the property of a given object specified by a given key path.
	     * @access public
	     * @param {string} binding - The key path for a property of the receiver previously exposed using the exposeBinding(_:) method.
	     * @param {Object} observable - 
	     * @param {string} keyPath - A key path to a property reachable from observableController. The elements in the path must be key-value observing compliant (see Key-Value Observing Programming Guide).
	     * @param {?Map<string, Object>} [options = null] - A dictionary containing options for the binding, such as placeholder objects or an NSValueTransformer identifier as described in Constants. This value is optional—pass nil to specify no options.
	     * @returns {void}
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1458185-bind
	     */

	  }, {
	    key: 'bindToWithKeyPath',
	    value: function bindToWithKeyPath(binding, observable, keyPath) {
	      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
	    }

	    /**
	     * Returns an array of candidates.
	     * @access public
	     * @param {!Object} sender - The client object requesting the candidates.
	     * @returns {!Object[]} - 
	     * @desc An input method should look up its currently composed string and return a list of candidate strings that that string might map to.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1385360-candidates
	     */

	  }, {
	    key: 'candidates',
	    value: function candidates(sender) {
	      return null;
	    }

	    /**
	     * Implements custom help behavior for the modal panel.
	     * @access public
	     * @param {!SFCertificatePanel} sender - The certificate panel for which to implement custom help.
	     * @returns {number} - 
	     * @desc You can use this delegate method to implement custom help if you call the setShowsHelp: method to display a help button in the sheet or panel. If you are not implementing custom help, do not implement this method.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1514145-certificatepanelshowhelp
	     */

	  }, {
	    key: 'certificatePanelShowHelp',
	    value: function certificatePanelShowHelp(sender) {
	      return 0;
	    }

	    /**
	     * Sent to the first responder when the user selects a color in an NSColorPanel object.
	     * @access public
	     * @param {?Object} sender - The NSColorPanel sending the message.
	     * @returns {void}
	     * @desc When the user selects a color in an NSColorPanel object, the panel sends a changeColor(_:) action message to the first responder. You can override this method in any responder that needs to respond to a color change. 
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1532638-changecolor
	     */

	  }, {
	    key: 'changeColor',
	    value: function changeColor(sender) {}

	    /**
	     * Informs responders of a font change.
	     * @access public
	     * @param {?Object} sender - The object that sent the message.
	     * @returns {void}
	     * @desc Generally this change is because the user changed the font either in the selection of a rich text field or in a whole plain text field. Any object that contains a font the user can change must respond to the changeFont(_:) message by sending a convert(_:) message back to sender (an NSFontManager object) for each font in the selection. For more information, see Responding to Font Changes.Be aware that selectedFont at this point may return unpredictable results. The font in this property may not be the last font selected, or there may be multiple fonts selected at the time changeFont(_:) is called. The use of selectedFont from within changeFont(_:) is strongly discouraged.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1462311-changefont
	     */

	  }, {
	    key: 'changeFont',
	    value: function changeFont(sender) {}

	    /**
	     * Implements custom help behavior for the modal panel.
	     * @access public
	     * @param {!SFChooseIdentityPanel} sender - The choose identity panel for which to implement custom help.
	     * @returns {number} - 
	     * @desc You can use this delegate method to implement custom help if you call the setShowsHelp: method to display a help button in the sheet or panel. If you are not implementing custom help, do not implement this method. 
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1514140-chooseidentitypanelshowhelp
	     */

	  }, {
	    key: 'chooseIdentityPanelShowHelp',
	    value: function chooseIdentityPanelShowHelp(sender) {
	      return 0;
	    }

	    /**
	     * 
	     * @deprecated
	     * @access public
	     * @param {Object} annotationClass - 
	     * @returns {Object} - 
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1436089-class
	     */

	  }, {
	    key: 'classForAnnotationClass',
	    value: function classForAnnotationClass(annotationClass) {
	      return null;
	    }

	    /**
	     * 
	     * @deprecated
	     * @access public
	     * @returns {Object} - 
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1436049-classforpage
	     */

	  }, {
	    key: 'classForPage',
	    value: function classForPage() {
	      return null;
	    }

	    /**
	     * Uses type info from the class description and NSScriptCoercionHandler to attempt to convert value for key to the proper type, if necessary.
	     * @access public
	     * @param {?Object} value - 
	     * @param {string} key - 
	     * @returns {?Object} - 
	     * @desc  The method coerceValueFor<Key>: is used if it exists.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1416527-coercevalue
	     */

	  }, {
	    key: 'coerceValueForKey',
	    value: function coerceValueForKey(value, key) {
	      return null;
	    }

	    /**
	     * Informs the controller that the composition should be committed.
	     * @access public
	     * @param {!Object} sender - The client object requesting the input method to commit the composition.
	     * @returns {void}
	     * @desc If an input method implements this method, it is called when the client wants to end the composition session immediately. A typical response would be to call the insertText method of the client and then clean up any per-session buffers and variables. After receiving this message an input method should consider the given composition session finished.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1385539-commitcomposition
	     */

	  }, {
	    key: 'commitComposition',
	    value: function commitComposition(sender) {}

	    /**
	     * Returns whether the receiver was able to commit any pending edits.
	     * @access public
	     * @returns {boolean} - 
	     * @desc A commit is denied if the receiver fails to apply the changes to the model object, perhaps due to a validation error.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1458190-commitediting
	     */

	  }, {
	    key: 'commitEditing',
	    value: function commitEditing() {
	      return false;
	    }

	    /**
	     * Attempt to commit pending edits, returning an error in the case of failure.
	     * @access public
	     * @returns {void}
	     * @throws {Error}
	     * @desc During autosaving, commit editing may fail, due to a pending edit. Rather than interrupt the user with an unexpected alert, this method provides the caller with the option to either present the error or fail silently, leaving the pending edit in place and the user's editing uninterrupted. In your implementation of this method, you should attempt to commit editing, but if there is a failure return false and in error an error object to be presented or ignored as appropriate. Handling Errors in Swift:
	    In Swift, this method returns Void and is marked with the throws keyword to indicate that it throws an error in cases of failure.
	    You call this method in a try expression and handle any errors in the catch clauses of a do statement, as described in Error Handling in The Swift Programming Language (Swift 3.1) and Error Handling in Using Swift with Cocoa and Objective-C (Swift 3.1).
	      * @see https://developer.apple.com/reference/objectivec/nsobject/1458181-commiteditingandreturnerror
	     */

	  }, {
	    key: 'commitEditingAndReturnError',
	    value: function commitEditingAndReturnError() {}

	    /**
	     * Attempt to commit any currently edited results of the receiver.
	     * @access public
	     * @param {?Object} delegate - 
	     * @param {?function} didCommitSelector - 
	     * @param {?Object} contextInfo - 
	     * @returns {void}
	     * @desc The receiver must have been registered as the editor of an object using objectDidBeginEditing:, and has not yet been unregistered by a subsequent invocation of objectDidEndEditing:. When the committing has either succeeded or failed, send the following message to the specified object. The didCommitSelector method must have the following method signature: - (void)editor:(id)editor didCommit:(BOOL)didCommit contextInfo:(void *)contextInfo
	    If an error occurs while attempting to commit, for example if key-value coding validation fails, an implementation of this method should typically send the NSView in which editing is being done a presentError:modalForWindow:delegate:didRecoverSelector:contextInfo: message, specifying the view's containing window.- (void)editor:(id)editor didCommit:(BOOL)didCommit contextInfo:(void *)contextInfo
	      * @see https://developer.apple.com/reference/objectivec/nsobject/1458179-commitediting
	     */

	  }, {
	    key: 'commitEditingWithDelegateDidCommit',
	    value: function commitEditingWithDelegateDidCommit(delegate, didCommitSelector, contextInfo) {}

	    /**
	     * Return the current composed string.
	     * @access public
	     * @param {!Object} sender - The client object requesting the string.
	     * @returns {!Object} - 
	     * @desc  A composed string refers to the buffer that an input method typically maintains to mirror the text contained in the active inline area. It is called the composed string to reflect the fact that the input method composed the string by converting the characters input by the user. In addition, using the term composed string makes it easier to differentiate between an input method  buffer and the text in the active inline area that the user sees. 
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1385416-composedstring
	     */

	  }, {
	    key: 'composedString',
	    value: function composedString(sender) {
	      return null;
	    }

	    /**
	     * Called after an input parameter in the composition parameter view has been edited.
	     * @access public
	     * @param {!QCCompositionParameterView} parameterView - The composition parameter view in which the parameter changed.
	     * @param {!string} portKey - A key for one of the composition parameters, which is provided to you by the Quartz Composer engine.
	     * @returns {void}
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1505265-compositionparameterview
	     */

	  }, {
	    key: 'compositionParameterViewDidChangeParameterWithKey',
	    value: function compositionParameterViewDidChangeParameterWithKey(parameterView, portKey) {}

	    /**
	     * Allows you to define which composition parameters are visible in the user interface when the composition parameter view refreshes.  
	     * @access public
	     * @param {!QCCompositionParameterView} parameterView - The composition parameter view in which the selection changed.
	     * @param {!string} portKey - A key for one of the composition parameters, which is provided to you by the Quartz Composer engine.
	     * @param {!Map<AnyHashable, Object>} [portAttributes = new Map()] - A dictionary of the attributes that you want to display in the user interface.
	     * @returns {boolean} - 
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1503523-compositionparameterview
	     */

	  }, {
	    key: 'compositionParameterViewShouldDisplayParameterWithKeyAttributes',
	    value: function compositionParameterViewShouldDisplayParameterWithKeyAttributes(parameterView, portKey) {
	      var portAttributes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Map();

	      return false;
	    }

	    /**
	     * Performs custom tasks when the selected composition in the composition picker view changes. 
	     * @access public
	     * @param {!QCCompositionPickerView} pickerView - The composition picker view in which the selection changed.
	     * @param {!QCComposition} composition - The selected composition or nil if the previously selected composition is no longer selected.
	     * @returns {void}
	     * @desc Quartz Composer invokes this method when the selected composition in the composition picker view changes. Implement this method if you want to perform custom tasks at that time.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1447352-compositionpickerview
	     */

	  }, {
	    key: 'compositionPickerViewDidSelect',
	    value: function compositionPickerViewDidSelect(pickerView, composition) {}

	    /**
	     * Performs custom tasks when the composition picker view starts animating a composition.
	     * @access public
	     * @param {!QCCompositionPickerView} pickerView - The composition picker view in which the composition started animating.
	     * @returns {void}
	     * @desc Quartz Composer invokes  this method when  the composition picker view starts animating a composition. Implement this method if you want to perform custom tasks at that time.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1447342-compositionpickerviewdidstartani
	     */

	  }, {
	    key: 'compositionPickerViewDidStartAnimating',
	    value: function compositionPickerViewDidStartAnimating(pickerView) {}

	    /**
	     * Performs custom tasks when the composition picker view stops animating a composition.
	     * @access public
	     * @param {!QCCompositionPickerView} pickerView - The composition picker view in which the composition stopped animating.
	     * @returns {void}
	     * @desc Quartz Composer invokes  this method whenever the composition picker view stops animating a composition. Implement this method if you want to perform custom tasks at that time.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1447348-compositionpickerviewwillstopani
	     */

	  }, {
	    key: 'compositionPickerViewWillStopAnimating',
	    value: function compositionPickerViewWillStopAnimating(pickerView) {}

	    /**
	     * Sent when a control with editable text begins an editing session.
	     * @access public
	     * @param {Notification} obj - 
	     * @returns {void}
	     * @desc This method is invoked when the user begins editing text in a control such as a text field or a form field. The control posts a NSControlTextDidBeginEditing notification, and if the control’s delegate implements this method, it is automatically registered to receive the notification. Use the key @"NSFieldEditor" to obtain the field editor from the userInfo dictionary of the notification object.  See controlTextDidEndEditing(_:) for an explanation of why you may not always get one invocation of controlTextDidBeginEditing(_:) for each invocation of controlTextDidEndEditing(_:).
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1428934-controltextdidbeginediting
	     */

	  }, {
	    key: 'controlTextDidBeginEditing',
	    value: function controlTextDidBeginEditing(obj) {}

	    /**
	     * Sent when the text in the receiving control changes. 
	     * @access public
	     * @param {Notification} obj - 
	     * @returns {void}
	     * @desc This method is invoked when text in a control such as a text field or form changes. The control posts a NSControlTextDidChange notification, and if the control’s delegate implements this method, it is automatically registered to receive the notification. Use the key @"NSFieldEditor" to obtain the field editor from the userInfo dictionary of the notification object.  
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1428982-controltextdidchange
	     */

	  }, {
	    key: 'controlTextDidChange',
	    value: function controlTextDidChange(obj) {}

	    /**
	     * Sent when a control with editable text ends an editing session.
	     * @access public
	     * @param {Notification} obj - 
	     * @returns {void}
	     * @desc This method is invoked when the user stops editing text in a control such as a text field or form. The control posts a NSControlTextDidEndEditing notification, and if the control’s delegate implements this method, it is automatically registered to receive the notification. Use the key @"NSFieldEditor" to obtain the field editor from the userInfo dictionary of the notification object.  WarningIn some cases, such as when editing within an instance of NSOutlineView, this method may be invoked without a previous invocation of controlTextDidBeginEditing(_:). You will only get the controlTextDidBeginEditing: notification if the user actually types something, but you can get the controlTextDidEndEditing: notification if the user just double-clicks the field and then clicks outside the field, without typing.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1428847-controltextdidendediting
	     */

	  }, {
	    key: 'controlTextDidEndEditing',
	    value: function controlTextDidEndEditing(obj) {}

	    /**
	     * Processes a command  generated by user action such as typing certain keys or pressing the mouse button.
	     * @access public
	     * @param {!function} aSelector - The action associated with the key down event. The selector can be an action specified in the input method  dictionary of keys and actions (that is, an action specific to the input method) or one of the NSResponder action methods such as insertNewline: or deleteBackward:. By definition such action methods do not return a value.
	     * @param {!Object} sender - The client object sending the key down event.
	     * @returns {boolean} - 
	     * @desc This method is called when the system binds a key down event to an action method. If you implement this method you should test if it is appropriate to call the action method before actually calling it, because calling the action method implies that you agree to handle the command. Suppose you have implemented a version of insertNewline:  that terminates the conversion session and sends the fully converted text to the client. However, if you conversion buffer is empty, you want the application to receive the return key that triggered the call to insertNewline:. In that case, when didCommandBySelector:client: is called you should test your buffer before calling your implementation of insertNewline:. If the buffer is empty, return false to indicate that the return key should be passed on to the application. If the buffer is not empty, call insertNewline: and then return true as the result of didCommandBySelector:client:.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1385394-didcommand
	     */

	  }, {
	    key: 'didCommandByClient',
	    value: function didCommandByClient(aSelector, sender) {
	      return false;
	    }

	    /**
	     * Called for every match found during a find operation.
	     * @access public
	     * @param {PDFSelection} instance - 
	     * @returns {void}
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1436046-didmatchstring
	     */

	  }, {
	    key: 'didMatchString',
	    value: function didMatchString(instance) {}

	    /**
	     * Causes the receiver to discard any changes, restoring the previous values.
	     * @access public
	     * @returns {void}
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1458076-discardediting
	     */

	  }, {
	    key: 'discardEditing',
	    value: function discardEditing() {}

	    /**
	     * Called when the PDFDocumentDidBeginFindNotification notification is posted. 
	     * @access public
	     * @param {Notification} notification - 
	     * @returns {void}
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1436080-documentdidbegindocumentfind
	     */

	  }, {
	    key: 'documentDidBeginDocumentFind',
	    value: function documentDidBeginDocumentFind(notification) {}

	    /**
	     * Called when the PDFDocumentDidBeginPageFindNotification notification is posted.
	     * @access public
	     * @param {Notification} notification - 
	     * @returns {void}
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1436094-documentdidbeginpagefind
	     */

	  }, {
	    key: 'documentDidBeginPageFind',
	    value: function documentDidBeginPageFind(notification) {}

	    /**
	     * Called when the PDFDocumentDidEndFindNotification notification is posted.
	     * @access public
	     * @param {Notification} notification - 
	     * @returns {void}
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1436068-documentdidenddocumentfind
	     */

	  }, {
	    key: 'documentDidEndDocumentFind',
	    value: function documentDidEndDocumentFind(notification) {}

	    /**
	     * Called when the PDFDocumentDidEndPageFindNotification notification is posted. 
	     * @access public
	     * @param {Notification} notification - 
	     * @returns {void}
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1436064-documentdidendpagefind
	     */

	  }, {
	    key: 'documentDidEndPageFind',
	    value: function documentDidEndPageFind(notification) {}

	    /**
	     * Called when the PDFDocumentDidFindMatchNotification notification is posted.
	     * @access public
	     * @param {Notification} notification - 
	     * @returns {void}
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1436044-documentdidfindmatch
	     */

	  }, {
	    key: 'documentDidFindMatch',
	    value: function documentDidFindMatch(notification) {}

	    /**
	     * Called when the PDFDocumentDidUnlockNotification notification is posted.
	     * @access public
	     * @param {Notification} notification - 
	     * @returns {void}
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1436029-documentdidunlock
	     */

	  }, {
	    key: 'documentDidUnlock',
	    value: function documentDidUnlock(notification) {}

	    /**
	     * Returns a Boolean value that indicates whether the receiver contains a given object.
	     * @access public
	     * @param {Object} object - The object to search for in the receiver.
	     * @returns {boolean} - 
	     * @desc Currently, doesContain(_:) messages are never sent to any object from within Cocoa itself. The default implementation for this method provided by NSObject returns true if the receiver is actually an NSArray object and an indexOfObjectIdentical(to:) message sent to the same object would return something other than NSNotFound.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1393848-doescontain
	     */

	  }, {
	    key: 'doesContain',
	    value: function doesContain(object) {
	      return false;
	    }

	    /**
	     * 
	     * @access public
	     * @param {!QLPreviewPanel} panel - 
	     * @returns {void}
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1505044-endpreviewpanelcontrol
	     */

	  }, {
	    key: 'endPreviewPanelControl',
	    value: function endPreviewPanelControl(panel) {}

	    /**
	     * Implemented by the delegate to evaluate whether the delegating NSExceptionHandler instance should handle a given exception.
	     * @access public
	     * @param {!NSExceptionHandler} sender - The NSExceptionHandler object sending the message.
	     * @param {!NSException} exception - An NSException object describing the exception to be evaluated.
	     * @param {number} aMask - The bit mask indicating the types of exceptions handled by the NSExceptionHandler object. See Logging and Handling Constants and System Hang Constants for descriptions of the possible enum constants.
	     * @returns {boolean} - 
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1489854-exceptionhandler
	     */

	  }, {
	    key: 'exceptionHandlerShouldHandleMask',
	    value: function exceptionHandlerShouldHandleMask(sender, exception, aMask) {
	      return false;
	    }

	    /**
	     * Implemented by the delegate to evaluate whether the delegating NSExceptionHandler instance should log a given exception.
	     * @access public
	     * @param {!NSExceptionHandler} sender - The NSExceptionHandler object sending the message.
	     * @param {!NSException} exception - An NSException object describing the exception to be evaluated.
	     * @param {number} aMask - The bit mask indicating the types of exceptions logged by the NSExceptionHandler object. See Logging and Handling Constants and System Hang Constants for descriptions of the possible enum constants.
	     * @returns {boolean} - 
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1489856-exceptionhandler
	     */

	  }, {
	    key: 'exceptionHandlerShouldLogExceptionMask',
	    value: function exceptionHandlerShouldLogExceptionMask(sender, exception, aMask) {
	      return false;
	    }

	    /**
	     * 
	     * @access public
	     * @param {!OBEXFileTransferServices} inServices - 
	     * @param {OBEXError} inError - 
	     * @returns {void}
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1430046-filetransferservicesabortcomplet
	     */

	  }, {
	    key: 'fileTransferServicesAbortCompleteError',
	    value: function fileTransferServicesAbortCompleteError(inServices, inError) {}

	    /**
	     * 
	     * @access public
	     * @param {!OBEXFileTransferServices} inServices - 
	     * @param {OBEXError} inError - 
	     * @returns {void}
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1428872-filetransferservicesconnectionco
	     */

	  }, {
	    key: 'fileTransferServicesConnectionCompleteError',
	    value: function fileTransferServicesConnectionCompleteError(inServices, inError) {}

	    /**
	     * 
	     * @access public
	     * @param {!OBEXFileTransferServices} inServices - 
	     * @param {OBEXError} inError - 
	     * @returns {void}
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1432094-filetransferservicescopyremotefi
	     */

	  }, {
	    key: 'fileTransferServicesCopyRemoteFileCompleteError',
	    value: function fileTransferServicesCopyRemoteFileCompleteError(inServices, inError) {}

	    /**
	     * 
	     * @access public
	     * @param {!OBEXFileTransferServices} inServices - 
	     * @param {!Map<AnyHashable, Object>} inProgressDescription - 
	     * @returns {void}
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1431422-filetransferservicescopyremotefi
	     */

	  }, {
	    key: 'fileTransferServicesCopyRemoteFileProgressTransferProgress',
	    value: function fileTransferServicesCopyRemoteFileProgressTransferProgress(inServices, inProgressDescription) {}

	    /**
	     * 
	     * @access public
	     * @param {!OBEXFileTransferServices} inServices - 
	     * @param {OBEXError} inError - 
	     * @param {!string} inFolderName - 
	     * @returns {void}
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1430913-filetransferservicescreatefolder
	     */

	  }, {
	    key: 'fileTransferServicesCreateFolderCompleteErrorFolder',
	    value: function fileTransferServicesCreateFolderCompleteErrorFolder(inServices, inError, inFolderName) {}

	    /**
	     * 
	     * @access public
	     * @param {!OBEXFileTransferServices} inServices - 
	     * @param {OBEXError} inError - 
	     * @returns {void}
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1434806-filetransferservicesdisconnectio
	     */

	  }, {
	    key: 'fileTransferServicesDisconnectionCompleteError',
	    value: function fileTransferServicesDisconnectionCompleteError(inServices, inError) {}

	    /**
	     * 
	     * @access public
	     * @param {!OBEXFileTransferServices} inServices - 
	     * @param {OBEXError} inError - 
	     * @returns {void}
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1432086-filetransferservicesfilepreparat
	     */

	  }, {
	    key: 'fileTransferServicesFilePreparationCompleteError',
	    value: function fileTransferServicesFilePreparationCompleteError(inServices, inError) {}

	    /**
	     * 
	     * @access public
	     * @param {!OBEXFileTransferServices} inServices - 
	     * @param {OBEXError} inError - 
	     * @param {!string} inPath - 
	     * @returns {void}
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1432583-filetransferservicespathchangeco
	     */

	  }, {
	    key: 'fileTransferServicesPathChangeCompleteErrorFinalPath',
	    value: function fileTransferServicesPathChangeCompleteErrorFinalPath(inServices, inError, inPath) {}

	    /**
	     * 
	     * @access public
	     * @param {!OBEXFileTransferServices} inServices - 
	     * @param {OBEXError} inError - 
	     * @param {!string} inItemName - 
	     * @returns {void}
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1434702-filetransferservicesremoveitemco
	     */

	  }, {
	    key: 'fileTransferServicesRemoveItemCompleteErrorRemovedItem',
	    value: function fileTransferServicesRemoveItemCompleteErrorRemovedItem(inServices, inError, inItemName) {}

	    /**
	     * 
	     * @access public
	     * @param {!OBEXFileTransferServices} inServices - 
	     * @param {OBEXError} inError - 
	     * @param {!Object[]} inListing - 
	     * @returns {void}
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1434777-filetransferservicesretrievefold
	     */

	  }, {
	    key: 'fileTransferServicesRetrieveFolderListingCompleteErrorListing',
	    value: function fileTransferServicesRetrieveFolderListingCompleteErrorListing(inServices, inError, inListing) {}

	    /**
	     * 
	     * @access public
	     * @param {!OBEXFileTransferServices} inServices - 
	     * @param {OBEXError} inError - 
	     * @returns {void}
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1434240-filetransferservicessendfilecomp
	     */

	  }, {
	    key: 'fileTransferServicesSendFileCompleteError',
	    value: function fileTransferServicesSendFileCompleteError(inServices, inError) {}

	    /**
	     * 
	     * @access public
	     * @param {!OBEXFileTransferServices} inServices - 
	     * @param {!Map<AnyHashable, Object>} inProgressDescription - 
	     * @returns {void}
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1430365-filetransferservicessendfileprog
	     */

	  }, {
	    key: 'fileTransferServicesSendFileProgressTransferProgress',
	    value: function fileTransferServicesSendFileProgressTransferProgress(inServices, inProgressDescription) {}

	    /**
	     * Performs cleanup when the scripting environment is reset.
	     * @access public
	     * @returns {void}
	     * @desc This method is invoked on objects exposed to the scripting environment just before the scripting environment is reset. After invocation, the receiving object will no longer be referenced by the scripting environment. Further references to WebScriptObject instances created by the exposed object will be invalid and may produce unpredictable results.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1528546-finalizeforwebscript
	     */

	  }, {
	    key: 'finalizeForWebScript',
	    value: function finalizeForWebScript() {}

	    /**
	     * Requests permission from the Font panel delegate to display the given font name in the Font panel.
	     * @deprecated
	     * @access public
	     * @param {Object} sender - 
	     * @param {string} fontName - The full PostScript name of the font to display, such as Helvetica-BoldOblique or Helvetica-Narrow-Bold.
	     * @returns {boolean} - 
	     * @desc In macOS versions 10.2 and earlier, this method is invoked repeatedly as necessary whenever the Font panel needs updating, such as when the Font panel is first loaded, and when the user selects a family name to see which typefaces in that family are available. Your implementation should execute fairly quickly to ensure the responsiveness of the Font panel.Important
	    This delegate method is not called in macOS versions 10.3 and later.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1462359-fontmanager
	     */

	  }, {
	    key: 'fontManagerWillIncludeFont',
	    value: function fontManagerWillIncludeFont(sender, fontName) {
	      return false;
	    }

	    /**
	     * Handles key down and mouse events.
	     * @access public
	     * @param {!NSEvent} event - The event to handle.
	     * @param {!Object} sender - The client object sending the event.
	     * @returns {boolean} - 
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1385363-handle
	     */

	  }, {
	    key: 'handleClient',
	    value: function handleClient(event, sender) {
	      return false;
	    }

	    /**
	     * Performs custom tasks when the user right-clicks the image browser view background.
	     * @access public
	     * @param {!IKImageBrowserView} aBrowser - An image browser view.
	     * @param {!NSEvent} event - The event that invoked the method.
	     * @returns {void}
	     * @desc This method signals  that the user either right-clicked the background or left-clicked it with the Alt key pressed. You can implement this method if you want to perform custom tasks at that time.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1503526-imagebrowser
	     */

	  }, {
	    key: 'imageBrowserBackgroundWasRightClickedWith',
	    value: function imageBrowserBackgroundWasRightClickedWith(aBrowser, event) {}

	    /**
	     * Performs custom tasks when the user double-clicks an item in the image browser view.
	     * @access public
	     * @param {!IKImageBrowserView} aBrowser - An image browser view.
	     * @param {number} index - The index of the cell.
	     * @returns {void}
	     * @desc This method signals that the user double-clicked an item in the image browser view. You can implement this method if you want to perform custom tasks at that time.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1504701-imagebrowser
	     */

	  }, {
	    key: 'imageBrowserCellWasDoubleClickedAt',
	    value: function imageBrowserCellWasDoubleClickedAt(aBrowser, index) {}

	    /**
	     * Performs custom tasks when the user right-clicks an item in the image browser view. 
	     * @access public
	     * @param {!IKImageBrowserView} aBrowser - An image browser view.
	     * @param {number} index - The index of the cell.
	     * @param {!NSEvent} event - The event that invoked the method.
	     * @returns {void}
	     * @desc This method signals that the user either right-clicked an item in the browser or left-clicked the item with the Alt key pressed. You can implement this method if you want to perform custom tasks at that time.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1503802-imagebrowser
	     */

	  }, {
	    key: 'imageBrowserCellWasRightClickedAtWith',
	    value: function imageBrowserCellWasRightClickedAtWith(aBrowser, index, event) {}

	    /**
	     * Returns the group at the specified index.
	     * @access public
	     * @param {!IKImageBrowserView} aBrowser - An image browser view.
	     * @param {number} index - The index of the group you want to retrieve.
	     * @returns {!Map<AnyHashable, Object>} - 
	     * @desc This method is optional.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1503488-imagebrowser
	     */

	  }, {
	    key: 'imageBrowserGroupAt',
	    value: function imageBrowserGroupAt(aBrowser, index) {
	      return null;
	    }

	    /**
	     * Returns an object for the item in an image browser view that corresponds to the specified index.
	     * @access public
	     * @param {!IKImageBrowserView} aBrowser - An image browser view.
	     * @param {number} index - The index of the item you want to retrieve.
	     * @returns {!Object} - 
	     * @desc Your data source must implement this method. The returned object must implement the required methods of the IKImageBrowserItem protocol. 
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1504064-imagebrowser
	     */

	  }, {
	    key: 'imageBrowserItemAt',
	    value: function imageBrowserItemAt(aBrowser, index) {
	      return null;
	    }

	    /**
	     * Signals that the specified items should be moved to the specified destination. 
	     * @access public
	     * @param {!IKImageBrowserView} aBrowser - An image browser view.
	     * @param {!Set} indexes - The indexes of the items that should be reordered.
	     * @param {number} destinationIndex - The starting index of the destination the items should be moved to.
	     * @returns {boolean} - 
	     * @desc This method is optional. It is invoked by the image browser view after  Image Kit determines  that a reordering operation should be applied. The data source should update itself by reordering its elements. 
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1503616-imagebrowser
	     */

	  }, {
	    key: 'imageBrowserMoveItemsAtTo',
	    value: function imageBrowserMoveItemsAtTo(aBrowser, indexes, destinationIndex) {
	      return false;
	    }

	    /**
	     * Signals that a remove operation should be applied to the specified items.
	     * @access public
	     * @param {!IKImageBrowserView} aBrowser - An image browser view.
	     * @param {!Set} indexes - The indexes of the items that should be removed.
	     * @returns {void}
	     * @desc This method is optional. It is invoked by the image browser after  Image Kit determines  that a remove operation should be applied. In response, the data source should update itself by removing the specified items.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1503834-imagebrowser
	     */

	  }, {
	    key: 'imageBrowserRemoveItemsAt',
	    value: function imageBrowserRemoveItemsAt(aBrowser, indexes) {}

	    /**
	     * Signals that a drag should begin.
	     * @access public
	     * @param {!IKImageBrowserView} aBrowser - An image browser view.
	     * @param {!Set} itemIndexes - The indexes of the items that should be dragged.
	     * @param {!NSPasteboard} pasteboard - The pasteboard to copy the items to.
	     * @returns {number} - 
	     * @desc This method is optional. It is invoked after Image Kit determines that a drag should begin, but before the drag has been started. 
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1504208-imagebrowser
	     */

	  }, {
	    key: 'imageBrowserWriteItemsAtTo',
	    value: function imageBrowserWriteItemsAtTo(aBrowser, itemIndexes, pasteboard) {
	      return 0;
	    }

	    /**
	     * Performs custom tasks when the selection changes.
	     * @access public
	     * @param {!IKImageBrowserView} aBrowser - An image browser view.
	     * @returns {void}
	     * @desc This method signals that the user changes the selection in the image browser view. You can implement this method if you want to perform custom tasks at that time.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1503765-imagebrowserselectiondidchange
	     */

	  }, {
	    key: 'imageBrowserSelectionDidChange',
	    value: function imageBrowserSelectionDidChange(aBrowser) {}

	    /**
	     * Returns the image to display.
	     * @access public
	     * @returns {!Object} - 
	     * @desc Your data source must implement this method. This method  is called frequently, so the receiver should cache the returned instance.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1504801-imagerepresentation
	     */

	  }, {
	    key: 'imageRepresentation',
	    value: function imageRepresentation() {
	      return null;
	    }

	    /**
	     * Returns the representation type of the image to display.
	     * @access public
	     * @returns {!string} - 
	     * @desc Your data source must implement this method.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1503547-imagerepresentationtype
	     */

	  }, {
	    key: 'imageRepresentationType',
	    value: function imageRepresentationType() {
	      return null;
	    }

	    /**
	     *  Returns the display subtitle of the image.
	     * @access public
	     * @returns {!string} - 
	     * @desc This method is optional.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1503725-imagesubtitle
	     */

	  }, {
	    key: 'imageSubtitle',
	    value: function imageSubtitle() {
	      return null;
	    }

	    /**
	     * Returns the display title of the image. 
	     * @access public
	     * @returns {!string} - 
	     * @desc This method is optional.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1504080-imagetitle
	     */

	  }, {
	    key: 'imageTitle',
	    value: function imageTitle() {
	      return null;
	    }

	    /**
	     * Returns a unique string that identifies the data source item.
	     * @access public
	     * @returns {!string} - 
	     * @desc Your data source must implement this method. The image browser view uses this identifier to associate the data source item and  its cache.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1503516-imageuid
	     */

	  }, {
	    key: 'imageUID',
	    value: function imageUID() {
	      return null;
	    }

	    /**
	     * Returns the version of the item. 
	     * @access public
	     * @returns {number} - 
	     * @desc This method is optional. The receiver can return a new version to let the image browser know that it should not use its cache for the item.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1504444-imageversion
	     */

	  }, {
	    key: 'imageVersion',
	    value: function imageVersion() {
	      return 0;
	    }

	    /**
	     * Returns the indices of the specified container objects.
	     * @access public
	     * @param {NSScriptObjectSpecifier} specifier - An object specifier for the container objects for which to obtain the indices.
	     * @returns {?number[]} - 
	     * @desc  Containers that want to evaluate some specifiers on their own should implement this method. If this method returns nil, the object specifier will go on to do its own evaluation, so you should only return nil if that's the behavior you want, or if an error occurs. If this method returns an array, the object specifier will use the NSNumber objects in it as the indices. So, if you evaluate the specifier and there are no objects that match, you should return an empty array, not nil. If you find only one object, you should still return its index in an array. Returning an array with a single index where the index is – is interpreted to mean all the objects.For an example implementation, see "Implementing Object Specifiers" in Object Specifiers in Cocoa Scripting Guide
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1417806-indicesofobjects
	     */

	  }, {
	    key: 'indicesOfObjectsByEvaluatingObjectSpecifier',
	    value: function indicesOfObjectsByEvaluatingObjectSpecifier(specifier) {
	      return null;
	    }

	    /**
	     * Returns a dictionary describing the receiver’s binding.
	     * @access public
	     * @param {string} binding - The name of a binding.
	     * @returns {?Map<string, Object>} - 
	     * @desc This method is mostly for use by subclasses which want to analyze the existing bindings of an object.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1458122-infoforbinding
	     */

	  }, {
	    key: 'infoForBinding',
	    value: function infoForBinding(binding) {
	      return null;
	    }

	    /**
	     * Handles key down events that do not map to an action method.
	     * @access public
	     * @param {!string} string - The key down event, which is the text input by the client.
	     * @param {!Object} sender - The client object sending the key down events.
	     * @returns {boolean} - 
	     * @desc An input method should implement this method when using key binding (that is, it implements didCommand(by:client:)).
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1385446-inputtext
	     */

	  }, {
	    key: 'inputTextClient',
	    value: function inputTextClient(string, sender) {
	      return false;
	    }

	    /**
	     * Receives Unicode, the key code that generated it, and any modifier flags.
	     * @access public
	     * @param {!string} string - The text input by the client.
	     * @param {number} keyCode - The key code for the associated Unicode.
	     * @param {number} flags - The modifier flags.
	     * @param {!Object} sender - The client object.
	     * @returns {boolean} - 
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1385436-inputtext
	     */

	  }, {
	    key: 'inputTextKeyModifiersClient',
	    value: function inputTextKeyModifiersClient(string, keyCode, flags, sender) {
	      return false;
	    }

	    /**
	     * Inserts an object at the specified index in the collection specified by the passed key.
	     * @access public
	     * @param {Object} value - 
	     * @param {number} index - 
	     * @param {string} key - 
	     * @returns {void}
	     * @desc  The method insertIn<Key>:atIndex: is invoked if it exists. If no corresponding scripting-KVC-compliant method (insertIn<Key>:atIndex: ) is found, this method invokes mutableArrayValueForKey: and mutates the result.Note Prior to OS X version 10.4, this method did not invoke -mutableArrayValueForKey:.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1417619-insertvalue
	     */

	  }, {
	    key: 'insertValueAtInPropertyWithKey',
	    value: function insertValueAtInPropertyWithKey(value, index, key) {}

	    /**
	     * Inserts an object in the collection specified by the passed key.
	     * @access public
	     * @param {Object} value - 
	     * @param {string} key - 
	     * @returns {void}
	     * @desc  The method insertIn<Key>: is used if it exists. Otherwise, raises an NSUndefinedKeyException. This is part of Cocoa’s scripting support for inserting newly-created objects into containers without explicitly specifying a location.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1416203-insertvalue
	     */

	  }, {
	    key: 'insertValueInPropertyWithKey',
	    value: function insertValueInPropertyWithKey(value, key) {}

	    /**
	     * Executes when a script attempts to invoke a method on an exposed object directly.
	     * @access public
	     * @param {!Object[]} _arguments - 
	     * @returns {!Object} - 
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1528543-invokedefaultmethod
	     */

	  }, {
	    key: 'invokeDefaultMethodWithArguments',
	    value: function invokeDefaultMethodWithArguments(_arguments) {
	      return null;
	    }

	    /**
	     * Handles undefined method invocation from the scripting environment.
	     * @access public
	     * @param {!string} name - The name of the undefined method.
	     * @param {!Object[]} _arguments - 
	     * @returns {!Object} - 
	     * @desc This method is invoked when a script attempts to invoke a method not directly exported to the scripting environment. You should return the result of the invocation, converted appropriately for the scripting environment.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1528562-invokeundefinedmethod
	     */

	  }, {
	    key: 'invokeUndefinedMethodFromWebScriptWithArguments',
	    value: function invokeUndefinedMethodFromWebScriptWithArguments(name, _arguments) {
	      return null;
	    }

	    /**
	     * Returns a Boolean value that indicates whether receiver is considered to be “like” a given string when the case of characters in the receiver is ignored.
	     * @access public
	     * @param {string} object - 
	     * @returns {boolean} - 
	     * @desc Currently, isCaseInsensitiveLike(_:) messages are never sent to any object from within Cocoa itself.The default implementation for this method provided by NSObject returns false. NSString also provides an implementation of this method, which returns true if the receiver matches a pattern described by aString, ignoring the case of the characters in the receiver.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1393837-iscaseinsensitivelike
	     */

	  }, {
	    key: 'isCaseInsensitiveLike',
	    value: function isCaseInsensitiveLike(object) {
	      return false;
	    }

	    /**
	     * Returns a Boolean value that indicates whether the receiver is equal to another given object.
	     * @access public
	     * @param {?Object} object - The object with which to compare the receiver.
	     * @returns {boolean} - 
	     * @desc During the evaluation of an NSWhoseSpecifier object that contains a test whose operator is NSEqualToComparison, an isEqual(to:) message may be sent to each potentially specified object, if neither the potentially specified object nor the object being tested against implements a scriptingIsEqual(to:) method.The default implementation for this method provided by NSObject returns true if an isEqualTo: message sent to the same object would return true.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1393823-isequal
	     */

	  }, {
	    key: 'isEqualTo',
	    value: function isEqualTo(object) {
	      return false;
	    }

	    /**
	     * Returns a Boolean value that indicates whether the receiver is greater than another given object.
	     * @access public
	     * @param {?Object} object - The object with which to compare the receiver.
	     * @returns {boolean} - 
	     * @desc During the evaluation of an NSWhoseSpecifier object that contains a test whose operator is NSGreaterThanComparison, an isGreaterThan(_:) message may be sent to each potentially specified object, if the potentially specified object does not implement a scriptingIsGreaterThan(_:) method and the object being tested against does not implement a scriptingIsLessThanOrEqual(to:) method.The default implementation for this method provided by NSObject returns true if a compare: message sent to the same object would return NSOrderedDescending.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1393885-isgreaterthan
	     */

	  }, {
	    key: 'isGreaterThan',
	    value: function isGreaterThan(object) {
	      return false;
	    }

	    /**
	     * Returns a Boolean value that indicates whether the receiver is greater than or equal to another given object.
	     * @access public
	     * @param {?Object} object - The object with which to compare the receiver.
	     * @returns {boolean} - 
	     * @desc During the evaluation of an NSWhoseSpecifier object that contains a test whose operator is NSGreaterThanOrEqualToComparison, anisGreaterThanOrEqual(to:) message may be sent to each potentially specified object, if the potentially specified object does not implement a scriptingIsGreaterThanOrEqual(to:) method and the object being tested against does not implement a scriptingIsLessThan(_:) method.The default implementation for this method provided by NSObject returns true if a compare: message sent to the same object would return NSOrderedSame or NSOrderedDescending.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1393862-isgreaterthanorequal
	     */

	  }, {
	    key: 'isGreaterThanOrEqualTo',
	    value: function isGreaterThanOrEqualTo(object) {
	      return false;
	    }

	    /**
	     * Returns a Boolean value that indicates whether the receiver is less than another given object.
	     * @access public
	     * @param {?Object} object - The object with which to compare the receiver.
	     * @returns {boolean} - 
	     * @desc During the evaluation of an NSWhoseSpecifier object that contains a test whose operator is NSLessThanComparison, an isLessThan(_:) message may be sent to each potentially specified object, if the potentially specified object does not implement a scriptingIsLessThan(_:) method and the object being tested against does not implement a scriptingIsGreaterThanOrEqual(to:) method.The default implementation for this method provided by NSObject method returns true if a compare: message sent to the same object would return NSOrderedAscending.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1393841-islessthan
	     */

	  }, {
	    key: 'isLessThan',
	    value: function isLessThan(object) {
	      return false;
	    }

	    /**
	     * Returns a Boolean value that indicates whether the receiver is less than or equal to another given object. 
	     * @access public
	     * @param {?Object} object - The object with which to compare the receiver.
	     * @returns {boolean} - 
	     * @desc During the evaluation of an NSWhoseSpecifier object that contains a test whose operator is NSLessThanOrEqualToComparison, an isLessThanOrEqual(to:) message may be sent to each potentially specified object, if the potentially specified object does not implement a scriptingIsLessThanOrEqual(to:) method and the object being tested against does not implement a scriptingIsGreaterThan(_:) method.The default implementation for this method provided by NSObject method returns true if a compare: message sent to the same object would return NSOrderedAscending or NSOrderedSame.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1393827-islessthanorequal
	     */

	  }, {
	    key: 'isLessThanOrEqualTo',
	    value: function isLessThanOrEqualTo(object) {
	      return false;
	    }

	    /**
	     * Returns a Boolean value that indicates whether the receiver is "like" another given object.
	     * @access public
	     * @param {string} object - The object with which to compare the receiver.
	     * @returns {boolean} - 
	     * @desc Currently, isLike(_:) messages are never sent to any object from within Cocoa itself.The default implementation for this method provided by NSObject method returns false. NSString also provides an implementation of this method, which returns true if the receiver matches a pattern described by object.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1393866-islike
	     */

	  }, {
	    key: 'isLike',
	    value: function isLike(object) {
	      return false;
	    }

	    /**
	     * Returns a Boolean value that indicates whether the receiver is not equal to another given object.
	     * @access public
	     * @param {?Object} object - The object with which to compare the receiver.
	     * @returns {boolean} - 
	     * @desc Currently, isNotEqual(to:) messages are never sent to any object from within Cocoa itself.The default implementation for this method provided by NSObject method returns true if an isEqual: message sent to the same object would return false.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1393843-isnotequal
	     */

	  }, {
	    key: 'isNotEqualTo',
	    value: function isNotEqualTo(object) {
	      return false;
	    }

	    /**
	     * Invoked when a resolution changes occurs for the window that hosts the layer.
	     * @access public
	     * @param {CALayer} layer - The layer whose scale and content might need updating.
	     * @param {number} newScale - The new scale of the window. 
	     * @param {NSWindow} window - The window that hosts the layer.
	     * @returns {boolean} - 
	     * @desc When a resolution change occurs for a given window, the system traverses the layer trees in that window to decide what action, if any, to take for each layer. The system queries the layer’s delegate to determine whether to change the layer’s contentsScale property to the new scale (either 2.0 or 1.0). Note that you don’t need to manage NSImage contents and that this method is not called on the delegate of a layer whose content is an NSImage object.If the delegate returns true, it should make any corresponding changes to the layer’s properties, as required by the resolution change. For example, a layer whose contents contain a CGImage object needs to determine whether an alternate CGImage object is available for the new scale factor. If the delegate finds a suitable CGImage object, then in addition to returning true, it should set the appropriate CGImage object as the layer’s new contents.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1483574-layer
	     */

	  }, {
	    key: 'layerShouldInheritContentsScaleFrom',
	    value: function layerShouldInheritContentsScaleFrom(layer, newScale, window) {
	      return false;
	    }

	    /**
	     * Returns the names of the files that the receiver promises to create at a specified location.
	     * @deprecated
	     * @access public
	     * @param {string} dropDestination - A URL object that identifies the location at which the promised files will be created.
	     * @returns {?string[]} - 
	     * @desc This method is invoked when the drop has been accepted by the destination and the destination, in the case of another Cocoa application, invokes the NSDraggingInfo method namesOfPromisedFilesDropped(atDestination:). For long operations, you can cache dropDestination and defer the creation of the files until the draggedImage:endedAt:operation: method to avoid blocking the destination application.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1416082-namesofpromisedfilesdropped
	     */

	  }, {
	    key: 'namesOfPromisedFilesDroppedAtDestination',
	    value: function namesOfPromisedFilesDroppedAtDestination(dropDestination) {
	      return null;
	    }

	    /**
	     * Returns the number of groups in an image browser view.
	     * @access public
	     * @param {!IKImageBrowserView} aBrowser - An image browser view.
	     * @returns {number} - 
	     * @desc This method is optional.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1503514-numberofgroups
	     */

	  }, {
	    key: 'numberOfGroupsInImageBrowser',
	    value: function numberOfGroupsInImageBrowser(aBrowser) {
	      return 0;
	    }

	    /**
	     * Returns the number of records managed by the data source object.
	     * @access public
	     * @param {!IKImageBrowserView} aBrowser - An image browser view.
	     * @returns {number} - 
	     * @desc Your data source must implement this method. An  IKImageView object uses this method to determine how many cells it should create and display.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1503497-numberofitems
	     */

	  }, {
	    key: 'numberOfItemsInImageBrowser',
	    value: function numberOfItemsInImageBrowser(aBrowser) {
	      return 0;
	    }

	    /**
	     * This message should be sent to the receiver when editor has uncommitted changes that can affect the receiver.
	     * @access public
	     * @param {Object} editor - 
	     * @returns {void}
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1458092-objectdidbeginediting
	     */

	  }, {
	    key: 'objectDidBeginEditing',
	    value: function objectDidBeginEditing(editor) {}

	    /**
	     * This message should be sent to the receiver when editor has finished editing a property belonging to the receiver.
	     * @access public
	     * @param {Object} editor - 
	     * @returns {void}
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1458187-objectdidendediting
	     */

	  }, {
	    key: 'objectDidEndEditing',
	    value: function objectDidEndEditing(editor) {}

	    /**
	     * Returns an array describing the options for the specified binding.
	     * @access public
	     * @param {string} binding - The name of a binding
	     * @returns {NSAttributeDescription[]} - 
	     * @desc The NSAttributeDescription instances in the array are used by Interface Builder to build the options editor user interface of the bindings inspector.The option name displayed for the option in the bindings inspector is based on the value of the NSAttributeDescription method name. The type of editor displayed for the option in the bindings inspector is based on the value of the  NSAttributeDescription method attributeType.The default value displayed in the bindings inspector for the option is based on the value of the NSAttributeDescription method defaultValue.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1458174-optiondescriptionsforbinding
	     */

	  }, {
	    key: 'optionDescriptionsForBinding',
	    value: function optionDescriptionsForBinding(binding) {
	      return null;
	    }

	    /**
	     * Return the a string that consists of the precomposed unicode characters.
	     * @access public
	     * @param {!Object} sender - The client object requesting the original string.
	     * @returns {!string} - 
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1385400-originalstring
	     */

	  }, {
	    key: 'originalString',
	    value: function originalString(sender) {
	      return null;
	    }

	    /**
	     * Implemented by an owner object to provide promised data.
	     * @access public
	     * @param {NSPasteboard} sender - The pasteboard that requires the specified data for a paste operation.
	     * @param {string} type - The type of data the owner object must provide.
	     * @returns {void}
	     * @desc The receiver should have been previously declared in a declareTypes(_:owner:) message.The requested data should be written to sender using the setData(_:forType:), setPropertyList(_:forType:), or setString(_:forType:) method. The pasteboard(_:provideDataForType:) messages may also be sent to the owner when the application is shut down through an application’s terminate(_:) method. This is the method that is invoked in response to a Quit command. Thus the user can copy something to the pasteboard, quit the application, and still paste the data that was copied. A pasteboard(_:provideDataForType:) message is sent only if the specified type of data has not already been supplied to the pasteboard. Instead of writing all data types when the cut or copy operation is done, an application can choose to implement this method to provide the data for certain types only when they are requested.If an application writes data to the pasteboard in the richest, and therefore most preferred, type at the time of a cut or copy operation, its pasteboard(_:provideDataForType:) method can simply read that data from the pasteboard, convert it to the requested type, and write it back to the pasteboard as the new type.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1525907-pasteboard
	     */

	  }, {
	    key: 'pasteboardProvideDataForType',
	    value: function pasteboardProvideDataForType(sender, type) {}

	    /**
	     * Notifies a prior owner of the specified pasteboard (and owners of representations on the pasteboard) that the pasteboard has changed owners.
	     * @access public
	     * @param {NSPasteboard} sender - The pasteboard object whose owner changed.
	     * @returns {void}
	     * @desc Pasteboard owners only need to implement this method if they need to know when they have lost ownership.The owner is not able to read the contents of the pasteboard when responding to this method. The owner should be prepared to receive this method at any time, even from within the declareTypes(_:owner:) method used to declare ownership.Once an owner has provided all of its data for declared types, it will not receive a pasteboardChangedOwner: message. If, therefore, you are maintaining an object just for the purpose of providing data lazily, rather than relying solely on receipt of a pasteboardChangedOwner: message you need to keep track of what types were promised and what types have been provided. When all the types have been provided, you may release the owner.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1532824-pasteboardchangedowner
	     */

	  }, {
	    key: 'pasteboardChangedOwner',
	    value: function pasteboardChangedOwner(sender) {}

	    /**
	     * Sent to the delegate to perform the action.
	     * @access public
	     * @param {!ABPerson} person - The person on which the action will be taken.
	     * @param {!string} identifier - The unique identifier of the selected value.
	     * @returns {void}
	     * @desc If the property returned by actionProperty() is a multivalue property, identifier contains the unique identifier of the value selected. The person being displayed in the Address Book application’s card view when the rollover menu is accesses is passed as person.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1411298-performaction
	     */

	  }, {
	    key: 'performActionFor',
	    value: function performActionFor(person, identifier) {}

	    /**
	     * Called when a designable object is created in Interface Builder.
	     * @access public
	     * @returns {void}
	     * @desc When Interface Builder instantiates a class with the IB_DESIGNABLE attribute, it calls this method to let the resulting object know that it was created at design time. You can implement this method in your designable classes and use it to configure their design-time appearance. For example, you might use the method to configure a custom text control with a default string. The system does not call this method; only Interface Builder calls it.Interface Builder waits until all objects in a graph have been created and initialized before calling this method. So if your object’s runtime configuration relies on subviews or parent views, those objects should exist by the time this method is called.Your implementation of this method must call super at some point so that parent classes can perform their own custom setup.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1402908-prepareforinterfacebuilder
	     */

	  }, {
	    key: 'prepareForInterfaceBuilder',
	    value: function prepareForInterfaceBuilder() {}

	    /**
	     * Supplies data to a CIImage object.
	     * @access public
	     * @param {Object} data - A pointer to image data. Note that data[0] refers to the first byte of the requested subimage, not the larger image buffer.
	     * @param {number} rowbytes - The number of bytes per row.
	     * @param {number} x - The x origin of the image data.
	     * @param {number} y - The y origin of the image data.
	     * @param {number} width - The width of the image data.
	     * @param {number} height - The height of the image data.
	     * @param {?Object} info - User supplied data, which is optional.
	     * @returns {void}
	     * @desc  You can supply the image provider to these methods of the CIImage class: imageWithImageProvider:size::format:colorSpace:options: to create a CIImage object from image datainit(imageProvider:size:_:format:colorSpace:options:) to initialize an existing CIImage with dataYou initialize the given bitmap with the subregion specified by the arguments x, y, width, and height. The subregion uses the local coordinate space of the image, with the origin at the upper-left corner of the image. If you change the virtual memory mapping of the buffer specified by the data argument (such as by using vm_copy to modify it), the behavior is undefined.That this callback always requests the full image data regardless of what is actually visible. All of the image is loaded or none of it is. The exception is when you create a tiled image by specifying the kCIImageProviderTileSize option. In this case, only the needed tiles are requested.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1438175-provideimagedata
	     */

	  }, {
	    key: 'provideImageDataBytesPerRowOriginSizeUserInfo',
	    value: function provideImageDataBytesPerRowOriginSizeUserInfo(data, rowbytes, x, y, width, height, info) {}

	    /**
	     * 
	     * @access public
	     * @param {!QuartzFilterManager} sender - 
	     * @param {!QuartzFilter} filter - 
	     * @returns {void}
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1504951-quartzfiltermanager
	     */

	  }, {
	    key: 'quartzFilterManagerDidAdd',
	    value: function quartzFilterManagerDidAdd(sender, filter) {}

	    /**
	     * 
	     * @access public
	     * @param {!QuartzFilterManager} sender - 
	     * @param {!QuartzFilter} filter - 
	     * @returns {void}
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1503494-quartzfiltermanager
	     */

	  }, {
	    key: 'quartzFilterManagerDidModifyFilter',
	    value: function quartzFilterManagerDidModifyFilter(sender, filter) {}

	    /**
	     * 
	     * @access public
	     * @param {!QuartzFilterManager} sender - 
	     * @param {!QuartzFilter} filter - 
	     * @returns {void}
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1503483-quartzfiltermanager
	     */

	  }, {
	    key: 'quartzFilterManagerDidRemove',
	    value: function quartzFilterManagerDidRemove(sender, filter) {}

	    /**
	     * 
	     * @access public
	     * @param {!QuartzFilterManager} sender - 
	     * @param {!QuartzFilter} filter - 
	     * @returns {void}
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1503484-quartzfiltermanager
	     */

	  }, {
	    key: 'quartzFilterManagerDidSelect',
	    value: function quartzFilterManagerDidSelect(sender, filter) {}

	    /**
	     * 
	     * @access public
	     * @param {!Object} controller - 
	     * @param {!IOBluetoothDevice} device - 
	     * @param {!UnsafeMutablePointer<BluetoothHCILinkQualityInfo>} info - 
	     * @param {IOReturn} error - 
	     * @returns {void}
	     * @desc This delegate gets invoked when an read link quality command complete event occurs. This could occur because you invoked it by issuing an -readLinkQualityForDevice: command, or someone else did from another app on the same controller.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1430075-readlinkquality
	     */

	  }, {
	    key: 'readLinkQualityForDeviceComplete',
	    value: function readLinkQualityForDeviceComplete(controller, device, info, error) {}

	    /**
	     * 
	     * @access public
	     * @param {!Object} controller - 
	     * @param {!IOBluetoothDevice} device - 
	     * @param {!UnsafeMutablePointer<BluetoothHCIRSSIInfo>} info - 
	     * @param {IOReturn} error - 
	     * @returns {void}
	     * @desc This delegate gets invoked when an RSSI command complete event occurs. This could occur because you invoked it by issuing an -readRSSIForDevice: command, or someone else did from another app on the same controller.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1428399-readrssi
	     */

	  }, {
	    key: 'readRSSIForDeviceComplete',
	    value: function readRSSIForDeviceComplete(controller, device, info, error) {}

	    /**
	     * Removes the object at the specified index from the collection specified by the passed key.
	     * @access public
	     * @param {number} index - 
	     * @param {string} key - 
	     * @returns {void}
	     * @desc  The method removeFrom<Key>AtIndex: is invoked if it exists. If no corresponding scripting-KVC-compliant method (-removeFrom<Key>AtIndex:) is found, this method invokes -mutableArrayValueForKey: and mutates the result.Note Prior to OS X version 10.4, this method did not invoke -mutableArrayValueForKey:.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1408773-removevalue
	     */

	  }, {
	    key: 'removeValueAtFromPropertyWithKey',
	    value: function removeValueAtFromPropertyWithKey(index, key) {}

	    /**
	     * Replaces the object at the specified index in the collection specified by the passed key.
	     * @access public
	     * @param {number} index - 
	     * @param {string} key - 
	     * @param {Object} value - 
	     * @returns {void}
	     * @desc  The method replaceIn<Key>:atIndex: is invoked if it exists. If no corresponding scripting-KVC-compliant method (-replaceIn<Key>atIndex:) is found, this method invokes -mutableArrayValueForKey: and mutates the result.Note Prior to OS X version 10.4, this method did not invoke -mutableArrayValueForKey:.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1411225-replacevalue
	     */

	  }, {
	    key: 'replaceValueAtInPropertyWithKeyWithValue',
	    value: function replaceValueAtInPropertyWithKeyWithValue(index, key, value) {}

	    /**
	     * Called to determine if the specified uniform type identifier should be shown in the save panel.
	     * @access public
	     * @param {!IKSaveOptions} saveOptions - The IKSaveOptions instance that called the delegate.
	     * @param {!string} utType - The uniform type identifier to test.
	     * @returns {boolean} - 
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1503501-saveoptions
	     */

	  }, {
	    key: 'saveOptionsShouldShowUTType',
	    value: function saveOptionsShouldShowUTType(saveOptions, utType) {
	      return false;
	    }

	    /**
	     * Returns true if, in a scripting comparison, the compared object matches the beginning of object. A default implementation is provided for NSString and NSAttributedString.
	     * @access public
	     * @param {Object} object - 
	     * @returns {boolean} - 
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1393858-scriptingbegins
	     */

	  }, {
	    key: 'scriptingBeginsWith',
	    value: function scriptingBeginsWith(object) {
	      return false;
	    }

	    /**
	     * Returns true if, in a scripting comparison, the compared object contains object. A default implementation is provided for NSString and NSAttributedString.
	     * @access public
	     * @param {Object} object - 
	     * @returns {boolean} - 
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1393821-scriptingcontains
	     */

	  }, {
	    key: 'scriptingContains',
	    value: function scriptingContains(object) {
	      return false;
	    }

	    /**
	     * Returns true if, in a scripting comparison, the compared object matches the end of object. A default implementation is provided for NSString and NSAttributedString.
	     * @access public
	     * @param {Object} object - 
	     * @returns {boolean} - 
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1393819-scriptingends
	     */

	  }, {
	    key: 'scriptingEndsWith',
	    value: function scriptingEndsWith(object) {
	      return false;
	    }

	    /**
	     * Returns true if, in a scripting comparison, the compared object is equal to object. A default implementation is provided for NSString and NSAttributedString.
	     * @access public
	     * @param {Object} object - 
	     * @returns {boolean} - 
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1393835-scriptingisequal
	     */

	  }, {
	    key: 'scriptingIsEqualTo',
	    value: function scriptingIsEqualTo(object) {
	      return false;
	    }

	    /**
	     * Returns true if, in a scripting comparison, the compared object is greater than object. A default implementation is provided for NSString and NSAttributedString.
	     * @access public
	     * @param {Object} object - 
	     * @returns {boolean} - 
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1393831-scriptingisgreaterthan
	     */

	  }, {
	    key: 'scriptingIsGreaterThan',
	    value: function scriptingIsGreaterThan(object) {
	      return false;
	    }

	    /**
	     * Returns true if, in a scripting comparison, the compared object is greater than or equal to object. A default implementation is provided for NSString and NSAttributedString.
	     * @access public
	     * @param {Object} object - 
	     * @returns {boolean} - 
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1393829-scriptingisgreaterthanorequal
	     */

	  }, {
	    key: 'scriptingIsGreaterThanOrEqualTo',
	    value: function scriptingIsGreaterThanOrEqualTo(object) {
	      return false;
	    }

	    /**
	     * Returns true if, in a scripting comparison, the compared object is less than object. A default implementation is provided for NSString and NSAttributedString.
	     * @access public
	     * @param {Object} object - 
	     * @returns {boolean} - 
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1393887-scriptingislessthan
	     */

	  }, {
	    key: 'scriptingIsLessThan',
	    value: function scriptingIsLessThan(object) {
	      return false;
	    }

	    /**
	     * Returns true if, in a scripting comparison, the compared object is less than or equal to object. A default implementation is provided for NSString and NSAttributedString.
	     * @access public
	     * @param {Object} object - 
	     * @returns {boolean} - 
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1393825-scriptingislessthanorequal
	     */

	  }, {
	    key: 'scriptingIsLessThanOrEqualTo',
	    value: function scriptingIsLessThanOrEqualTo(object) {
	      return false;
	    }

	    /**
	     * Sent to the delegate to determine whether the action should be enabled.
	     * @access public
	     * @param {!ABPerson} person - The person on which the action will be taken.
	     * @param {!string} identifier - The unique identifier of the selected value.
	     * @returns {boolean} - 
	     * @desc If the property returned by actionProperty() is a multivalue property, identifier contains the unique identifier of the value selected.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1411300-shouldenableaction
	     */

	  }, {
	    key: 'shouldEnableActionFor',
	    value: function shouldEnableActionFor(person, identifier) {
	      return false;
	    }

	    /**
	     * 
	     * @deprecated
	     * @access public
	     * @param {Notification} notification - 
	     * @returns {void}
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1532645-textstoragedidprocessediting
	     */

	  }, {
	    key: 'textStorageDidProcessEditing',
	    value: function textStorageDidProcessEditing(notification) {}

	    /**
	     * 
	     * @deprecated
	     * @access public
	     * @param {Notification} notification - 
	     * @returns {void}
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1533957-textstoragewillprocessediting
	     */

	  }, {
	    key: 'textStorageWillProcessEditing',
	    value: function textStorageWillProcessEditing(notification) {}

	    /**
	     * Sent to the delegate to request the title of the menu item for the action.
	     * @access public
	     * @param {!ABPerson} person - The person on which the action will be taken.
	     * @param {!string} identifier - The unique identifier of the value for which the menu item will be displayed.
	     * @returns {!string} - 
	     * @desc If the property returned by actionProperty() is a multivalue property, identifier contains the unique identifier of the value selected.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1411304-title
	     */

	  }, {
	    key: 'titleFor',
	    value: function titleFor(person, identifier) {
	      return null;
	    }

	    /**
	     * Removes a given binding between the receiver and a controller.
	     * @access public
	     * @param {string} binding - The name of a binding.
	     * @returns {void}
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1458088-unbind
	     */

	  }, {
	    key: 'unbind',
	    value: function unbind(binding) {}

	    /**
	     * Returns the mode mask corresponding to the expected font panel mode.
	     * @access public
	     * @param {NSFontPanel} fontPanel - 
	     * @returns {number} - 
	     * @desc The mode masks are defined in Mode Masks. The Font Panel has the ability to hide elements that are not applicable for a given context by having the target respond to validModesForFontPanel(_:). If the target desires a font panel mode other than the standard mode mask, it must respond to this method.This message is sent up the responder chain to the first responder implementing the method. Ideally that object should be the first responder found that also implements changeFont(_:).
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1534415-validmodesforfontpanel
	     */

	  }, {
	    key: 'validModesForFontPanel',
	    value: function validModesForFontPanel(fontPanel) {
	      return 0;
	    }

	    /**
	     * Implemented to override the default action of enabling or disabling a specific menu item.
	     * @access public
	     * @param {NSMenuItem} menuItem - An NSMenuItem object that represents the menu item.
	     * @returns {boolean} - 
	     * @desc The object implementing this method must be the target of menuItem. You can determine which menu item menuItem is by querying it for its tag or action. The following example disables the menu item associated with the nextRecord action method when the selected line in a table view is the last one; conversely, it disables the menu item with priorRecord as its action method when the selected row is the first one in the table view. (The countryKeys array contains names that appear in the table view.)- (BOOL)validateMenuItem:(NSMenuItem *)item {
	      int row = [tableView selectedRow];
	      if ([item action] == @selector(nextRecord) &&
	          (row == [countryKeys indexOfObject:[countryKeys lastObject]])) {
	          return NO;
	      }
	      if ([item action] == @selector(priorRecord) && row == 0) {
	          return NO;
	      }
	      return YES;
	    }
	    - (BOOL)validateMenuItem:(NSMenuItem *)item {
	      int row = [tableView selectedRow];
	      if ([item action] == @selector(nextRecord) &&
	          (row == [countryKeys indexOfObject:[countryKeys lastObject]])) {
	          return NO;
	      }
	      if ([item action] == @selector(priorRecord) && row == 0) {
	          return NO;
	      }
	      return YES;
	    }
	      * @see https://developer.apple.com/reference/objectivec/nsobject/1518160-validatemenuitem
	     */

	  }, {
	    key: 'validateMenuItem',
	    value: function validateMenuItem(menuItem) {
	      return false;
	    }

	    /**
	     * If this method is implemented and returns false, NSToolbar will disable theItem; returning true causes theItem to be enabled.
	     * @access public
	     * @param {NSToolbarItem} item - 
	     * @returns {boolean} - 
	     * @desc NSToolbar only calls this method for image items.Note
	    validateToolbarItem(_:) is called very frequently, so it must be efficient.If the receiver is the target for the actions of multiple toolbar items, it’s necessary to determine which toolbar item theItem refers to by testing the itemIdentifier.-(BOOL)validateToolbarItem:(NSToolbarItem *)toolbarItem
	    {
	      BOOL enable = NO;
	      if ([[toolbarItem itemIdentifier] isEqual:SaveDocToolbarItemIdentifier]) {
	          // We will return YES (enable the save item)
	          // only when the document is dirty and needs saving
	          enable = [self isDocumentEdited];
	      } else if ([[toolbarItem itemIdentifier] isEqual:NSToolbarPrintItemIdentifier]) {
	          // always enable print for this window
	          enable = YES;
	      }
	      return enable;
	    }
	    -(BOOL)validateToolbarItem:(NSToolbarItem *)toolbarItem
	    {
	      BOOL enable = NO;
	      if ([[toolbarItem itemIdentifier] isEqual:SaveDocToolbarItemIdentifier]) {
	          // We will return YES (enable the save item)
	          // only when the document is dirty and needs saving
	          enable = [self isDocumentEdited];
	      } else if ([[toolbarItem itemIdentifier] isEqual:NSToolbarPrintItemIdentifier]) {
	          // always enable print for this window
	          enable = YES;
	      }
	      return enable;
	    }
	      * @see https://developer.apple.com/reference/objectivec/nsobject/1524282-validatetoolbaritem
	     */

	  }, {
	    key: 'validateToolbarItem',
	    value: function validateToolbarItem(item) {
	      return false;
	    }

	    /**
	     * Retrieves an indexed object from the collection specified by the passed key.
	     * @access public
	     * @param {number} index - 
	     * @param {string} key - 
	     * @returns {?Object} - 
	     * @desc  This actually works with a single-value key as well if index is 0. The method valueIn<Key>AtIndex: is used if it exists.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1407605-value
	     */

	  }, {
	    key: 'valueAtInPropertyWithKey',
	    value: function valueAtInPropertyWithKey(index, key) {
	      return null;
	    }

	    /**
	     * Returns the class of the value that will be returned for the specified binding.
	     * @access public
	     * @param {string} binding - The name of a binding.
	     * @returns {?Object} - 
	     * @desc This method is used by Interface Builder to determine the appropriate transformers for a binding. Implementation of this method is optional.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1458101-valueclassforbinding
	     */

	  }, {
	    key: 'valueClassForBinding',
	    value: function valueClassForBinding(binding) {
	      return null;
	    }

	    /**
	     * Retrieves a named object from the collection specified by the passed key.
	     * @access public
	     * @param {string} name - 
	     * @param {string} key - 
	     * @returns {?Object} - 
	     * @desc  The method valueIn<Key>WithName: is used if it exists. Otherwise, raises an NSUndefinedKeyException.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1418031-value
	     */

	  }, {
	    key: 'valueWithNameInPropertyWithKey',
	    value: function valueWithNameInPropertyWithKey(name, key) {
	      return null;
	    }

	    /**
	     * Retrieves an object by ID from the collection specified by the passed key.
	     * @access public
	     * @param {Object} uniqueID - 
	     * @param {string} key - 
	     * @returns {?Object} - 
	     * @desc  The method valueIn<Key>WithUniqueID: is invoked if it exists. Otherwise, raises an NSUndefinedKeyException. The declared type of uniqueID in the constructed method must be id, NSNumber *, NSString *, or one of the scalar types that can be encapsulated by NSNumber.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1407321-value
	     */

	  }, {
	    key: 'valueWithUniqueIDInPropertyWithKey',
	    value: function valueWithUniqueIDInPropertyWithKey(uniqueID, key) {
	      return null;
	    }

	    /**
	     * Returns the tool tip string to be displayed due to the cursor pausing at location point within the tool tip rectangle identified by tag in the view view.
	     * @access public
	     * @param {NSView} view - 
	     * @param {NSToolTipTag} tag - 
	     * @param {CGPoint} point - 
	     * @param {?Object} data - 
	     * @returns {string} - 
	     * @desc  userData is additional information provided by the creator of the tool tip rectangle.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1483693-view
	     */

	  }, {
	    key: 'viewStringForToolTipUserData',
	    value: function viewStringForToolTipUserData(view, tag, point, data) {
	      return '';
	    }

	    /**
	     * Loads a URL into a web frame.
	     * @access public
	     * @param {!URLRequest} request - The request that specifies the URL.
	     * @param {!string} target - The frame into which the URL is loaded.
	     * @returns {void}
	     * @desc If the frame specified by target is not found, a new window is opened, loaded with the URL request, and given the specified frame name. If target is nil, the frame enclosing the plug-in is loaded with the URL request.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1536649-webplugincontainerload
	     */

	  }, {
	    key: 'webPlugInContainerLoadInFrame',
	    value: function webPlugInContainerLoadInFrame(request, target) {}

	    /**
	     * Tells the container to show a status message.
	     * @access public
	     * @param {!string} message - The status message to be displayed.
	     * @returns {void}
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1537604-webplugincontainershowstatus
	     */

	  }, {
	    key: 'webPlugInContainerShowStatus',
	    value: function webPlugInContainerShowStatus(message) {}

	    /**
	     * Prepares the plug-in for deallocation.
	     * @access public
	     * @returns {void}
	     * @desc Typically, this method frees the memory and other resources used by the plug-in. For example, if the plug-in had a copy of a WebPlugInContainer object, this method should relinquish ownership of that object. Do not send any other messages to the plug-in after invoking this method, because calling this method destroys the plug-in. No other methods in this interface may be called after the application has called this method.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1536659-webplugindestroy
	     */

	  }, {
	    key: 'webPlugInDestroy',
	    value: function webPlugInDestroy() {}

	    /**
	     * Initializes the plug-in.
	     * @access public
	     * @returns {void}
	     * @desc Tells the plug-in to perform one-time initialization. This method must be called only once per instance of the plug-in object, before any other methods in the protocol are called.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1537623-webplugininitialize
	     */

	  }, {
	    key: 'webPlugInInitialize',
	    value: function webPlugInInitialize() {}

	    /**
	     * Invoked when an error occurs loading the main resource.
	     * @access public
	     * @param {!Error} error - An error object containing details of why the connection failed to load the request successfully.
	     * @returns {void}
	     * @desc This message is invoked when the underlying NSURLConnection object for the main resource sends the connection:didFailWithError: message to its delegate.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1536829-webpluginmainresourcedidfailwith
	     */

	  }, {
	    key: 'webPlugInMainResourceDidFailWithError',
	    value: function webPlugInMainResourceDidFailWithError(error) {}

	    /**
	     * Invoked when the connection successfully finishes loading data.
	     * @access public
	     * @returns {void}
	     * @desc This message is invoked when the WebPlugInShouldLoadMainResourceKey plug-in command-line argument is set to false and the underlying NSURLConnection object for the main resource sends the connectionDidFinishLoading: message to its delegate.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1537693-webpluginmainresourcedidfinishlo
	     */

	  }, {
	    key: 'webPlugInMainResourceDidFinishLoading',
	    value: function webPlugInMainResourceDidFinishLoading() {}

	    /**
	     * Invoked when the connection receives sufficient data to construct the URL response for its request.
	     * @access public
	     * @param {!URLResponse} response - The URL response for the connection's request.
	     * @returns {void}
	     * @desc This message is invoked when the WebPlugInShouldLoadMainResourceKey plug-in command-line argument is set to false and the underlying NSURLConnection object for the main resource sends the connection:didReceiveResponse: message to its delegate.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1537895-webpluginmainresourcedidreceive
	     */

	  }, {
	    key: 'webPlugInMainResourceDidReceive',
	    value: function webPlugInMainResourceDidReceive(response) {}

	    /**
	     * Controls plug-in behavior based on its selection.
	     * @access public
	     * @param {boolean} isSelected - If true, the plug-in is currently selected. Otherwise, it is not selected.
	     * @returns {void}
	     * @desc This may be used, for example, to change the plug-in’s appearance when it is selected by the user.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1536477-webpluginsetisselected
	     */

	  }, {
	    key: 'webPlugInSetIsSelected',
	    value: function webPlugInSetIsSelected(isSelected) {}

	    /**
	     * Tells the plug-in to start normal operation.
	     * @access public
	     * @returns {void}
	     * @desc The plug-in usually begins its primary task (such as drawing, playing sounds, or animating) in this method. This method may be called more than once, provided that the application has already called webPlugInInitialize() and that each call to this method is followed later by a call to webPlugInStop().
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1536197-webpluginstart
	     */

	  }, {
	    key: 'webPlugInStart',
	    value: function webPlugInStart() {}

	    /**
	     * Tells the plug-in to stop normal operation.
	     * @access public
	     * @returns {void}
	     * @desc This method may be called more than once, provided that the application has already called webPlugInInitialize() and that each call to this method is preceded by a call to webPlugInStart().
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1536433-webpluginstop
	     */

	  }, {
	    key: 'webPlugInStop',
	    value: function webPlugInStop() {}

	    /**
	     * Invoked when the receiver's workflow encounters an error.
	     * @access public
	     * @param {AMWorkflowController} controller - The controller object sending the message.
	     * @param {Error} error - If a workflow error occurs, upon return contains an instance of NSError that describes the problem.
	     * @returns {void}
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1419652-workflowcontroller
	     */

	  }, {
	    key: 'workflowControllerDidError',
	    value: function workflowControllerDidError(controller, error) {}

	    /**
	     * Invoked when an action in the receiver's workflow is finished running.
	     * @access public
	     * @param {AMWorkflowController} controller - The controller object sending the message.
	     * @param {AMAction} action - The workflow action that ran.
	     * @returns {void}
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1419675-workflowcontroller
	     */

	  }, {
	    key: 'workflowControllerDidRun',
	    value: function workflowControllerDidRun(controller, action) {}

	    /**
	     * Invoked when an action in the receiver's workflow is about to run.
	     * @access public
	     * @param {AMWorkflowController} controller - The controller object sending the message.
	     * @param {AMAction} action - The workflow action that will run.
	     * @returns {void}
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1419720-workflowcontroller
	     */

	  }, {
	    key: 'workflowControllerWillRun',
	    value: function workflowControllerWillRun(controller, action) {}

	    /**
	     * Tells the delegate that the workflow controller object has stopped.
	     * @access public
	     * @param {AMWorkflowController} controller - The workflow controller object that stopped.
	     * @returns {void}
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1419770-workflowcontrollerdidstop
	     */

	  }, {
	    key: 'workflowControllerDidStop',
	    value: function workflowControllerDidStop(controller) {}

	    /**
	     * Tells the delegate that the workflow controller object is about to stop.
	     * @access public
	     * @param {AMWorkflowController} controller - The workflow controller object to be stopped.
	     * @returns {void}
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1419598-workflowcontrollerwillstop
	     */

	  }, {
	    key: 'workflowControllerWillStop',
	    value: function workflowControllerWillStop(controller) {}

	    /**
	     * Tells the element to activate itself and report the success or failure of the operation.
	     * @access public
	     * @returns {boolean} - 
	     * @desc You can use this method to make complex controls more readily accessible to users. The accessibility system calls this method when a VoiceOver user double taps the selected element. Your implementation of this method should activate the element and perform whatever other tasks it deems appropriate. For example, you might use the method to activate a control that requires a complex gesture and would be difficult for VoiceOver users to perform, possibly because the gesture has a different meaning when VoiceOver is running.After performing any tasks, return an appropriate Boolean value to indicate success or failure.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1615165-accessibilityactivate
	     */

	  }, {
	    key: 'accessibilityActivate',
	    value: function accessibilityActivate() {
	      return false;
	    }

	    /**
	     * 
	     * @access public
	     * @returns {?Set<String>} - 
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1615206-accessibilityassistivetechnology
	     */

	  }, {
	    key: 'accessibilityAssistiveTechnologyFocusedIdentifiers',
	    value: function accessibilityAssistiveTechnologyFocusedIdentifiers() {
	      return null;
	    }

	    /**
	     * Tells the accessibility element to decrement the value of its content.
	     * @access public
	     * @returns {void}
	     * @desc If your element has the UIAccessibilityTraitAdjustable trait, you must implement this method. Use this method to decrement the value of the element. For example, a UISlider object uses this method to decrement its value by an appropriate amount. 
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1615169-accessibilitydecrement
	     */

	  }, {
	    key: 'accessibilityDecrement',
	    value: function accessibilityDecrement() {}

	    /**
	     * Returns the accessibility element at the specified index.
	     * @access public
	     * @param {number} index - The index of the accessibility element.
	     * @returns {?Object} - 
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1615084-accessibilityelement
	     */

	  }, {
	    key: 'accessibilityElementAt',
	    value: function accessibilityElementAt(index) {
	      return null;
	    }

	    /**
	     * Returns the number of accessibility elements in the container.
	     * @access public
	     * @returns {number} - 
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1615149-accessibilityelementcount
	     */

	  }, {
	    key: 'accessibilityElementCount',
	    value: function accessibilityElementCount() {
	      return 0;
	    }

	    /**
	     * Sent after an assistive technology has set its virtual focus on the accessibility element.
	     * @access public
	     * @returns {void}
	     * @desc Override accessibilityElementDidBecomeFocused if you need to know when an assistive technology has set its virtual focus on an accessibility element.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1615183-accessibilityelementdidbecomefoc
	     */

	  }, {
	    key: 'accessibilityElementDidBecomeFocused',
	    value: function accessibilityElementDidBecomeFocused() {}

	    /**
	     * Sent after an assistive technology has removed its virtual focus from an accessibility element.
	     * @access public
	     * @returns {void}
	     * @desc Override accessibilityElementDidLoseFocus if you need to know when an assistive technology has removed its virtual focus from an accessibility element. Note that accessibilityElementDidLoseFocus is sent before accessibilityElementDidBecomeFocused().
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1615082-accessibilityelementdidlosefocus
	     */

	  }, {
	    key: 'accessibilityElementDidLoseFocus',
	    value: function accessibilityElementDidLoseFocus() {}

	    /**
	     * Returns a Boolean value indicating whether an assistive technology is focused on the accessibility element.
	     * @access public
	     * @returns {boolean} - 
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1615190-accessibilityelementisfocused
	     */

	  }, {
	    key: 'accessibilityElementIsFocused',
	    value: function accessibilityElementIsFocused() {
	      return false;
	    }

	    /**
	     * Tells the accessibility element to increment the value of its content.
	     * @access public
	     * @returns {void}
	     * @desc If your element has the UIAccessibilityTraitAdjustable trait, you must implement this method. Use this method to increment the value of the element. For example, a UISlider object uses this method to increment its value by an appropriate amount. 
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1615076-accessibilityincrement
	     */

	  }, {
	    key: 'accessibilityIncrement',
	    value: function accessibilityIncrement() {}

	    /**
	     * Dismisses a modal view and returns the success or failure of the action.
	     * @access public
	     * @returns {boolean} - 
	     * @desc Implement this method on an element or containing view that can be revealed modally or in a hierarchy. When a VoiceOver user performs a dismiss action, this method dismisses the view. For example, you might implement this method for a popover in order to give users a deliberate dismiss action to perform that closes the popover.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1615091-accessibilityperformescape
	     */

	  }, {
	    key: 'accessibilityPerformEscape',
	    value: function accessibilityPerformEscape() {
	      return false;
	    }

	    /**
	     * Performs a salient action.
	     * @access public
	     * @returns {boolean} - 
	     * @desc The exact action performed by this method depends your app, typically toggling the most important state of the app. For example, in the Phone app it answers and ends phone calls, in the Music app it plays and pauses playback, in the Clock app it starts and stops a timer, and in the Camera app it takes a picture.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1615137-accessibilityperformmagictap
	     */

	  }, {
	    key: 'accessibilityPerformMagicTap',
	    value: function accessibilityPerformMagicTap() {
	      return false;
	    }

	    /**
	     * Scrolls screen content in an application-specific way and returns the success or failure of the action.
	     * @access public
	     * @param {UIAccessibilityScrollDirection} direction - A constant that specifies the direction of the scrolling action. See UIAccessibilityScrollDirection for descriptions of valid constants.
	     * @returns {boolean} - 
	     * @desc Implement this method if a view in the view hierarchy supports a scroll by page action.If the scrolling action succeeds for the specified direction, return true and post the UIAccessibilityPageScrolledNotification notification. If the scrolling action fails, accessibilityScroll: is called on a parent view in the hierarchy.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1615161-accessibilityscroll
	     */

	  }, {
	    key: 'accessibilityScroll',
	    value: function accessibilityScroll(direction) {
	      return false;
	    }

	    /**
	     * Returns the index of the specified accessibility element.
	     * @access public
	     * @param {Object} element - The accessibility element.
	     * @returns {number} - 
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1615078-index
	     */

	  }, {
	    key: 'indexOfAccessibilityElement',
	    value: function indexOfAccessibilityElement(element) {
	      return 0;
	    }

	    // Type Methods

	    /**
	     * Returns a Boolean value that indicates whether the observed object supports automatic key-value observation for the given key.
	     * @access public
	     * @param {string} key - 
	     * @returns {boolean} - 
	     * @desc The default implementation returns true. Starting in OS X 10.5, the default implementation of this method searches the receiving class for a method whose name matches the pattern +automaticallyNotifiesObserversOf<Key>, and returns the result of invoking that method if it is found. Any found methods must return BOOL. If no such method is found true is returned.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1409370-automaticallynotifiesobservers
	     */

	  }, {
	    key: 'autoContentAccessingProxy',


	    // Discardable Content Proxy Support
	    /**
	     * A proxy for the receiving object
	     * @type {Object}
	     * @desc This property returns a proxy for the receiving object if the receiver adopts the NSDiscardableContent protocol and still has content that has not been discarded.The proxy calls beginContentAccess() on the receiver to keep the content available as long as the proxy lives, and calls endContentAccess() when the proxy is deallocated.The wrapper object is otherwise a subclass of NSProxy and forwards messages to the original receiver object as an NSProxy does.This method can be used to hide an NSDiscardableContent object's content volatility by creating an object that responds to the same messages but holds the contents of the original receiver available as long as the created proxy lives. Thus hidden, the NSDiscardableContent object (by way of the proxy) can be given out to unsuspecting recipients of the object who would otherwise not know they might have to call beginContentAccess() and endContentAccess() around particular usages (specific to each NSDiscardableContent object) of the NSDiscardableContent object.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1409224-autocontentaccessingproxy
	     */
	    get: function get() {
	      return this._autoContentAccessingProxy;
	    }
	  }, {
	    key: 'classForArchiver',

	    /**
	     * The class to substitute for the receiver's own class during archiving.
	     * @type {?Object}
	     * @desc 
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1411359-classforarchiver
	     */
	    get: function get() {
	      return this._classForArchiver;
	    }
	    /**
	     * Overridden by subclasses to substitute a class other than its own during coding.
	     * @type {Object}
	     * @desc This method is invoked by NSCoder. NSObject’s implementation returns the receiver’s class. The private subclasses of a class cluster substitute the name of their public superclass when being archived.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1411876-classforcoder
	     */

	  }, {
	    key: 'classForCoder',
	    get: function get() {
	      return this._classForCoder;
	    }
	    /**
	     * Subclasses to substitute a new class for instances during keyed archiving.
	     * @type {?Object}
	     * @desc The object will be encoded as if it were a member of the class. This property is overridden by the encoder class and instance name to class encoding tables. If this property is nil, the result of this property is ignored.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1410512-classforkeyedarchiver
	     */

	  }, {
	    key: 'classForKeyedArchiver',
	    get: function get() {
	      return this._classForKeyedArchiver;
	    }
	  }, {
	    key: 'attributeKeys',
	    get: function get() {
	      return this._attributeKeys;
	    }
	    /**
	     * An object containing information about the attributes and relationships of the receiver’s class.
	     * @type {NSClassDescription}
	     * @desc 
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1411858-classdescription
	     */

	  }, {
	    key: 'classDescription',
	    get: function get() {
	      return this._classDescription;
	    }
	    /**
	     * An array containing the keys for the to-many relationship properties of the receiver.
	     * @type {string[]}
	     * @desc 
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1415662-tomanyrelationshipkeys
	     */

	  }, {
	    key: 'toManyRelationshipKeys',
	    get: function get() {
	      return this._toManyRelationshipKeys;
	    }
	    /**
	     * The keys for the to-one relationship properties of the receiver, if any.
	     * @type {string[]}
	     * @desc 
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1414814-toonerelationshipkeys
	     */

	  }, {
	    key: 'toOneRelationshipKeys',
	    get: function get() {
	      return this._toOneRelationshipKeys;
	    }
	  }, {
	    key: 'classCode',
	    get: function get() {
	      return this._classCode;
	    }
	    /**
	     * A string containing the name of the class.
	     * @type {string}
	     * @desc 
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1411337-classname
	     */

	  }, {
	    key: 'className',
	    get: function get() {
	      return this._className;
	    }
	  }, {
	    key: 'hashValue',
	    get: function get() {
	      return this._hashValue;
	    }
	    /**
	     * The deepest descendant of the accessibility hierarchy that has the focus.
	     * @type {?Object}
	     * @desc You can assume that the search for the focus has already been narrowed down to the accessibility element. Override this method to do deeper searching by identifying which child element, if any, may have the focus. If a child element does not have the focus, either return self or, if available, invoke the superclass's implementation. The default NSView and NSCell implementations test whether the accessibility element is an ignored element and, if so, return the element’s first unignored parent; otherwise they return self
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1526100-accessibilityfocuseduielement
	     */

	  }, {
	    key: 'accessibilityFocusedUIElement',
	    get: function get() {
	      return this._accessibilityFocusedUIElement;
	    }
	    /**
	     * A Boolean value that indicates whether a custom accessibility object sends a notification when its corresponding UI element is destroyed.
	     * @type {boolean}
	     * @desc In macOS 10.9 and later, a custom accessibility object that is an NSObject subclass can post accessibility notifications if it meets the following criteria:The lifetime of the custom accessibility object must match the lifetime of the corresponding element in the app's UI.Typically, a custom accessibility object that acts as a proxy for an onscreen UI element gets autoreleased and deallocated immediately after the app responds to an accessibility request. Such an object can’t post accessibility notifications, because all registered observers get removed as soon as the object is deallocated. To correct this, an app must guarantee that a custom accessibility object remains allocated for as long as its corresponding UI element remains visible.The object must post the NSAccessibilityUIElementDestroyedNotification  notification at the appropriate time. The appropriate time is most likely to be when the corresponding UI element is removed from the screen, but it can also be when the object itself is deallocated. The object must implement accessibilityNotifiesWhenDestroyed and return true.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1534050-accessibilitynotifieswhendestroy
	     */

	  }, {
	    key: 'accessibilityNotifiesWhenDestroyed',
	    get: function get() {
	      return this._accessibilityNotifiesWhenDestroyed;
	    }
	    /**
	     * Returns an array containing the bindings exposed by the receiver.
	     * @type {string[]}
	     * @desc A subclass can override this method to remove bindings that are exposed by a superclass that are not appropriate for the subclass.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1458048-exposedbindings
	     */

	  }, {
	    key: 'exposedBindings',
	    get: function get() {
	      return this._exposedBindings;
	    }
	    /**
	     * Returns an object that exposes the plug-in’s scripting interface.
	     * @type {!Object}
	     * @desc The methods of the object are exposed to the script environment. Messages sent to the returned object will be invoked in the scripting environment. See the WebScripting Protocol Reference informal protocol for more details.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1537612-objectforwebscript
	     */

	  }, {
	    key: 'objectForWebScript',
	    get: function get() {
	      return this._objectForWebScript;
	    }
	    /**
	     * Returns an object specifier for the receiver.
	     * @type {?NSScriptObjectSpecifier}
	     * @desc 
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1409884-objectspecifier
	     */

	  }, {
	    key: 'objectSpecifier',
	    get: function get() {
	      return this._objectSpecifier;
	    }
	    /**
	     * Returns the WebFrame that contains the plug-in.
	     * @type {!WebFrame}
	     * @desc Only implemented by containers that are based on the WebKit’s plug-in architecture.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1537727-webframe
	     */

	  }, {
	    key: 'webFrame',
	    get: function get() {
	      return this._webFrame;
	    }
	    /**
	     * Returns the plug-in selection color.
	     * @type {!CGColor}
	     * @desc The color should be used for any special drawing when the plug-in is selected.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1536394-webplugincontainerselectioncolor
	     */

	  }, {
	    key: 'webPlugInContainerSelectionColor',
	    get: function get() {
	      return this._webPlugInContainerSelectionColor;
	    }
	    /**
	     * Returns a Boolean value that indicates whether the key-value coding methods should access the corresponding instance variable directly on finding no accessor method for a property.
	     * @type {boolean}
	     * @desc The default returns true. Subclasses can override it to return false, in which case the key-value coding methods won’t access instance variables.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1415307-accessinstancevariablesdirectly
	     */

	  }, {
	    key: 'isSelectable',

	    /**
	     * 
	     * @type {boolean}
	     * @desc 
	     * @see https://developer.apple.com/reference/objectivec/nsobject/2369549-isselectable
	     */
	    get: function get() {
	      return this._isSelectable;
	    }
	  }], [{
	    key: 'superclass',
	    value: function superclass() {
	      return null;
	    }

	    /**
	     * Returns a Boolean value that indicates whether the receiving class is a subclass of, or identical to, a given class.
	     * @access public
	     * @param {Object} aClass - A class object.
	     * @returns {boolean} - 
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1418669-issubclass
	     */

	  }, {
	    key: 'isSubclassOf',
	    value: function isSubclassOf(aClass) {
	      return false;
	    }

	    // Testing Class Functionality

	    /**
	     * Returns a Boolean value that indicates whether instances of the receiver are capable of responding to a given selector.
	     * @access public
	     * @param {!function} aSelector - A Selector.
	     * @returns {boolean} - 
	     * @desc If aSelector messages are forwarded to other objects, instances of the class are able to receive those messages without error even though this method returns false.To ask the class whether it, rather than its instances, can respond to a particular message, send to the class instead the  NSObject protocol instance method responds(to:).
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1418555-instancesrespond
	     */

	  }, {
	    key: 'instancesRespondTo',
	    value: function instancesRespondTo(aSelector) {
	      return false;
	    }

	    // Testing Protocol Conformance

	    /**
	     * Returns a Boolean value that indicates whether the receiver conforms to a given protocol.
	     * @access public
	     * @param {Object} protocol - 
	     * @returns {boolean} - 
	     * @desc A class is said to “conform to” a protocol if it adopts the protocol or inherits from another class that adopts it. Protocols are adopted by listing them within angle brackets after the interface declaration. For example, here MyClass adopts the (fictitious) AffiliationRequests and Normalization protocols:@interface MyClass : NSObject <AffiliationRequests, Normalization>
	    A class also conforms to any protocols that are incorporated in the protocols it adopts or inherits. Protocols incorporate other protocols in the same way classes adopt them. For example, here the AffiliationRequests protocol incorporates the Joining protocol:@protocol AffiliationRequests <Joining>
	    If a class adopts a protocol that incorporates another protocol, it must also implement all the methods in the incorporated protocol or inherit those methods from a class that adopts it.This method determines conformance solely on the basis of the formal declarations in header files, as illustrated above. It doesn’t check to see whether the methods declared in the protocol are actually implemented—that’s the programmer’s responsibility.The protocol required as this method’s argument can be specified using the @protocol() directive:BOOL canJoin = [MyClass conformsToProtocol:@protocol(Joining)];
	    @interface MyClass : NSObject <AffiliationRequests, Normalization>
	    @protocol AffiliationRequests <Joining>
	    BOOL canJoin = [MyClass conformsToProtocol:@protocol(Joining)];
	      * @see https://developer.apple.com/reference/objectivec/nsobject/1418893-conforms
	     */

	  }, {
	    key: 'conformsTo',
	    value: function conformsTo(protocol) {
	      return false;
	    }
	  }, {
	    key: 'instanceMethodFor',
	    value: function instanceMethodFor(aSelector) {
	      return null;
	    }

	    // Describing Objects

	    /**
	     * Returns a string that represents the contents of the receiving class.
	     * @access public
	     * @returns {string} - 
	     * @desc The debugger’s print-object command invokes this method to produce a textual description of an object.NSObject's implementation of this method simply prints the name of the class.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1418799-description
	     */

	  }, {
	    key: 'description',
	    value: function description() {
	      return '';
	    }
	  }, {
	    key: 'cancelPreviousPerformRequestsWithTarget',
	    value: function cancelPreviousPerformRequestsWithTarget(aTarget) {}

	    /**
	     * Cancels perform requests previously registered with perform(_:with:afterDelay:).
	     * @access public
	     * @param {Object} aTarget - The target for requests previously registered with the perform(_:with:afterDelay:) instance method
	     * @param {function} aSelector - The Selector for requests previously registered with the perform(_:with:afterDelay:) instance method.
	     * @param {?Object} anArgument - The argument for requests previously registered with the perform(_:with:afterDelay:) instance method. Argument equality is determined using isEqual(_:), so the value need not be the same object that was passed originally. Pass nil to match a request for nil that was originally passed as the argument.
	     * @returns {void}
	     * @desc All perform requests are canceled that have the same target as aTarget, argument as anArgument, and selector as aSelector. This method removes perform requests only in the current run loop, not all run loops.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1410849-cancelpreviousperformrequests
	     */

	  }, {
	    key: 'cancelPreviousPerformRequestsWithTargetSelectorObject',
	    value: function cancelPreviousPerformRequestsWithTargetSelectorObject(aTarget, aSelector, anArgument) {}
	  }, {
	    key: 'resolveClassMethod',
	    value: function resolveClassMethod(sel) {
	      return false;
	    }

	    /**
	     * Dynamically provides an implementation for a given selector for an instance method.
	     * @access public
	     * @param {!function} sel - 
	     * @returns {boolean} - 
	     * @desc This method and resolveClassMethod(_:) allow you to dynamically provide an implementation for a given selector.An Objective-C method is simply a C function that take at least two arguments—self and _cmd. Using the class_addMethod(_:_:_:_:) function, you can add a function to a class as a method. Given the following function:void dynamicMethodIMP(id self, SEL _cmd)
	    {
	      // implementation ....
	    }
	    you can use resolveInstanceMethod: to dynamically add it to a class as a method (called resolveThisMethodDynamically) like this:+ (BOOL) resolveInstanceMethod:(SEL)aSEL
	    {
	      if (aSEL == @selector(resolveThisMethodDynamically))
	      {
	            class_addMethod([self class], aSEL, (IMP) dynamicMethodIMP, "v@:");
	            return YES;
	      }
	      return [super resolveInstanceMethod:aSel];
	    }
	    Special ConsiderationsThis method is called before the Objective-C forwarding mechanism is invoked. If responds(to:) or instancesRespond(to:) is invoked, the dynamic method resolver is given the opportunity to provide an IMP for the given selector first.void dynamicMethodIMP(id self, SEL _cmd)
	    {
	      // implementation ....
	    }
	    + (BOOL) resolveInstanceMethod:(SEL)aSEL
	    {
	      if (aSEL == @selector(resolveThisMethodDynamically))
	      {
	            class_addMethod([self class], aSEL, (IMP) dynamicMethodIMP, "v@:");
	            return YES;
	      }
	      return [super resolveInstanceMethod:aSel];
	    }
	      * @see https://developer.apple.com/reference/objectivec/nsobject/1418500-resolveinstancemethod
	     */

	  }, {
	    key: 'resolveInstanceMethod',
	    value: function resolveInstanceMethod(sel) {
	      return false;
	    }
	  }, {
	    key: 'classFallbacksForKeyedArchiver',
	    value: function classFallbacksForKeyedArchiver() {
	      return null;
	    }

	    /**
	     * Overridden by subclasses to substitute a new class during keyed unarchiving.
	     * @access public
	     * @returns {Object} - 
	     * @desc During keyed unarchiving, instances of the receiver will be decoded as members of the returned class. This method overrides the results of the decoder’s class and instance name to class encoding tables.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1410547-classforkeyedunarchiver
	     */

	  }, {
	    key: 'classForKeyedUnarchiver',
	    value: function classForKeyedUnarchiver() {
	      return null;
	    }
	  }, {
	    key: 'setVersion',
	    value: function setVersion(aVersion) {}

	    /**
	     * Returns the version number assigned to the class.
	     * @access public
	     * @returns {number} - 
	     * @desc If no version has been set, the default is 0. Version numbers are needed for decoding or unarchiving, so older versions of an object can be detected and decoded correctly.Caution should be taken when obtaining the version from within an NSCoding protocol or other methods. Use the class name explicitly when getting a class version number:version = [MyClass version];
	    Don’t simply send version to the return value of class—a subclass version number may be returned instead.Special ConsiderationsThe version number applies to NSArchiver/NSUnarchiver, but not to NSKeyedArchiver/NSKeyedUnarchiver.  A keyed archiver does not encode class version numbers.version = [MyClass version];
	      * @see https://developer.apple.com/reference/objectivec/nsobject/1415151-version
	     */

	  }, {
	    key: 'version',
	    value: function version() {
	      return 0;
	    }
	  }, {
	    key: 'automaticallyNotifiesObserversForKey',
	    value: function automaticallyNotifiesObserversForKey(key) {
	      return false;
	    }

	    /**
	     * 
	     * @access public
	     * @returns {string} - 
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1418711-debugdescription
	     */

	  }, {
	    key: 'debugDescription',
	    value: function debugDescription() {
	      return '';
	    }

	    /**
	     * 
	     * @access public
	     * @returns {number} - 
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1418561-hash
	     */

	  }, {
	    key: 'hash',
	    value: function hash() {
	      return 0;
	    }

	    /**
	     * Returns a set of key paths for properties whose values affect the value of the specified key.
	     * @access public
	     * @param {string} key - The key whose value is affected by the key paths.
	     * @returns {Set<String>} - 
	     * @desc When an observer for the key is registered with an instance of the receiving class, key-value observing itself automatically observes all of the key paths for the same instance, and sends change notifications for the key to the observer when the value for any of those key paths changes.The default implementation of this method searches the receiving class for a method whose name matches the pattern +keyPathsForValuesAffecting<Key>, and returns the result of invoking that method if it is found. Any such method must return an NSSet. If no such method is found, an NSSet that is computed from information provided by previous invocations of the now-deprecated setKeys:triggerChangeNotificationsForDependentKey: method is returned, for backward binary compatibility.You can override this method when the getter method of one of your properties computes a value to return using the values of other properties, including those that are located by key paths. Your override should typically call super and return a set that includes any members in the set that result from doing that (so as not to interfere with overrides of this method in superclasses).NoteYou must not override this method when you add a computed property to an existing class using a category, overriding methods in categories is unsupported. In that case, implement a matching +keyPathsForValuesAffecting<Key> to take advantage of this mechanism.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1414299-keypathsforvaluesaffectingvalue
	     */

	  }, {
	    key: 'keyPathsForValuesAffectingValueForKey',
	    value: function keyPathsForValuesAffectingValueForKey(key) {
	      return null;
	    }

	    /**
	     * Returns an object that will be used as the placeholder for the binding, when a key value coding compliant property of an instance of the receiving class returns the value specified by marker, and no other placeholder has been specified. 
	     * @access public
	     * @param {?Object} marker - 
	     * @param {string} binding - 
	     * @returns {?Object} - 
	     * @desc The marker can be nil or one of the constants described in Selection Markers.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1458203-defaultplaceholder
	     */

	  }, {
	    key: 'defaultPlaceholderForMarkerWithBinding',
	    value: function defaultPlaceholderForMarkerWithBinding(marker, binding) {
	      return null;
	    }

	    /**
	     * Exposes the specified binding, advertising its availability. 
	     * @access public
	     * @param {string} binding - The key path for the property to be exposed.
	     * @returns {void}
	     * @desc The bound property will be accessed using key-value-coding compliant methods. This method is typically invoked in the class’s initialize implementation.Bindings exposed using exposeBinding will be exposed automatically in exposedBindings unless that method explicitly filters them out, for example in subclasses.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1458184-exposebinding
	     */

	  }, {
	    key: 'exposeBinding',
	    value: function exposeBinding(binding) {}

	    /**
	     * Returns whether a key should be hidden from the scripting environment.
	     * @access public
	     * @param {!UnsafePointer<Int8>} name - The name of the attribute.
	     * @returns {boolean} - 
	     * @desc The default value is true.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1528545-iskeyexcluded
	     */

	  }, {
	    key: 'isKeyExcludedFromWebScript',
	    value: function isKeyExcludedFromWebScript(name) {
	      return false;
	    }

	    /**
	     * Returns whether a selector should be hidden from the scripting environment.
	     * @access public
	     * @param {!function} selector - 
	     * @returns {boolean} - 
	     * @desc Only methods with valid parameters and return types are exported to the WebKit JavaScript environment. The valid types are Objective-C objects and scalars. The default value is true.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1528532-isselectorexcluded
	     */

	  }, {
	    key: 'isSelectorExcludedFromWebScript',
	    value: function isSelectorExcludedFromWebScript(selector) {
	      return false;
	    }

	    /**
	     * Sets placeholder as the default placeholder for the binding, when a key value coding compliant property of an instance of the receiving class returns the value specified by marker, and no other placeholder has been specified.
	     * @access public
	     * @param {?Object} placeholder - 
	     * @param {?Object} marker - 
	     * @param {string} binding - 
	     * @returns {void}
	     * @desc The marker can be nil or one of the constants described in Selection Markers.
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1458194-setdefaultplaceholder
	     */

	  }, {
	    key: 'setDefaultPlaceholderForMarkerWithBinding',
	    value: function setDefaultPlaceholderForMarkerWithBinding(placeholder, marker, binding) {}

	    /**
	     * Returns the scripting environment name for an attribute specified by a key.
	     * @access public
	     * @param {!UnsafePointer<Int8>} name - The name of the attribute.
	     * @returns {!string} - 
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1528541-webscriptname
	     */

	  }, {
	    key: 'webScriptNameForKey',
	    value: function webScriptNameForKey(name) {
	      return null;
	    }

	    /**
	     * Returns the scripting environment name for a selector.
	     * @access public
	     * @param {!function} selector - 
	     * @returns {!string} - 
	     * @desc It is your responsibility to ensure that the returned name is unique to the script invoking this method. If this method returns nil or you do not implement it, the default name for the selector is constructed as follows: A colon (“:”) in the Objective-C selector is replaced by an underscore (“_”).An underscore in the Objective-C selector is prefixed with a dollar sign (“$”).A dollar sign in the Objective-C selector is prefixed with another dollar sign.The following table shows examples of how the default name is constructed:Objective-C selectorDefault script name for selectorsetFlag:setFlag_setFlag:forKey:withAttributes:setFlag_forKey_withAttributes_propertiesForExample_Object:propertiesForExample$_Object_set_$_forKey:withDictionary:set$_$$_$_forKey_withDictionary_Since the default construction for a method name can be confusing depending on its Objective-C name, you should implement this method and return a more human-readable name.Objective-C selectorDefault script name for selectorsetFlag:setFlag_setFlag:forKey:withAttributes:setFlag_forKey_withAttributes_propertiesForExample_Object:propertiesForExample$_Object_set_$_forKey:withDictionary:set$_$$_$_forKey_withDictionary_
	     * @see https://developer.apple.com/reference/objectivec/nsobject/1528539-webscriptname
	     */

	  }, {
	    key: 'webScriptNameFor',
	    value: function webScriptNameFor(selector) {
	      return null;
	    }
	  }, {
	    key: 'accessInstanceVariablesDirectly',
	    get: function get() {
	      return true;
	    }
	  }]);

	  return NSObject;
	}();

	exports.default = NSObject;

/***/ },
/* 14 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * Defines the standard transform matrix used throughout Core Animation.
	 * @access public
	 * @see https://developer.apple.com/reference/quartzcore/catransform3d
	 */

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var CATransform3D =

	// Initializers

	/**
	 * 
	 * @access public
	 * @param {number[][]} m - 
	 * @returns {void}
	 * @see https://developer.apple.com/reference/quartzcore/catransform3d/1523734-init
	 */
	function CATransform3D(m) {
	  _classCallCheck(this, CATransform3D);

	  // Instance Properties

	  this._m11 = 1;
	  this._m12 = 0;
	  this._m13 = 0;
	  this._m14 = 0;
	  this._m21 = 0;
	  this._m22 = 1;
	  this._m23 = 0;
	  this._m24 = 0;
	  this._m31 = 0;
	  this._m32 = 0;
	  this._m33 = 1;
	  this._m34 = 0;
	  this._m41 = 0;
	  this._m42 = 0;
	  this._m43 = 0;
	  this._m44 = 1;
	}

	// Instance Properties
	;

	exports.default = CATransform3D;

/***/ },
/* 15 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * A representation of a three-component vector.
	 * @access public
	 * @see https://developer.apple.com/reference/scenekit/scnvector3
	 */

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var SCNVector3 = function () {

	  // Initializers

	  /**
	   * 
	   * @access public
	   * @constructor
	   * @param {number} x - 
	   * @param {number} y - 
	   * @param {number} z - 
	   * @returns {void}
	   * @see https://developer.apple.com/reference/scenekit/scnvector3/1522904-init
	   */
	  function SCNVector3() {
	    var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
	    var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
	    var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

	    _classCallCheck(this, SCNVector3);

	    // Instance Properties
	    /** @type {number} */
	    this.x = x;
	    /** @type {number} */
	    this.y = y;
	    /** @type {number} */
	    this.z = z;
	  }

	  // extensions

	  /**
	   * @access public
	   * @param {SCNVector3} v -
	   * @returns {SCNVector3} -
	   */


	  _createClass(SCNVector3, [{
	    key: 'add',
	    value: function add(v) {
	      var r = new SCNVector3();
	      r.x = this.x + v.x;
	      r.y = this.y + v.y;
	      r.z = this.z + v.z;
	      return r;
	    }

	    /**
	     * @access public
	     * @param {SCNVector3} v -
	     * @returns {SCNVector3} -
	     */

	  }, {
	    key: 'sub',
	    value: function sub(v) {
	      var r = new SCNVector3();
	      r.x = this.x - v.x;
	      r.y = this.y - v.y;
	      r.z = this.z - v.z;
	      return r;
	    }

	    /**
	     * @access public
	     * @param {number} n -
	     * @returns {SCNVector3} -
	     */

	  }, {
	    key: 'mul',
	    value: function mul(n) {
	      var r = new SCNVector3();
	      r.x = this.x * n;
	      r.y = this.y * n;
	      r.z = this.z * n;
	      return r;
	    }

	    /**
	     * @access public
	     * @param {SCNVector3} v -
	     * @returns {number} -
	     */

	  }, {
	    key: 'dot',
	    value: function dot(v) {
	      return this.x * v.x + this.y * v.y + this.z * v.z;
	    }

	    /**
	     * @access public
	     * @param {SCNVecor3} v -
	     * @returns {SCNVector3} -
	     */

	  }, {
	    key: 'cross',
	    value: function cross(v) {
	      var r = new SCNVector3();
	      r.x = this.y * v.z - this.z * v.y;
	      r.y = this.z * v.x - this.x * v.z;
	      r.z = this.x * v.y - this.y * v.x;
	      return r;
	    }

	    /**
	     * @access public
	     * @param {SCNVector3} v -
	     * @param {number} rate -
	     * @returns {SCNVector3} -
	     */

	  }, {
	    key: 'lerp',
	    value: function lerp(v, rate) {
	      var r = new SCNVector3();
	      r.x = this.x + rate * (v.x - this.x);
	      r.y = this.y + rate * (v.y - this.y);
	      r.z = this.z + rate * (v.z - this.z);
	      return r;
	    }

	    /**
	     * @access public
	     * @returns {SCNVector3} -
	     */

	  }, {
	    key: 'normalize',
	    value: function normalize() {
	      var len = this.length();
	      var r = new SCNVector3();
	      if (len === 0) {
	        return r;
	      }
	      var sqr = 1.0 / len;
	      r.x = this.x * sqr;
	      r.y = this.y * sqr;
	      r.z = this.z * sqr;

	      return r;
	    }

	    /**
	     * @access public
	     * @returns {number} -
	     */

	  }, {
	    key: 'length',
	    value: function length() {
	      return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
	    }

	    /**
	     * @access public
	     * @param {SCNMatrix4} m -
	     * @returns {SCNVector3} -
	     */

	  }, {
	    key: 'transform',
	    value: function transform(m) {
	      var r = new SCNVector3();
	      r.x = this.x * m.m11 + this.y * m.m21 + this.z * m.m31 + m.m41;
	      r.y = this.x * m.m12 + this.y * m.m22 + this.z * m.m32 + m.m42;
	      r.z = this.x * m.m13 + this.y * m.m23 + this.z * m.m33 + m.m43;
	      return r;
	    }

	    /**
	     * @access public
	     * @param {SCNMatrix4} m -
	     * @returns {SCNVector3} -
	     */

	  }, {
	    key: 'rotate',
	    value: function rotate(m) {
	      var r = new SCNVector3();
	      r.x = this.x * m.m11 + this.y * m.m21 + this.z * m.m31;
	      r.y = this.x * m.m12 + this.y * m.m22 + this.z * m.m32;
	      r.z = this.x * m.m13 + this.y * m.m23 + this.z * m.m33;
	      return r;
	    }

	    /**
	     * @access public
	     * @returns {Float32Array} -
	     */

	  }, {
	    key: 'float32Array',
	    value: function float32Array() {
	      return new Float32Array([this.x, this.y, this.z]);
	    }
	  }]);

	  return SCNVector3;
	}();

	exports.default = SCNVector3;

/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _SCNMatrix = __webpack_require__(17);

	var _SCNMatrix2 = _interopRequireDefault(_SCNMatrix);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	/**
	 * A representation of a four-component vector.
	 * @access public
	 * @see https://developer.apple.com/reference/scenekit/scnvector4
	 */
	var SCNVector4 = function () {
	  // Initializers

	  /**
	   * 
	   * @access public
	   * @constructor
	   * @param {number} x - 
	   * @param {number} y - 
	   * @param {number} z - 
	   * @param {number} w - 
	   * @see https://developer.apple.com/reference/scenekit/scnvector4/1523931-init
	   */
	  function SCNVector4() {
	    var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
	    var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
	    var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
	    var w = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;

	    _classCallCheck(this, SCNVector4);

	    // Instance Properties
	    /** @type {number} */
	    this.x = x;
	    /** @type {number} */
	    this.y = y;
	    /** @type {number} */
	    this.z = z;
	    /** @type {number} */
	    this.w = w;
	  }

	  // extensions

	  /**
	   * @access public
	   * @param {SCNVector4} v -
	   * @returns {SCNVector4} -
	   */


	  _createClass(SCNVector4, [{
	    key: 'add',
	    value: function add(v) {
	      var r = new SCNVector4();
	      r.x = this.x + v.x;
	      r.y = this.y + v.y;
	      r.z = this.z + v.z;
	      r.w = this.w + v.w;
	      return r;
	    }

	    /**
	     * @access public
	     * @param {SCNVector4} v -
	     * @returns {SCNVector4} -
	     */

	  }, {
	    key: 'sub',
	    value: function sub(v) {
	      var r = new SCNVector4();
	      r.x = this.x - v.x;
	      r.y = this.y - v.y;
	      r.z = this.z - v.z;
	      r.w = this.w - v.w;
	      return r;
	    }

	    /**
	     * @access public
	     * @param {number} n -
	     * @returns {SCNVector4} -
	     */

	  }, {
	    key: 'mul',
	    value: function mul(n) {
	      var r = new SCNVector4();
	      r.x = this.x * n;
	      r.y = this.y * n;
	      r.z = this.z * n;
	      r.w = this.w * n;
	      return r;
	    }

	    /**
	     * @access public
	     * @param {SCNVector4} v -
	     * @returns {number} -
	     */

	  }, {
	    key: 'dot',
	    value: function dot(v) {
	      return this.x * v.x + this.y * v.y + this.z * v.z + this.z * v.z;
	    }

	    /**
	     * @access public
	     * @param {SCNVecor4} v -
	     * @returns {SCNVector4} -
	     */

	  }, {
	    key: 'cross',
	    value: function cross(v) {
	      var r = new SCNVector4();
	      r.x = this.w * v.x + this.x * v.w + this.y * v.z - this.z * v.y;
	      r.y = this.w * v.y - this.x * v.z + this.y * v.w + this.z * v.x;
	      r.z = this.w * v.z + this.x * v.y - this.y * v.x + this.z * v.w;
	      r.w = this.w * v.w - this.x * v.x - this.y * v.y - this.z * v.z;
	      return r;
	    }

	    /**
	     * @access public
	     * @param {SCNVector4} v -
	     * @param {number} rate -
	     * @returns {SCNVector4} -
	     */

	  }, {
	    key: 'lerp',
	    value: function lerp(v, rate) {
	      var r = new SCNVector4();
	      r.x = this.x + rate * (v.x - this.x);
	      r.y = this.y + rate * (v.y - this.y);
	      r.z = this.z + rate * (v.z - this.z);
	      r.w = this.w + rate * (v.w - this.w);
	      return r;
	    }

	    /**
	     * @access public
	     * @param {SCNVector4} v -
	     * @param {number} rate -
	     * @returns {SCNVector4} -
	     */

	  }, {
	    key: 'slerp',
	    value: function slerp(v, rate) {
	      var r = new SCNVector4();
	      var qr = this.dot(v);

	      if (qr < 0) {
	        r.x = this.x - (this.x + v.x) * rate;
	        r.y = this.y - (this.y + v.y) * rate;
	        r.z = this.z - (this.z + v.z) * rate;
	        r.w = this.w - (this.w + v.w) * rate;
	      } else {
	        r.x = this.x + (v.x - this.x) * rate;
	        r.y = this.y + (v.y - this.y) * rate;
	        r.z = this.z + (v.z - this.z) * rate;
	        r.w = this.w + (v.w - this.w) * rate;
	      }
	      return r.normalize();
	    }

	    /**
	     * @access public
	     * @returns {SCNVector4} -
	     */

	  }, {
	    key: 'normalize',
	    value: function normalize() {
	      var r = new SCNVector4();
	      var sqr = 1.0 / this.length();
	      r.x = this.x * sqr;
	      r.y = this.y * sqr;
	      r.z = this.z * sqr;
	      r.w = this.w * sqr;
	      return r;
	    }

	    /**
	     * @access public
	     * @returns {number} -
	     */

	  }, {
	    key: 'length',
	    value: function length() {
	      return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
	    }
	  }, {
	    key: 'transform',
	    value: function transform(m) {
	      var r = new SCNVector4();
	      r.x = this.x * m.m11 + this.y * m.m21 + this.z * m.m31 + this.w * m.m41;
	      r.y = this.x * m.m12 + this.y * m.m22 + this.z * m.m32 + this.w * m.m42;
	      r.z = this.x * m.m13 + this.y * m.m23 + this.z * m.m33 + this.w * m.m43;
	      r.w = this.x * m.m14 + this.y * m.m24 + this.z * m.m34 + this.w * m.m44;
	      return r;
	    }

	    /**
	     * @access public
	     * @returns {SCNVector4} -
	     */

	  }, {
	    key: 'ln',
	    value: function ln() {
	      var r = new SCNVector4();
	      var v = this.normalize();

	      var n = Math.sqrt(v.x * v.x + v.y * v.y + v.z * v.z);
	      if (n === 0) {
	        r.x = 0;
	        r.y = 0;
	        r.z = 0;
	        r.w = 0;
	        return r;
	      }
	      var theta = Math.atan2(n, v.w) / n;

	      r.x = theta * v.x;
	      r.y = theta * v.y;
	      r.z = theta * v.z;
	      r.w = 0;
	      return r;
	    }

	    /**
	     * @access public
	     * @returns {SCNVector4} -
	     */

	  }, {
	    key: 'exp',
	    value: function exp() {
	      var r = new SCNVector4();
	      var n = Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);

	      if (n > 0.0) {
	        var sinn = Math.sin(n);
	        r.x = sinn * this.x / n;
	        r.y = sinn * this.y / n;
	        r.z = sinn * this.z / n;
	        r.w = Math.cos(n);
	      } else {
	        r.x = 0.0;
	        r.y = 0.0;
	        r.z = 0.0;
	        r.w = 1.0;
	      }
	      return r;
	    }

	    /**
	     * @access public
	     * @returns {SCNMatrix4} -
	     */

	  }, {
	    key: 'rotMatrix',
	    value: function rotMatrix() {
	      var r = new _SCNMatrix2.default();
	      var x2 = this.x * this.x * 2.0;
	      var y2 = this.y * this.y * 2.0;
	      var z2 = this.z * this.z * 2.0;
	      var xy = this.x * this.y * 2.0;
	      var yz = this.y * this.z * 2.0;
	      var zx = this.z * this.x * 2.0;
	      var xw = this.x * this.w * 2.0;
	      var yw = this.y * this.w * 2.0;
	      var zw = this.z * this.w * 2.0;

	      r.m11 = 1.0 - y2 - z2;
	      r.m12 = xy + zw;
	      r.m13 = zx - yw;
	      r.m14 = 0.0;
	      r.m21 = xy - zw;
	      r.m22 = 1.0 - z2 - x2;
	      r.m23 = yz + xw;
	      r.m24 = 0.0;
	      r.m31 = zx + yw;
	      r.m32 = yz - xw;
	      r.m33 = 1.0 - x2 - y2;
	      r.m34 = 0.0;
	      r.m41 = 0.0;
	      r.m42 = 0.0;
	      r.m43 = 0.0;
	      r.m44 = 1.0;
	      return r;
	    }

	    /**
	     * @access public
	     * @returns {SCNVector4} -
	     */

	  }, {
	    key: 'rotationToQuat',
	    value: function rotationToQuat() {
	      var quat = new SCNVector4();
	      if (this.x === 0 && this.y === 0 && this.z === 0) {
	        quat.x = 0;
	        quat.y = 0;
	        quat.z = 0;
	        quat.w = 1.0;
	      } else {
	        var r = 1.0 / Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
	        var cosW = Math.cos(this.w * 0.5);
	        var sinW = Math.sin(this.w * 0.5) * r;
	        quat.x = this.x * sinW;
	        quat.y = this.y * sinW;
	        quat.z = this.z * sinW;
	        quat.w = cosW;
	      }

	      return quat;
	    }

	    /**
	     * @access public
	     * @returns {SCNVector4} -
	     */

	  }, {
	    key: 'quatToRotation',
	    value: function quatToRotation() {
	      var rot = new SCNVector4();
	      if (this.x === 0 && this.y === 0 && this.z === 0) {
	        rot.x = 0;
	        rot.y = 0;
	        rot.z = 0;
	        if (Math.abs(this.w) > 1) {
	          // actually, if this.w < -1, rotation will be NaN...
	          rot.w = 0;
	        } else {
	          // I don't know why it needs to be double but I make it the same as SceneKit
	          rot.w = Math.acos(this.w) * 2.0;
	        }
	      } else {
	        var quat = this.normalize();
	        var r = 1.0 / Math.sqrt(quat.x * quat.x + quat.y * quat.y + quat.z * quat.z);
	        rot.x = quat.x * r;
	        rot.y = quat.y * r;
	        rot.z = quat.z * r;

	        var w = Math.acos(quat.w);
	        if (isNaN(w)) {
	          rot.w = 0;
	        } else {
	          // I don't know why it needs to be double but I make it the same as SceneKit
	          rot.w = w * 2.0;
	        }
	      }
	      return rot;
	    }

	    /**
	     * @access public
	     * @returns {Float32Array} -
	     */

	  }, {
	    key: 'float32Array',
	    value: function float32Array() {
	      return new Float32Array([this.x, this.y, this.z, this.w]);
	    }
	  }]);

	  return SCNVector4;
	}();

	exports.default = SCNVector4;

/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _SCNVector = __webpack_require__(15);

	var _SCNVector2 = _interopRequireDefault(_SCNVector);

	var _SCNVector3 = __webpack_require__(16);

	var _SCNVector4 = _interopRequireDefault(_SCNVector3);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var _epsilon = 0.0000001;

	/**
	 * A representation of a 4 x 4 matrix.
	 * @access public
	 * @see https://developer.apple.com/reference/scenekit/scnmatrix4
	 */

	var SCNMatrix4 = function () {

	  // Initializers

	  /**
	   * 
	   * @access public
	   * @construtor
	   * @param {number[][]} [m = null] - 
	   * @see https://developer.apple.com/reference/quartzcore/catransform3d/1524036-init
	   */
	  function SCNMatrix4() {
	    var m = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

	    _classCallCheck(this, SCNMatrix4);

	    // Instance Properties

	    /** @type {number} */
	    this.m11 = 0;
	    /** @type {number} */
	    this.m12 = 0;
	    /** @type {number} */
	    this.m13 = 0;
	    /** @type {number} */
	    this.m14 = 0;
	    /** @type {number} */
	    this.m21 = 0;
	    /** @type {number} */
	    this.m22 = 0;
	    /** @type {number} */
	    this.m23 = 0;
	    /** @type {number} */
	    this.m24 = 0;
	    /** @type {number} */
	    this.m31 = 0;
	    /** @type {number} */
	    this.m32 = 0;
	    /** @type {number} */
	    this.m33 = 0;
	    /** @type {number} */
	    this.m34 = 0;
	    /** @type {number} */
	    this.m41 = 0;
	    /** @type {number} */
	    this.m42 = 0;
	    /** @type {number} */
	    this.m43 = 0;
	    /** @type {number} */
	    this.m44 = 0;

	    if (m instanceof SCNMatrix4) {
	      this.m11 = m.m11;
	      this.m12 = m.m12;
	      this.m13 = m.m13;
	      this.m14 = m.m14;
	      this.m21 = m.m21;
	      this.m22 = m.m22;
	      this.m23 = m.m23;
	      this.m24 = m.m24;
	      this.m31 = m.m31;
	      this.m32 = m.m32;
	      this.m33 = m.m33;
	      this.m34 = m.m34;
	      this.m41 = m.m41;
	      this.m42 = m.m42;
	      this.m43 = m.m43;
	      this.m44 = m.m44;
	    } else if (arguments.length >= 16) {
	      this.m11 = arguments[0];
	      this.m12 = arguments[1];
	      this.m13 = arguments[2];
	      this.m14 = arguments[3];
	      this.m21 = arguments[4];
	      this.m22 = arguments[5];
	      this.m23 = arguments[6];
	      this.m24 = arguments[7];
	      this.m31 = arguments[8];
	      this.m32 = arguments[9];
	      this.m33 = arguments[10];
	      this.m34 = arguments[11];
	      this.m41 = arguments[12];
	      this.m42 = arguments[13];
	      this.m43 = arguments[14];
	      this.m44 = arguments[15];
	    } else if (m !== null) {
	      // TODO: type check
	      this.m11 = m[0][0];
	      this.m12 = m[0][1];
	      this.m13 = m[0][2];
	      this.m14 = m[0][3];
	      this.m21 = m[1][0];
	      this.m22 = m[1][1];
	      this.m23 = m[1][2];
	      this.m24 = m[1][3];
	      this.m31 = m[2][0];
	      this.m32 = m[2][1];
	      this.m33 = m[2][2];
	      this.m34 = m[2][3];
	      this.m41 = m[3][0];
	      this.m42 = m[3][1];
	      this.m43 = m[3][2];
	      this.m44 = m[3][3];
	    }
	  }

	  // extensions

	  /**
	   * @access public
	   * @param {SCNMatrix4} m -
	   * @returns {SCNMatrix4} - 
	   */


	  _createClass(SCNMatrix4, [{
	    key: 'mult',
	    value: function mult(m) {
	      var r = new SCNMatrix4();
	      r.m11 = this.m11 * m.m11 + this.m12 * m.m21 + this.m13 * m.m31 + this.m14 * m.m41;
	      r.m12 = this.m11 * m.m12 + this.m12 * m.m22 + this.m13 * m.m32 + this.m14 * m.m42;
	      r.m13 = this.m11 * m.m13 + this.m12 * m.m23 + this.m13 * m.m33 + this.m14 * m.m43;
	      r.m14 = this.m11 * m.m14 + this.m12 * m.m24 + this.m13 * m.m34 + this.m14 * m.m44;
	      r.m21 = this.m21 * m.m11 + this.m22 * m.m21 + this.m23 * m.m31 + this.m24 * m.m41;
	      r.m22 = this.m21 * m.m12 + this.m22 * m.m22 + this.m23 * m.m32 + this.m24 * m.m42;
	      r.m23 = this.m21 * m.m13 + this.m22 * m.m23 + this.m23 * m.m33 + this.m24 * m.m43;
	      r.m24 = this.m21 * m.m14 + this.m22 * m.m24 + this.m23 * m.m34 + this.m24 * m.m44;
	      r.m31 = this.m31 * m.m11 + this.m32 * m.m21 + this.m33 * m.m31 + this.m34 * m.m41;
	      r.m32 = this.m31 * m.m12 + this.m32 * m.m22 + this.m33 * m.m32 + this.m34 * m.m42;
	      r.m33 = this.m31 * m.m13 + this.m32 * m.m23 + this.m33 * m.m33 + this.m34 * m.m43;
	      r.m34 = this.m31 * m.m14 + this.m32 * m.m24 + this.m33 * m.m34 + this.m34 * m.m44;
	      r.m41 = this.m41 * m.m11 + this.m42 * m.m21 + this.m43 * m.m31 + this.m44 * m.m41;
	      r.m42 = this.m41 * m.m12 + this.m42 * m.m22 + this.m43 * m.m32 + this.m44 * m.m42;
	      r.m43 = this.m41 * m.m13 + this.m42 * m.m23 + this.m43 * m.m33 + this.m44 * m.m43;
	      r.m44 = this.m41 * m.m14 + this.m42 * m.m24 + this.m43 * m.m34 + this.m44 * m.m44;
	      return r;
	    }

	    /**
	     * @access public
	     * @param {SCNMatrix4} m -
	     * @param {number} rate -
	     * @returns {SCNMatrix4} - 
	     */

	  }, {
	    key: 'lerp',
	    value: function lerp(m, rate) {
	      var r = new SCNMatrix4();
	      r.m11 = this.m11 + rate * (this.m11 - m.m11);
	      r.m12 = this.m12 + rate * (this.m12 - m.m12);
	      r.m13 = this.m13 + rate * (this.m13 - m.m13);
	      r.m14 = this.m14 + rate * (this.m14 - m.m14);
	      r.m21 = this.m21 + rate * (this.m21 - m.m21);
	      r.m22 = this.m22 + rate * (this.m22 - m.m22);
	      r.m23 = this.m23 + rate * (this.m23 - m.m23);
	      r.m24 = this.m24 + rate * (this.m24 - m.m24);
	      r.m31 = this.m31 + rate * (this.m31 - m.m31);
	      r.m32 = this.m32 + rate * (this.m32 - m.m32);
	      r.m33 = this.m33 + rate * (this.m33 - m.m33);
	      r.m34 = this.m34 + rate * (this.m34 - m.m34);
	      r.m41 = this.m41 + rate * (this.m41 - m.m41);
	      r.m42 = this.m42 + rate * (this.m42 - m.m42);
	      r.m43 = this.m43 + rate * (this.m43 - m.m43);
	      r.m44 = this.m44 + rate * (this.m44 - m.m44);
	      return r;
	    }

	    /**
	     * @access public
	     * @returns {SCNVector4} -
	     */

	  }, {
	    key: 'quaternion',
	    value: function quaternion() {
	      var r = new _SCNVector4.default();
	      r.x = this.m32 - this.m23;
	      r.y = this.m13 - this.m31;
	      r.z = this.m21 - this.m12;
	      r.w = Math.acos((this.m11 + this.m22 + this.m33 - 1) * 0.5);
	      return r;
	    }

	    /**
	     * @access public
	     * @returns {SCNMatrix4} -
	     */

	  }, {
	    key: 'invert',
	    value: function invert() {
	      var mat = SCNMatrix4._identity();
	      var tmp = new SCNMatrix4(this);

	      var buf = 0;
	      var w1 = Math.abs(tmp.m11);
	      var w2 = Math.abs(tmp.m21);
	      var w3 = Math.abs(tmp.m31);
	      var w4 = Math.abs(tmp.m41);
	      var max = w1 > w2 ? w1 : w2;
	      if (max < w3) max = w3;

	      // 1
	      if (max < w4) {
	        buf = 1.0 / tmp.m41;
	        w1 = tmp.m11;
	        w2 = tmp.m12;
	        w3 = tmp.m13;
	        w4 = tmp.m14;
	        tmp.m12 = tmp.m42 * buf;
	        tmp.m13 = tmp.m43 * buf;
	        tmp.m14 = tmp.m44 * buf;
	        tmp.m41 = w1;
	        tmp.m42 = w2;
	        tmp.m43 = w3;
	        tmp.m44 = w4;
	        mat.m11 = 0.0;
	        mat.m14 = buf;
	        mat.m41 = 1.0;
	        mat.m44 = 0.0;
	      } else if (max === w1) {
	        buf = 1.0 / tmp.m11;
	        tmp.m12 *= buf;
	        tmp.m13 *= buf;
	        tmp.m14 *= buf;
	        mat.m11 = buf;
	      } else if (max === w2) {
	        buf = 1.0 / tmp.m21;
	        w1 = tmp.m11;
	        w2 = tmp.m12;
	        w3 = tmp.m13;
	        w4 = tmp.m14;
	        tmp.m12 = tmp.m22 * buf;
	        tmp.m13 = tmp.m23 * buf;
	        tmp.m14 = tmp.m24 * buf;
	        tmp.m21 = w1;
	        tmp.m22 = w2;
	        tmp.m23 = w3;
	        tmp.m24 = w4;
	        mat.m11 = 0.0;
	        mat.m12 = buf;
	        mat.m21 = 1.0;
	        mat.m22 = 0.0;
	      } else {
	        buf = 1.0 / tmp.m31;
	        w1 = tmp.m11;
	        w2 = tmp.m12;
	        w3 = tmp.m13;
	        w4 = tmp.m14;
	        tmp.m12 = tmp.m32 * buf;
	        tmp.m13 = tmp.m33 * buf;
	        tmp.m14 = tmp.m34 * buf;
	        tmp.m31 = w1;
	        tmp.m32 = w2;
	        tmp.m33 = w3;
	        tmp.m34 = w4;
	        mat.m11 = 0.0;
	        mat.m13 = buf;
	        mat.m31 = 1.0;
	        mat.m33 = 0.0;
	      }

	      buf = tmp.m21;
	      tmp.m22 -= tmp.m12 * buf;
	      tmp.m23 -= tmp.m13 * buf;
	      tmp.m24 -= tmp.m14 * buf;
	      mat.m21 -= mat.m11 * buf;
	      mat.m22 -= mat.m12 * buf;
	      mat.m23 -= mat.m13 * buf;
	      mat.m24 -= mat.m14 * buf;

	      buf = tmp.m31;
	      tmp.m32 -= tmp.m12 * buf;
	      tmp.m33 -= tmp.m13 * buf;
	      tmp.m34 -= tmp.m14 * buf;
	      mat.m31 -= mat.m11 * buf;
	      mat.m32 -= mat.m12 * buf;
	      mat.m33 -= mat.m13 * buf;
	      mat.m34 -= mat.m14 * buf;

	      buf = tmp.m41;
	      tmp.m42 -= tmp.m12 * buf;
	      tmp.m43 -= tmp.m13 * buf;
	      tmp.m44 -= tmp.m14 * buf;
	      mat.m41 -= mat.m11 * buf;
	      mat.m42 -= mat.m12 * buf;
	      mat.m43 -= mat.m13 * buf;
	      mat.m44 -= mat.m14 * buf;

	      // 2
	      w2 = Math.abs(tmp.m22);
	      w3 = Math.abs(tmp.m32);
	      w4 = Math.abs(tmp.m42);
	      max = w2 > w3 ? w2 : w3;
	      if (max < w4) {
	        buf = 1.0 / tmp.m42;
	        w2 = tmp.m22;
	        w3 = tmp.m23;
	        w4 = tmp.m24;
	        tmp.m23 = tmp.m43 * buf;
	        tmp.m24 = tmp.m44 * buf;
	        tmp.m42 = w2;
	        tmp.m43 = w3;
	        tmp.m44 = w4;
	        w1 = mat.m21;
	        w2 = mat.m22;
	        w3 = mat.m23;
	        w4 = mat.m24;
	        mat.m21 = mat.m41 * buf;
	        mat.m22 = mat.m42 * buf;
	        mat.m23 = mat.m43 * buf;
	        mat.m24 = mat.m44 * buf;
	        mat.m41 = w1;
	        mat.m42 = w2;
	        mat.m43 = w3;
	        mat.m44 = w4;
	      } else if (w2 > w3) {
	        buf = 1.0 / tmp.m22;
	        tmp.m23 *= buf;
	        tmp.m24 *= buf;
	        mat.m21 *= buf;
	        mat.m22 *= buf;
	        mat.m23 *= buf;
	        mat.m24 *= buf;
	      } else {
	        buf = 1.0 / tmp.m32;
	        w2 = tmp.m22;
	        w3 = tmp.m23;
	        w4 = tmp.m24;
	        tmp.m23 = tmp.m33 * buf;
	        tmp.m24 = tmp.m34 * buf;
	        tmp.m32 = w2;
	        tmp.m33 = w3;
	        tmp.m34 = w4;
	        w1 = mat.m21;
	        w2 = mat.m22;
	        w3 = mat.m23;
	        w4 = mat.m24;
	        mat.m21 = mat.m31 * buf;
	        mat.m22 = mat.m32 * buf;
	        mat.m23 = mat.m33 * buf;
	        mat.m24 = mat.m34 * buf;
	        mat.m31 = w1;
	        mat.m32 = w2;
	        mat.m33 = w3;
	        mat.m34 = w4;
	      }

	      buf = tmp.m12;
	      tmp.m13 -= tmp.m23 * buf;
	      tmp.m14 -= tmp.m24 * buf;
	      mat.m11 -= mat.m21 * buf;
	      mat.m12 -= mat.m22 * buf;
	      mat.m13 -= mat.m23 * buf;
	      mat.m14 -= mat.m24 * buf;

	      buf = tmp.m32;
	      tmp.m33 -= tmp.m23 * buf;
	      tmp.m34 -= tmp.m24 * buf;
	      mat.m31 -= mat.m21 * buf;
	      mat.m32 -= mat.m22 * buf;
	      mat.m33 -= mat.m23 * buf;
	      mat.m34 -= mat.m24 * buf;

	      buf = tmp.m42;
	      tmp.m43 -= tmp.m23 * buf;
	      tmp.m44 -= tmp.m24 * buf;
	      mat.m41 -= mat.m21 * buf;
	      mat.m42 -= mat.m22 * buf;
	      mat.m43 -= mat.m23 * buf;
	      mat.m44 -= mat.m24 * buf;

	      // 3
	      if (Math.abs(tmp.m33) > Math.abs(tmp.m43)) {
	        buf = 1.0 / tmp.m33;
	        tmp.m34 *= buf;
	        mat.m31 *= buf;
	        mat.m32 *= buf;
	        mat.m33 *= buf;
	        mat.m34 *= buf;
	      } else {
	        buf = 1.0 / tmp.m43;
	        w3 = tmp.m33;
	        w4 = tmp.m34;
	        tmp.m34 = tmp.m44 * buf;
	        tmp.m43 = w3;
	        tmp.m44 = w4;
	        w1 = mat.m31;
	        w2 = mat.m32;
	        w3 = mat.m33;
	        w4 = mat.m34;
	        mat.m31 = mat.m41 * buf;
	        mat.m32 = mat.m42 * buf;
	        mat.m33 = mat.m43 * buf;
	        mat.m34 = mat.m44 * buf;
	        mat.m41 = w1;
	        mat.m42 = w2;
	        mat.m43 = w3;
	        mat.m44 = w4;
	      }
	      buf = tmp.m13;
	      tmp.m14 -= tmp.m34 * buf;
	      mat.m11 -= mat.m31 * buf;
	      mat.m12 -= mat.m32 * buf;
	      mat.m13 -= mat.m33 * buf;
	      mat.m14 -= mat.m34 * buf;

	      buf = tmp.m23;
	      tmp.m24 -= tmp.m34 * buf;
	      mat.m21 -= mat.m31 * buf;
	      mat.m22 -= mat.m32 * buf;
	      mat.m23 -= mat.m33 * buf;
	      mat.m24 -= mat.m34 * buf;

	      buf = tmp.m43;
	      tmp.m44 -= tmp.m34 * buf;
	      mat.m41 -= mat.m31 * buf;
	      mat.m42 -= mat.m32 * buf;
	      mat.m43 -= mat.m33 * buf;
	      mat.m44 -= mat.m34 * buf;

	      // 4
	      buf = 1.0 / tmp.m44;
	      mat.m41 *= buf;
	      mat.m42 *= buf;
	      mat.m43 *= buf;
	      mat.m44 *= buf;

	      buf = tmp.m14;
	      mat.m11 -= mat.m41 * buf;
	      mat.m12 -= mat.m42 * buf;
	      mat.m13 -= mat.m43 * buf;
	      mat.m14 -= mat.m44 * buf;

	      buf = tmp.m24;
	      mat.m21 -= mat.m41 * buf;
	      mat.m22 -= mat.m42 * buf;
	      mat.m23 -= mat.m43 * buf;
	      mat.m24 -= mat.m44 * buf;

	      buf = tmp.m34;
	      mat.m31 -= mat.m41 * buf;
	      mat.m32 -= mat.m42 * buf;
	      mat.m33 -= mat.m43 * buf;
	      mat.m34 -= mat.m44 * buf;

	      return mat;
	    }

	    /**
	     * @access public
	     * @returns {SCNMatrix4} -
	     */

	  }, {
	    key: 'transpose',
	    value: function transpose() {
	      var r = new SCNMatrix4();
	      r.m11 = this.m11;
	      r.m12 = this.m21;
	      r.m13 = this.m31;
	      r.m14 = this.m41;
	      r.m21 = this.m12;
	      r.m22 = this.m22;
	      r.m23 = this.m32;
	      r.m24 = this.m42;
	      r.m31 = this.m13;
	      r.m32 = this.m23;
	      r.m33 = this.m33;
	      r.m34 = this.m43;
	      r.m41 = this.m14;
	      r.m42 = this.m24;
	      r.m43 = this.m34;
	      r.m44 = this.m44;
	      return r;
	    }

	    /**
	     * @access public
	     * @param {number} x -
	     * @param {number} y -
	     * @param {number} z -
	     * @returns {SCNMatrix4} -
	     */

	  }, {
	    key: 'scale',
	    value: function scale(x, y, z) {
	      var m = SCNMatrix4.matrixWithScale(x, y, z);
	      return this.mult(m);
	    }

	    /**
	     * @access public
	     * @param {number} x -
	     * @param {number} y -
	     * @param {number} z -
	     * @returns {SCNMatrix4} -
	     */

	  }, {
	    key: 'rotation',


	    /**
	     * @access public
	     * @param {number} x -
	     * @param {number} y -
	     * @param {number} z -
	     * @param {number} w -
	     * @returns {SCNMatrix4} -
	     */
	    value: function rotation(x, y, z, w) {
	      var m = SCNMatrix4.matrixWithRotation(x, y, z, w);
	      return this.mult(m);
	    }

	    /**
	     * @access public
	     * @param {number} x -
	     * @param {number} y -
	     * @param {number} z -
	     * @param {number} w -
	     * @returns {SCNMatrix4} -
	     */

	  }, {
	    key: 'translation',


	    /**
	     * @access public
	     * @param {number} x -
	     * @param {number} y -
	     * @param {number} z -
	     * @returns {SCNMatrix4} -
	     */
	    value: function translation(x, y, z) {
	      var m = SCNMatrix4.matrixWithTranslation(x, y, z);
	      return this.mult(m);
	    }

	    /**
	     * @access public
	     * @param {number} x -
	     * @param {number} y -
	     * @param {number} z -
	     * @returns {SCNMatrix4} -
	     */

	  }, {
	    key: 'equalTo',


	    /**
	     * Returns a Boolean value that indicates whether the corresponding elements of two matrices are equal.
	     * @access public
	     * @param {SCNMatrix4} m -
	     * @returns {boolean} -
	     * @desc This function performs a numeric (not bitwise) comparison of each pair of elements.
	     * @see https://developer.apple.com/reference/scenekit/1409665-scnmatrix4equaltomatrix4
	     */
	    value: function equalTo(m) {
	      if (!(m instanceof SCNMatrix4)) {
	        return false;
	      }

	      return Math.abs(this.m11 - m.m11) < _epsilon && Math.abs(this.m12 - m.m12) < _epsilon && Math.abs(this.m13 - m.m13) < _epsilon && Math.abs(this.m14 - m.m14) < _epsilon && Math.abs(this.m21 - m.m21) < _epsilon && Math.abs(this.m22 - m.m22) < _epsilon && Math.abs(this.m23 - m.m23) < _epsilon && Math.abs(this.m24 - m.m24) < _epsilon && Math.abs(this.m31 - m.m31) < _epsilon && Math.abs(this.m32 - m.m32) < _epsilon && Math.abs(this.m33 - m.m33) < _epsilon && Math.abs(this.m34 - m.m34) < _epsilon && Math.abs(this.m41 - m.m41) < _epsilon && Math.abs(this.m42 - m.m42) < _epsilon && Math.abs(this.m43 - m.m43) < _epsilon && Math.abs(this.m44 - m.m44) < _epsilon;
	    }

	    /**
	     * Returns a Boolean value that indicates whether the matrix is equal to the identity matrix.
	     * @access public
	     * @returns {boolean} - 
	     * @see https://developer.apple.com/reference/scenekit/1409715-scnmatrix4isidentity
	     */

	  }, {
	    key: 'isIdentity',
	    value: function isIdentity() {
	      return this.equalTo(SCNMatrix4._identity());
	    }

	    /**
	     * @access public
	     * @returns {SCNVector3} -
	     */

	  }, {
	    key: 'getScale',
	    value: function getScale() {
	      var sx = new _SCNVector2.default(this.m11, this.m21, this.m31);
	      var sy = new _SCNVector2.default(this.m12, this.m22, this.m32);
	      var sz = new _SCNVector2.default(this.m13, this.m23, this.m33);
	      return new _SCNVector2.default(sx.length(), sy.length(), sz.length());
	    }

	    /**
	     * @access public
	     * @returns {SCNVector3} -
	     */

	  }, {
	    key: 'getTranslation',
	    value: function getTranslation() {
	      return new _SCNVector2.default(this.m14, this.m24, this.m34);
	    }

	    /**
	     * @access public
	     * @returns {Float32Array} -
	     */

	  }, {
	    key: 'float32Array',
	    value: function float32Array() {
	      /*
	      return new Float32Array([
	        this.m11, this.m21, this.m31, this.m41,
	        this.m12, this.m22, this.m32, this.m42,
	        this.m13, this.m23, this.m33, this.m43,
	        this.m14, this.m24, this.m34, this.m44
	      ])
	      */
	      return new Float32Array([this.m11, this.m12, this.m13, this.m14, this.m21, this.m22, this.m23, this.m24, this.m31, this.m32, this.m33, this.m34, this.m41, this.m42, this.m43, this.m44]);
	    }

	    /**
	     * @access public
	     * @returns {Float32Array} -
	     */

	  }, {
	    key: 'float32Array3x4f',
	    value: function float32Array3x4f() {
	      return new Float32Array([this.m11, this.m21, this.m31, this.m41, this.m12, this.m22, this.m32, this.m42, this.m13, this.m23, this.m33, this.m43]);
	    }
	  }, {
	    key: 'floatArray3x4f',
	    value: function floatArray3x4f() {
	      return [this.m11, this.m21, this.m31, this.m41, this.m12, this.m22, this.m32, this.m42, this.m13, this.m23, this.m33, this.m43];
	    }
	  }], [{
	    key: 'matrixWithScale',
	    value: function matrixWithScale(x, y, z) {
	      var _x = x;
	      var _y = y;
	      var _z = z;
	      if (x instanceof _SCNVector2.default) {
	        var v = x;
	        _x = v.x;
	        _y = v.y;
	        _z = v.z;
	      }

	      //const m = new SCNMatrix4()
	      var m = SCNMatrix4._identity();
	      m.m11 = _x;
	      m.m22 = _y;
	      m.m33 = _z;
	      return m;
	    }
	  }, {
	    key: 'matrixWithRotation',
	    value: function matrixWithRotation(x, y, z, w) {
	      if (x instanceof _SCNVector4.default) {
	        var _v = x;
	        x = _v.x;
	        y = _v.y;
	        z = _v.z;
	        w = _v.w;
	      }

	      var c = Math.cos(w);
	      var s = Math.sin(w);
	      var v = new _SCNVector2.default(x, y, z).normalize();
	      var m = SCNMatrix4._identity();

	      var nx = v.x;
	      var ny = v.y;
	      var nz = v.z;

	      m.m11 = nx * nx * (1.0 - c) + c;
	      m.m12 = ny * nx * (1.0 - c) + nz * s;
	      m.m13 = nz * nx * (1.0 - c) - ny * s;
	      m.m14 = 0.0;
	      m.m21 = nx * ny * (1.0 - c) - nz * s;
	      m.m22 = ny * ny * (1.0 - c) + c;
	      m.m23 = nz * ny * (1.0 - c) + nx * s;
	      m.m24 = 0.0;
	      m.m31 = nx * nz * (1.0 - c) + ny * s;
	      m.m32 = ny * nz * (1.0 - c) - nx * s;
	      m.m33 = nz * nz * (1.0 - c) + c;
	      m.m34 = 0.0;
	      m.m41 = 0.0;
	      m.m42 = 0.0;
	      m.m43 = 0.0;
	      m.m44 = 1.0;

	      return m;
	    }
	  }, {
	    key: 'matrixWithTranslation',
	    value: function matrixWithTranslation(x, y, z) {
	      var _x = x;
	      var _y = y;
	      var _z = z;
	      if (x instanceof _SCNVector2.default) {
	        var v = x;
	        _x = v.x;
	        _y = v.y;
	        _z = v.z;
	      }

	      //const m = new SCNMatrix4()
	      var m = SCNMatrix4._identity();
	      m.m41 = _x;
	      m.m42 = _y;
	      m.m43 = _z;
	      return m;
	    }
	  }, {
	    key: '_identity',
	    value: function _identity() {
	      return new SCNMatrix4(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
	    }
	  }]);

	  return SCNMatrix4;
	}();

	exports.default = SCNMatrix4;

/***/ },
/* 18 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * An interface that allows objects to respond to actions triggered by a CALayer.
	 * @interface
	 * @see https://developer.apple.com/reference/quartzcore/caaction
	 */

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var CAAction = function () {
	  function CAAction() {
	    _classCallCheck(this, CAAction);
	  }

	  _createClass(CAAction, [{
	    key: 'init',


	    /**
	     * constructor
	     * @access public
	     * @returns {void}
	     */
	    value: function init() {}

	    // Responding to an action

	    /**
	     * Required. Called to trigger the action specified by the identifier.
	     * @access public
	     * @param {string} event - 
	     * @param {Object} anObject - The layer on which the action should occur.
	     * @param {?Map<AnyHashable, Object>} dict - A dictionary containing parameters associated with this event. May be nil.
	     * @returns {void}
	     * @see https://developer.apple.com/reference/quartzcore/caaction/1410806-run
	     */

	  }, {
	    key: 'runForKeyObjectArguments',
	    value: function runForKeyObjectArguments(event, anObject, dict) {}
	  }]);

	  return CAAction;
	}();

	exports.default = CAAction;

/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

	var _constants = __webpack_require__(20);

	var Constants = _interopRequireWildcard(_constants);

	var _NSObject2 = __webpack_require__(13);

	var _NSObject3 = _interopRequireDefault(_NSObject2);

	var _CAAction = __webpack_require__(18);

	var _CAAction2 = _interopRequireDefault(_CAAction);

	var _CAMediaTiming = __webpack_require__(21);

	var _CAMediaTiming2 = _interopRequireDefault(_CAMediaTiming);

	var _CAMediaTimingFunction = __webpack_require__(22);

	var _CAMediaTimingFunction2 = _interopRequireDefault(_CAMediaTimingFunction);

	var _CAAnimationDelegate = __webpack_require__(23);

	var _CAAnimationDelegate2 = _interopRequireDefault(_CAAnimationDelegate);

	var _SCNAnimationEvent = __webpack_require__(24);

	var _SCNAnimationEvent2 = _interopRequireDefault(_SCNAnimationEvent);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * The abstract superclass for Core Animation animations. 
	 * @access public
	 * @extends {NSObject}
	 * @implements {CAAction}
	 * @implements {CAMediaTiming}
	 * @see https://developer.apple.com/reference/quartzcore/caanimation
	 */
	var CAAnimation = function (_NSObject) {
	  _inherits(CAAnimation, _NSObject);

	  /**
	   * constructor
	   * @access public
	   * @constructor
	   */
	  function CAAnimation() {
	    _classCallCheck(this, CAAnimation);

	    // Animation attributes

	    /**
	     * Determines if the animation is removed from the target layer’s animations upon completion.
	     * @type {boolean}
	     * @see https://developer.apple.com/reference/quartzcore/caanimation/1412458-isremovedoncompletion
	     */
	    var _this = _possibleConstructorReturn(this, (CAAnimation.__proto__ || Object.getPrototypeOf(CAAnimation)).call(this));

	    _this.isRemovedOnCompletion = false;

	    /**
	     * An optional timing function defining the pacing of the animation.
	     * @type {?CAMediaTimingFunction}
	     * @see https://developer.apple.com/reference/quartzcore/caanimation/1412456-timingfunction
	     */
	    _this.timingFunction = null;

	    // Getting and setting the delegate

	    /**
	     * Specifies the receiver’s delegate object.
	     * @type {?CAAnimationDelegate}
	     * @see https://developer.apple.com/reference/quartzcore/caanimation/1412490-delegate
	     */
	    _this.delegate = null;

	    // Controlling SceneKit Animation Timing

	    /**
	     * For animations attached to SceneKit objects, a Boolean value that determines whether the animation is evaluated using the scene time or the system time.
	     * @type {boolean}
	     * @see https://developer.apple.com/reference/quartzcore/caanimation/1523819-usesscenetimebase
	     */
	    _this.usesSceneTimeBase = false;

	    // Fading Between SceneKit Animations

	    /**
	     * For animations attached to SceneKit objects, the duration for transitioning into the animation’s effect as it beins.
	     * @type {number}
	     * @see https://developer.apple.com/reference/quartzcore/caanimation/1523370-fadeinduration
	     */
	    _this.fadeInDuration = 0;

	    /**
	     * For animations attached to SceneKit objects, the duration for transitioning out of the animation’s effect as it ends.
	     * @type {number}
	     * @see https://developer.apple.com/reference/quartzcore/caanimation/1522959-fadeoutduration
	     */
	    _this.fadeOutDuration = 0;

	    // Attaching SceneKit Animation Events

	    /**
	     * For animations attached to SceneKit objects, a list of events attached to an animation.
	     * @type {?SCNAnimationEvent[]}
	     * @see https://developer.apple.com/reference/quartzcore/caanimation/1523940-animationevents
	     */
	    _this.animationEvents = null;

	    ///////////////////
	    // CAMediaTiming //
	    ///////////////////

	    // Animation Start Time

	    /**
	     * Required. Specifies the begin time of the receiver in relation to its parent object, if applicable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/quartzcore/camediatiming/1427654-begintime
	     */
	    _this.beginTime = 0;

	    /**
	     * Required. Specifies an additional time offset in active local time.
	     * @type {number}
	     * @see https://developer.apple.com/reference/quartzcore/camediatiming/1427650-timeoffset
	     */
	    _this.timeOffset = 0;

	    // Repeating Animations

	    /**
	     * Required. Determines the number of times the animation will repeat.
	     * @type {number}
	     * @see https://developer.apple.com/reference/quartzcore/camediatiming/1427666-repeatcount
	     */
	    _this.repeatCount = 0;

	    /**
	     * Required. Determines how many seconds the animation will repeat for.
	     * @type {number}
	     * @see https://developer.apple.com/reference/quartzcore/camediatiming/1427643-repeatduration
	     */
	    _this.repeatDuration = 0;

	    // Duration and Speed

	    /**
	     * Required. Specifies the basic duration of the animation, in seconds.
	     * @type {number}
	     * @see https://developer.apple.com/reference/quartzcore/camediatiming/1427652-duration
	     */
	    _this.duration = 0;

	    /**
	     * Required. Specifies how time is mapped to receiver’s time space from the parent time space. 
	     * @type {number}
	     * @see https://developer.apple.com/reference/quartzcore/camediatiming/1427647-speed
	     */
	    _this.speed = 1;

	    // Playback Modes

	    /**
	     * Required. Determines if the receiver plays in the reverse upon completion.
	     * @type {boolean}
	     * @see https://developer.apple.com/reference/quartzcore/camediatiming/1427645-autoreverses
	     */
	    _this.autoreverses = false;

	    /**
	     * Required. Determines if the receiver’s presentation is frozen or removed once its active duration has completed.
	     * @type {string}
	     * @see https://developer.apple.com/reference/quartzcore/camediatiming/1427656-fillmode
	     */
	    _this.fillMode = Constants.kCAFillModeRemoved;

	    _this._isFinished = false;

	    _this._prevTime = null;
	    _this._animationStartTime = null;
	    return _this;
	  }

	  // Archiving properties

	  /**
	   * Specifies whether the value of the property for a given key is archived.
	   * @access public
	   * @param {string} key - The name of one of the receiver’s properties.
	   * @returns {boolean} - 
	   * @desc Called by the object's implementation of encodeWithCoder:. The object must implement keyed archiving. The default implementation returns true. 
	   * @see https://developer.apple.com/reference/quartzcore/caanimation/1412525-shouldarchivevalue
	   */


	  _createClass(CAAnimation, [{
	    key: 'shouldArchiveValueForKey',
	    value: function shouldArchiveValueForKey(key) {
	      return false;
	    }

	    // Providing default values for properties

	    /**
	     * Specifies the default value of the property with the specified key. 
	     * @access public
	     * @param {string} key - The name of one of the receiver’s properties.
	     * @returns {?Object} - 
	     * @desc If this method returns nil a suitable “zero” default value for the property is provided, based on the declared type of the key. For example, if key is a CGSize object, a size of (0.0,0.0) is returned. For a CGRect an empty rectangle is returned. For CGAffineTransform and CATransform3D, the appropriate identity matrix is returned. Special ConsiderationsIf key is not a known for property of the class, the result of the method is undefined.
	     * @see https://developer.apple.com/reference/quartzcore/caanimation/1412530-defaultvalue
	     */

	  }, {
	    key: 'copy',


	    /**
	     * @access public
	     * @returns {CAAnimation} -
	     */
	    value: function copy() {
	      console.log('CAAnimation.copy');
	      var anim = _get(CAAnimation.prototype.__proto__ || Object.getPrototypeOf(CAAnimation.prototype), 'copy', this).call(this);

	      anim.isRemovedOnCompletion = this.isRemovedOnCompletion;
	      anim.timingFunction = this.timingFunction;
	      anim.delegate = this.delegate;
	      anim.usesSceneTimeBase = this.usesSceneTimeBase;
	      anim.fadeInDuration = this.fadeInDuration;
	      anim.fadeOutDuration = this.fadeOutDuration;
	      anim.animationEvents = this.animationEvents;
	      anim.beginTime = this.beginTime;
	      anim.timeOffset = this.timeOffset;
	      anim.repeatCount = this.repeatCount;
	      anim.repeatDuration = this.repeatDuration;
	      anim.duration = this.duration;
	      anim.speed = this.speed;
	      anim.autoreverses = this.autoreverses;
	      anim.fillMode = this.fillMode;

	      return anim;
	    }

	    /*
	    _copyValue(src) {
	      console.log('CAAnimation._copyValue')
	      this.isRemovedOnCompletion = src.isRemovedOnCompletion
	      this.timingFunction = src.timingFunction
	      this.delegate = src.delegate
	      this.usesSceneTimeBase = src.usesSceneTimeBase
	      this.fadeInDuration = src.fadeInDuration
	      this.fadeOutDuration = src.fadeOutDuration
	      this.animationEvents = src.animationEvents
	      this.beginTime = src.beginTime
	      this.timeOffset = src.timeOffset
	      this.repeatCount = src.repeatCount
	      this.repeatDuration = src.repeatDuration
	      this.duration = src.duration
	      this.speed = src.speed
	      this.autoreverses = src.autoreverses
	      this.fillMode = src.fillMode
	    }
	    */

	    /**
	     * apply animation to the given node.
	     * @access private
	     * @param {Object} obj - target object to apply this animation.
	     * @param {number} time - active time
	     * @param {boolean} [needTimeConversion = true] -
	     * @returns {void}
	     */

	  }, {
	    key: '_applyAnimation',
	    value: function _applyAnimation(obj, time) {
	      var needTimeConversion = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

	      var t = time;
	      if (needTimeConversion) {
	        var baseTime = this._basetimeFromTime(time);
	        t = baseTime;
	        if (this.timingFunction !== null) {
	          t = this.timingFunction._getValueAtTime(baseTime);
	        }
	      }
	      this._handleEvents(obj, t);
	    }
	  }, {
	    key: '_handleEvents',
	    value: function _handleEvents(obj, time) {
	      var _this2 = this;

	      if (this.animationEvents === null) {
	        return;
	      }
	      var prevTime = this._prevTime;
	      if (prevTime === null) {
	        prevTime = time - 0.0000001;
	      }
	      this.animationEvents.forEach(function (event) {
	        if (prevTime < event.time && event.time <= time) {
	          if (event.block) {
	            // FIXME: set playingBackward
	            // SCNAnimationEventBlock(animation, animatedObject, playingBackward)
	            event.block(_this2, obj, false);
	          }
	        }
	      });
	    }

	    /**
	     * convert parent time to base time
	     * @access private
	     * @param {number} time - parent time
	     * @returns {number} - animation base time for the current frame (0-1 or null).
	     */

	  }, {
	    key: '_basetimeFromTime',
	    value: function _basetimeFromTime(time) {
	      var activeTime = time - this._animationStartTime;
	      return this._basetimeFromActivetime(activeTime);
	    }

	    /**
	     * convert active time to base time
	     * @access private
	     * @param {number} time - active time
	     * @returns {number} - animation base time for the current frame (0-1 or null).
	     */

	  }, {
	    key: '_basetimeFromActivetime',
	    value: function _basetimeFromActivetime(time) {
	      var dt = time - this.beginTime;
	      if (dt < 0) {
	        if (this.fillMode === Constants.kCAFillModeBackwards || this.fillMode === Constants.kCAFillModeBoth) {
	          dt = 0;
	        } else {
	          return null;
	        }
	      }
	      if (this.speed === 0) {
	        return 0;
	      }
	      var oneLoopDuration = this.duration / Math.abs(this.speed);
	      var duration = oneLoopDuration;
	      if (duration === 0) {
	        duration = 0.25;
	      }

	      if (this.repeatDuration > 0) {
	        duration = this.repeatDuration;
	      } else {
	        if (this.repeatCount > 0) {
	          duration *= this.repeatCount;
	        }
	        if (this.autoreverses) {
	          oneLoopDuration *= 2.0;
	          duration *= 2.0;
	        }
	      }

	      if (dt > duration) {
	        // animation is over
	        this._isFinished = true;
	        if (this.fillMode === Constants.kCAFillModeForwards || this.fillMode === Constants.kCAFillModeBoth) {
	          dt = duration;
	        } else {
	          return null;
	        }
	      }

	      var t = (dt + this.timeOffset) / oneLoopDuration;
	      if (Math.abs(t) > 1) {
	        t = t - Math.floor(t);
	      }
	      if (t < 0) {
	        t = 1 + t;
	      }
	      if (this.autoreverses) {
	        if (t <= 0.5) {
	          return t * 2.0;
	        }
	        return (1 - t) * 2.0;
	      }
	      return t;
	    }
	  }], [{
	    key: 'defaultValueForKey',
	    value: function defaultValueForKey(key) {
	      return null;
	    }
	  }]);

	  return CAAnimation;
	}(_NSObject3.default);

	exports.default = CAAnimation;

/***/ },
/* 20 */
/***/ function(module, exports) {

	'use strict';

	/*global exports*/

	// 
	exports.kCAFillModeRemoved = 'removed';
	exports.kCAFillModeForwards = 'forwards';
	exports.kCAFillModeBackwards = 'backwards';
	exports.kCAFillModeBoth = 'both';

	// 
	exports.kCAMediaTimingFunctionLinear = 'linear';
	exports.kCAMediaTimingFunctionEaseIn = 'easeIn';
	exports.kCAMediaTimingFunctionEaseOut = 'easeOut';
	exports.kCAMediaTimingFunctionEaseInEaseOut = 'easeInEaseOut';
	exports.kCAMediaTimingFunctionDefault = 'default';

	// Value calculation modes
	exports.kCAAnimationLinear = 'linear';
	exports.kCAAnimationDiscrete = 'discrete';
	exports.kCAAnimationPaced = 'paced';
	exports.kCAAnimationCubic = 'cubic';
	exports.kCAAnimationCubicPaced = 'cubicPaced';

	// Rotation Mode Values
	exports.kCAAnimationRotateAuto = 'auto';
	exports.kCAAnimationRotateAutoReverse = 'autoReverse';

/***/ },
/* 21 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * Methods that model a hierarchical timing system, allowing objects to map time between their parent and local time. 
	 * @interface
	 * @see https://developer.apple.com/reference/quartzcore/camediatiming
	 */

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var CAMediaTiming =

	/**
	 * constructor
	 * @access public
	 * @constructor
	 */
	function CAMediaTiming() {
	  _classCallCheck(this, CAMediaTiming);

	  // Animation Start Time

	  /**
	   * Required. Specifies the begin time of the receiver in relation to its parent object, if applicable.
	   * @type {number}
	   * @see https://developer.apple.com/reference/quartzcore/camediatiming/1427654-begintime
	   */
	  this.beginTime = 0;

	  /**
	   * Required. Specifies an additional time offset in active local time.
	   * @type {number}
	   * @see https://developer.apple.com/reference/quartzcore/camediatiming/1427650-timeoffset
	   */
	  this.timeOffset = 0;

	  // Repeating Animations

	  /**
	   * Required. Determines the number of times the animation will repeat.
	   * @type {number}
	   * @see https://developer.apple.com/reference/quartzcore/camediatiming/1427666-repeatcount
	   */
	  this.repeatCount = 0;

	  /**
	   * Required. Determines how many seconds the animation will repeat for.
	   * @type {number}
	   * @see https://developer.apple.com/reference/quartzcore/camediatiming/1427643-repeatduration
	   */
	  this.repeatDuration = 0;

	  // Duration and Speed

	  /**
	   * Required. Specifies the basic duration of the animation, in seconds.
	   * @type {number}
	   * @see https://developer.apple.com/reference/quartzcore/camediatiming/1427652-duration
	   */
	  this.duration = 0;

	  /**
	   * Required. Specifies how time is mapped to receiver’s time space from the parent time space. 
	   * @type {number}
	   * @see https://developer.apple.com/reference/quartzcore/camediatiming/1427647-speed
	   */
	  this.speed = 0;

	  // Playback Modes

	  /**
	   * Required. Determines if the receiver plays in the reverse upon completion.
	   * @type {boolean}
	   * @see https://developer.apple.com/reference/quartzcore/camediatiming/1427645-autoreverses
	   */
	  this.autoreverses = false;

	  /**
	   * Required. Determines if the receiver’s presentation is frozen or removed once its active duration has completed.
	   * @type {string}
	   * @see https://developer.apple.com/reference/quartzcore/camediatiming/1427656-fillmode
	   */
	  this.fillMode = '';
	};

	exports.default = CAMediaTiming;

/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _NSObject2 = __webpack_require__(13);

	var _NSObject3 = _interopRequireDefault(_NSObject2);

	var _constants = __webpack_require__(20);

	var Constants = _interopRequireWildcard(_constants);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * A function that defines the pacing of an animation as a timing curve. 
	 * @access public
	 * @extends {NSObject}
	 * @see https://developer.apple.com/reference/quartzcore/camediatimingfunction
	 */
	var CAMediaTimingFunction = function (_NSObject) {
	  _inherits(CAMediaTimingFunction, _NSObject);

	  // Creating Timing Functions

	  /**
	   * Returns an initialized timing function modeled as a cubic Bézier curve using the specified control points.
	   * @access public
	   * @constructor
	   * @param {number} c1x - A floating point number representing the x position of the c1 control point.
	   * @param {number} c1y - A floating point number representing the y position of the c1 control point.
	   * @param {number} c2x - A floating point number representing the x position of the c2 control point.
	   * @param {number} c2y - A floating point number representing the y position of the c2 control point.
	   * @desc The end points of the Bézier curve are automatically set to (0.0,0.0) and (1.0,1.0). The control points defining the Bézier curve are: [(0.0,0.0), (c1x,c1y), (c2x,c2y), (1.0,1.0)].
	   * @see https://developer.apple.com/reference/quartzcore/camediatimingfunction/1522235-init
	   */
	  function CAMediaTimingFunction(c1x, c1y, c2x, c2y) {
	    _classCallCheck(this, CAMediaTimingFunction);

	    var _this = _possibleConstructorReturn(this, (CAMediaTimingFunction.__proto__ || Object.getPrototypeOf(CAMediaTimingFunction)).call(this));

	    _this._c1x = c1x;
	    _this._c1y = c1y;
	    _this._c2x = c2x;
	    _this._c2y = c2y;
	    return _this;
	  }

	  /**
	   * Creates and returns a new instance of CAMediaTimingFunction configured with the predefined timing function specified by name.
	   * @access public
	   * @param {string} name - The timing function to use as specified in Predefined Timing Functions. 
	   * @returns {CAMediaTimingFunction} -
	   * @see https://developer.apple.com/reference/quartzcore/camediatimingfunction/1521979-init
	   */


	  _createClass(CAMediaTimingFunction, [{
	    key: 'getControlPointAtValues',


	    // Accessing the Control Points

	    /**
	     * Returns the control point for the specified index.
	     * @access public
	     * @param {number} idx - 
	     * @param {!UnsafeMutablePointer<Float>} ptr - A pointer to an array that, upon return, will contain the x and y values of the specified point.
	     * @returns {void}
	     * @desc The value of index must be between 0 and 3.
	     * @see https://developer.apple.com/reference/quartzcore/camediatimingfunction/1522057-getcontrolpoint
	     */
	    value: function getControlPointAtValues(idx, ptr) {}
	  }, {
	    key: '_getValueAtTime',
	    value: function _getValueAtTime(time) {
	      var t0 = 0;
	      var t1 = 1;
	      var t = 0.5;
	      var r = 0;

	      for (var i = 0; i < 8; i++) {
	        r = 1 - t;
	        var tval = 3 * t * r * (this._c1x * r + this._c2x * t) + t * t * t;
	        if (time > tval) {
	          t0 = t;
	        } else {
	          t1 = t;
	        }
	        t = (t0 + t1) * 0.5;
	      }
	      r = 1 - t;
	      var val = 3 * t * r * (this._c1y * r + this._c2y * t) + t * t * t;

	      return val;
	    }
	  }], [{
	    key: 'functionWithName',
	    value: function functionWithName(name) {
	      switch (name) {
	        case Constants.kCAMediaTimingFunctionLinear:
	          return new CAMediaTimingFunction(0.0, 0.0, 1.0, 1.0);
	        case Constants.kCAMediaTimingFunctionEaseIn:
	          return new CAMediaTimingFunction(0.42, 0.0, 1.0, 1.0);
	        case Constants.kCAMediaTimingFunctionEaseOut:
	          return new CAMediaTimingFunction(0.0, 0.0, 0.58, 1.0);
	        case Constants.kCAMediaTimingFunctionEaseInEaseOut:
	          return new CAMediaTimingFunction(0.42, 0.0, 0.58, 1.0);
	        case Constants.kCAMediaTimingFunctionDefault:
	          return new CAMediaTimingFunction(0.25, 0.1, 0.25, 1.0);
	        default:
	          throw new Error('CAMediaTimingFunction: unknown name: ' + name);
	      }
	    }

	    /**
	     * Returns an initialized timing function modeled as a cubic Bézier curve using the specified control points.
	     * @access public
	     * @param {number} c1x - A floating point number representing the x position of the c1 control point.
	     * @param {number} c1y - A floating point number representing the y position of the c1 control point.
	     * @param {number} c2x - A floating point number representing the x position of the c2 control point.
	     * @param {number} c2y - A floating point number representing the y position of the c2 control point.
	     * @returns {CAMediaTimingFunction} -
	     * @desc The end points of the Bézier curve are automatically set to (0.0,0.0) and (1.0,1.0). The control points defining the Bézier curve are: [(0.0,0.0), (c1x,c1y), (c2x,c2y), (1.0,1.0)].
	     * @see https://developer.apple.com/reference/quartzcore/camediatimingfunction/1522235-init
	     */

	  }, {
	    key: 'functionWithControlPoints',
	    value: function functionWithControlPoints(c1x, c1y, c2x, c2y) {
	      return new CAMediaTimingFunction(c1x, c1y, c2x, c2y);
	    }
	  }]);

	  return CAMediaTimingFunction;
	}(_NSObject3.default);

	exports.default = CAMediaTimingFunction;

/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _CAAnimation = __webpack_require__(19);

	var _CAAnimation2 = _interopRequireDefault(_CAAnimation);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	/**
	 * Methods your app can implement to respond when animations start and stop.
	 * @interface
	 * @see https://developer.apple.com/reference/quartzcore/caanimationdelegate
	 */
	var CAAnimationDelegate = function () {
	  function CAAnimationDelegate() {
	    _classCallCheck(this, CAAnimationDelegate);
	  }

	  _createClass(CAAnimationDelegate, [{
	    key: 'init',


	    /**
	     * constructor
	     * @access public
	     * @returns {void}
	     */
	    value: function init() {}

	    // Instance Methods

	    /**
	     * Tells the delegate the animation has started. 
	     * @access public
	     * @param {CAAnimation} anim - The CAAnimation object that has started.
	     * @returns {void}
	     * @see https://developer.apple.com/reference/quartzcore/caanimationdelegate/2097265-animationdidstart
	     */

	  }, {
	    key: 'animationDidStart',
	    value: function animationDidStart(anim) {}

	    /**
	     * Tells the delegate the animation has ended. 
	     * @access public
	     * @param {CAAnimation} anim - The CAAnimation object that has ended.
	     * @param {boolean} flag - A flag indicating whether the animation has completed by reaching the end of its duration.
	     * @returns {void}
	     * @desc The animation may have ended because it has completed its active duration or because it has been removed from the layer it is attached to. flag is true if the animation reached the end of its duration without being removed.
	     * @see https://developer.apple.com/reference/quartzcore/caanimationdelegate/2097259-animationdidstop
	     */

	  }, {
	    key: 'animationDidStopFinished',
	    value: function animationDidStopFinished(anim, flag) {}
	  }]);

	  return CAAnimationDelegate;
	}();

	exports.default = CAAnimationDelegate;

/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _NSObject2 = __webpack_require__(13);

	var _NSObject3 = _interopRequireDefault(_NSObject2);

	var _SCNAnimationEventBlock = __webpack_require__(25);

	var _SCNAnimationEventBlock2 = _interopRequireDefault(_SCNAnimationEventBlock);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * A container for a closure to be executed at a specific time during playback of an animation.
	 * @access public
	 * @extends {NSObject}
	 * @see https://developer.apple.com/reference/scenekit/scnanimationevent
	 */
	var SCNAnimationEvent = function (_NSObject) {
	  _inherits(SCNAnimationEvent, _NSObject);

	  function SCNAnimationEvent() {
	    _classCallCheck(this, SCNAnimationEvent);

	    return _possibleConstructorReturn(this, (SCNAnimationEvent.__proto__ || Object.getPrototypeOf(SCNAnimationEvent)).apply(this, arguments));
	  }

	  _createClass(SCNAnimationEvent, [{
	    key: 'init',


	    /**
	     * constructor
	     * @access public
	     * @returns {void}
	     */
	    value: function init() {}

	    // Creating an Animation Event

	    /**
	     * Creates an animation event.
	     * @access public
	     * @param {number} time - A number between 0.0 and 1.0 specifying the relative time for triggering the event.
	     * @param {SCNAnimationEventBlock} eventBlock - A block to call at the specified time.
	     * @returns {void}
	     * @desc The time parameter is relative to the duration of the animation the event is attached to. For example, an event with a time of 0.5 triggers when the animation is halfway complete, and an event with a time of 1.0 triggers when the animation ends.
	     * @see https://developer.apple.com/reference/scenekit/scnanimationevent/1524004-init
	     */

	  }, {
	    key: 'initKeyTimeBlock',
	    value: function initKeyTimeBlock(time, eventBlock) {}
	  }]);

	  return SCNAnimationEvent;
	}(_NSObject3.default);

	exports.default = SCNAnimationEvent;

/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _CAAnimation = __webpack_require__(19);

	var _CAAnimation2 = _interopRequireDefault(_CAAnimation);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Signature for the block called when an animation event triggers.
	 * @type {function(animation: CAAnimation, animatedObject: Object, playingBackward: boolean): void}
	 * @param {CAAnimation} animation - The animation triggering the animation event.
	 * @param {Object} animatedObject - The Scene Kit object affected by the animation.
	 * @param {boolean} playingBackward - true if the animation is playing in reverse; otherwise, false.
	 * @returns {void}
	 * @see https://developer.apple.com/reference/scenekit/scnanimationeventblock
	 */
	var SCNAnimationEventBlock = function SCNAnimationEventBlock(animation, animatedObject, playingBackward) {};

	exports.default = SCNAnimationEventBlock;

/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

	var _CAAnimation2 = __webpack_require__(19);

	var _CAAnimation3 = _interopRequireDefault(_CAAnimation2);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * An object that allows multiple animations to be grouped and run concurrently. 
	 * @access public
	 * @extends {CAAnimation}
	 * @see https://developer.apple.com/reference/quartzcore/caanimationgroup
	 */
	var CAAnimationGroup = function (_CAAnimation) {
	  _inherits(CAAnimationGroup, _CAAnimation);

	  /**
	   * constructor
	   * @access public
	   * @constructor
	   */
	  function CAAnimationGroup() {
	    _classCallCheck(this, CAAnimationGroup);

	    // Grouped animations

	    /**
	     * An array of CAAnimation objects to be evaluated in the time space of the receiver.
	     * @type {?CAAnimation[]}
	     * @see https://developer.apple.com/reference/quartzcore/caanimationgroup/1412516-animations
	     */
	    var _this = _possibleConstructorReturn(this, (CAAnimationGroup.__proto__ || Object.getPrototypeOf(CAAnimationGroup)).call(this));

	    _this.animations = [];
	    return _this;
	  }

	  /**
	   * apply animation to the given node.
	   * @access private
	   * @param {Object} obj - target object to apply this animation.
	   * @param {number} time - active time
	   * @param {boolean} [needTimeConversion = true] -
	   * @returns {void}
	   */


	  _createClass(CAAnimationGroup, [{
	    key: '_applyAnimation',
	    value: function _applyAnimation(obj, time) {
	      var needTimeConversion = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

	      var t = time;
	      if (needTimeConversion) {
	        var baseTime = this._basetimeFromTime(time);
	        t = baseTime;
	        if (this.timingFunction !== null) {
	          t = this.timingFunction._getValueAtTime(baseTime);
	        }
	        //console.log(`time ${time} activeTime ${time - this._animationStartTime} baseTime ${baseTime}`)
	      }

	      this.animations.forEach(function (animation) {
	        animation._applyAnimation(obj, t, false);
	      });
	    }

	    /**
	      * @access public
	      * @returns {CAAnimationGroup} -
	      */

	  }, {
	    key: 'copy',
	    value: function copy() {
	      console.log('CAAnimationGroup.copy');
	      var anim = _get(CAAnimationGroup.prototype.__proto__ || Object.getPrototypeOf(CAAnimationGroup.prototype), 'copy', this).call(this);

	      anim.animations = this.animations.slice();

	      return anim;
	    }

	    /*
	    _copyValue(src) {
	      console.log('CAAnimationGroup._copyValue')
	      //super._copyValue(src)
	      this.animations = src.animations.slice()
	    }
	    */

	  }]);

	  return CAAnimationGroup;
	}(_CAAnimation3.default);

	exports.default = CAAnimationGroup;

/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

	var _CAPropertyAnimation2 = __webpack_require__(28);

	var _CAPropertyAnimation3 = _interopRequireDefault(_CAPropertyAnimation2);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * An object that provides basic, single-keyframe animation capabilities for a layer property. 
	 * @access public
	 * @extends {CAPropertyAnimation}
	 * @see https://developer.apple.com/reference/quartzcore/cabasicanimation
	 */
	var CABasicAnimation = function (_CAPropertyAnimation) {
	  _inherits(CABasicAnimation, _CAPropertyAnimation);

	  /**
	   * constructor
	   * @access public
	   * @param {?string} path -
	   * @constructor
	   */
	  function CABasicAnimation(path) {
	    _classCallCheck(this, CABasicAnimation);

	    // Interpolation values

	    /**
	     * Defines the value the receiver uses to start interpolation.
	     * @type {?Object}
	     * @see https://developer.apple.com/reference/quartzcore/cabasicanimation/1412519-fromvalue
	     */
	    var _this = _possibleConstructorReturn(this, (CABasicAnimation.__proto__ || Object.getPrototypeOf(CABasicAnimation)).call(this, path));

	    _this.fromValue = null;

	    /**
	     * Defines the value the receiver uses to end interpolation.
	     * @type {?Object}
	     * @see https://developer.apple.com/reference/quartzcore/cabasicanimation/1412523-tovalue
	     */
	    _this.toValue = null;

	    /**
	     * Defines the value the receiver uses to perform relative interpolation.
	     * @type {?Object}
	     * @see https://developer.apple.com/reference/quartzcore/cabasicanimation/1412445-byvalue
	     */
	    _this.byValue = null;
	    return _this;
	  }

	  /**
	   * @access public
	   * @returns {CABasicAnimation} -
	   */


	  _createClass(CABasicAnimation, [{
	    key: 'copy',
	    value: function copy() {
	      var anim = _get(CABasicAnimation.prototype.__proto__ || Object.getPrototypeOf(CABasicAnimation.prototype), 'copy', this).call(this);
	      //anim._copyValue(this)

	      anim.fromValue = this.fromValue;
	      anim.toValue = this.toValue;
	      anim.byValue = this.byValue;

	      return anim;
	    }

	    /*
	    _copyValue(src) {
	      this.fromValue = src.fromValue
	      this.toValue = src.toValue
	      this.byValue = src.byValue
	    }
	    */

	    /**
	     * apply animation to the given node.
	     * @access private
	     * @param {Object} obj - target object to apply this animation.
	     * @param {number} time - active time
	     * @param {boolean} [needTimeConversion = true] -
	     * @returns {void}
	     */

	  }, {
	    key: '_applyAnimation',
	    value: function _applyAnimation(obj, time) {
	      var needTimeConversion = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

	      var t = time;
	      if (needTimeConversion) {
	        var baseTime = this._basetimeFromTime(time);
	        t = baseTime;
	        if (this.timingFunction !== null) {
	          t = this.timingFunction._getValueAtTime(baseTime);
	        }
	        if (t < 0) {
	          t = 0;
	        }
	        if (t > 1) {
	          t = 1;
	        }
	        //console.log('t = ' + t)
	      }

	      var value = 0;
	      var currentValue = obj.valueForKeyPath(this.keyPath);
	      if (this.fromValue !== null && this.toValue !== null) {
	        value = this._lerp(this.fromValue, this.toValue, t);
	      } else if (this.fromValue !== null && this.byValue !== null) {
	        value = this._lerp(this.fromValue, this.fromValue + this.byValue, t);
	      } else if (this.byValue !== null && this.toValue !== null) {
	        value = this._lerp(this.toValue - this.byValue, this.toValue, t);
	      } else if (this.fromValue !== null) {
	        value = this._lerp(this.fromValue, currentValue, t);
	      } else if (this.toValue !== null) {
	        value = this._lerp(currentValue, this.toValue, t);
	      } else if (this.byValue !== null) {
	        value = this._lerp(currentValue, currentValue + this.byValue, t);
	      } else {}
	      // TODO: retain prevValue
	      //value = this._lerp(prevValue, currentValue, t)

	      //console.log(`CABasicAnimation._applyAnimation: keyPath: ${this.keyPath}, time: ${time}, baseTime: ${baseTime}, t: ${t}, value: ${value}`)
	      this._applyValue(obj, value);
	    }
	  }]);

	  return CABasicAnimation;
	}(_CAPropertyAnimation3.default);

	exports.default = CABasicAnimation;

/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

	var _CAAnimation2 = __webpack_require__(19);

	var _CAAnimation3 = _interopRequireDefault(_CAAnimation2);

	var _CGPoint = __webpack_require__(5);

	var _CGPoint2 = _interopRequireDefault(_CGPoint);

	var _CGSize = __webpack_require__(7);

	var _CGSize2 = _interopRequireDefault(_CGSize);

	var _CGRect = __webpack_require__(6);

	var _CGRect2 = _interopRequireDefault(_CGRect);

	var _SCNMatrix = __webpack_require__(17);

	var _SCNMatrix2 = _interopRequireDefault(_SCNMatrix);

	var _SCNQuaternion = __webpack_require__(29);

	var _SCNQuaternion2 = _interopRequireDefault(_SCNQuaternion);

	var _SCNVector = __webpack_require__(16);

	var _SCNVector2 = _interopRequireDefault(_SCNVector);

	var _SCNVector3 = __webpack_require__(15);

	var _SCNVector4 = _interopRequireDefault(_SCNVector3);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * An abstract subclass of CAAnimation for creating animations that manipulate the value of layer properties. 
	 * @access public
	 * @extends {CAAnimation}
	 * @see https://developer.apple.com/reference/quartzcore/capropertyanimation
	 */
	var CAPropertyAnimation = function (_CAAnimation) {
	  _inherits(CAPropertyAnimation, _CAAnimation);

	  // Creating an Animation

	  /**
	   * Creates and returns an CAPropertyAnimation instance for the specified key path.
	   * @access public
	   * @constructor
	   * @param {?string} path - 
	   * @see https://developer.apple.com/reference/quartzcore/capropertyanimation/1412534-init
	   */
	  function CAPropertyAnimation(path) {
	    _classCallCheck(this, CAPropertyAnimation);

	    // Animated Key Path

	    /**
	     * Specifies the key path the receiver animates.
	     * @type {?string}
	     * @see https://developer.apple.com/reference/quartzcore/capropertyanimation/1412496-keypath
	     */
	    var _this = _possibleConstructorReturn(this, (CAPropertyAnimation.__proto__ || Object.getPrototypeOf(CAPropertyAnimation)).call(this));

	    _this.keyPath = path;

	    // Property Value Calculation Behavior

	    /**
	     * Determines if the value of the property is the value at the end of the previous repeat cycle, plus the value of the current repeat cycle.
	     * @type {boolean}
	     * @see https://developer.apple.com/reference/quartzcore/capropertyanimation/1412538-iscumulative
	     */
	    _this.isCumulative = false;

	    /**
	     * Determines if the value specified by the animation is added to the current render tree value to produce the new render tree value.
	     * @type {boolean}
	     * @see https://developer.apple.com/reference/quartzcore/capropertyanimation/1412493-isadditive
	     */
	    _this.isAdditive = false;

	    /**
	     * An optional value function that is applied to interpolated values.
	     * @type {?CAValueFunction}
	     * @see https://developer.apple.com/reference/quartzcore/capropertyanimation/1412447-valuefunction
	     */
	    _this.valueFunction = null;
	    return _this;
	  }

	  /**
	   * @access public
	   * @returns {CAPropertyAnimation} -
	   */


	  _createClass(CAPropertyAnimation, [{
	    key: 'copy',
	    value: function copy() {
	      var anim = _get(CAPropertyAnimation.prototype.__proto__ || Object.getPrototypeOf(CAPropertyAnimation.prototype), 'copy', this).call(this);
	      //anim._copyValue(this)
	      anim.keyPath = this.keyPath;
	      anim.isCumulative = this.isCumulative;
	      anim.isAdditive = this.isAdditive;
	      anim.valueFunction = this.valueFunction;

	      return anim;
	    }

	    /*
	    _copyValue(src) {
	      console.log('CAPropertyAnimation._copyValue: ' + src.keyPath)
	      this.keyPath = src.keyPath
	      this.isCumulative = src.isCumulative
	      this.isAdditive = src.isAdditive
	      this.valueFunction = src.valueFunction
	    }
	    */

	    /**
	     * apply animation to the given node.
	     * @access private
	     * @param {Object} obj - target object to apply this animation.
	     * @param {number} time - active time
	     * @param {boolean} [needTimeConversion = true] -
	     * @returns {void}
	     */

	  }, {
	    key: '_applyAnimation',
	    value: function _applyAnimation(obj, time) {
	      var needTimeConversion = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

	      var t = time;
	      if (needTimeConversion) {
	        var baseTime = this._basetimeFromTime(time);
	        t = baseTime;
	        if (this.timingFunction !== null) {
	          t = this.timingFunction._getValueAtTime(baseTime);
	        }
	      }

	      var value = t;
	      if (this.valueFunction !== null) {
	        value = this.valueFunction._getValueAtTime(t);
	      }
	      console.log('CAPropertyAnimation: obj: ' + obj.name + ', time: ' + time + ', keyPath: ' + this.keyPath + ', value: ' + value);
	      this._applyValue(obj, value);
	    }
	  }, {
	    key: '_applyValue',
	    value: function _applyValue(obj, value) {
	      //console.log('CAPropertyAnimation._applyValue: ' + obj + ', ' + value)
	      /*
	      const paths = this.keyPath.split('.')
	      if(obj instanceof SCNMatrix4){
	        switch(this.keyPath){
	          case 'rotation.x':
	            
	            break
	          case 'rotation.y':
	            break
	          case 'rotation.z':
	          case 'rotation':
	            break
	          case 'quaternion':
	            break
	          case 'scale.x':
	            break
	          case 'scale.y':
	            break
	          case 'scale.z':
	            break
	          case 'scale':
	            break
	          case 'translation.x':
	            break
	          case 'translation.y':
	            break
	          case 'translation.z':
	            break
	          case 'translation':
	            break
	          default:
	            break
	        }
	      
	      }else if(obj instanceof CGPoint){
	        switch(this.keyPath){
	          case 'x':
	          case 'y':
	          default:
	        }
	      }else if(obj instanceof CGSize){
	        switch(this.keyPath){
	          case 'width':
	          case 'height':
	          default:
	        }
	      }else if(obj instanceof CGRect){
	        switch(this.keyPath){
	          case 'origin':
	          case 'origin.x':
	          case 'origin.y':
	          case 'size':
	          case 'size.width':
	          case 'size.height':
	        }
	      }
	      */

	      /*
	      if(obj._isPresentationInstance || obj._presentation === null){
	        console.log('obj._isPresentationInstance')
	        console.log('func: ' + obj.setValueForKeyPath)
	        obj.setValueForKeyPath(value, this.keyPath)
	      }else{
	        console.log('obj._presentation')
	        console.log('setValueForKeyPath: ' + obj._presentation.setValueForKeyPath)
	        obj._presentation.setValueForKeyPath(value, this.keyPath)
	      }
	      */
	      obj.setValueForKeyPath(value, this.keyPath);
	    }
	  }, {
	    key: '_lerp',
	    value: function _lerp(from, to, t) {
	      //if(from instanceof SCNQuaternion){
	      //  return from.slerp(to, t)
	      //}else 
	      if (from instanceof _SCNVector2.default) {
	        return from.lerp(to, t);
	      } else if (from instanceof _SCNVector4.default) {
	        return from.lerp(to, t);
	      } else if (from instanceof _CGSize2.default) {
	        // TODO: implement
	      } else if (from instanceof _CGPoint2.default) {
	        // TODO: implement
	      } else if (from instanceof _CGRect2.default) {
	        // TODO: implement
	      }
	      return from + (to - from) * t;
	    }
	  }, {
	    key: '_slerp',
	    value: function _slerp(from, to, t) {
	      if (!(from instanceof _SCNVector2.default)) {
	        throw new Error('CABasicAnimation._slerp: object is not SCNVector4');
	      }
	    }
	  }]);

	  return CAPropertyAnimation;
	}(_CAAnimation3.default);

	exports.default = CAPropertyAnimation;

/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _SCNVector = __webpack_require__(16);

	var _SCNVector2 = _interopRequireDefault(_SCNVector);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * A representation of a quaternion.
	 * @type {SCNVector4}
	 * @desc A quaternion is a mathematical construct useful for describing rotations in three-dimensional space. Although its implementation differs from that of a 4-component vector, you specify a quaternion value using the same fields as an SCNVector4 structure.SceneKit uses unit quaternions (those whose components satisfy the equation x*x + y*y + z*z + w*w == 1) for the orientation property of nodes.
	 * @see https://developer.apple.com/reference/scenekit/scnquaternion
	 */
	var SCNQuaternion = _SCNVector2.default;

	exports.default = SCNQuaternion;

/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

	var _CAPropertyAnimation2 = __webpack_require__(28);

	var _CAPropertyAnimation3 = _interopRequireDefault(_CAPropertyAnimation2);

	var _CGPath = __webpack_require__(8);

	var _CGPath2 = _interopRequireDefault(_CGPath);

	var _CAMediaTimingFunction = __webpack_require__(22);

	var _CAMediaTimingFunction2 = _interopRequireDefault(_CAMediaTimingFunction);

	var _constants = __webpack_require__(20);

	var Constants = _interopRequireWildcard(_constants);

	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * An object that provides keyframe animation capabilities for a layer object. 
	 * @access public
	 * @extends {CAPropertyAnimation}
	 * @see https://developer.apple.com/reference/quartzcore/cakeyframeanimation
	 */
	var CAKeyframeAnimation = function (_CAPropertyAnimation) {
	  _inherits(CAKeyframeAnimation, _CAPropertyAnimation);

	  // Creating an Animation

	  /**
	   * Creates and returns an CAKeyframeAnimation instance for the specified key path.
	   * @access public
	   * @constructor
	   * @param {?string} path - 
	   */
	  function CAKeyframeAnimation(path) {
	    _classCallCheck(this, CAKeyframeAnimation);

	    // Providing keyframe values

	    /**
	     * An array of objects that specify the keyframe values to use for the animation.
	     * @type {?Object[]}
	     * @see https://developer.apple.com/reference/quartzcore/cakeyframeanimation/1412498-values
	     */
	    var _this = _possibleConstructorReturn(this, (CAKeyframeAnimation.__proto__ || Object.getPrototypeOf(CAKeyframeAnimation)).call(this, path));

	    _this.values = null;

	    /**
	     * The path for a point-based property to follow.
	     * @type {?CGPath}
	     * @see https://developer.apple.com/reference/quartzcore/cakeyframeanimation/1412474-path
	     */
	    _this.path = null;

	    // Keyframe timing

	    /**
	     * An optional array of NSNumber objects that define the time at which to apply a given keyframe segment.
	     * @type {?number[]}
	     * @see https://developer.apple.com/reference/quartzcore/cakeyframeanimation/1412522-keytimes
	     */
	    _this.keyTimes = null;

	    /**
	     * An optional array of CAMediaTimingFunction objects that define the pacing for each keyframe segment.
	     * @type {?CAMediaTimingFunction[]}
	     * @see https://developer.apple.com/reference/quartzcore/cakeyframeanimation/1412465-timingfunctions
	     */
	    _this.timingFunctions = null;

	    /**
	     * Specifies how intermediate keyframe values are calculated by the receiver.
	     * @type {string}
	     * @see https://developer.apple.com/reference/quartzcore/cakeyframeanimation/1412500-calculationmode
	     */
	    _this.calculationMode = Constants.kCAAnimationLinear;

	    // Rotation Mode Attribute

	    /**
	     * Determines whether objects animating along the path rotate to match the path tangent.
	     * @type {?string}
	     * @see https://developer.apple.com/reference/quartzcore/cakeyframeanimation/1412454-rotationmode
	     */
	    _this.rotationMode = null;

	    // Cubic Mode Attributes

	    /**
	     * An array of NSNumber objects that define the tightness of the curve. 
	     * @type {?number[]}
	     * @see https://developer.apple.com/reference/quartzcore/cakeyframeanimation/1412475-tensionvalues
	     */
	    _this.tensionValues = null;

	    /**
	     * An array of NSNumber objects that define the sharpness of the timing curve’s corners.
	     * @type {?number[]}
	     * @see https://developer.apple.com/reference/quartzcore/cakeyframeanimation/1412491-continuityvalues
	     */
	    _this.continuityValues = null;

	    /**
	     * An array of NSNumber objects that define the position of the curve relative to a control point.
	     * @type {?number[]}
	     * @see https://developer.apple.com/reference/quartzcore/cakeyframeanimation/1412485-biasvalues
	     */
	    _this.biasValues = null;

	    /**
	     * @access private
	     * @type {number}
	     */
	    _this._indexCache = 0;
	    return _this;
	  }

	  /**
	   * @access public
	   * @returns {CAKeyframeAnimation} -
	   */


	  _createClass(CAKeyframeAnimation, [{
	    key: 'copy',
	    value: function copy() {
	      var anim = _get(CAKeyframeAnimation.prototype.__proto__ || Object.getPrototypeOf(CAKeyframeAnimation.prototype), 'copy', this).call(this);

	      anim.values = this.values ? this.values.slice() : null;
	      anim.path = this.path;
	      anim.keyTimes = this.keyTimes ? this.keyTimes.slice() : null;
	      anim.timingFunctions = this.timingFunctions ? this.timingFunctions.slice() : null;
	      anim.calculationMode = this.calculationMode;
	      anim.rotationMode = this.rotationMode;
	      anim.tensionValues = this.tensionValues ? this.tensionValues.slice() : null;
	      anim.continuityValues = this.continuityValues ? this.continuityValues.slice() : null;
	      anim.biasValues = this.biasValues ? this.biasValues.slice() : null;

	      return anim;
	    }

	    /**
	     * apply animation to the given node.
	     * @access private
	     * @param {Object} obj - target object to apply this animation.
	     * @param {number} time - active time
	     * @param {boolean} [needTimeConversion = true] -
	     * @returns {void}
	     */

	  }, {
	    key: '_applyAnimation',
	    value: function _applyAnimation(obj, time) {
	      var needTimeConversion = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

	      var t = time;
	      if (needTimeConversion) {
	        var baseTime = this._basetimeFromTime(time);
	        t = baseTime;
	      }

	      var index = this._indexCache;
	      var key0 = 0;
	      var key1 = 0;

	      if (t > 1) {
	        throw new Error('CAKeyframeAnimation._applyAnimation: t ' + t + ' > 1');
	      }

	      var len = this.keyTimes.length;
	      if (index >= len) {
	        console.log('CAKeyframeAnimation index >= len  ' + index + ' >= ' + len);
	        index = len - 1;
	      }

	      // search keyTime linearly
	      if (this.keyTimes[index] < t) {
	        for (; index < len; index++) {
	          if (this.keyTimes[index] >= t) break;
	        }
	        key0 = index - 1;
	        key1 = index;
	      } else {
	        for (; index >= 0; index--) {
	          if (this.keyTimes[index] < t) break;
	        }
	        key0 = index;
	        key1 = index + 1;
	      }
	      if (key0 <= 0) {
	        key0 = 0;
	      }
	      if (key1 >= len) {
	        key1 = len - 1;
	      }

	      this._indexCache = key0;

	      var time0 = this.keyTimes[key0];
	      var time1 = this.keyTimes[key1];
	      var val0 = this.values[key0];
	      var val1 = this.values[key1];

	      var value = val0;
	      if (time0 !== time1) {
	        var dt = (t - time0) / (time1 - time0);
	        var r = this.timingFunctions[key0]._getValueAtTime(dt);

	        switch (this.calculationMode) {
	          case Constants.kCAAnimationLinear:
	            value = this._lerp(val0, val1, r);
	            break;
	          case Constants.kCAAnimationDiscrete:
	            // TODO: implement
	            throw new Error('kCAAnimationDiscrete not implemented');
	          case Constants.kCAAnimationPaced:
	            // TODO: implement
	            throw new Error('kCAAnimationPaced not implemented');
	          case Constants.kCAAnimationCubic:
	            // TODO: implement
	            throw new Error('kCAAnimationCubic not implemented');
	          case Constants.kCAAnimationCubicPaced:
	            // TODO: impelement
	            throw new Error('kCAAnimationCubicPaced not implemented');
	          default:
	            throw new Error('unknown calculation mode: ' + this.calculationMode);
	        }

	        //console.log(`t: ${t}, time0: ${time0}, time1: ${time1}, dt: ${dt}, r: ${r}, value: ${value}`)
	      } else {
	          //console.log(`t: ${t}, time0: ${time0}, time1: ${time1}, value: ${value}`)
	        }

	      this._applyValue(obj, value);
	    }
	  }]);

	  return CAKeyframeAnimation;
	}(_CAPropertyAnimation3.default);

	exports.default = CAKeyframeAnimation;

/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _NSObject2 = __webpack_require__(13);

	var _NSObject3 = _interopRequireDefault(_NSObject2);

	var _SCNVector = __webpack_require__(15);

	var _SCNVector2 = _interopRequireDefault(_SCNVector);

	var _SCNVector3 = __webpack_require__(16);

	var _SCNVector4 = _interopRequireDefault(_SCNVector3);

	var _SCNAudioSource = __webpack_require__(32);

	var _SCNAudioSource2 = _interopRequireDefault(_SCNAudioSource);

	var _SCNNode = __webpack_require__(33);

	var _SCNNode2 = _interopRequireDefault(_SCNNode);

	var _SCNActionTimingMode = __webpack_require__(105);

	var _SCNActionTimingMode2 = _interopRequireDefault(_SCNActionTimingMode);

	var _SCNActionTimingFunction = __webpack_require__(106);

	var _SCNActionTimingFunction2 = _interopRequireDefault(_SCNActionTimingFunction);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * A simple, reusable animation that changes attributes of any node you attach it to.
	 * @access public
	 * @extends {NSObject}
	 * @see https://developer.apple.com/reference/scenekit/scnaction
	 */
	var SCNAction = function (_NSObject) {
	  _inherits(SCNAction, _NSObject);

	  function SCNAction() {
	    _classCallCheck(this, SCNAction);

	    return _possibleConstructorReturn(this, (SCNAction.__proto__ || Object.getPrototypeOf(SCNAction)).apply(this, arguments));
	  }

	  _createClass(SCNAction, [{
	    key: 'init',


	    /**
	     * constructor
	     * @access public
	     * @returns {void}
	     */
	    value: function init() {

	      // Adjusting an Action’s Animation Properties

	      /**
	       * The duration required to complete an action.
	       * @type {number}
	       * @see https://developer.apple.com/reference/scenekit/scnaction/1524162-duration
	       */
	      this.duration = 0;

	      /**
	       * A speed factor that modifies how fast an action runs.
	       * @type {number}
	       * @see https://developer.apple.com/reference/scenekit/scnaction/1522811-speed
	       */
	      this.speed = 0;

	      /**
	       * The timing mode used to execute an action.
	       * @type {SCNActionTimingMode}
	       * @see https://developer.apple.com/reference/scenekit/scnaction/1524055-timingmode
	       */
	      this.timingMode = null;

	      /**
	       * A block SceneKit calls to determine the action’s animation timing.
	       * @type {?SCNActionTimingFunction}
	       * @see https://developer.apple.com/reference/scenekit/scnaction/1524130-timingfunction
	       */
	      this.timingFunction = null;
	    }

	    // Creating Actions That Move a Node

	    /**
	     * Creates an action that moves a node relative to its current position.
	     * @access public
	     * @param {number} deltaX - The distance to move the node in the X direction of its parent node’s local coordinate space.
	     * @param {number} deltaY - The distance to move the node in the Y direction of its parent node’s local coordinate space.
	     * @param {number} deltaZ - The distance to move the node in the Z direction of its parent node’s local coordinate space.
	     * @param {number} duration - The duration, in seconds, of the animation.
	     * @returns {SCNAction} - 
	     * @desc When the action executes, the node’s position property animates from its current position to its new position.This action is reversible; the reverse is created as if the following code had been executed:[SCNAction moveByX: -deltaX y: -deltaY z: -deltaZ duration: duration];
	    [SCNAction moveByX: -deltaX y: -deltaY z: -deltaZ duration: duration];
	      * @see https://developer.apple.com/reference/scenekit/scnaction/1523238-moveby
	     */

	  }, {
	    key: 'reversed',


	    // Reversing an Action

	    /**
	     * Creates an action that reverses the behavior of another action.
	     * @access public
	     * @returns {SCNAction} - 
	     * @desc This method always returns an action object; however, not all actions are reversible. When reversed, some actions return an object that either does nothing or performs the same action as the original action. For details on how an action is reversed, see the description of the class method used to create that action.
	     * @see https://developer.apple.com/reference/scenekit/scnaction/1522815-reversed
	     */
	    value: function reversed() {
	      return null;
	    }
	  }], [{
	    key: 'moveByXYZ',
	    value: function moveByXYZ(deltaX, deltaY, deltaZ, duration) {
	      return null;
	    }

	    /**
	     * Creates an action that moves a node relative to its current position.
	     * @access public
	     * @param {SCNVector3} delta - A vector that describes the change to be applied to the node’s position.
	     * @param {number} duration - The duration, in seconds, of the animation.
	     * @returns {SCNAction} - 
	     * @desc When the action executes, the node’s position property animates from its current position to its new position.This action is reversible; the reverse is created as if the following code had been executed:SCNVector3 reverseDelta = SCNVector3Make(-delta.x, -delta.y, -delta.z);
	    [SCNAction moveBy: reverseDelta duration: duration];
	    SCNVector3 reverseDelta = SCNVector3Make(-delta.x, -delta.y, -delta.z);
	    [SCNAction moveBy: reverseDelta duration: duration];
	      * @see https://developer.apple.com/reference/scenekit/scnaction/1522605-move
	     */

	  }, {
	    key: 'moveBy',
	    value: function moveBy(delta, duration) {
	      return null;
	    }

	    /**
	     * Creates an action that moves a node to a new position.
	     * @access public
	     * @param {SCNVector3} location - The coordinates for the node’s new position in its parent node’s local coordinate space.
	     * @param {number} duration - The duration, in seconds, of the animation.
	     * @returns {SCNAction} - 
	     * @desc When the action executes, the node’s position property animates from its current position to its new position.This action is not reversible; the reverse of this action has the same duration but does not move the node.
	     * @see https://developer.apple.com/reference/scenekit/scnaction/1522826-move
	     */

	  }, {
	    key: 'moveTo',
	    value: function moveTo(location, duration) {
	      return null;
	    }

	    // Creating Actions That Rotate a Node

	    /**
	     * Creates an action that rotates the node in each of the three principal axes by angles relative to its current orientation.
	     * @access public
	     * @param {number} xAngle - The amount to rotate the node counterclockwise around the x-axis of its local coordinate space, in radians.
	     * @param {number} yAngle - The amount to rotate the node counterclockwise around the y-axis of its local coordinate space, in radians.
	     * @param {number} zAngle - The amount to rotate the node counterclockwise around the z-axis of its local coordinate space, in radians.
	     * @param {number} duration - The duration, in seconds, of the animation.
	     * @returns {SCNAction} - 
	     * @desc When the action executes, the node’s rotation property animates to the new angle.This action is reversible; the reverse is created as if the following code had been executed:[SCNAction rotateByX: -xAngle y: -yAngle z: -zAngle duration: duration];
	    [SCNAction rotateByX: -xAngle y: -yAngle z: -zAngle duration: duration];
	      * @see https://developer.apple.com/reference/scenekit/scnaction/1523522-rotateby
	     */

	  }, {
	    key: 'rotateByXYZ',
	    value: function rotateByXYZ(xAngle, yAngle, zAngle, duration) {
	      return null;
	    }

	    /**
	     * Creates an action that rotates the node to absolute angles in each of the three principal axes.
	     * @access public
	     * @param {number} xAngle - The amount to rotate the node counterclockwise around the x-axis of its local coordinate space, in radians.
	     * @param {number} yAngle - The amount to rotate the node counterclockwise around the y-axis of its local coordinate space, in radians.
	     * @param {number} zAngle - The amount to rotate the node counterclockwise around the z-axis of its local coordinate space, in radians.
	     * @param {number} duration - The duration, in seconds, of the animation.
	     * @returns {SCNAction} - 
	     * @desc When the action executes, the node’s rotation property animates to the new angle. Calling this method is equivalent to calling rotateTo(x:y:z:duration:usesShortestUnitArc:) and passing false for the shortestUnitArc parameter.This action is not reversible; the reverse of this action has the same duration but does not change anything.
	     * @see https://developer.apple.com/reference/scenekit/scnaction/1524044-rotateto
	     */

	  }, {
	    key: 'rotateToXYZ',
	    value: function rotateToXYZ(xAngle, yAngle, zAngle, duration) {
	      return null;
	    }

	    /**
	     * Creates an action that rotates the node to absolute angles in each of the three principal axes.
	     * @access public
	     * @param {number} xAngle - The amount to rotate the node counterclockwise around the x-axis of its local coordinate space, in radians.
	     * @param {number} yAngle - The amount to rotate the node counterclockwise around the y-axis of its local coordinate space, in radians.
	     * @param {number} zAngle - The amount to rotate the node counterclockwise around the z-axis of its local coordinate space, in radians.
	     * @param {number} duration - The duration, in seconds, of the animation.
	     * @param {boolean} shortestUnitArc - If false (the default), the animation interpolates each component of the node’s rotation between its current value and the new value. If true, the animation makes the most direct rotation possible from the node’s current orientation to the new orientation.
	     * @returns {SCNAction} - 
	     * @desc When the action executes, the node’s rotation property animates to the new angle.This action is not reversible; the reverse of this action has the same duration but does not change anything.
	     * @see https://developer.apple.com/reference/scenekit/scnaction/1522808-rotateto
	     */

	  }, {
	    key: 'rotateToXYZUsesShortestUnitArc',
	    value: function rotateToXYZUsesShortestUnitArc(xAngle, yAngle, zAngle, duration, shortestUnitArc) {
	      return null;
	    }

	    /**
	     * Creates an action that rotates the node by an angle around a specified axis.
	     * @access public
	     * @param {number} angle - The amount to rotate the node counterclockwise around the specified axis, in radians.
	     * @param {SCNVector3} axis - A vector in the node’s local coordinate space whose direction specifies the axis of rotation.
	     * @param {number} duration - The duration, in seconds, of the animation.
	     * @returns {SCNAction} - 
	     * @desc When the action executes, the node’s rotation property animates to the new angle.This action is reversible; the reverse is created as if the following code had been executed:[SCNAction rotateByAngle: -angle aroundAxis: axis duration: sec];
	    [SCNAction rotateByAngle: -angle aroundAxis: axis duration: sec];
	      * @see https://developer.apple.com/reference/scenekit/scnaction/1523805-rotate
	     */

	  }, {
	    key: 'rotateByAround',
	    value: function rotateByAround(angle, axis, duration) {
	      return null;
	    }

	    /**
	     * Creates an action that rotates the node to an absolute angle around a specified axis.
	     * @access public
	     * @param {SCNVector4} axisAngle - A four-component vector whose first three components are a vector in the node’s local coordinate space specifying an axis and whose fourth component is the amount to rotate the node counterclockwise around that axis, in radians.
	     * @param {number} duration - The duration, in seconds, of the animation.
	     * @returns {SCNAction} - 
	     * @desc When the action executes, the node’s rotation property animates to the new angle.This action is not reversible; the reverse of this action has the same duration but does not change anything.
	     * @see https://developer.apple.com/reference/scenekit/scnaction/1524191-rotate
	     */

	  }, {
	    key: 'rotateToAxisAngle',
	    value: function rotateToAxisAngle(axisAngle, duration) {
	      return null;
	    }

	    // Creating Actions That Change a Node’s Scale

	    /**
	     * Creates an action that uniformly changes the scale factor of a node by a relative value.
	     * @access public
	     * @param {number} scale - The amount of change to make to all three components of the node’s scale.
	     * @param {number} sec - The duration, in seconds, of the animation.
	     * @returns {SCNAction} - 
	     * @desc When the action executes, the node’s scale property animates to the new value.This action is reversible; the reverse is created as if the following code had been executed:[SCNAction scaleBy: -scale duration: sec];
	    [SCNAction scaleBy: -scale duration: sec];
	      * @see https://developer.apple.com/reference/scenekit/scnaction/1523129-scale
	     */

	  }, {
	    key: 'scaleByDuration',
	    value: function scaleByDuration(scale, sec) {
	      return null;
	    }

	    /**
	     * Creates an action that uniformly changes the scale factor of a node to an absolute value.
	     * @access public
	     * @param {number} scale - The new value for all three components of the node’s scale.
	     * @param {number} sec - The duration, in seconds, of the animation.
	     * @returns {SCNAction} - 
	     * @desc When the action executes, the node’s scale property animates to the new value.This action is not reversible; the reverse of this action has the same duration but does not change anything.
	     * @see https://developer.apple.com/reference/scenekit/scnaction/1523322-scale
	     */

	  }, {
	    key: 'scaleToDuration',
	    value: function scaleToDuration(scale, sec) {
	      return null;
	    }

	    // Creating Actions That Change a Node’s Opacity

	    /**
	     * Creates an action that changes the opacity of the node to 1.0.
	     * @access public
	     * @param {number} sec - The duration, in seconds, of the animation.
	     * @returns {SCNAction} - 
	     * @desc When the action executes, the node’s opacity property animates from its current value to 1.0.This action is reversible; the reverse is created as if the following code had been executed:[SCNAction fadeOutWithDuration: sec];
	    [SCNAction fadeOutWithDuration: sec];
	      * @see https://developer.apple.com/reference/scenekit/scnaction/1522777-fadein
	     */

	  }, {
	    key: 'fadeInDuration',
	    value: function fadeInDuration(sec) {
	      return null;
	    }

	    /**
	     * Creates an action that changes the opacity of the node to 0.0.
	     * @access public
	     * @param {number} sec - The duration, in seconds, of the animation.
	     * @returns {SCNAction} - 
	     * @desc When the action executes, the node’s opacity property animates from its current value to 0.0.This action is reversible; the reverse is created as if the following code had been executed:[SCNAction fadeInWithDuration: sec];
	    [SCNAction fadeInWithDuration: sec];
	      * @see https://developer.apple.com/reference/scenekit/scnaction/1523922-fadeout
	     */

	  }, {
	    key: 'fadeOutDuration',
	    value: function fadeOutDuration(sec) {
	      return null;
	    }

	    /**
	     * Creates an action that adjusts the opacity of a node by a relative value.
	     * @access public
	     * @param {number} factor - The amount to change the node’s opacity by.
	     * @param {number} sec - The duration, in seconds, of the animation.
	     * @returns {SCNAction} - 
	     * @desc When the action executes, the node’s opacity property animates to its new value.This action is reversible; the reverse is created as if the following code had been executed:[SCNAction fadeOpacityBy: -factor duration: sec];
	    [SCNAction fadeOpacityBy: -factor duration: sec];
	      * @see https://developer.apple.com/reference/scenekit/scnaction/1523595-fadeopacity
	     */

	  }, {
	    key: 'fadeOpacityByDuration',
	    value: function fadeOpacityByDuration(factor, sec) {
	      return null;
	    }

	    /**
	     * Creates an action that adjusts the opacity of a node to a new value.
	     * @access public
	     * @param {number} opacity - The new opacity value of the node.
	     * @param {number} sec - The duration, in seconds, of the animation.
	     * @returns {SCNAction} - 
	     * @desc When the action executes, the node’s opacity property animates to its new value.This action is not reversible; the reverse of this action has the same duration but does not change anything.
	     * @see https://developer.apple.com/reference/scenekit/scnaction/1523875-fadeopacity
	     */

	  }, {
	    key: 'fadeOpacityToDuration',
	    value: function fadeOpacityToDuration(opacity, sec) {
	      return null;
	    }

	    // Creating Actions That Change a Node’s Visibility

	    /**
	     * Creates an action that hides a node.
	     * @access public
	     * @returns {SCNAction} - 
	     * @desc When the action executes, the node’s isHidden property is set to true.This action is reversible; the reverse is equivalent to the unhide() action.
	     * @see https://developer.apple.com/reference/scenekit/scnaction/1523487-hide
	     */

	  }, {
	    key: 'hide',
	    value: function hide() {
	      return null;
	    }

	    /**
	     * Creates an action that ensures a node is not hidden.
	     * @access public
	     * @returns {SCNAction} - 
	     * @desc When the action executes, the node’s isHidden property is set to false.This action is reversible; the reverse is equivalent to the hide() action.
	     * @see https://developer.apple.com/reference/scenekit/scnaction/1524205-unhide
	     */

	  }, {
	    key: 'unhide',
	    value: function unhide() {
	      return null;
	    }

	    // Creating Actions That Remove Nodes from the Scene

	    /**
	     * Creates an action that removes the node from its parent.
	     * @access public
	     * @returns {SCNAction} - 
	     * @desc When the action executes, the node is immediately removed from its parent.This action is not reversible; the reverse of this action is the same action.
	     * @see https://developer.apple.com/reference/scenekit/scnaction/1522966-removefromparentnode
	     */

	  }, {
	    key: 'removeFromParentNode',
	    value: function removeFromParentNode() {
	      return null;
	    }

	    // Creating Actions That Play Audio

	    /**
	     * Creates an action that plays an audio source.
	     * @access public
	     * @param {SCNAudioSource} source - The audio source to play.
	     * @param {boolean} wait - If true, the duration of this action is the same as the length of the audio playback. If false, the action is considered to have completed immediately.
	     * @returns {SCNAction} - 
	     * @desc When the action executes, SceneKit plays the audio source on the target node—any positional audio effects are based on the node’s position. For more information about positional audio in SceneKit, see SCNAudioPlayer.This action is not reversible; the reverse of this action is the same action.
	     * @see https://developer.apple.com/reference/scenekit/scnaction/1523651-playaudio
	     */

	  }, {
	    key: 'playAudioWaitForCompletion',
	    value: function playAudioWaitForCompletion(source, wait) {
	      return null;
	    }

	    // Creating Actions That Combine or Repeat Other Actions

	    /**
	     * Creates an action that runs a collection of actions in parallel.
	     * @access public
	     * @param {SCNAction[]} actions - An array of SCNAction objects.
	     * @returns {SCNAction} - 
	     * @desc When the action executes, the actions that make up the group all start immediately and run in parallel. The duration of the group action is the longest duration among the collection of actions. If an action in the group has a duration less than the group’s duration, the action completes and then idles until the group completes the remaining actions. This matters most when creating a repeating action that repeats a group.This action is reversible; it creates a new group action that contains the reverse of each action specified in the group. 
	     * @see https://developer.apple.com/reference/scenekit/scnaction/1522779-group
	     */

	  }, {
	    key: 'group',
	    value: function group(actions) {
	      return null;
	    }

	    /**
	     * Creates an action that runs a collection of actions sequentially.
	     * @access public
	     * @param {SCNAction[]} actions - An array of SCNAction objects.
	     * @returns {SCNAction} - 
	     * @desc When the action executes, the first action in the sequence starts and runs to completion. Subsequent actions in the sequence run in a similar fashion until all of the actions in the sequence have executed. The duration of the sequence action is the sum of the durations of the actions in the sequence.This action is reversible; it creates a new sequence action that reverses the order of the actions. Each action in the reversed sequence is itself reversed. For example, the actions reverseSequence and sequenceReverse in the code example below are equivalent:SCNAction *sequence = [SCNAction sequence:@[ actionA, actionB, actionC ]];
	    SCNAction *reverseSequence = [SCNAction sequence:@[ [actionC reversedAction],
	                                                      [actionB reversedAction],
	                                                      [actionA reversedAction] ]];
	    SCNAction *sequenceReverse = [sequence reversedAction];
	    SCNAction *sequence = [SCNAction sequence:@[ actionA, actionB, actionC ]];
	    SCNAction *reverseSequence = [SCNAction sequence:@[ [actionC reversedAction],
	                                                      [actionB reversedAction],
	                                                      [actionA reversedAction] ]];
	    SCNAction *sequenceReverse = [sequence reversedAction];
	      * @see https://developer.apple.com/reference/scenekit/scnaction/1522793-sequence
	     */

	  }, {
	    key: 'sequence',
	    value: function sequence(actions) {
	      return null;
	    }

	    /**
	     * Creates an action that repeats another action a specified number of times.
	     * @access public
	     * @param {SCNAction} action - The action to be executed.
	     * @param {number} count - The number of times to execute the action.
	     * @returns {SCNAction} - 
	     * @desc When the action executes, the associated action runs to completion and then repeats, until the count is reached.This action is reversible; it creates a new action that is the reverse of the specified action and then repeats it the same number of times.
	     * @see https://developer.apple.com/reference/scenekit/scnaction/1522764-repeat
	     */

	  }, {
	    key: 'repeat',
	    value: function repeat(action, count) {
	      return null;
	    }

	    /**
	     * Creates an action that repeats another action forever.
	     * @access public
	     * @param {SCNAction} action - The action to execute.
	     * @returns {SCNAction} - 
	     * @desc When the action executes, the associated action runs to completion and then repeats.This action is reversible; it creates a new action that is the reverse of the specified action and then repeats it forever.NoteThe action to be repeated must have a non-instantaneous duration.
	     * @see https://developer.apple.com/reference/scenekit/scnaction/1522908-repeatforever
	     */

	  }, {
	    key: 'repeatForever',
	    value: function repeatForever(action) {
	      return null;
	    }

	    // Creating Actions That Add Delays to Action Sequences

	    /**
	     * Creates an action that idles for a specified period of time.
	     * @access public
	     * @param {number} sec - The amount of time to wait.
	     * @returns {SCNAction} - 
	     * @desc When the action executes, the action waits for the specified amount of time and then ends. This is typically used as part of a sequence of actions to insert a delay between two other actions. You might also use it in conjunction with the runAction(_:completionHandler:) method to trigger code that needs to run at a later time.This action is not reversible; the reverse of this action is the same action.
	     * @see https://developer.apple.com/reference/scenekit/scnaction/1523915-wait
	     */

	  }, {
	    key: 'waitDuration',
	    value: function waitDuration(sec) {
	      return null;
	    }

	    /**
	     * Creates an action that idles for a randomized period of time.
	     * @access public
	     * @param {number} sec - The average amount of time to wait.
	     * @param {number} durationRange - The range of possible values for the duration.
	     * @returns {SCNAction} - 
	     * @desc When the action executes, the action waits for the specified amount of time and then ends. This is typically used as part of a sequence of actions to insert a delay between two other actions. However, you might also use it in conjunction with the runAction(_:completionHandler:) method to trigger code that needs to run at a later time.Each time the action is executed, the action computes a new random value for the duration. The duration may vary in either direction by up to half of the value of the durationRange parameter.This action is not reversible; the reverse of this action is the same action.
	     * @see https://developer.apple.com/reference/scenekit/scnaction/1523086-wait
	     */

	  }, {
	    key: 'waitDurationWithRange',
	    value: function waitDurationWithRange(sec, durationRange) {
	      return null;
	    }

	    // Creating Custom Actions

	    /**
	     * Creates an action that executes a block.
	     * @access public
	     * @param {function(arg1: SCNNode): void} block - The block to run. The block takes a single parameter:nodeThe node on which the action is running.
	     * @returns {SCNAction} - 
	     * @desc When the action executes, SceneKit calls the block. This action takes place instantaneously.This action is not reversible; the reverse action executes the same block.
	     * @see https://developer.apple.com/reference/scenekit/scnaction/1523637-run
	     */

	  }, {
	    key: 'run',
	    value: function run(block) {
	      return null;
	    }

	    /**
	     * Creates an action that executes a block periodically over a specified duration.
	     * @access public
	     * @param {number} seconds - The duration of the action, in seconds.
	     * @param {function(arg1: SCNNode, arg2: number): void} block - The block to run. The block takes the following parameters:nodeThe node on which the action is running.elapsedTimeThe amount of time that has passed since the action began executing.
	     * @returns {SCNAction} - 
	     * @desc When the action executes, SceneKit calls the block repeatedly until the action’s duration expires. For each call, SceneKit computes the elapsed time and passes it to the block.This action is not reversible; the reverse action executes the same block.
	     * @see https://developer.apple.com/reference/scenekit/scnaction/1523692-customaction
	     */

	  }, {
	    key: 'customActionDurationAction',
	    value: function customActionDurationAction(seconds, block) {
	      return null;
	    }

	    /**
	     * Creates an action that executes a JavaScript script periodically over a specified duration.
	     * @access public
	     * @param {string} script - A string containing JavaScript source code.
	     * @param {number} seconds - The duration of the action, in seconds.
	     * @returns {SCNAction} - 
	     * @desc SceneKit exposes its classes, methods, and functions in the JavaScript context that runs the script—see the SCNJavaScript.h header file for details.When the action executes, SceneKit runs the script repeatedly until the action’s duration expires. Each time SceneKit runs the script, it computes the elapsed time since the action began executing (as a fraction of the action’s duration between 0.0 and 1.0) and makes it available to the script as a variable named elapsedTime. The script can also reference the SCNNode object running the action as a variable named node.This action is not reversible; the reverse action executes the same script.
	     * @see https://developer.apple.com/reference/scenekit/scnaction/1523984-javascriptaction
	     */

	  }, {
	    key: 'javaScriptActionWithScriptDuration',
	    value: function javaScriptActionWithScriptDuration(script, seconds) {
	      return null;
	    }
	  }]);

	  return SCNAction;
	}(_NSObject3.default);

	exports.default = SCNAction;

/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _NSObject2 = __webpack_require__(13);

	var _NSObject3 = _interopRequireDefault(_NSObject2);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * A simple, reusable audio source—music or sound effects loaded from a file—for use in positional audio playback.
	 * @access public
	 * @extends {NSObject}
	 * @see https://developer.apple.com/reference/scenekit/scnaudiosource
	 */
	var SCNAudioSource = function (_NSObject) {
	  _inherits(SCNAudioSource, _NSObject);

	  function SCNAudioSource() {
	    _classCallCheck(this, SCNAudioSource);

	    return _possibleConstructorReturn(this, (SCNAudioSource.__proto__ || Object.getPrototypeOf(SCNAudioSource)).apply(this, arguments));
	  }

	  _createClass(SCNAudioSource, [{
	    key: 'initNamed',


	    // Creating an Audio Source

	    /**
	     * Returns the audio source associated with the specified filename.
	     * @access public
	     * @param {string} fileName - The name of an audio file. If this filename has not been previously requested, the method looks for an audio file with the specified name in the application’s main bundle.
	     * @returns {void}
	     * @desc This method looks in the system caches for an audio source with the specified name and returns that object if it exists. If a matching audio source is not already in the cache, this method locates the audio file with the specified name in the application’s main bundle, then creates a new audio source and caches it for reuse.
	     * @see https://developer.apple.com/reference/scenekit/scnaudiosource/1524138-init
	     */
	    value: function initNamed(fileName) {}

	    /**
	     * Initializes an audio source from an audio file in the application’s main bundle.
	     * @access public
	     * @param {string} name - The name of an audio file in the application’s main bundle.
	     * @returns {void}
	     * @desc Calling this method is equivalent to using the Bundle class to locate an audio file in the application’s main bundle and then passing the resulting URL to the init(url:) method.
	     * @see https://developer.apple.com/reference/scenekit/scnaudiosource/1524225-init
	     */

	  }, {
	    key: 'initFileNamed',
	    value: function initFileNamed(name) {}

	    /**
	     * Initializes an audio source from the specified audio file.
	     * @access public
	     * @param {string} url - A URL locating an audio file.
	     * @returns {void}
	     * @see https://developer.apple.com/reference/scenekit/scnaudiosource/1523264-init
	     */

	  }, {
	    key: 'init',
	    value: function init(url) {

	      // Controlling 3D Audio Spatialization

	      /**
	       * A Boolean value that determines whether audio from this source uses 3D positional mixing.
	       * @type {boolean}
	       * @see https://developer.apple.com/reference/scenekit/scnaudiosource/1524185-ispositional
	       */
	      this.isPositional = false;

	      // Setting Default Playback Parameters

	      /**
	       * The default playback volume for the audio source.
	       * @type {number}
	       * @see https://developer.apple.com/reference/scenekit/scnaudiosource/1524106-volume
	       */
	      this.volume = 0;

	      /**
	       * The default playback rate for the audio source.
	       * @type {number}
	       * @see https://developer.apple.com/reference/scenekit/scnaudiosource/1524189-rate
	       */
	      this.rate = 0;

	      /**
	       * The default blend of blend of unmodified and reverb-processed (also called dry and wet) audio for playback of the audio source.
	       * @type {number}
	       * @see https://developer.apple.com/reference/scenekit/scnaudiosource/1523450-reverbblend
	       */
	      this.reverbBlend = 0;

	      /**
	       * A Boolean value that determines whether the audio source should play repeatedly.
	       * @type {boolean}
	       * @see https://developer.apple.com/reference/scenekit/scnaudiosource/1524183-loops
	       */
	      this.loops = false;

	      /**
	       * A Boolean value that determines whether the audio source should stream content from its source URL when playing.
	       * @type {boolean}
	       * @see https://developer.apple.com/reference/scenekit/scnaudiosource/1523475-shouldstream
	       */
	      this.shouldStream = false;
	    }

	    // Preloading Audio Data

	    /**
	     * Loads audio data from the source and prepares it for playing.
	     * @access public
	     * @returns {void}
	     * @desc This method reads audio data from the source file (specified when initializing the audio source) and performs any decompression necessary to prepare for playing audio. Use this method to control when your app or game incurs the run-time performance cost of such work—for example, you can load all audio source before starting a game level, instead of suffering a frame rate drop upon playing a new audio source during gameplay.This method has no effect if the shouldStream property’s value is true.
	     * @see https://developer.apple.com/reference/scenekit/scnaudiosource/1523399-load
	     */

	  }, {
	    key: 'load',
	    value: function load() {}
	  }]);

	  return SCNAudioSource;
	}(_NSObject3.default);

	exports.default = SCNAudioSource;

/***/ },
/* 33 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

	var _CAAnimationGroup = __webpack_require__(26);

	var _CAAnimationGroup2 = _interopRequireDefault(_CAAnimationGroup);

	var _NSObject2 = __webpack_require__(13);

	var _NSObject3 = _interopRequireDefault(_NSObject2);

	var _SCNActionable = __webpack_require__(34);

	var _SCNActionable2 = _interopRequireDefault(_SCNActionable);

	var _SCNAnimatable = __webpack_require__(35);

	var _SCNAnimatable2 = _interopRequireDefault(_SCNAnimatable);

	var _SCNBoundingVolume = __webpack_require__(36);

	var _SCNBoundingVolume2 = _interopRequireDefault(_SCNBoundingVolume);

	var _SCNGeometry = __webpack_require__(37);

	var _SCNGeometry2 = _interopRequireDefault(_SCNGeometry);

	var _SCNLight = __webpack_require__(81);

	var _SCNLight2 = _interopRequireDefault(_SCNLight);

	var _SCNCamera = __webpack_require__(80);

	var _SCNCamera2 = _interopRequireDefault(_SCNCamera);

	var _SCNMorpher = __webpack_require__(95);

	var _SCNMorpher2 = _interopRequireDefault(_SCNMorpher);

	var _SCNSkinner = __webpack_require__(97);

	var _SCNSkinner2 = _interopRequireDefault(_SCNSkinner);

	var _SCNMatrix = __webpack_require__(17);

	var _SCNMatrix2 = _interopRequireDefault(_SCNMatrix);

	var _SCNMatrix4MakeTranslation = __webpack_require__(45);

	var _SCNMatrix4MakeTranslation2 = _interopRequireDefault(_SCNMatrix4MakeTranslation);

	var _SCNVector = __webpack_require__(15);

	var _SCNVector2 = _interopRequireDefault(_SCNVector);

	var _SCNVector3 = __webpack_require__(16);

	var _SCNVector4 = _interopRequireDefault(_SCNVector3);

	var _SCNQuaternion = __webpack_require__(29);

	var _SCNQuaternion2 = _interopRequireDefault(_SCNQuaternion);

	var _SCNConstraint = __webpack_require__(98);

	var _SCNConstraint2 = _interopRequireDefault(_SCNConstraint);

	var _SCNMovabilityHint = __webpack_require__(99);

	var _SCNMovabilityHint2 = _interopRequireDefault(_SCNMovabilityHint);

	var _SCNNodeRendererDelegate = __webpack_require__(100);

	var _SCNNodeRendererDelegate2 = _interopRequireDefault(_SCNNodeRendererDelegate);

	var _SCNPhysicsBody = __webpack_require__(55);

	var _SCNPhysicsBody2 = _interopRequireDefault(_SCNPhysicsBody);

	var _SCNPhysicsField = __webpack_require__(101);

	var _SCNPhysicsField2 = _interopRequireDefault(_SCNPhysicsField);

	var _SCNParticleSystem = __webpack_require__(59);

	var _SCNParticleSystem2 = _interopRequireDefault(_SCNParticleSystem);

	var _SCNAudioPlayer = __webpack_require__(104);

	var _SCNAudioPlayer2 = _interopRequireDefault(_SCNAudioPlayer);

	var _SCNHitTestResult = __webpack_require__(58);

	var _SCNHitTestResult2 = _interopRequireDefault(_SCNHitTestResult);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * A structural element of a scene graph, representing a position and transform in a 3D coordinate space, to which you can attach geometry, lights, cameras, or other displayable content.
	 * @access public
	 * @extends {NSObject}
	 * @implements {SCNActionable}
	 * @implements {SCNAnimatable}
	 * @implements {SCNBoundingVolume}
	 * @see https://developer.apple.com/reference/scenekit/scnnode
	 */
	var SCNNode = function (_NSObject) {
	  _inherits(SCNNode, _NSObject);

	  // Creating a Node

	  /**
	   * Creates and returns a node object with the specified geometry attached.
	   * @access public
	   * @constructor
	   * @param {?SCNGeometry} [geometry = null] - The geometry to be attached.
	   * @see https://developer.apple.com/reference/scenekit/scnnode/1408020-init
	   */
	  function SCNNode() {
	    var geometry = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

	    _classCallCheck(this, SCNNode);

	    // Managing Node Attributes

	    /**
	     * A name associated with the node.
	     * @type {?string}
	     * @see https://developer.apple.com/reference/scenekit/scnnode/1408014-name
	     */
	    var _this = _possibleConstructorReturn(this, (SCNNode.__proto__ || Object.getPrototypeOf(SCNNode)).call(this));

	    _this.name = null;

	    /**
	     * The light attached to the node.
	     * @type {?SCNLight}
	     * @see https://developer.apple.com/reference/scenekit/scnnode/1408004-light
	     */
	    _this.light = null;

	    /**
	     * The camera attached to the node.
	     * @type {?SCNCamera}
	     * @see https://developer.apple.com/reference/scenekit/scnnode/1407976-camera
	     */
	    _this.camera = null;

	    /**
	     * The geometry attached to the node.
	     * @type {?SCNGeometry}
	     * @see https://developer.apple.com/reference/scenekit/scnnode/1407966-geometry
	     */
	    _this.geometry = geometry;

	    /**
	     * The morpher object responsible for blending the node’s geometry.
	     * @type {?SCNMorpher}
	     * @see https://developer.apple.com/reference/scenekit/scnnode/1408022-morpher
	     */
	    _this.morpher = null;

	    /**
	     * The skinner object responsible for skeletal animations of node’s contents.
	     * @type {?SCNSkinner}
	     * @see https://developer.apple.com/reference/scenekit/scnnode/1407953-skinner
	     */
	    _this.skinner = null;

	    /**
	     * A mask that defines which categories the node belongs to.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnnode/1407994-categorybitmask
	     */
	    _this.categoryBitMask = 0;

	    // Working With Node Animation

	    /**
	     * A Boolean value that determines whether to run actions and animations attached to the node and its child nodes.
	     * @type {boolean}
	     * @see https://developer.apple.com/reference/scenekit/scnnode/1407962-ispaused
	     */
	    _this.isPaused = false;

	    /**
	     * A node object representing the state of the node as it currently appears onscreen.
	     * @type {SCNNode}
	     * @access private
	     * @see https://developer.apple.com/reference/scenekit/scnnode/1408030-presentation
	     */
	    _this._presentation = null;

	    /**
	     * 
	     * @type {boolean}
	     * @access private
	     */
	    _this._isPresentationInstance = false;

	    // Managing the Node’s Transformation

	    /**
	     * The transformation applied to the node relative to its parent. Animatable.
	     * @type {SCNMatrix4}
	     * @access private
	     * @see https://developer.apple.com/reference/scenekit/scnnode/1407964-transform
	     */
	    _this._transform = new _SCNMatrix2.default();

	    _this._worldTransform = new _SCNMatrix2.default();

	    /**
	     * 
	     * @type {boolean}
	     * @access private
	     */
	    _this._transformUpToDate = false;

	    /**
	     * The translation applied to the node. Animatable.
	     * @type {SCNVector3}
	     * @see https://developer.apple.com/reference/scenekit/scnnode/1408026-position
	     */
	    _this._position = new _SCNVector2.default(0, 0, 0);

	    /**
	     * The node’s orientation, expressed as a rotation angle about an axis. Animatable.
	     * @type {SCNVector4}
	     * @see https://developer.apple.com/reference/scenekit/scnnode/1408034-rotation
	     */
	    _this._rotation = new _SCNVector4.default(1, 0, 0, 0);

	    /**
	     * The node’s orientation, expressed as pitch, yaw, and roll angles, each in radians. Animatable.
	     * @type {SCNVector3}
	     * @see https://developer.apple.com/reference/scenekit/scnnode/1407980-eulerangles
	     */
	    //this.eulerAngles = null

	    /**
	     * The node’s orientation, expressed as a quaternion. Animatable.
	     * @type {SCNQuaternion}
	     * @see https://developer.apple.com/reference/scenekit/scnnode/1408048-orientation
	     */
	    //this.orientation = null

	    /**
	     * The scale factor applied to the node. Animatable.
	     * @type {SCNVector3}
	     * @see https://developer.apple.com/reference/scenekit/scnnode/1408050-scale
	     */
	    _this._scale = new _SCNVector2.default(1, 1, 1);

	    /**
	     * The pivot point for the node’s position, rotation, and scale. Animatable.
	     * @type {SCNMatrix4}
	     * @see https://developer.apple.com/reference/scenekit/scnnode/1408044-pivot
	     */
	    _this.pivot = null;

	    /**
	     * A list of constraints affecting the node’s transformation.
	     * @type {?SCNConstraint[]}
	     * @see https://developer.apple.com/reference/scenekit/scnnode/1408016-constraints
	     */
	    _this.constraints = null;

	    //this._worldTransform = null

	    // Modifying the Node Visibility

	    /**
	     * A Boolean value that determines the visibility of the node’s contents. Animatable.
	     * @type {boolean}
	     * @see https://developer.apple.com/reference/scenekit/scnnode/1407967-ishidden
	     */
	    _this.isHidden = false;

	    /**
	     * The opacity value of the node. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnnode/1408010-opacity
	     */
	    _this.opacity = 0;

	    /**
	     * The order the node’s content is drawn in relative to that of other nodes.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnnode/1407978-renderingorder
	     */
	    _this.renderingOrder = 0;

	    /**
	     * A Boolean value that determines whether SceneKit renders the node’s contents into shadow maps.
	     * @type {boolean}
	     * @see https://developer.apple.com/reference/scenekit/scnnode/1407955-castsshadow
	     */
	    _this.castsShadow = false;

	    /**
	     * A value that indicates how SceneKit should handle the node when rendering movement-related effects.
	     * @type {SCNMovabilityHint}
	     * @see https://developer.apple.com/reference/scenekit/scnnode/1690499-movabilityhint
	     */
	    _this.movabilityHint = null;

	    // Managing the Node Hierarchy

	    /**
	     * The node’s parent in the scene graph hierarchy.
	     * @type {?SCNNode}
	     * @access private
	     * @see https://developer.apple.com/reference/scenekit/scnnode/1407968-parent
	     */
	    _this._parent = null;

	    /**
	     * An array of the node’s children in the scene graph hierarchy.
	     * @type {SCNNode[]}
	     * @access private
	     * @see https://developer.apple.com/reference/scenekit/scnnode/1407984-childnodes
	     */
	    _this._childNodes = [];

	    // Customizing Node Rendering

	    /**
	     * An array of Core Image filters to be applied to the rendered contents of the node.
	     * @type {?CIFilter[]}
	     * @see https://developer.apple.com/reference/scenekit/scnnode/1407949-filters
	     */
	    _this.filters = null;

	    /**
	     * An object responsible for rendering custom contents for the node using Metal or OpenGL.
	     * @type {?SCNNodeRendererDelegate}
	     * @see https://developer.apple.com/reference/scenekit/scnnode/1408012-rendererdelegate
	     */
	    _this.rendererDelegate = null;

	    // Adding Physics to a Node

	    /**
	     * The physics body associated with the node.
	     * @type {?SCNPhysicsBody}
	     * @see https://developer.apple.com/reference/scenekit/scnnode/1407988-physicsbody
	     */
	    _this.physicsBody = null;

	    /**
	     * The physics field associated with the node.
	     * @type {?SCNPhysicsField}
	     * @see https://developer.apple.com/reference/scenekit/scnnode/1408006-physicsfield
	     */
	    _this.physicsField = null;

	    // Working With Particle Systems

	    _this._particleSystems = null;

	    // Working With Positional Audio

	    _this._audioPlayers = null;

	    ///////////////////
	    // SCNActionable //
	    ///////////////////

	    // Inspecting a Node’s Running Action
	    _this._hasActions = false;

	    /**
	     * @access private
	     * @type {Map}
	     */
	    _this._actions = new Map();

	    ///////////////////
	    // SCNAnimatable //
	    ///////////////////

	    /**
	     * @access private
	     * @type {Map}
	     */
	    _this._animations = new Map();

	    ///////////////////////
	    // SCNBoundingVolume //
	    ///////////////////////

	    // Working with Bounding Volumes

	    /**
	     * The minimum and maximum corner points of the object’s bounding box.
	     * @type {{min: SCNVector3, max: SCNVector3}}
	     * @see https://developer.apple.com/reference/scenekit/scnboundingvolume/2034705-boundingbox
	     */
	    _this.boundingBox = null;

	    //this._boundingSphere = null

	    return _this;
	  }

	  /**
	   * Constructor for JSExport compatibility
	   * @access public
	   * @returns {SCNNode} -
	   */


	  _createClass(SCNNode, [{
	    key: '_updateWorldTransform',
	    value: function _updateWorldTransform() {
	      var p = null;
	      if (this._parent === null) {
	        p = (0, _SCNMatrix4MakeTranslation2.default)(0, 0, 0);
	      } else {
	        p = this._parent._worldTransform;
	      }
	      this._worldTransform = this.transform.mult(p);

	      if (this._presentation) {
	        var pp = null;
	        if (this._parent === null) {
	          pp = (0, _SCNMatrix4MakeTranslation2.default)(0, 0, 0);
	        } else if (this._parent._presentation === null) {
	          pp = this._parent._worldTransform;
	        } else {
	          pp = this._parent._presentation._worldTransform;
	        }
	        this._presentation._updateTransform();
	        this._presentation._worldTransform = this._presentation.transform.mult(pp);
	      }

	      this._childNodes.forEach(function (child) {
	        child._updateWorldTransform();
	      });
	    }

	    /*
	    _updatePresentationTransform() {
	      let p = null
	      if(this._parent === null){
	        p = SCNMatrix4MakeTranslation(0, 0, 0)
	      }else{
	        p = this._parent._presentation._worldTransform
	      }
	      
	      this._presentation._worldTransform = this._presentation.transform.mult(parentTransform)
	      this._childNodes.forEach((child) => {
	        child._updatePrsentationTransform(this._presentation._worldTransform)
	      })
	    }
	    */

	    /**
	     * The translation applied to the node. Animatable.
	     * @type {SCNVector3}
	     * @see https://developer.apple.com/reference/scenekit/scnnode/1408026-position
	     */

	  }, {
	    key: 'addChildNode',


	    // Managing the Node Hierarchy

	    /**
	     * Adds a node to the node’s array of children.
	     * @access public
	     * @param {SCNNode} child - The node to be added.
	     * @returns {void}
	     * @desc Calling this method appends the node to the end of the childNodes array.
	     * @see https://developer.apple.com/reference/scenekit/scnnode/1407974-addchildnode
	     */
	    value: function addChildNode(child) {
	      if (this._childNodes.indexOf(child) >= 0) {
	        return;
	      }
	      child.removeFromParentNode();
	      this._childNodes.push(child);
	      child._parent = this;
	    }

	    /**
	     * Adds a node to the node’s array of children at a specified index.
	     * @access public
	     * @param {SCNNode} child - The node to be inserted.ImportantRaises an exception (invalidArgumentException) if child is nil.
	     * @param {number} index - The position at which to insert the new child node.ImportantRaises an exception (rangeException) if index is greater than the number of elements in the node’s childNodes array.
	     * @returns {void}
	     * @see https://developer.apple.com/reference/scenekit/scnnode/1407958-insertchildnode
	     */

	  }, {
	    key: 'insertChildNodeAt',
	    value: function insertChildNodeAt(child, index) {
	      if (this._childNodes.indexOf(child) >= 0) {
	        return;
	      }
	      child.removeFromParentNode();
	      this._insertObjectInChildNodesAtIndex(child, index);
	      this._parent = this;
	    }

	    /**
	     * Removes the node from its parent’s array of child nodes.
	     * @access public
	     * @returns {void}
	     * @desc Removing nodes from the node hierarchy serves two purposes. Nodes own their contents (child nodes or attached lights, geometries, and other objects), so deallocating unneeded nodes can reduce memory usage. Additionally, SceneKit does more work at rendering time with a large, complex node hierarchy, so removing nodes whose contents you don’t need to display can improve rendering performance.
	     * @see https://developer.apple.com/reference/scenekit/scnnode/1407991-removefromparentnode
	     */

	  }, {
	    key: 'removeFromParentNode',
	    value: function removeFromParentNode() {
	      var parentNode = this._parent;
	      if (parentNode === null) {
	        return;
	      }
	      var index = parentNode._childNodes.indexOf(this);
	      if (index < 0) {
	        return;
	      }
	      parentNode._removeObjectFromChildNodesAtIndex(index);
	    }

	    /**
	     * Removes a child from the node’s array of children and inserts another node in its place. 
	     * @access public
	     * @param {SCNNode} oldChild - 
	     * @param {SCNNode} newChild - 
	     * @returns {void}
	     * @desc If both the child and child2 nodes are children of the node, calling this method swaps their positions in the array. Note that removing a node from the node hierarchy may result in it being deallocated.Calling this method results in undefined behavior if the child parameter does not refer to a child of this node.
	     * @see https://developer.apple.com/reference/scenekit/scnnode/1408002-replacechildnode
	     */

	  }, {
	    key: 'replaceChildNodeWith',
	    value: function replaceChildNodeWith(oldChild, newChild) {
	      var index = this._childNodes.indexOf(oldChild);
	      if (index < 0) {
	        return;
	      }
	      this._removeObjectFromChildNodesAtIndex(index);
	      this._insertObjectInChildNodesAtIndex(newChild, index);
	    }

	    /**
	     *
	     * @access private
	     * @param {number} index -
	     * @returns {void}
	     */

	  }, {
	    key: '_removeObjectFromChildNodesAtIndex',
	    value: function _removeObjectFromChildNodesAtIndex(index) {
	      var arr = this._childNodes.splice(index, 1);
	      if (arr.length === 0) {
	        return;
	      }
	      var obj = arr[0];

	      obj._parent = null;
	      obj._transformUpToDate = false;
	    }

	    /**
	     *
	     * @access private
	     * @param {SCNNode} object -
	     * @param {number} index -
	     * @returns {void}
	     */

	  }, {
	    key: '_insertObjectInChildNodesAtIndex',
	    value: function _insertObjectInChildNodesAtIndex(object, index) {
	      var length = this._childNodes.length;
	      if (index > length) {
	        throw new Error('SCNNode.childNodes out of index: ' + index + ' > ' + length);
	      }
	      this._childNodes.splice(index, 0, object);
	    }

	    /**
	     * The node’s parent in the scene graph hierarchy.
	     * @type {?SCNNode}
	     * @desc For a scene’s rootNode object, the value of this property is nil.
	     * @see https://developer.apple.com/reference/scenekit/scnnode/1407968-parent
	     */

	  }, {
	    key: 'childNodesPassingTest',


	    // Searching the Node Hierarchy

	    /**
	     * Returns all nodes in the node’s child node subtree that satisfy the test applied by a block.
	     * @access public
	     * @param {function(child: SCNNode, stop: UnsafeMutablePointer<ObjCBool>): boolean} predicate - The block to apply to the node’s child and descendant nodes .The block takes two parameters:child The child node currently being searched. stop A reference to a Boolean value. Set *stop to true in the block to abort further processing of the child node subtree.The block returns a Boolean value indicating whether to include the child node in the search results array.
	     * @returns {SCNNode[]} - 
	     * @desc Use this method to search for nodes using a test you specify. For example, you can search for empty nodes using a block that returns YES for nodes whose light, camera, and geometry properties are all nil.SceneKit uses a recursive preorder traversal to search the child node subtree—that is, the block searches a node before it searches each of the node’s children, and it searches all children of a node before searching any of that node’s sibling nodes.
	     * @see https://developer.apple.com/reference/scenekit/scnnode/1407982-childnodes
	     */
	    value: function childNodesPassingTest(predicate) {
	      var result = [];
	      return result;
	    }

	    /**
	     * Returns the first node in the node’s child node subtree with the specified name.
	     * @access public
	     * @param {string} name - The name of the node to search for.
	     * @param {boolean} [recursively = true] - true to search the entire child node subtree, or false to search only the node’s immediate children.
	     * @returns {?SCNNode} - 
	     * @desc If the recursive parameter is true, SceneKit uses a preorder traversal to search the child node subtree—that is, the block searches a node before it searches each of the node’s children, and it searches all children of a node before searching any of that node’s sibling nodes. Otherwise, SceneKit searches only those nodes in the node’s childNodes array.
	     * @see https://developer.apple.com/reference/scenekit/scnnode/1407951-childnode
	     */

	  }, {
	    key: 'childNodeWithNameRecursively',
	    value: function childNodeWithNameRecursively(name) {
	      var recursively = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

	      for (var i = 0; i < this._childNodes.length; i++) {
	        if (this._childNodes[i].name === name) {
	          return this._childNodes[i];
	        }
	        if (recursively) {
	          var result = this._childNodes[i].childNodeWithNameRecursively(name, recursively);
	          if (result !== null) {
	            return result;
	          }
	        }
	      }

	      return null;
	    }

	    /**
	     * Returns the first node in the node’s child nodearray with the specified name.
	     * @access public
	     * @param {string} name - The name of the node to search for.
	     * @returns {?SCNNode} - 
	     * @desc SceneKit searches only those nodes in the node’s childNodes array.
	     * @see https://developer.apple.com/reference/scenekit/scnnode/1407951-childnode
	     */

	  }, {
	    key: 'childNodeWithName',
	    value: function childNodeWithName(name) {
	      return this.childNodeWithNameRecursively(name, false);
	    }

	    /**
	     * Executes the specified block for each of the node’s child and descendant nodes.
	     * @access public
	     * @param {function(child: SCNNode, stop: UnsafeMutablePointer<ObjCBool>): void} block - The block to apply to the node’s child and descendant nodes.The block takes two parameters:childThe child node currently being evaluated.stopA reference to a Boolean value. Set *stop to true in the block to abort further processing of the child node subtree.
	     * @returns {void}
	     * @desc SceneKit uses a recursive preorder traversal to process the child node subtree—that is, the block runs for a node before it runs for each of the node’s children, and it processes all children of a node before processing any of that node’s sibling nodes.
	     * @see https://developer.apple.com/reference/scenekit/scnnode/1408032-enumeratechildnodes
	     */

	  }, {
	    key: 'enumerateChildNodes',
	    value: function enumerateChildNodes(block) {}

	    /**
	     * Executes the specified block for each of the node’s child and descendant nodes, as well as for the node itself.
	     * @access public
	     * @param {function(arg1: SCNNode, arg2: UnsafeMutablePointer<ObjCBool>): void} block - The block to apply to the node’s child and descendant nodes.The block takes two parameters:childThe child node currently being evaluated.stopA reference to a Boolean value. Set *stop to true in the block to abort further processing of the child node subtree.
	     * @returns {void}
	     * @desc SceneKit uses a recursive preorder traversal to process the child node subtree—that is, the block runs for a node before it runs for each of the node’s children, and it processes all children of a node before processing any of that node’s sibling nodes.This method is equivalent to the enumerateChildNodes(_:) method, but unlike that method it also runs the block to process the node itself, not just its child nodes.
	     * @see https://developer.apple.com/reference/scenekit/scnnode/1642248-enumeratehierarchy
	     */

	  }, {
	    key: 'enumerateHierarchy',
	    value: function enumerateHierarchy(block) {}

	    // Working With Particle Systems

	    /**
	     * Attaches a particle system to the node.
	     * @access public
	     * @param {SCNParticleSystem} system - A particle system.
	     * @returns {void}
	     * @desc When attached to a node, a particle system’s emitter location follows that node as it moves through the scene. To instead attach a particle system to a location in the scene’s world coordinate space, use the corresponding method on SCNScene.For details on particle systems, see SCNParticleSystem.
	     * @see https://developer.apple.com/reference/scenekit/scnnode/1523123-addparticlesystem
	     */

	  }, {
	    key: 'addParticleSystem',
	    value: function addParticleSystem(system) {}

	    /**
	     * Removes a particle system attached to the node.
	     * @access public
	     * @param {SCNParticleSystem} system - A particle system.
	     * @returns {void}
	     * @desc This method has no effect if the system parameter does not reference a particle system directly attached to the node.
	     * @see https://developer.apple.com/reference/scenekit/scnnode/1524014-removeparticlesystem
	     */

	  }, {
	    key: 'removeParticleSystem',
	    value: function removeParticleSystem(system) {}

	    /**
	     * Removes any particle systems directly attached to the node.
	     * @access public
	     * @returns {void}
	     * @see https://developer.apple.com/reference/scenekit/scnnode/1522801-removeallparticlesystems
	     */

	  }, {
	    key: 'removeAllParticleSystems',
	    value: function removeAllParticleSystems() {}

	    /**
	     * The particle systems attached to the node.
	     * @access public
	     * @type {?SCNParticleSystem[]}
	     * @desc An array of SCNParticleSystem objects directly attached to the node. This array does not include particle systems attached to the node's child nodes. For details on particle systems, see SCNParticleSystem.
	     * @see https://developer.apple.com/reference/scenekit/scnnode/1522705-particlesystems
	     */

	  }, {
	    key: 'addAudioPlayer',


	    // Working With Positional Audio

	    /**
	     * Adds the specified auto player to the node and begins playback.
	     * @access public
	     * @param {SCNAudioPlayer} player - An audio player object.
	     * @returns {void}
	     * @desc Positional audio effects from a player attached to a node are based on that node’s position relative to the audioListener position in the scene.After playback has completed, SceneKit automatically removes the audio player from the node.
	     * @see https://developer.apple.com/reference/scenekit/scnnode/1523464-addaudioplayer
	     */
	    value: function addAudioPlayer(player) {}

	    /**
	     * Removes the specified audio player from the node, stopping playback.
	     * @access public
	     * @param {SCNAudioPlayer} player - An audio player attached to the node.
	     * @returns {void}
	     * @desc This method has no effect if the player parameter does not reference an audio player directly attached to the node.
	     * @see https://developer.apple.com/reference/scenekit/scnnode/1522767-removeaudioplayer
	     */

	  }, {
	    key: 'removeAudioPlayer',
	    value: function removeAudioPlayer(player) {}

	    /**
	     * Removes all audio players attached to the node, stopping playback.
	     * @access public
	     * @returns {void}
	     * @see https://developer.apple.com/reference/scenekit/scnnode/1523570-removeallaudioplayers
	     */

	  }, {
	    key: 'removeAllAudioPlayers',
	    value: function removeAllAudioPlayers() {}
	    /**
	     * The audio players currently attached to the node.
	     * @type {SCNAudioPlayer[]}
	     * @desc Positional audio effects from a player attached to a node are based on that node’s position relative to the audioListener position in the scene.After an audio player completes playback, SceneKit automatically removes it from the node. Therefore, this array always contains audio players that are currently playing back audio.
	     * @see https://developer.apple.com/reference/scenekit/scnnode/1523244-audioplayers
	     */

	  }, {
	    key: 'clone',


	    // Copying a Node

	    /**
	     * Creates a copy of the node and its children.
	     * @access public
	     * @returns {SCNNode} - 
	     * @desc This method recursively copies the node and its child nodes. For a nonrecursive copy, use the inherited copy() method, which creates a copy of the node without any child nodes.Cloning or copying a node creates a duplicate of the node object, but not the geometries, lights, cameras, and other SceneKit objects attached to it—instead, each copied node shares references to these objects.This behavior means that you can use cloning to, for example, place the same geometry at several locations within a scene without  maintaining multiple copies of the geometry and its materials. However, it also means that changes to the objects attached to one node will affect other nodes that share the same attachments. For example, to render two copies of a node using different materials, you must copy both the node and its geometry before assigning a new material.- (void)duplicateNode:(SCNNode *)node withMaterial:(SCNMaterial *)material
	    {
	      SCNNode *newNode = [node clone];
	      newNode.geometry = [node.geometry copy];
	      newNode.geometry.firstMaterial = material;
	    }
	    Multiple copies of an SCNGeometry object efficiently share the same vertex data, so you can copy geometries without a significant performance penalty.- (void)duplicateNode:(SCNNode *)node withMaterial:(SCNMaterial *)material
	    {
	      SCNNode *newNode = [node clone];
	      newNode.geometry = [node.geometry copy];
	      newNode.geometry.firstMaterial = material;
	    }
	      * @see https://developer.apple.com/reference/scenekit/scnnode/1408046-clone
	     */
	    value: function clone() {
	      var node = this.copy();

	      this._childNodes.forEach(function (child) {
	        node.addChildNode(child.clone());
	      });

	      return node;
	    }

	    /**
	     * Creates an optimized copy of the node and its children.
	     * @access public
	     * @returns {SCNNode} - 
	     * @desc Rendering complex node hierarchies can incur a performance cost. Each geometry and material requires a separate draw command to be sent to the GPU, and each draw command comes with a performance overhead. If you plan for a portion of your scene’s node hierarchy to remain static (with respect to itself, if not the rest of the scene), use this method to create a single node containing all elements of that node hierarchy that SceneKit can render using fewer draw commands.
	     * @see https://developer.apple.com/reference/scenekit/scnnode/1407960-flattenedclone
	     */

	  }, {
	    key: 'flattenedClone',
	    value: function flattenedClone() {
	      return null;
	    }

	    // Hit-Testing

	    /**
	     * Searches the node’s child node subtree for objects intersecting a line segment between two specified points.
	     * @access public
	     * @param {SCNVector3} pointA - An endpoint of the line segment to search along, specified in the node’s local coordinate system.
	     * @param {SCNVector3} pointB - The other endpoint of the line segment to search along, specified in the node’s local coordinate system.
	     * @param {?Map<string, Object>} [options = null] - A dictionary of options affecting the search. See Hit Testing Options Keys for acceptable values.
	     * @returns {SCNHitTestResult[]} - 
	     * @desc Hit-testing is the process of finding elements of a scene located along a specified line segment in the scene’s coordinate space (or that of a particular node in the scene). For example, you can use this method to determine whether a projectile launched by a game character will hit its target.To search for the scene element corresponding to a two-dimensional point in the rendered image, use the renderer’s hitTest(_:options:) method instead.
	     * @see https://developer.apple.com/reference/scenekit/scnnode/1407998-hittestwithsegment
	     */

	  }, {
	    key: 'hitTestWithSegmentFromTo',
	    value: function hitTestWithSegmentFromTo(pointA, pointB) {
	      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

	      return null;
	    }

	    // Converting Between Node Coordinate Spaces

	    /**
	     * Converts a position to the node’s coordinate space from that defined by another node.
	     * @access public
	     * @param {SCNVector3} position - A position in the local coordinate space defined by the other node.
	     * @param {?SCNNode} node - Another node in the same scene graph as the node, or nil to convert from the scene’s world coordinate space.
	     * @returns {SCNVector3} - 
	     * @see https://developer.apple.com/reference/scenekit/scnnode/1408018-convertposition
	     */

	  }, {
	    key: 'convertPositionFrom',
	    value: function convertPositionFrom(position, node) {
	      return null;
	    }

	    /**
	     * Converts a position from the node’s coordinate space to that defined by another node.
	     * @access public
	     * @param {SCNVector3} position - A position in the node’s local coordinate space.
	     * @param {?SCNNode} node - Another node in the same scene graph as the node, or nil to convert to the scene’s world coordinate space.
	     * @returns {SCNVector3} - 
	     * @see https://developer.apple.com/reference/scenekit/scnnode/1407990-convertposition
	     */

	  }, {
	    key: 'convertPositionTo',
	    value: function convertPositionTo(position, node) {
	      return null;
	    }

	    /**
	     * Converts a transformation to the node’s coordinate space from that defined by another node.
	     * @access public
	     * @param {SCNMatrix4} transform - A transformation relative to the local coordinate space defined by the other node.
	     * @param {?SCNNode} node - Another node in the same scene graph as the node, or nil to convert from the scene’s world coordinate space.
	     * @returns {SCNMatrix4} - 
	     * @see https://developer.apple.com/reference/scenekit/scnnode/1407996-converttransform
	     */

	  }, {
	    key: 'convertTransformFrom',
	    value: function convertTransformFrom(transform, node) {
	      return null;
	    }

	    /**
	     * Converts a transformation from the node’s coordinate space to that defined by another node.
	     * @access public
	     * @param {SCNMatrix4} transform - A transformation relative to the node’s coordinate space.
	     * @param {?SCNNode} node - Another node in the same scene graph as the node, or nil to convert to the scene’s world coordinate space.
	     * @returns {SCNMatrix4} - 
	     * @see https://developer.apple.com/reference/scenekit/scnnode/1407986-converttransform
	     */

	  }, {
	    key: 'convertTransformTo',
	    value: function convertTransformTo(transform, node) {
	      return null;
	    }

	    ///////////////////
	    // SCNActionable //
	    ///////////////////

	    // Running Actions

	    /**
	     * Required. Adds an action to the list of actions executed by the node.
	     * @access public
	     * @param {SCNAction} action - The action to be performed.
	     * @returns {void}
	     * @desc SceneKit begins running a newly added action when it prepares to render the next frame.
	     * @see https://developer.apple.com/reference/scenekit/scnactionable/1523164-runaction
	     */

	  }, {
	    key: 'runAction',
	    value: function runAction(action) {}

	    /**
	     * Required. Adds an action to the list of actions executed by the node. SceneKit calls the specified block when the action completes.
	     * @access public
	     * @param {SCNAction} action - The action to be performed.
	     * @param {?function(): void} [block = null] - A completion block that SceneKit calls when the action completes.
	     * @returns {void}
	     * @desc The new action is processed the next time SceneKit prepares to render a frame.SceneKit calls your block after the action’s duration is complete. For example, in a game you could use this method to show a Game Over message after performing a fade-out action on a node that displays a player character.
	     * @see https://developer.apple.com/reference/scenekit/scnactionable/1524219-runaction
	     */

	  }, {
	    key: 'runActionCompletionHandler',
	    value: function runActionCompletionHandler(action) {
	      var block = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
	    }

	    /**
	     * Required. Adds an identifiable action to the list of actions executed by the node.
	     * @access public
	     * @param {SCNAction} action - The action to be performed.
	     * @param {?string} key - A unique key used to identify the action.
	     * @returns {void}
	     * @desc This method is identical to runAction(_:), but the action is stored and identified so that you can retrieve or cancel it later. If an action using the same key is already running, SceneKit removes it before adding the new action.
	     * @see https://developer.apple.com/reference/scenekit/scnactionable/1524222-runaction
	     */

	  }, {
	    key: 'runActionForKey',
	    value: function runActionForKey(action, key) {}

	    /**
	     * Required. Adds an identifiable action to the list of actions executed by the node. SceneKit calls the specified block when the action completes.
	     * @access public
	     * @param {SCNAction} action - The action to be performed.
	     * @param {?string} key - A unique key used to identify the action.
	     * @param {?function(): void} [block = null] - A completion block called when the action completes.
	     * @returns {void}
	     * @desc This method is identical to runAction(_:completionHandler:), but the action is stored and identified so that you can retrieve or cancel it later. If an action using the same key is already running, SceneKit removes it before adding the new action.SceneKit calls your block after the action’s duration is complete. For example, you can use this method with a wait action to execute some code after a timed delay. If during the delay period you need to prevent the code from running, use the removeAction(forKey:) method to cancel it.
	     * @see https://developer.apple.com/reference/scenekit/scnactionable/1522791-runaction
	     */

	  }, {
	    key: 'runActionForKeyCompletionHandler',
	    value: function runActionForKeyCompletionHandler(action, key) {
	      var block = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
	    }

	    // Inspecting a Node’s Running Actions

	    /**
	     * Required. Returns an action associated with a specific key.
	     * @access public
	     * @param {string} key - A string that uniquely identifies a action.
	     * @returns {?SCNAction} - 
	     * @desc Use this method to retrieve actions you scheduled using the runAction(_:forKey:) or runAction(_:forKey:completionHandler:) method.
	     * @see https://developer.apple.com/reference/scenekit/scnactionable/1523287-action
	     */

	  }, {
	    key: 'actionForKey',
	    value: function actionForKey(key) {
	      return this._actions.get(key);
	    }

	    /**
	     * Required. A Boolean value that indicates whether the node is currently executing any actions.
	     * @type {boolean}
	     * @desc This value is true if the node has any executing actions; otherwise the value is false.
	     * @see https://developer.apple.com/reference/scenekit/scnactionable/1523794-hasactions
	     */

	  }, {
	    key: 'removeActionForKey',


	    // Canceling a Node’s Running Actions

	    /**
	     * Required. Removes an action associated with a specific key.
	     * @access public
	     * @param {string} key - A string that uniquely identifies a action.
	     * @returns {void}
	     * @desc If the node is currently running an action that matches the key, SceneKit removes that action from the node, skipping any remaining animation it would perform but keeping any changes already made to the node.Use this method to cancel actions you scheduled using the runAction(_:forKey:) or runAction(_:forKey:completionHandler:) method.
	     * @see https://developer.apple.com/reference/scenekit/scnactionable/1523617-removeaction
	     */
	    value: function removeActionForKey(key) {}

	    /**
	     * Required. Ends and removes all actions from the node.
	     * @access public
	     * @returns {void}
	     * @desc When SceneKit removes an action from a node, it skips any remaining animation the action would perform. However, any changes the action has already made to the node’s state remain in effect.
	     * @see https://developer.apple.com/reference/scenekit/scnactionable/1524181-removeallactions
	     */

	  }, {
	    key: 'removeAllActions',
	    value: function removeAllActions() {}

	    ///////////////////
	    // SCNAnimatable //
	    ///////////////////

	    // Managing Animations

	    /**
	     * Required. Adds an animation object for the specified key.
	     * @access public
	     * @param {CAAnimation} animation - The animation object to be added.
	     * @param {?string} key - An string identifying the animation for later retrieval. You may pass nil if you don’t need to reference the animation later.
	     * @returns {void}
	     * @desc Newly added animations begin executing after the current run loop cycle ends.SceneKit does not define any requirements for the contents of the key parameter—it need only be unique among the keys for other animations you add. If you add an animation with an existing key, this method overwrites the existing animation.
	     * @see https://developer.apple.com/reference/scenekit/scnanimatable/1523386-addanimation
	     */

	  }, {
	    key: 'addAnimationForKey',
	    value: function addAnimationForKey(animation, key) {
	      //console.log('addAnimationForKey: ' + key)
	      if (typeof key === 'undefined' || key === null) {
	        key = Symbol();
	      }
	      var anim = animation.copy();
	      // FIXME: use current frame time
	      anim._animationStartTime = Date.now() * 0.001;
	      anim._prevTime = anim._animationStartTime - 0.0000001;
	      //const now = Date.now() * 0.001
	      //this._setAnimationStartTime(anim, now)
	      this._animations.set(key, anim);
	    }

	    /**
	     * @access private
	     * @param {CAAnimation} animatino -
	     * @param {number} time -
	     * @returns {void}
	     */
	    /*
	    _setAnimationStartTime(animation, time) {
	      animation._animationStartTime = time
	      animation._prevTime = time - 0.0000001
	      if(animation instanceof CAAnimationGroup){
	        animation.animations.forEach((anim) => {
	          this._setAnimationStartTime(anim, time)
	        })
	      }
	    }
	    */

	    /**
	     * Required. Returns the animation with the specified key.
	     * @access public
	     * @param {string} key - A string identifying a previously added animation.
	     * @returns {?CAAnimation} - 
	     * @desc Attempting to modify any properties of the returned object results in undefined behavior.
	     * @see https://developer.apple.com/reference/scenekit/scnanimatable/1524020-animation
	     */

	  }, {
	    key: 'animationForKey',
	    value: function animationForKey(key) {
	      return this._animations.get(key);
	    }

	    /**
	     * Required. Removes all the animations currently attached to the object.
	     * @access public
	     * @returns {void}
	     * @see https://developer.apple.com/reference/scenekit/scnanimatable/1522762-removeallanimations
	     */

	  }, {
	    key: 'removeAllAnimations',
	    value: function removeAllAnimations() {
	      this._animations.clear();
	    }

	    /**
	     * Required. Removes the animation attached to the object with the specified key.
	     * @access public
	     * @param {string} key - A string identifying an attached animation to remove.
	     * @returns {void}
	     * @see https://developer.apple.com/reference/scenekit/scnanimatable/1522880-removeanimation
	     */

	  }, {
	    key: 'removeAnimationForKey',
	    value: function removeAnimationForKey(key) {
	      this._animations.delete(key);
	    }

	    /**
	     * Required. Removes the animation attached to the object with the specified key, smoothly transitioning out of the animation’s effect.
	     * @access public
	     * @param {string} key - A string identifying an attached animation to remove.
	     * @param {number} duration - The duration for transitioning out of the animation’s effect before it is removed.
	     * @returns {void}
	     * @desc Use this method to create smooth transitions between the effects of multiple animations. For example, the geometry loaded from a scene file for a game character may have associated animations for player actions such as walking and jumping. When the player lands from a jump, you remove the jump animation so the character continues walking. If you use the removeAnimation(forKey:) method to remove the jump animation, SceneKit abruptly switches from the current frame of the jump animation to the current frame of the walk animation. If you use the removeAnimation(forKey:fadeOutDuration:) method instead, SceneKit plays both animations at once during that duration and interpolates vertex positions from one animation to the other, creating a smooth transition.
	     * @see https://developer.apple.com/reference/scenekit/scnanimatable/1522841-removeanimation
	     */

	  }, {
	    key: 'removeAnimationForKeyFadeOutDuration',
	    value: function removeAnimationForKeyFadeOutDuration(key, duration) {}

	    /**
	     * Required. An array containing the keys of all animations currently attached to the object.
	     * @type {string[]}
	     * @desc This array contains all keys for which animations are attached to the object, or is empty if there are no attached animations. The ordering of animation keys in the array is arbitrary.
	     * @see https://developer.apple.com/reference/scenekit/scnanimatable/1523610-animationkeys
	     */

	  }, {
	    key: 'pauseAnimationForKey',


	    // Pausing and Resuming Animations

	    /**
	     * Required. Pauses the animation attached to the object with the specified key.
	     * @access public
	     * @param {string} key - A string identifying an attached animation.
	     * @returns {void}
	     * @desc This method has no effect if no animation is attached to the object with the specified key.
	     * @see https://developer.apple.com/reference/scenekit/scnanimatable/1523592-pauseanimation
	     */
	    value: function pauseAnimationForKey(key) {}

	    /**
	     * Required. Resumes a previously paused animation attached to the object with the specified key.
	     * @access public
	     * @param {string} key - A string identifying an attached animation.
	     * @returns {void}
	     * @desc This method has no effect if no animation is attached to the object with the specified key or if the specified animation is not currently paused.
	     * @see https://developer.apple.com/reference/scenekit/scnanimatable/1523332-resumeanimation
	     */

	  }, {
	    key: 'resumeAnimationForKey',
	    value: function resumeAnimationForKey(key) {}

	    /**
	     * Required. Returns a Boolean value indicating whether the animation attached to the object with the specified key is paused.
	     * @access public
	     * @param {string} key - A string identifying an attached animation.
	     * @returns {boolean} - 
	     * @see https://developer.apple.com/reference/scenekit/scnanimatable/1523703-isanimationpaused
	     */

	  }, {
	    key: 'isAnimationPausedForKey',
	    value: function isAnimationPausedForKey(key) {
	      return false;
	    }

	    // Instance Methods

	    /**
	     * Required. 
	     * @access public
	     * @param {number} speed - 
	     * @param {string} key - 
	     * @returns {void}
	     * @see https://developer.apple.com/reference/scenekit/scnanimatable/1778343-setanimationspeed
	     */

	  }, {
	    key: 'setAnimationSpeedForKey',
	    value: function setAnimationSpeedForKey(speed, key) {}

	    ///////////////////////
	    // SCNBoundingVolume //
	    ///////////////////////

	    // Working with Bounding Volumes

	    /**
	     * The center point and radius of the object’s bounding sphere.
	     * @type {{center: SCNVector3, radius: number}}
	     * @desc Scene Kit defines a bounding sphere in the local coordinate space using a center point and a radius. For example, if a node’s bounding sphere has the center point {3, 1, 4} and radius 2.0, all points in the vertex data of node’s geometry (and any geometry attached to its child nodes) lie within 2.0 units of the center point.The coordinates provided when reading this property are valid only if the object has a volume to be measured. For a geometry containing no vertex data or a node containing no geometry (and whose child nodes, if any, contain no geometry), the values center and radius are both zero.
	     * @see https://developer.apple.com/reference/scenekit/scnboundingvolume/2034707-boundingsphere
	     */

	  }, {
	    key: '_updateTransform',
	    value: function _updateTransform() {
	      var m1 = _SCNMatrix2.default.matrixWithScale(this._scale);
	      var m2 = m1.rotation(this._rotation);
	      var m3 = m2.translation(this._position);
	      this._transform = m3;
	      this._transformUpToDate = true;
	    }

	    /**
	     *
	     * @access public
	     * @returns {SCNNode} -
	     */

	  }, {
	    key: 'copy',
	    value: function copy() {
	      var node = new SCNNode();
	      node.name = this.name;
	      node.light = this.light;
	      node.camera = this.camera;
	      node.geometry = this.geometry;
	      node.morpher = this.morpher;
	      node.skinner = this.skinner;
	      node.categoryBitMask = this.categoryBitMask;
	      node.isPaused = this.isPaused;
	      node._presentation = this._presentation ? this._presentation.copy() : null;
	      node._isPresentationInstance = this._isPresentationInstance;
	      node.constraints = this.constraints ? this.constraints.slice() : null;
	      node.isHidden = this.isHidden;
	      node.opacity = this.opacity;
	      node.renderingOrder = this.renderingOrder;
	      node.castsShadow = this.castsShadow;
	      node.movabilityHint = this.movabilityHint;
	      node.filters = this.filters ? this.filters.slice() : null;
	      node.rendererDelegate = this.rendererDelegate;
	      node.physicsBody = this.physicsBody;
	      node.physicsField = this.physicsField;
	      node._particleSystems = this._particleSystems ? this._particleSystems.slice() : null;
	      node._audioPlayers = this._audioPlayers;
	      node._hasActions = this._hasActions;
	      node._actions = new Map(this._actions);
	      node._animations = new Map(this._animations);
	      node.boundingBox = this.boundingBox;
	      //node._boundingSphere = this._boundingSphere

	      node._position = new _SCNVector2.default(this._position.x, this._position.y, this._position.z);
	      node._rotation = new _SCNVector4.default(this._rotation.x, this._rotation.y, this._rotation.z, this._rotation.w);
	      node._scale = new _SCNVector2.default(this._scale.x, this._scale.y, this._scale.z);
	      node._transformUpToDate = false;

	      return node;
	    }
	  }, {
	    key: 'setValueForKey',
	    value: function setValueForKey(value, key) {
	      if (key === 'position') {
	        this.position = value;
	      } else if (key === 'rotation') {
	        this.rotation = value;
	      } else if (key === 'scale') {
	        this.scale = value;
	      } else if (key === 'eulerAngles') {
	        this.eulerAngles = value;
	      } else if (key === 'orientation') {
	        this.orientation = value;
	      } else if (key === 'transform') {
	        this.transform = value;
	      } else {
	        _get(SCNNode.prototype.__proto__ || Object.getPrototypeOf(SCNNode.prototype), 'setValueForKey', this).call(this, value, key);
	      }
	    }
	  }, {
	    key: 'setValueForKeyPath',
	    value: function setValueForKeyPath(value, keyPath) {
	      // FIXME: check flags to decide to use a presentation node
	      var target = this._presentation ? this._presentation : this;

	      var paths = keyPath.split('.');
	      var key = paths.shift();
	      var restPath = paths.join('.');
	      //console.log(`SCNNode setValueForKeyPath ${this.name} ${key} ${restPath}`)
	      if (key === 'transform') {
	        switch (restPath) {
	          case 'rotation.x':
	            target._rotation.x = value;
	            target._transformUpToDate = false;
	            return;
	          case 'rotation.y':
	            target._rotation.y = value;
	            target._transformUpToDate = false;
	            return;
	          case 'rotation.z':
	            target._rotation.z = value;
	            target._transformUpToDate = false;
	            return;
	          case 'rotation':
	            target._rotation.z = value;
	            target._transformUpToDate = false;
	            return;
	          case 'quaternion':
	            target.orientation = value;
	            target._transformUpToDate = false;
	            return;
	          case 'scale.x':
	            target._scale.x = value;
	            target._transformUpToDate = false;
	            return;
	          case 'scale.y':
	            target._scale.y = value;
	            target._transformUpToDate = false;
	            return;
	          case 'scale.z':
	            target._scale.z = value;
	            target._transformUpToDate = false;
	            return;
	          case 'scale':
	            {
	              var rate = value / target._scale.length();
	              target._scale.mul(rate);
	              target._transformUpToDate = false;
	              return;
	            }
	          case 'translation.x':
	            target._position.x = value;
	            target._transformUpToDate = false;
	            return;
	          case 'translation.y':
	            target._position.y = value;
	            target._transformUpToDate = false;
	            return;
	          case 'translation.z':
	            target._position.z = value;
	            target._transformUpToDate = false;
	            return;
	          case 'translation':
	            target._position.x = value.x;
	            target._position.y = value.y;
	            target._transformUpToDate = false;
	            return;
	          default:
	          // do nothing
	        }
	      } else if (key === 'morpher') {
	        if (target.morpher === null) {
	          throw new Error('target morpher === null');
	        }
	        target.morpher.setValueForKeyPath(value, restPath);
	        return;
	      }
	      // TODO: add other properties

	      _get(SCNNode.prototype.__proto__ || Object.getPrototypeOf(SCNNode.prototype), 'setValueForKeyPath', this).call(this, value, keyPath);
	    }
	  }, {
	    key: 'presentation',


	    // Working With Node Animation

	    /**
	     * A node object representing the state of the node as it currently appears onscreen.
	     * @type {SCNNode}
	     * @desc When you use implicit animation (see SCNTransaction) to change a node’s properties, those node properties are set immediately to their target values, even though the animated node content appears to transition from the old property values to the new. During the animation SceneKit maintains a copy of the node, called the presentation node, whose properties reflect the transitory values determined by any in-flight animations currently affecting the node. The presentation node’s properties provide a close approximation to the version of the node that is currently displayed. SceneKit also uses the presentation node when computing the results of explicit animations, physics, and constraints.Do not modify the properties of the presentation node. (Attempting to do so results in undefined behavior.) Instead, you use the presentation node to read current animation values—for example, to create a new animation starting at those values. The presentation node has no parent or child nodes. To access animated properties of related nodes, use the node’s own parent and childNodes properties and the presentation property of each related node.
	     * @see https://developer.apple.com/reference/scenekit/scnnode/1408030-presentation
	     */
	    get: function get() {
	      if (this._presentation === null) {
	        return null;
	      }

	      return this._presentation;
	    }

	    // Managing the Node’s Transformation

	    /**
	     * The transformation applied to the node relative to its parent. Animatable.
	     * @type {SCNMatrix4}
	     * @see https://developer.apple.com/reference/scenekit/scnnode/1407964-transform
	     */

	  }, {
	    key: 'transform',
	    get: function get() {
	      // FIXME: it should return the copy of _transform,
	      //        but you should be able to change value with this statement:
	      //          let node = new SCNNode()
	      //          node.transform.m14 = 123
	      //          console.log(node.transform.m14)   // '123'
	      if (!this._transformUpToDate) {
	        this._updateTransform();
	      }
	      return this._transform;
	    },
	    set: function set(newValue) {
	      this._transform = newValue;
	      // TODO: update position, rotation, scale
	      this._transformUpToDate = true;
	    }

	    /**
	     * The world transform applied to the node.
	     * @type {SCNMatrix4}
	     * @desc A world transform is the node’s coordinate space transformation relative to the scene’s coordinate space. This transformation is the concatenation of the node’s transform property with that of its parent node, the parent’s parent, and so on up to the rootNode object of the scene.
	     * @see https://developer.apple.com/reference/scenekit/scnnode/1407970-worldtransform
	     */

	  }, {
	    key: 'worldTransform',
	    get: function get() {
	      /*
	      if(this._parent === null){
	        if(this._isPresentationInstance){
	          return this._worldTransform
	        }
	        return this.transform
	      }
	      return this.transform.mult(this._parent.worldTransform)
	      */
	      return this._worldTransform;
	    }
	  }, {
	    key: 'position',
	    get: function get() {
	      return this._position;
	    },
	    set: function set(newValue) {
	      if (typeof newValue.x !== 'number' || typeof newValue.y !== 'number' || typeof newValue.z !== 'number') {
	        throw new Error('error: SCNNode.position must have x, y, z values');
	      }
	      this._position.x = newValue.x;
	      this._position.y = newValue.y;
	      this._position.z = newValue.z;
	      this._transformUpToDate = false;
	      this._updateWorldTransform();
	    }
	  }, {
	    key: 'rotation',
	    get: function get() {
	      return this._rotation;
	    },
	    set: function set(newValue) {
	      if (typeof newValue.x !== 'number' || typeof newValue.y !== 'number' || typeof newValue.z !== 'number' || typeof newValue.w !== 'number') {
	        throw new Error('error: SCNNode.rotation must have x, y, z, w values');
	      }
	      this._rotation.x = newValue.x;
	      this._rotation.y = newValue.y;
	      this._rotation.z = newValue.z;
	      this._rotation.w = newValue.w;
	      this._transformUpToDate = false;
	      this._updateWorldTransform();
	    }
	  }, {
	    key: 'scale',
	    get: function get() {
	      return this._scale;
	    },
	    set: function set(newValue) {
	      if (typeof newValue.x !== 'number' || typeof newValue.y !== 'number' || typeof newValue.z !== 'number') {
	        throw new Error('error: SCNNode.scale must have x, y, z values');
	      }
	      this._scale.x = newValue.x;
	      this._scale.y = newValue.y;
	      this._scale.z = newValue.z;
	      this._transformUpToDate = false;
	      this._updateWorldTransform();
	    }

	    /**
	     * The node’s orientation, expressed as pitch, yaw, and roll angles, each in radians. Animatable.
	     * @type {SCNVector3}
	     * @see https://developer.apple.com/reference/scenekit/scnnode/1407980-eulerangles
	     */

	  }, {
	    key: 'eulerAngles',
	    get: function get() {
	      var rot = this._rotation;
	      var euler = new _SCNVector2.default();
	      var sinW = Math.sin(rot.w);
	      var cosWR = 1.0 - Math.cos(rot.w);
	      var len2 = rot.x * rot.x + rot.y * rot.y + rot.z * rot.z;
	      if (len2 === 0) {
	        return euler;
	      }
	      var r = 1.0 / Math.sqrt(len2);
	      var x = rot.x * r;
	      var y = rot.y * r;
	      var z = rot.z * r;
	      var s = y * sinW - x * z * cosWR;

	      if (s > 0.998) {
	        // TODO: check SceneKit implementation
	        euler.x = 0;
	        euler.y = -Math.PI * 0.5;
	        euler.z = -2.0 * Math.atan2(z * Math.sin(rot.w * 0.5), Math.cos(rot.w * 0.5));
	      } else if (s < -0.998) {
	        // TODO: check SceneKit implementation
	        euler.x = 0;
	        euler.y = Math.PI * 0.5;
	        euler.z = 2.0 * Math.atan2(z * Math.sin(rot.w * 0.5), Math.cos(rot.w * 0.5));
	      } else {
	        euler.x = Math.atan2(x * sinW + y * z * cosWR, 1 - (y * y + x * x) * cosWR);
	        euler.y = Math.asin(s);
	        euler.z = Math.atan2(z * sinW + x * y * cosWR, 1 - (z * z + y * y) * cosWR);
	      }

	      return euler;
	    },
	    set: function set(newValue) {
	      var halfX = newValue.x * 0.5;
	      var halfY = newValue.y * 0.5;
	      var halfZ = newValue.z * 0.5;
	      var cosX = Math.cos(halfX);
	      var sinX = Math.sin(halfX);
	      var cosY = Math.cos(halfY);
	      var sinY = Math.sin(halfY);
	      var cosZ = Math.cos(halfZ);
	      var sinZ = Math.sin(halfZ);

	      var q = new _SCNVector4.default();
	      var x = sinX * cosY * cosZ - cosX * sinY * sinZ;
	      var y = cosX * sinY * cosZ + sinX * cosY * sinZ;
	      var z = cosX * cosY * sinZ - sinX * sinY * cosZ;
	      var r = 1.0 / Math.sqrt(x * x + y * y + z * z);
	      q.x = x * r;
	      q.y = y * r;
	      q.z = z * r;
	      q.w = 2 * Math.acos(cosX * cosY * cosZ + sinX * sinY * sinZ);

	      this._rotation = q;
	      this._transformUpToDate = false;
	    }

	    /**
	     * The node’s orientation, expressed as a quaternion. Animatable.
	     * @type {SCNQuaternion}
	     * @see https://developer.apple.com/reference/scenekit/scnnode/1408048-orientation
	     */

	  }, {
	    key: 'orientation',
	    get: function get() {
	      /*
	      const quat = new SCNVector4()
	      const rot = this._rotation
	       if(rot.x === 0 && rot.y === 0 && rot.z === 0){
	        quat.x = 0
	        quat.y = 0
	        quat.z = 0
	        quat.w = 1.0
	      }else{
	        const r = 1.0 / Math.sqrt(rot.x * rot.x + rot.y * rot.y + rot.z * rot.z)
	        const cosW = Math.cos(rot.w)
	        const sinW = Math.sin(rot.w)
	        quat.x = rot.x * sinW
	        quat.y = rot.y * sinW
	        quat.z = rot.z * sinW
	        quat.w = cosW
	      }
	      return quat
	      */
	      //console.log(`SCNNode get orientation: ${this._rotation.rotationToQuat()}`)
	      return this._rotation.rotationToQuat();
	    },
	    set: function set(newValue) {
	      /*
	      const rot = new SCNVector4()
	       if(newValue.x === 0 && newValue.y === 0 && newValue.z === 0){
	        rot.x = 0
	        rot.y = 0
	        rot.z = 0
	        rot.w = 0
	      }else{
	        rot.x = newValue.x
	        rot.y = newValue.y
	        rot.z = newValue.z
	        let quatW = newValue.w
	        if(quatW > 1){
	          quatW = 1.0
	        }else if(quatW < -1){
	          quatW = -1.0
	        }
	        const w = Math.acos(quatW)
	         if(isNaN(w)){
	          rot.w = 0
	        }else{
	          rot.w = w
	        }
	      }
	          
	      this._rotation = rot
	      */
	      if (!(newValue instanceof _SCNVector4.default)) {
	        throw new Error('orientation must be SCNVector4');
	      }

	      this._rotation = newValue.quatToRotation();
	      //console.log(`SCNNode set orientation: ${this._rotation.float32Array()}`)
	      this._transformUpToDate = false;
	    }
	  }, {
	    key: 'parent',
	    get: function get() {
	      return this._parent;
	    }
	    /**
	     * An array of the node’s children in the scene graph hierarchy.
	     * @type {SCNNode[]}
	     * @see https://developer.apple.com/reference/scenekit/scnnode/1407984-childnodes
	     */

	  }, {
	    key: 'childNodes',
	    get: function get() {
	      return this._childNodes.slice(0);
	    }
	  }, {
	    key: 'particleSystems',
	    get: function get() {
	      return this._particleSystems;
	    }
	  }, {
	    key: 'audioPlayers',
	    get: function get() {
	      return this._audioPlayers;
	    }
	  }, {
	    key: 'hasActions',
	    get: function get() {
	      return this._hasActions;
	    }

	    /**
	     * Required. The list of keys for which the node has attached actions.
	     * @type {string[]}
	     * @desc Use this property to list actions you scheduled using the runAction(_:forKey:) or runAction(_:forKey:completionHandler:) method.
	     * @see https://developer.apple.com/reference/scenekit/scnactionable/1523036-actionkeys
	     */

	  }, {
	    key: 'actionKeys',
	    get: function get() {
	      var keys = [];
	      var _iteratorNormalCompletion = true;
	      var _didIteratorError = false;
	      var _iteratorError = undefined;

	      try {
	        for (var _iterator = this._actions.keys()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	          var key = _step.value;

	          keys.push(key);
	        }
	      } catch (err) {
	        _didIteratorError = true;
	        _iteratorError = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion && _iterator.return) {
	            _iterator.return();
	          }
	        } finally {
	          if (_didIteratorError) {
	            throw _iteratorError;
	          }
	        }
	      }

	      return keys;
	    }
	  }, {
	    key: 'animationKeys',
	    get: function get() {
	      var keys = [];
	      var _iteratorNormalCompletion2 = true;
	      var _didIteratorError2 = false;
	      var _iteratorError2 = undefined;

	      try {
	        for (var _iterator2 = this._animations.keys()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
	          var key = _step2.value;

	          keys.push(key);
	        }
	      } catch (err) {
	        _didIteratorError2 = true;
	        _iteratorError2 = err;
	      } finally {
	        try {
	          if (!_iteratorNormalCompletion2 && _iterator2.return) {
	            _iterator2.return();
	          }
	        } finally {
	          if (_didIteratorError2) {
	            throw _iteratorError2;
	          }
	        }
	      }

	      return keys;
	    }
	  }, {
	    key: 'boundingSphere',
	    get: function get() {
	      // TODO: calculate bounding sphere
	      return { center: new _SCNVector2.default(), radius: 0 };
	    }
	  }, {
	    key: 'viewTransform',
	    get: function get() {
	      return this.worldTransform.invert();
	    }
	  }, {
	    key: 'viewProjectionTransform',
	    get: function get() {
	      if (this.camera === null) {
	        return null;
	      }
	      var proj = this.camera.projectionTransform;
	      var view = this.viewTransform;
	      //return proj.mult(view)
	      return view.mult(proj);
	    }
	  }], [{
	    key: 'node',
	    value: function node() {
	      return new SCNNode();
	    }

	    /**
	     * Constructor for JSExport compatibility
	     * @access public
	     * @param {?SCNGeometry} [geometry] - The geometry to be attached.
	     * @returns {SCNNode} -
	     */

	  }, {
	    key: 'nodeWithGeometry',
	    value: function nodeWithGeometry(geometry) {
	      return new SCNNode(geometry);
	    }
	  }]);

	  return SCNNode;
	}(_NSObject3.default);

	exports.default = SCNNode;

/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _SCNAction = __webpack_require__(31);

	var _SCNAction2 = _interopRequireDefault(_SCNAction);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	/**
	 * Methods for running actions on nodes.
	 * @interface
	 * @see https://developer.apple.com/reference/scenekit/scnactionable
	 */
	var SCNActionable = function () {
	  function SCNActionable() {
	    _classCallCheck(this, SCNActionable);
	  }

	  _createClass(SCNActionable, [{
	    key: 'init',


	    /**
	     * constructor
	     * @access public
	     * @returns {void}
	     */
	    value: function init() {

	      // Inspecting a Node’s Running Actions

	      this._hasActions = false;
	      this._actionKeys = null;
	    }

	    // Running Actions

	    /**
	     * Required. Adds an action to the list of actions executed by the node.
	     * @access public
	     * @param {SCNAction} action - The action to be performed.
	     * @returns {void}
	     * @desc SceneKit begins running a newly added action when it prepares to render the next frame.
	     * @see https://developer.apple.com/reference/scenekit/scnactionable/1523164-runaction
	     */

	  }, {
	    key: 'runAction',
	    value: function runAction(action) {}

	    /**
	     * Required. Adds an action to the list of actions executed by the node. SceneKit calls the specified block when the action completes.
	     * @access public
	     * @param {SCNAction} action - The action to be performed.
	     * @param {?function(): void} [block = null] - A completion block that SceneKit calls when the action completes.
	     * @returns {void}
	     * @desc The new action is processed the next time SceneKit prepares to render a frame.SceneKit calls your block after the action’s duration is complete. For example, in a game you could use this method to show a Game Over message after performing a fade-out action on a node that displays a player character.
	     * @see https://developer.apple.com/reference/scenekit/scnactionable/1524219-runaction
	     */

	  }, {
	    key: 'runActionCompletionHandler',
	    value: function runActionCompletionHandler(action) {
	      var block = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
	    }

	    /**
	     * Required. Adds an identifiable action to the list of actions executed by the node.
	     * @access public
	     * @param {SCNAction} action - The action to be performed.
	     * @param {?string} key - A unique key used to identify the action.
	     * @returns {void}
	     * @desc This method is identical to runAction(_:), but the action is stored and identified so that you can retrieve or cancel it later. If an action using the same key is already running, SceneKit removes it before adding the new action.
	     * @see https://developer.apple.com/reference/scenekit/scnactionable/1524222-runaction
	     */

	  }, {
	    key: 'runActionForKey',
	    value: function runActionForKey(action, key) {}

	    /**
	     * Required. Adds an identifiable action to the list of actions executed by the node. SceneKit calls the specified block when the action completes.
	     * @access public
	     * @param {SCNAction} action - The action to be performed.
	     * @param {?string} key - A unique key used to identify the action.
	     * @param {?function(): void} [block = null] - A completion block called when the action completes.
	     * @returns {void}
	     * @desc This method is identical to runAction(_:completionHandler:), but the action is stored and identified so that you can retrieve or cancel it later. If an action using the same key is already running, SceneKit removes it before adding the new action.SceneKit calls your block after the action’s duration is complete. For example, you can use this method with a wait action to execute some code after a timed delay. If during the delay period you need to prevent the code from running, use the removeAction(forKey:) method to cancel it.
	     * @see https://developer.apple.com/reference/scenekit/scnactionable/1522791-runaction
	     */

	  }, {
	    key: 'runActionForKeyCompletionHandler',
	    value: function runActionForKeyCompletionHandler(action, key) {
	      var block = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
	    }

	    // Inspecting a Node’s Running Actions

	    /**
	     * Required. Returns an action associated with a specific key.
	     * @access public
	     * @param {string} key - A string that uniquely identifies a action.
	     * @returns {?SCNAction} - 
	     * @desc Use this method to retrieve actions you scheduled using the runAction(_:forKey:) or runAction(_:forKey:completionHandler:) method.
	     * @see https://developer.apple.com/reference/scenekit/scnactionable/1523287-action
	     */

	  }, {
	    key: 'actionForKey',
	    value: function actionForKey(key) {
	      return null;
	    }
	    /**
	     * Required. A Boolean value that indicates whether the node is currently executing any actions.
	     * @type {boolean}
	     * @desc This value is true if the node has any executing actions; otherwise the value is false.
	     * @see https://developer.apple.com/reference/scenekit/scnactionable/1523794-hasactions
	     */

	  }, {
	    key: 'removeActionForKey',


	    // Canceling a Node’s Running Actions

	    /**
	     * Required. Removes an action associated with a specific key.
	     * @access public
	     * @param {string} key - A string that uniquely identifies a action.
	     * @returns {void}
	     * @desc If the node is currently running an action that matches the key, SceneKit removes that action from the node, skipping any remaining animation it would perform but keeping any changes already made to the node.Use this method to cancel actions you scheduled using the runAction(_:forKey:) or runAction(_:forKey:completionHandler:) method.
	     * @see https://developer.apple.com/reference/scenekit/scnactionable/1523617-removeaction
	     */
	    value: function removeActionForKey(key) {}

	    /**
	     * Required. Ends and removes all actions from the node.
	     * @access public
	     * @returns {void}
	     * @desc When SceneKit removes an action from a node, it skips any remaining animation the action would perform. However, any changes the action has already made to the node’s state remain in effect.
	     * @see https://developer.apple.com/reference/scenekit/scnactionable/1524181-removeallactions
	     */

	  }, {
	    key: 'removeAllActions',
	    value: function removeAllActions() {}
	  }, {
	    key: 'hasActions',
	    get: function get() {
	      return this._hasActions;
	    }
	    /**
	     * Required. The list of keys for which the node has attached actions.
	     * @type {string[]}
	     * @desc Use this property to list actions you scheduled using the runAction(_:forKey:) or runAction(_:forKey:completionHandler:) method.
	     * @see https://developer.apple.com/reference/scenekit/scnactionable/1523036-actionkeys
	     */

	  }, {
	    key: 'actionKeys',
	    get: function get() {
	      return this._actionKeys;
	    }
	  }]);

	  return SCNActionable;
	}();

	exports.default = SCNActionable;

/***/ },
/* 35 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _CAAnimation = __webpack_require__(19);

	var _CAAnimation2 = _interopRequireDefault(_CAAnimation);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	/**
	 * The common interface for attaching animations to nodes, geometries, materials, and other SceneKit objects.
	 * @interface
	 * @see https://developer.apple.com/reference/scenekit/scnanimatable
	 */
	var SCNAnimatable = function () {
	  function SCNAnimatable() {
	    _classCallCheck(this, SCNAnimatable);
	  }

	  _createClass(SCNAnimatable, [{
	    key: 'init',


	    /**
	     * constructor
	     * @access public
	     * @returns {void}
	     */
	    value: function init() {

	      // Managing Animations

	      this._animationKeys = null;
	    }

	    // Managing Animations

	    /**
	     * Required. Adds an animation object for the specified key.
	     * @access public
	     * @param {CAAnimation} animation - The animation object to be added.
	     * @param {?string} key - An string identifying the animation for later retrieval. You may pass nil if you don’t need to reference the animation later.
	     * @returns {void}
	     * @desc Newly added animations begin executing after the current run loop cycle ends.SceneKit does not define any requirements for the contents of the key parameter—it need only be unique among the keys for other animations you add. If you add an animation with an existing key, this method overwrites the existing animation.
	     * @see https://developer.apple.com/reference/scenekit/scnanimatable/1523386-addanimation
	     */

	  }, {
	    key: 'addAnimationForKey',
	    value: function addAnimationForKey(animation, key) {}

	    /**
	     * Required. Returns the animation with the specified key.
	     * @access public
	     * @param {string} key - A string identifying a previously added animation.
	     * @returns {?CAAnimation} - 
	     * @desc Attempting to modify any properties of the returned object results in undefined behavior.
	     * @see https://developer.apple.com/reference/scenekit/scnanimatable/1524020-animation
	     */

	  }, {
	    key: 'animationForKey',
	    value: function animationForKey(key) {
	      return null;
	    }

	    /**
	     * Required. Removes all the animations currently attached to the object.
	     * @access public
	     * @returns {void}
	     * @see https://developer.apple.com/reference/scenekit/scnanimatable/1522762-removeallanimations
	     */

	  }, {
	    key: 'removeAllAnimations',
	    value: function removeAllAnimations() {}

	    /**
	     * Required. Removes the animation attached to the object with the specified key.
	     * @access public
	     * @param {string} key - A string identifying an attached animation to remove.
	     * @returns {void}
	     * @see https://developer.apple.com/reference/scenekit/scnanimatable/1522880-removeanimation
	     */

	  }, {
	    key: 'removeAnimationForKey',
	    value: function removeAnimationForKey(key) {}

	    /**
	     * Required. Removes the animation attached to the object with the specified key, smoothly transitioning out of the animation’s effect.
	     * @access public
	     * @param {string} key - A string identifying an attached animation to remove.
	     * @param {number} duration - The duration for transitioning out of the animation’s effect before it is removed.
	     * @returns {void}
	     * @desc Use this method to create smooth transitions between the effects of multiple animations. For example, the geometry loaded from a scene file for a game character may have associated animations for player actions such as walking and jumping. When the player lands from a jump, you remove the jump animation so the character continues walking. If you use the removeAnimation(forKey:) method to remove the jump animation, SceneKit abruptly switches from the current frame of the jump animation to the current frame of the walk animation. If you use the removeAnimation(forKey:fadeOutDuration:) method instead, SceneKit plays both animations at once during that duration and interpolates vertex positions from one animation to the other, creating a smooth transition.
	     * @see https://developer.apple.com/reference/scenekit/scnanimatable/1522841-removeanimation
	     */

	  }, {
	    key: 'removeAnimationForKeyFadeOutDuration',
	    value: function removeAnimationForKeyFadeOutDuration(key, duration) {}
	    /**
	     * Required. An array containing the keys of all animations currently attached to the object.
	     * @type {string[]}
	     * @desc This array contains all keys for which animations are attached to the object, or is empty if there are no attached animations. The ordering of animation keys in the array is arbitrary.
	     * @see https://developer.apple.com/reference/scenekit/scnanimatable/1523610-animationkeys
	     */

	  }, {
	    key: 'pauseAnimationForKey',


	    // Pausing and Resuming Animations

	    /**
	     * Required. Pauses the animation attached to the object with the specified key.
	     * @access public
	     * @param {string} key - A string identifying an attached animation.
	     * @returns {void}
	     * @desc This method has no effect if no animation is attached to the object with the specified key.
	     * @see https://developer.apple.com/reference/scenekit/scnanimatable/1523592-pauseanimation
	     */
	    value: function pauseAnimationForKey(key) {}

	    /**
	     * Required. Resumes a previously paused animation attached to the object with the specified key.
	     * @access public
	     * @param {string} key - A string identifying an attached animation.
	     * @returns {void}
	     * @desc This method has no effect if no animation is attached to the object with the specified key or if the specified animation is not currently paused.
	     * @see https://developer.apple.com/reference/scenekit/scnanimatable/1523332-resumeanimation
	     */

	  }, {
	    key: 'resumeAnimationForKey',
	    value: function resumeAnimationForKey(key) {}

	    /**
	     * Required. Returns a Boolean value indicating whether the animation attached to the object with the specified key is paused.
	     * @access public
	     * @param {string} key - A string identifying an attached animation.
	     * @returns {boolean} - 
	     * @see https://developer.apple.com/reference/scenekit/scnanimatable/1523703-isanimationpaused
	     */

	  }, {
	    key: 'isAnimationPausedForKey',
	    value: function isAnimationPausedForKey(key) {
	      return false;
	    }

	    // Instance Methods

	    /**
	     * Required. 
	     * @access public
	     * @param {number} speed - 
	     * @param {string} key - 
	     * @returns {void}
	     * @see https://developer.apple.com/reference/scenekit/scnanimatable/1778343-setanimationspeed
	     */

	  }, {
	    key: 'setAnimationSpeedForKey',
	    value: function setAnimationSpeedForKey(speed, key) {}
	  }, {
	    key: 'animationKeys',
	    get: function get() {
	      return this._animationKeys;
	    }
	  }]);

	  return SCNAnimatable;
	}();

	exports.default = SCNAnimatable;

/***/ },
/* 36 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _SCNVector = __webpack_require__(15);

	var _SCNVector2 = _interopRequireDefault(_SCNVector);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	/**
	 * Properties for measuring an object's location and size, expressed as either a box or a sphere.
	 * @interface
	 * @see https://developer.apple.com/reference/scenekit/scnboundingvolume
	 */
	var SCNBoundingVolume = function () {
	  function SCNBoundingVolume() {
	    _classCallCheck(this, SCNBoundingVolume);
	  }

	  _createClass(SCNBoundingVolume, [{
	    key: 'init',


	    /**
	     * constructor
	     * @access public
	     * @returns {void}
	     */
	    value: function init() {

	      // Working with Bounding Volumes

	      /**
	       * The minimum and maximum corner points of the object’s bounding box.
	       * @type {{min: SCNVector3, max: SCNVector3}}
	       * @see https://developer.apple.com/reference/scenekit/scnboundingvolume/2034705-boundingbox
	       */
	      this.boundingBox = null;

	      this._boundingSphere = null;
	    }

	    // Working with Bounding Volumes
	    /**
	     * The center point and radius of the object’s bounding sphere.
	     * @type {{center: SCNVector3, radius: number}}
	     * @desc Scene Kit defines a bounding sphere in the local coordinate space using a center point and a radius. For example, if a node’s bounding sphere has the center point {3, 1, 4} and radius 2.0, all points in the vertex data of node’s geometry (and any geometry attached to its child nodes) lie within 2.0 units of the center point.The coordinates provided when reading this property are valid only if the object has a volume to be measured. For a geometry containing no vertex data or a node containing no geometry (and whose child nodes, if any, contain no geometry), the values center and radius are both zero.
	     * @see https://developer.apple.com/reference/scenekit/scnboundingvolume/2034707-boundingsphere
	     */

	  }, {
	    key: 'boundingSphere',
	    get: function get() {
	      return this._boundingSphere;
	    }
	  }]);

	  return SCNBoundingVolume;
	}();

	exports.default = SCNBoundingVolume;

/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _NSObject2 = __webpack_require__(13);

	var _NSObject3 = _interopRequireDefault(_NSObject2);

	var _SCNAnimatable = __webpack_require__(35);

	var _SCNAnimatable2 = _interopRequireDefault(_SCNAnimatable);

	var _SCNBoundingVolume = __webpack_require__(36);

	var _SCNBoundingVolume2 = _interopRequireDefault(_SCNBoundingVolume);

	var _SCNShadable = __webpack_require__(38);

	var _SCNShadable2 = _interopRequireDefault(_SCNShadable);

	var _SCNGeometrySource = __webpack_require__(83);

	var _SCNGeometrySource2 = _interopRequireDefault(_SCNGeometrySource);

	var _SCNGeometryElement = __webpack_require__(88);

	var _SCNGeometryElement2 = _interopRequireDefault(_SCNGeometryElement);

	var _SCNLevelOfDetail = __webpack_require__(90);

	var _SCNLevelOfDetail2 = _interopRequireDefault(_SCNLevelOfDetail);

	var _SCNMaterial = __webpack_require__(91);

	var _SCNMaterial2 = _interopRequireDefault(_SCNMaterial);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * A three-dimensional shape (also called a model or mesh) that can be displayed in a scene, with attached materials that define its appearance.
	 * @access public
	 * @extends {NSObject}
	 * @implements {SCNAnimatable}
	 * @implements {SCNBoundingVolume}
	 * @implements {SCNShadable}
	 * @see https://developer.apple.com/reference/scenekit/scngeometry
	 */
	var SCNGeometry = function (_NSObject) {
	  _inherits(SCNGeometry, _NSObject);

	  // Creating a Geometry Object

	  /**
	   * Creates a new geometry built from the specified geometry sources and elements.
	   * @access public
	   * @constructor
	   * @param {SCNGeometrySource[]} sources - An array of SCNGeometrySource objects describing vertices in the geometry and their attributes.
	   * @param {?SCNGeometryElement[]} elements - An array of SCNGeometryElement objects describing how to connect the geometry’s vertices.
	   * @desc A geometry's visible content comes from the combination of geometry sources, which contain data describing its vertices, with geometry elements, which contain data describing how the vertices connect to form a surface. Each SCNGeometrySource object describes an attribute of all vertices in the geometry (vertex position, surface normal vector, color, or texture mapping coordinates) identified by the source's semantic property. To create a custom geometry you must provide at least one source, for the vertex semantic. Typically, you also provide sources for normals and texture coordinates for use in lighting and shading.Sources for the vertex, normal, and color semantics must be unique-if multiple objects in the sources array have the same semantic, SceneKit uses only the first. A geometry may have multiple sources for the texcoord semantic-the order of texture coordinate sources in the sources array determines the value to use for the mappingChannel property when attaching materials.Each SCNGeometryElement object describes how vertices from the geometry sources are combined into polygons to create the geometry's shape. Creating a custom geometry requires at least one element. If the elements array contains multiple objects, their order determines the arrangement of the geometry's materials-for details, see the discussion of the materials property.
	   * @see https://developer.apple.com/reference/scenekit/scngeometry/1522803-init
	   */
	  function SCNGeometry() {
	    var sources = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
	    var elements = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

	    _classCallCheck(this, SCNGeometry);

	    var _this = _possibleConstructorReturn(this, (SCNGeometry.__proto__ || Object.getPrototypeOf(SCNGeometry)).call(this));

	    if (!Array.isArray(sources)) {
	      throw new Error('SCNGeometry(sources, elements): sources must be Array');
	    }
	    if (!Array.isArray(elements)) {
	      throw new Error('SCNGeometry(sources, elements): elements must be Array');
	    }

	    // Managing Geometry Attributes

	    /**
	     * A name associated with the geometry object.
	     * @type {?string}
	     * @see https://developer.apple.com/reference/scenekit/scngeometry/1522953-name
	     */
	    _this.name = null;

	    /**
	     * An array of SCNLevelOfDetail objects for managing the geometry’s appearance when viewed from far away.
	     * @type {?SCNLevelOfDetail[]}
	     * @see https://developer.apple.com/reference/scenekit/scngeometry/1523745-levelsofdetail
	     */
	    _this.levelsOfDetail = null;

	    // Managing a Geometry’s Materials

	    /**
	     * An array of SCNMaterial objects that determine the geometry’s appearance when rendered.
	     * @type {SCNMaterial[]}
	     * @see https://developer.apple.com/reference/scenekit/scngeometry/1523472-materials
	     */
	    _this.materials = [];

	    // Managing Geometry Data

	    _this._geometryElements = elements;
	    _this._geometrySources = sources;
	    _this._vertexArrayObjects = null;

	    // Working with Subdivision Surfaces

	    /**
	     * The number of subdivisions SceneKit uses to smooth the geometry’s surface at render time.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scngeometry/1524177-subdivisionlevel
	     */
	    _this.subdivisionLevel = 0;

	    /**
	     * The geometry element identifying which edges of the geometry’s surface should remain sharp after subdivision.
	     * @type {?SCNGeometryElement}
	     * @see https://developer.apple.com/reference/scenekit/scngeometry/1523246-edgecreaseselement
	     */
	    _this.edgeCreasesElement = null;

	    /**
	     * The geometry source specifying the smoothness or sharpness of edges after surface subdivision.
	     * @type {?SCNGeometrySource}
	     * @see https://developer.apple.com/reference/scenekit/scngeometry/1523479-edgecreasessource
	     */
	    _this.edgeCreasesSource = null;

	    /////////////////
	    // SCNShadable //
	    /////////////////

	    // Assigning a Custom Shader Program

	    /**
	     * A program used when rendering the object.
	     * @type {?SCNProgram}
	     * @see https://developer.apple.com/reference/scenekit/scnshadable/1523689-program
	     */
	    _this.program = null;

	    // Customizing SceneKit’s Shader Programs

	    /**
	     * A dictionary of GLSL source code snippets for customizing the shader programs provided by SceneKit.
	     * @type {?Map<SCNShaderModifierEntryPoint, string>}
	     * @see https://developer.apple.com/reference/scenekit/scnshadable/1523348-shadermodifiers
	     */
	    _this.shaderModifiers = null;

	    ///////////////////
	    // SCNAnimatable //
	    ///////////////////

	    // Managing Animations

	    //this._animationKeys = null

	    ///////////////////////
	    // SCNBoundingVolume //
	    ///////////////////////

	    // Working with Bounding Volumes

	    /**
	     * The minimum and maximum corner points of the object’s bounding box.
	     * @type {{min: SCNVector3, max: SCNVector3}}
	     * @see https://developer.apple.com/reference/scenekit/scnboundingvolume/2034705-boundingbox
	     */
	    _this.boundingBox = null;

	    /**
	     * The center point and radius of the object’s bounding sphere.
	     * @access private
	     * @type {Object}
	     * @parameter {SCNVector3} _boundingSphere.center
	     * @parameter {number} _boundingSphere.radius
	     */
	    _this._boundingSphere = null;

	    _this._vertexBuffer = null;
	    _this._indexBuffer = null;
	    return _this;
	  }

	  // Managing a Geometry’s Materials

	  /**
	   * The first material attached to the geometry.
	   * @type {?SCNMaterial}
	   * @see https://developer.apple.com/reference/scenekit/scngeometry/1523485-firstmaterial
	   */


	  _createClass(SCNGeometry, [{
	    key: 'materialNamed',


	    /**
	     * Returns the first material attached to the geometry with the specified name.
	     * @access public
	     * @param {string} name - The name of the material to be retrieved.
	     * @returns {?SCNMaterial} - 
	     * @desc You can use the name property of each SCNMaterial object to make managing your scene graph easier. Materials loaded from a scene file may have names assigned by an artist using a 3D authoring tool.If a geometry has multiple materials attached with the same name, this method returns the first according to the order of the materials array.
	     * @see https://developer.apple.com/reference/scenekit/scngeometry/1523789-material
	     */
	    value: function materialNamed(name) {
	      return null;
	    }

	    /**
	     * Attaches a material to the geometry at the specified index.
	     * @access public
	     * @param {SCNMaterial} material - The material to attach.
	     * @param {number} index - The location in the geometry’s materials array at which to add the new material.ImportantRaises an exception (rangeException) if index is greater than the number of elements in the materials array.
	     * @returns {void}
	     * @see https://developer.apple.com/reference/scenekit/scngeometry/1522876-insertmaterial
	     */

	  }, {
	    key: 'insertMaterialAt',
	    value: function insertMaterialAt(material, index) {}

	    /**
	     * Removes a material attached to the geometry.
	     * @access public
	     * @param {number} index - The index of the attached material to be removed.ImportantRaises an exception (rangeException) if index is beyond the bounds of the materials array.
	     * @returns {void}
	     * @see https://developer.apple.com/reference/scenekit/scngeometry/1522646-removematerial
	     */

	  }, {
	    key: 'removeMaterialAt',
	    value: function removeMaterialAt(index) {}

	    /**
	     * Replaces a material attached to the geometry with another.
	     * @access public
	     * @param {number} index - The index of the attached material to be replaced.ImportantRaises an exception (rangeException) if index is beyond the bounds of the materials array.
	     * @param {SCNMaterial} material - The material with which to replace the attached material.
	     * @returns {void}
	     * @see https://developer.apple.com/reference/scenekit/scngeometry/1522714-replacematerial
	     */

	  }, {
	    key: 'replaceMaterialAtIndexWith',
	    value: function replaceMaterialAtIndexWith(index, material) {}

	    // Managing Geometry Data

	    /**
	     * Returns the geometry element at a specified index.
	     * @access public
	     * @param {number} elementIndex - The index of the geometry element.
	     * @returns {SCNGeometryElement} - 
	     * @desc Each SCNGeometryElement object describes how vertices from the geometry’s sources are combined into polygons to create the geometry’s shape. Visible geometries contain at least one element.
	     * @see https://developer.apple.com/reference/scenekit/scngeometry/1523266-geometryelement
	     */

	  }, {
	    key: 'geometryElementAtIndex',
	    value: function geometryElementAtIndex(elementIndex) {
	      return this._geometryElements[elementIndex];
	    }

	    /**
	     * Returns the geometry sources for a specified semantic.
	     * @access public
	     * @param {SCNGeometrySource.Semantic} semantic - A constant identifying a semantic for which to return geometry sources. See Geometry Semantic Identifiers for possible values.
	     * @returns {SCNGeometrySource[]} - 
	     * @desc Each SCNGeometrySource object describes an attribute of all vertices in the geometry (such as vertex position, surface normal vector, color, or texture mapping coordinates) identified by the source’s semantic property. A geometry always has at least one source, for the vertex semantic, typically has additional sources for use in lighting and shading, and may have other sources for skeletal animation or surface subdivision information.The vertex, normal, and color semantics each refer to at most one source. A geometry may have multiple sources for the texcoord semantic—in this case, indices in the returned array correspond to values for the mappingChannel property used when attaching textures to materials.
	     * @see https://developer.apple.com/reference/scenekit/scngeometry/1522926-getgeometrysources
	     */

	  }, {
	    key: 'getGeometrySourcesForSemantic',
	    value: function getGeometrySourcesForSemantic(semantic) {
	      return this._geometrySources.filter(function (source) {
	        return source.semantic === semantic;
	      });
	    }

	    /**
	     * An array of geometry elements that describe the geometry’s shape.
	     * @type {SCNGeometryElement[]}
	     * @desc Each SCNGeometryElement object describes how vertices from the geometry’s sources are combined into polygons to create the geometry’s shape. Visible geometries contain at least one element.For geometries with multiple elements, you can use the materials property to attach different materials to each element.
	     * @see https://developer.apple.com/reference/scenekit/scngeometry/1523046-geometryelements
	     */

	  }, {
	    key: 'getBoundingSphere',


	    ///////////////////////
	    // SCNBoundingVolume //
	    ///////////////////////

	    // Working with Bounding Volumes

	    /**
	     * The center point and radius of the object’s bounding sphere.
	     * @type {Object}
	     * @parameter {SCNVector3} _boundingSphere.center -
	     * @parameter {number} _boundingSphere.radius -
	     * @returns {Object} -
	     * @desc Scene Kit defines a bounding sphere in the local coordinate space using a center point and a radius. For example, if a node’s bounding sphere has the center point {3, 1, 4} and radius 2.0, all points in the vertex data of node’s geometry (and any geometry attached to its child nodes) lie within 2.0 units of the center point.The coordinates provided when reading this property are valid only if the object has a volume to be measured. For a geometry containing no vertex data or a node containing no geometry (and whose child nodes, if any, contain no geometry), the values center and radius are both zero.
	     * @see https://developer.apple.com/reference/scenekit/scnboundingvolume/2034707-boundingsphere
	     */
	    value: function getBoundingSphere() {
	      return this._boundingSphere;
	    }

	    /////////////////
	    // SCNShadable //
	    /////////////////

	    // Handling Parameters in Custom OpenGL Shader Programs

	    /**
	     * Specifies a block to be called before rendering with programs with the specified GLSL uniform variable or attribute name.
	     * @access public
	     * @param {string} symbol - A GLSL uniform variable or attribute name.
	     * @param {?SCNBindingBlock} [block = null] - A block to be called by SceneKit.
	     * @returns {void}
	     * @desc Use this method to associate a block with a SceneKit object (geometry or material) to handle setup of an attribute or uniform variable in a custom SCNProgram shader associated with that object. SceneKit calls your block before rendering the object. In the block, you can execute any OpenGL commands or other code necessary for preparing your custom shader. For example, the following block updates the time uniform variable in a custom fragment shader for producing animated effects:CFTimeInterval startTime = CFAbsoluteTimeGetCurrent();
	    [myNode.geometry.firstMaterial handleBindingOfSymbol:@"time" usingBlock:
	      ^(unsigned int programID, unsigned int location, SCNNode *renderedNode, SCNRenderer *renderer) {
	          glUniform1f(location, CFAbsoluteTimeGetCurrent() - startTime);
	      }];
	    This method is for OpenGL shader programs only. To bind custom variable data for Metal shader programs, use the handleBinding(ofBufferNamed:frequency:handler:) method.CFTimeInterval startTime = CFAbsoluteTimeGetCurrent();
	    [myNode.geometry.firstMaterial handleBindingOfSymbol:@"time" usingBlock:
	      ^(unsigned int programID, unsigned int location, SCNNode *renderedNode, SCNRenderer *renderer) {
	          glUniform1f(location, CFAbsoluteTimeGetCurrent() - startTime);
	      }];
	      * @see https://developer.apple.com/reference/scenekit/scnshadable/1523063-handlebinding
	     */

	  }, {
	    key: 'handleBindingOfSymbolHandler',
	    value: function handleBindingOfSymbolHandler(symbol) {
	      var block = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
	    }

	    /**
	     * Specifies a block to be called after rendering with programs with the specified GLSL uniform variable or attribute name.
	     * @access public
	     * @param {string} symbol - A GLSL uniform variable or attribute name.
	     * @param {?SCNBindingBlock} [block = null] - A block to be called by SceneKit.
	     * @returns {void}
	     * @desc Use this method to associate a block with a SceneKit object (geometry or material) to handle cleanup related to an attribute or uniform variable in a custom SCNProgram shader associated with that object. SceneKit will call your block after rendering the object. In the block, you can execute any OpenGL commands or other code necessary for post-rendering tasks.This method is for OpenGL shader programs only. To bind custom variable data for Metal shader programs, use the handleBinding(ofBufferNamed:frequency:handler:) method.
	     * @see https://developer.apple.com/reference/scenekit/scnshadable/1522783-handleunbinding
	     */

	  }, {
	    key: 'handleUnbindingOfSymbolHandler',
	    value: function handleUnbindingOfSymbolHandler(symbol) {
	      var block = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
	    }

	    ///////////////////
	    // SCNAnimatable //
	    ///////////////////

	    // Managing Animations

	    /**
	     * Required. Adds an animation object for the specified key.
	     * @access public
	     * @param {CAAnimation} animation - The animation object to be added.
	     * @param {?string} key - An string identifying the animation for later retrieval. You may pass nil if you don’t need to reference the animation later.
	     * @returns {void}
	     * @desc Newly added animations begin executing after the current run loop cycle ends.SceneKit does not define any requirements for the contents of the key parameter—it need only be unique among the keys for other animations you add. If you add an animation with an existing key, this method overwrites the existing animation.
	     * @see https://developer.apple.com/reference/scenekit/scnanimatable/1523386-addanimation
	     */

	  }, {
	    key: 'addAnimationForKey',
	    value: function addAnimationForKey(animation, key) {}

	    /**
	     * Required. Returns the animation with the specified key.
	     * @access public
	     * @param {string} key - A string identifying a previously added animation.
	     * @returns {?CAAnimation} - 
	     * @desc Attempting to modify any properties of the returned object results in undefined behavior.
	     * @see https://developer.apple.com/reference/scenekit/scnanimatable/1524020-animation
	     */

	  }, {
	    key: 'animationForKey',
	    value: function animationForKey(key) {
	      return null;
	    }

	    /**
	     * Required. Removes all the animations currently attached to the object.
	     * @access public
	     * @returns {void}
	     * @see https://developer.apple.com/reference/scenekit/scnanimatable/1522762-removeallanimations
	     */

	  }, {
	    key: 'removeAllAnimations',
	    value: function removeAllAnimations() {}

	    /**
	     * Required. Removes the animation attached to the object with the specified key.
	     * @access public
	     * @param {string} key - A string identifying an attached animation to remove.
	     * @returns {void}
	     * @see https://developer.apple.com/reference/scenekit/scnanimatable/1522880-removeanimation
	     */

	  }, {
	    key: 'removeAnimationForKey',
	    value: function removeAnimationForKey(key) {}

	    /**
	     * Required. Removes the animation attached to the object with the specified key, smoothly transitioning out of the animation’s effect.
	     * @access public
	     * @param {string} key - A string identifying an attached animation to remove.
	     * @param {number} duration - The duration for transitioning out of the animation’s effect before it is removed.
	     * @returns {void}
	     * @desc Use this method to create smooth transitions between the effects of multiple animations. For example, the geometry loaded from a scene file for a game character may have associated animations for player actions such as walking and jumping. When the player lands from a jump, you remove the jump animation so the character continues walking. If you use the removeAnimation(forKey:) method to remove the jump animation, SceneKit abruptly switches from the current frame of the jump animation to the current frame of the walk animation. If you use the removeAnimation(forKey:fadeOutDuration:) method instead, SceneKit plays both animations at once during that duration and interpolates vertex positions from one animation to the other, creating a smooth transition.
	     * @see https://developer.apple.com/reference/scenekit/scnanimatable/1522841-removeanimation
	     */

	  }, {
	    key: 'removeAnimationForKeyFadeOutDuration',
	    value: function removeAnimationForKeyFadeOutDuration(key, duration) {}

	    /**
	     * Required. An array containing the keys of all animations currently attached to the object.
	     * @type {string[]}
	     * @desc This array contains all keys for which animations are attached to the object, or is empty if there are no attached animations. The ordering of animation keys in the array is arbitrary.
	     * @see https://developer.apple.com/reference/scenekit/scnanimatable/1523610-animationkeys
	     */

	  }, {
	    key: 'pauseAnimationForKey',


	    // Pausing and Resuming Animations

	    /**
	     * Required. Pauses the animation attached to the object with the specified key.
	     * @access public
	     * @param {string} key - A string identifying an attached animation.
	     * @returns {void}
	     * @desc This method has no effect if no animation is attached to the object with the specified key.
	     * @see https://developer.apple.com/reference/scenekit/scnanimatable/1523592-pauseanimation
	     */
	    value: function pauseAnimationForKey(key) {}

	    /**
	     * Required. Resumes a previously paused animation attached to the object with the specified key.
	     * @access public
	     * @param {string} key - A string identifying an attached animation.
	     * @returns {void}
	     * @desc This method has no effect if no animation is attached to the object with the specified key or if the specified animation is not currently paused.
	     * @see https://developer.apple.com/reference/scenekit/scnanimatable/1523332-resumeanimation
	     */

	  }, {
	    key: 'resumeAnimationForKey',
	    value: function resumeAnimationForKey(key) {}

	    /**
	     * Required. Returns a Boolean value indicating whether the animation attached to the object with the specified key is paused.
	     * @access public
	     * @param {string} key - A string identifying an attached animation.
	     * @returns {boolean} - 
	     * @see https://developer.apple.com/reference/scenekit/scnanimatable/1523703-isanimationpaused
	     */

	  }, {
	    key: 'isAnimationPausedForKey',
	    value: function isAnimationPausedForKey(key) {
	      return false;
	    }

	    // Instance Methods

	    /**
	     * Required. 
	     * @access public
	     * @param {number} speed - 
	     * @param {string} key - 
	     * @returns {void}
	     * @see https://developer.apple.com/reference/scenekit/scnanimatable/1778343-setanimationspeed
	     */

	  }, {
	    key: 'setAnimationSpeedForKey',
	    value: function setAnimationSpeedForKey(speed, key) {}

	    /**
	     * @access private
	     * @param {WebGLContext} gl -
	     * @param {SCNGeometry} geometry - 
	     * @param {boolean} update -
	     * @returns {WebGLBuffer} -
	     */

	  }, {
	    key: '_createVertexBuffer',
	    value: function _createVertexBuffer(gl, baseGeometry) {
	      var update = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

	      if (this._vertexBuffer === null) {
	        this._vertexBuffer = gl.createBuffer();
	      } else if (!update) {
	        return this._vertexBuffer;
	      }

	      gl.bindBuffer(gl.ARRAY_BUFFER, this._vertexBuffer);
	      var arr = [];
	      var vertexSource = baseGeometry.getGeometrySourcesForSemantic(_SCNGeometrySource2.default.Semantic.vertex)[0];
	      var normalSource = baseGeometry.getGeometrySourcesForSemantic(_SCNGeometrySource2.default.Semantic.normal)[0];
	      var texcoordSource = baseGeometry.getGeometrySourcesForSemantic(_SCNGeometrySource2.default.Semantic.texcoord)[0];
	      var indexSource = baseGeometry.getGeometrySourcesForSemantic(_SCNGeometrySource2.default.Semantic.boneIndices)[0];
	      var weightSource = baseGeometry.getGeometrySourcesForSemantic(_SCNGeometrySource2.default.Semantic.boneWeights)[0];
	      var vectorCount = vertexSource.vectorCount;

	      var pVertexSource = this.getGeometrySourcesForSemantic(_SCNGeometrySource2.default.Semantic.vertex)[0];
	      var pNormalSource = this.getGeometrySourcesForSemantic(_SCNGeometrySource2.default.Semantic.normal)[0];
	      var pTexcoordSource = this.getGeometrySourcesForSemantic(_SCNGeometrySource2.default.Semantic.texcoord)[0];
	      var pIndexSource = this.getGeometrySourcesForSemantic(_SCNGeometrySource2.default.Semantic.boneIndices)[0];
	      var pWeightSource = this.getGeometrySourcesForSemantic(_SCNGeometrySource2.default.Semantic.boneWeights)[0];

	      if (typeof vertexSource === 'undefined') {
	        throw new Error('vertexSource is undefined');
	      }
	      if (typeof normalSource !== 'undefined' && normalSource.vectorCount !== vectorCount) {
	        throw new Error('normalSource.vectorCount !== vertexSource.vectorCount');
	      }
	      if (typeof texcoordSource !== 'undefined' && texcoordSource.vectorCount !== vectorCount) {
	        throw new Error('texcoordSource.vectorCount !== vertexSource.vectorCount');
	      }

	      var vertexArray = vertexSource ? vertexSource.data : null;
	      var vertexComponents = vertexSource ? vertexSource.componentsPerVector : 0;
	      var normalArray = normalSource ? normalSource.data : null;
	      var normalComponents = normalSource ? normalSource.componentsPerVector : 0;
	      var texcoordArray = texcoordSource ? texcoordSource.data : null;
	      var texcoordComponents = texcoordSource ? texcoordSource.componentsPerVector : 0;

	      for (var i = 0; i < vectorCount; i++) {
	        if (vertexSource) {
	          arr.push.apply(arr, _toConsumableArray(vertexSource.vectorAt(i)));
	        }
	        if (normalSource) {
	          arr.push.apply(arr, _toConsumableArray(normalSource.vectorAt(i)));
	        }
	        if (texcoordSource) {
	          //console.log(`tex ${i} ${texcoordSource.vectorAt(i)}`)
	          arr.push.apply(arr, _toConsumableArray(texcoordSource.vectorAt(i)));
	        }
	      }

	      //console.log(`vertex(0): ${vertexSource.vectorAt(0)}`)
	      //console.log(`normal(0): ${normalSource.vectorAt(0)}`)
	      //console.log(`texcoord(0): ${texcoordSource.vectorAt(0)}`)

	      // update geometry sources
	      // FIXME: Don't change geometry sources. Use other variables
	      var bytesPerComponent = 4;
	      var offset = 0;
	      var stride = (vertexComponents + normalComponents + texcoordComponents) * bytesPerComponent;
	      pVertexSource._bytesPerComponent = bytesPerComponent;
	      pVertexSource._dataOffset = offset;
	      pVertexSource._dataStride = stride;
	      offset += vertexComponents * bytesPerComponent;

	      if (pNormalSource) {
	        pNormalSource._bytesPerComponent = bytesPerComponent;
	        pNormalSource._dataOffset = offset;
	        pNormalSource._dataStride = stride;
	        offset += normalComponents * bytesPerComponent;
	      }
	      if (pTexcoordSource) {
	        pTexcoordSource._bytesPerComponent = bytesPerComponent;
	        pTexcoordSource._dataOffset = offset;
	        pTexcoordSource._dataStride = stride;
	        offset += texcoordComponents * bytesPerComponent;
	      }

	      //console.log(`offset: ${offset}, vectorCount: ${vectorCount}`)
	      offset *= vectorCount;

	      // FIXME: check if each source needs to update
	      //if(update){
	      //  const vertexSubData = new Float32Array(arr)
	      // void gl.bufferSubData(target, dstByteOffset, ArrayBufferView srcData, srcOffset, length)
	      //gl.bufferSubData(gl.ARRAY_BUFFER, 0, vertexSubData, 0, arr.length)
	      //gl.bufferSubData(gl.ARRAY_BUFFER, 0, this._hoge, 0, arr.length)
	      //for(let i=0; i<arr.length; i++){
	      //  console.log(`morph ${this._hoge[i]} => ${arr[i]}`)
	      //}
	      //  return this._vertexBuffer
	      //}

	      var indexArray = indexSource ? indexSource.data : null;
	      var indexComponents = indexSource ? indexSource.componentsPerVector : 0;
	      var weightArray = weightSource ? weightSource.data : null;
	      var weightComponents = weightSource ? weightSource.componentsPerVector : 0;
	      var boneStride = (indexComponents + weightComponents) * bytesPerComponent;

	      for (var _i = 0; _i < vectorCount; _i++) {
	        if (indexSource) {
	          arr.push.apply(arr, _toConsumableArray(indexSource.vectorAt(_i)));
	        }
	        if (weightSource) {
	          arr.push.apply(arr, _toConsumableArray(weightSource.vectorAt(_i)));
	        }
	      }

	      if (pIndexSource) {
	        pIndexSource._bytesPerComponent = bytesPerComponent;
	        pIndexSource._dataOffset = offset;
	        pIndexSource._dataStride = boneStride;
	        offset += indexComponents * bytesPerComponent;
	      }
	      if (pWeightSource) {
	        pWeightSource._bytesPerComponent = bytesPerComponent;
	        pWeightSource._dataOffset = offset;
	        pWeightSource._dataStride = boneStride;
	        offset += weightComponents * bytesPerComponent;
	      }

	      var vertexData = new Float32Array(arr);
	      gl.bufferData(gl.ARRAY_BUFFER, vertexData, gl.DYNAMIC_DRAW);

	      // set new data
	      pVertexSource._data = arr;
	      if (pNormalSource) {
	        pNormalSource._data = arr;
	      }
	      if (pTexcoordSource) {
	        pTexcoordSource._data = arr;
	      }
	      if (pIndexSource) {
	        pIndexSource._data = arr;
	      }
	      if (pWeightSource) {
	        pWeightSource._data = arr;
	      }

	      return this._vertexBuffer;
	    }

	    /**
	     * @access private
	     * @param {WebGLContext} gl -
	     * @param {boolean} update -
	     * @returns {WebGLBuffer} -
	     */

	  }, {
	    key: '_createIndexBuffer',
	    value: function _createIndexBuffer(gl) {
	      var update = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

	      if (this._indexBuffer && !update) {
	        return this._indexBuffer;
	      }
	      this._indexBuffer = this._geometryElements[0]._createBuffer(gl);
	      return this._indexBuffer;
	    }

	    /**
	     * @access private
	     * @param {WebGLContext} gl -
	     * @param {SCNGeometry} baseGeometry - 
	     * @returns {void}
	     */

	  }, {
	    key: '_updateVertexBuffer',
	    value: function _updateVertexBuffer(gl, baseGeometry) {
	      //this._createVertexBuffer(gl, baseGeometry, true)
	      var pVertexSource = this.getGeometrySourcesForSemantic(_SCNGeometrySource2.default.Semantic.vertex)[0];
	      var vertexData = new Float32Array(pVertexSource._data);
	      gl.bindBuffer(gl.ARRAY_BUFFER, this._vertexBuffer);
	      gl.bufferData(gl.ARRAY_BUFFER, vertexData, gl.DYNAMIC_DRAW);
	    }
	  }, {
	    key: 'copy',
	    value: function copy() {
	      var geometry = new SCNGeometry();
	      geometry.name = this.name;
	      geometry.levelsOfDetail = this.levelsOfDetail;
	      geometry.materials = this.materials;
	      geometry._geometryElements = this._geometryElements.slice(0);
	      geometry._geometrySources = this._geometrySources.slice(0);
	      geometry._vertexArrayObjects = this._vertexArrayObjects ? this._vertexArrayObjects.slice(0) : null;
	      geometry.subdivisonLevel = this.subdivisionLevel;
	      geometry.edgeCreasesElement = this.edgeCreasesElement;
	      geometry.edgeCreasesSource = this.edgeCreasesSource;
	      geometry.program = this.program;
	      geometry.shaderModifiers = this.shaderModifiers;
	      //geometry._animationKeys = this._animationKeys
	      geometry.boundingBox = this.boundingBox;
	      //geometry._boundingSphere = this._boundingSphere
	      geometry._vertexBuffer = this._vertexBuffer;
	      geometry._indexBuffer = this._indexBuffer;

	      return geometry;
	    }
	  }, {
	    key: 'firstMaterial',
	    get: function get() {
	      return this.materials[0];
	    },
	    set: function set(newValue) {
	      this.materials[0] = newValue;
	    }
	  }, {
	    key: 'geometryElements',
	    get: function get() {
	      return this._geometryElements.slice(0);
	    }

	    /**
	     * An array of geometry sources that provide vertex data for the geometry.
	     * @type {SCNGeometrySource[]}
	     * @desc Each SCNGeometrySource object describes an attribute of all vertices in the geometry (such as vertex position, surface normal vector, color, or texture mapping coordinates) identified by the source’s semantic property. A geometry always has at least one source (for the vertex semantic), typically has additional sources for use in lighting and shading, and may have other sources for skeletal animation or surface subdivision information.
	     * @see https://developer.apple.com/reference/scenekit/scngeometry/1523662-geometrysources
	     */

	  }, {
	    key: 'geometrySources',
	    get: function get() {
	      return this._geometrySources.slice(0);
	    }
	  }, {
	    key: 'geometryGLSource',
	    get: function get() {
	      return new Float32Array(this._geometrySources[0]);
	    }

	    /**
	     * The number of geometry elements in the geometry.
	     * @type {number}
	     * @desc Each SCNGeometryElement object describes how vertices from the geometry’s sources are combined into polygons to create the geometry’s shape. Visible geometries contain at least one element.For geometries with multiple elements, you can use the materials property to attach different materials to each element.
	     * @see https://developer.apple.com/reference/scenekit/scngeometry/1523800-geometryelementcount
	     */

	  }, {
	    key: 'geometryElementCount',
	    get: function get() {
	      return this._geometryElements.length;
	    }
	  }, {
	    key: 'animationKeys',
	    get: function get() {
	      // TODO: implement
	      return [];
	    }
	  }]);

	  return SCNGeometry;
	}(_NSObject3.default);

	exports.default = SCNGeometry;

/***/ },
/* 38 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _SCNProgram = __webpack_require__(39);

	var _SCNProgram2 = _interopRequireDefault(_SCNProgram);

	var _SCNShaderModifierEntryPoint = __webpack_require__(87);

	var _SCNShaderModifierEntryPoint2 = _interopRequireDefault(_SCNShaderModifierEntryPoint);

	var _SCNBindingBlock = __webpack_require__(78);

	var _SCNBindingBlock2 = _interopRequireDefault(_SCNBindingBlock);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	/**
	 * Methods for customizing SceneKit's rendering of geometry and materials using Metal or OpenGL shader programs.
	 * @interface
	 * @see https://developer.apple.com/reference/scenekit/scnshadable
	 */
	var SCNShadable = function () {
	  function SCNShadable() {
	    _classCallCheck(this, SCNShadable);
	  }

	  _createClass(SCNShadable, [{
	    key: 'init',


	    /**
	     * constructor
	     * @access public
	     * @returns {void}
	     */
	    value: function init() {

	      // Assigning a Custom Shader Program

	      /**
	       * A program used when rendering the object.
	       * @type {?SCNProgram}
	       * @see https://developer.apple.com/reference/scenekit/scnshadable/1523689-program
	       */
	      this.program = null;

	      // Customizing SceneKit’s Shader Programs

	      /**
	       * A dictionary of GLSL source code snippets for customizing the shader programs provided by SceneKit.
	       * @type {?Map<SCNShaderModifierEntryPoint, string>}
	       * @see https://developer.apple.com/reference/scenekit/scnshadable/1523348-shadermodifiers
	       */
	      this.shaderModifiers = null;
	    }

	    // Handling Parameters in Custom OpenGL Shader Programs

	    /**
	     * Specifies a block to be called before rendering with programs with the specified GLSL uniform variable or attribute name.
	     * @access public
	     * @param {string} symbol - A GLSL uniform variable or attribute name.
	     * @param {?SCNBindingBlock} [block = null] - A block to be called by SceneKit.
	     * @returns {void}
	     * @desc Use this method to associate a block with a SceneKit object (geometry or material) to handle setup of an attribute or uniform variable in a custom SCNProgram shader associated with that object. SceneKit calls your block before rendering the object. In the block, you can execute any OpenGL commands or other code necessary for preparing your custom shader. For example, the following block updates the time uniform variable in a custom fragment shader for producing animated effects:CFTimeInterval startTime = CFAbsoluteTimeGetCurrent();
	    [myNode.geometry.firstMaterial handleBindingOfSymbol:@"time" usingBlock:
	      ^(unsigned int programID, unsigned int location, SCNNode *renderedNode, SCNRenderer *renderer) {
	          glUniform1f(location, CFAbsoluteTimeGetCurrent() - startTime);
	      }];
	    This method is for OpenGL shader programs only. To bind custom variable data for Metal shader programs, use the handleBinding(ofBufferNamed:frequency:handler:) method.CFTimeInterval startTime = CFAbsoluteTimeGetCurrent();
	    [myNode.geometry.firstMaterial handleBindingOfSymbol:@"time" usingBlock:
	      ^(unsigned int programID, unsigned int location, SCNNode *renderedNode, SCNRenderer *renderer) {
	          glUniform1f(location, CFAbsoluteTimeGetCurrent() - startTime);
	      }];
	      * @see https://developer.apple.com/reference/scenekit/scnshadable/1523063-handlebinding
	     */

	  }, {
	    key: 'handleBindingOfSymbolHandler',
	    value: function handleBindingOfSymbolHandler(symbol) {
	      var block = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
	    }

	    /**
	     * Specifies a block to be called after rendering with programs with the specified GLSL uniform variable or attribute name.
	     * @access public
	     * @param {string} symbol - A GLSL uniform variable or attribute name.
	     * @param {?SCNBindingBlock} [block = null] - A block to be called by SceneKit.
	     * @returns {void}
	     * @desc Use this method to associate a block with a SceneKit object (geometry or material) to handle cleanup related to an attribute or uniform variable in a custom SCNProgram shader associated with that object. SceneKit will call your block after rendering the object. In the block, you can execute any OpenGL commands or other code necessary for post-rendering tasks.This method is for OpenGL shader programs only. To bind custom variable data for Metal shader programs, use the handleBinding(ofBufferNamed:frequency:handler:) method.
	     * @see https://developer.apple.com/reference/scenekit/scnshadable/1522783-handleunbinding
	     */

	  }, {
	    key: 'handleUnbindingOfSymbolHandler',
	    value: function handleUnbindingOfSymbolHandler(symbol) {
	      var block = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
	    }
	  }]);

	  return SCNShadable;
	}();

	exports.default = SCNShadable;

/***/ },
/* 39 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _NSObject2 = __webpack_require__(13);

	var _NSObject3 = _interopRequireDefault(_NSObject2);

	var _SCNProgramDelegate = __webpack_require__(40);

	var _SCNProgramDelegate2 = _interopRequireDefault(_SCNProgramDelegate);

	var _SCNBufferFrequency = __webpack_require__(84);

	var _SCNBufferFrequency2 = _interopRequireDefault(_SCNBufferFrequency);

	var _SCNBufferBindingBlock = __webpack_require__(85);

	var _SCNBufferBindingBlock2 = _interopRequireDefault(_SCNBufferBindingBlock);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * A complete Metal or OpenGL shader program that replaces SceneKit's rendering of a geometry or material.
	 * @access public
	 * @extends {NSObject}
	 * @see https://developer.apple.com/reference/scenekit/scnprogram
	 */
	var SCNProgram = function (_NSObject) {
	  _inherits(SCNProgram, _NSObject);

	  /**
	   * constructor
	   * @access public
	   * @constructor
	   */
	  function SCNProgram() {
	    _classCallCheck(this, SCNProgram);

	    // Working with OpenGL Shader Source Code

	    /**
	     * GLSL source code for the program’s vertex shader.
	     * @type {?string}
	     * @see https://developer.apple.com/reference/scenekit/scnprogram/1522891-vertexshader
	     */
	    var _this = _possibleConstructorReturn(this, (SCNProgram.__proto__ || Object.getPrototypeOf(SCNProgram)).call(this));

	    _this.vertexShader = null;

	    /**
	     * GLSL source code for the program’s fragment shader.
	     * @type {?string}
	     * @see https://developer.apple.com/reference/scenekit/scnprogram/1523135-fragmentshader
	     */
	    _this.fragmentShader = null;

	    /**
	     * GLSL source code for the program’s optional geometry shader.
	     * @type {?string}
	     * @see https://developer.apple.com/reference/scenekit/scnprogram/1524049-geometryshader
	     */
	    _this.geometryShader = null;

	    /**
	     * GLSL source code for the program’s optional tessellation control shader.
	     * @type {?string}
	     * @see https://developer.apple.com/reference/scenekit/scnprogram/1523852-tessellationcontrolshader
	     */
	    _this.tessellationControlShader = null;

	    /**
	     * GLSL source code for the program’s optional tessellation evaluation shader.
	     * @type {?string}
	     * @see https://developer.apple.com/reference/scenekit/scnprogram/1523760-tessellationevaluationshader
	     */
	    _this.tessellationEvaluationShader = null;

	    // Providing a Delegate Object

	    /**
	     * The delegate of the program object.
	     * @type {?SCNProgramDelegate}
	     * @see https://developer.apple.com/reference/scenekit/scnprogram/1522611-delegate
	     */
	    _this.delegate = null;

	    // Managing Opacity

	    /**
	     * A Boolean value that indicates whether fragments rendered by the program are fully opaque.
	     * @type {boolean}
	     * @see https://developer.apple.com/reference/scenekit/scnprogram/1522844-isopaque
	     */
	    _this.isOpaque = false;

	    // Working With Metal Shaders

	    /**
	     * The name of the vertex shader function to load from a Metal shader library.
	     * @type {?string}
	     * @see https://developer.apple.com/reference/scenekit/scnprogram/1522799-vertexfunctionname
	     */
	    _this.vertexFunctionName = null;

	    /**
	     * The name of the fragment shader function to load from a Metal shader library.
	     * @type {?string}
	     * @see https://developer.apple.com/reference/scenekit/scnprogram/1524012-fragmentfunctionname
	     */
	    _this.fragmentFunctionName = null;

	    /**
	     * The Metal shader library containing shader functions to be used by this program.
	     * @type {?MTLLibrary}
	     * @see https://developer.apple.com/reference/scenekit/scnprogram/1522934-library
	     */
	    _this.library = null;

	    /**
	     * @access private
	     * @type {WebGLProgram}
	     */
	    _this._glProgram = null;
	    return _this;
	  }

	  // Mapping GLSL Symbols to SceneKit Semantics

	  /**
	   * Associates a SceneKit semantic identifier with the specified GLSL vertex attribute or uniform variable.
	   * @access public
	   * @param {?string} semantic - A SceneKit semantic identifier. See Geometry Semantic Identifiers and Rendering Transform Keys for possible values.
	   * @param {string} symbol - The name declared in the program’s GLSL source code for the vertex attribute or uniform variable to be associated with the semantic.
	   * @param {?Map<string, Object>} [options = null] - A dictionary of options affecting the semantic. See Program Semantic Options for applicable keys and values.
	   * @returns {void}
	   * @desc Use this method to provide inputs managed by SceneKit to your GLSL program.To use vertex attributes provided by SCNGeometry objects, use the constants listed in Geometry Semantic Identifiers.To use the coordinate transformations defined by the scene’s node hierarchy and point-of-view camera, use the constants listed in Rendering Transform Keys.
	   * @see https://developer.apple.com/reference/scenekit/scnprogram/1522730-setsemantic
	   */


	  _createClass(SCNProgram, [{
	    key: 'setSemanticForSymbol',
	    value: function setSemanticForSymbol(semantic, symbol) {
	      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
	    }

	    /**
	     * Returns the SceneKit semantic identifiers associated with the specified GLSL vertex attribute or uniform variable.
	     * @access public
	     * @param {string} symbol - The name declared in the program’s GLSL source code for a vertex attribute or uniform variable semantic.
	     * @returns {?string} - 
	     * @see https://developer.apple.com/reference/scenekit/scnprogram/1523350-semantic
	     */

	  }, {
	    key: 'semanticForSymbol',
	    value: function semanticForSymbol(symbol) {
	      return null;
	    }

	    // Providing Input for Metal Shaders

	    /**
	     * Registers a block for SceneKit to call at render time for binding a Metal buffer to the shader program.
	     * @access public
	     * @param {string} name - The name identifying the buffer in Metal shader source code.
	     * @param {SCNBufferFrequency} frequency - An option specifying whether SceneKit calls the block only once per rendered frame or more frequently (for example, once for each object to be rendered).
	     * @param {SCNBufferBindingBlock} block - A block to be run when SceneKit prepares for rendering with the Metal shader.
	     * @returns {void}
	     * @desc Use this method to associate a block with a Metal shader program to handle setup of a buffer used in that shader. SceneKit calls your block before rendering any objects whose program property is set to this SCNProgram object. In the block, use the writeBytes(_:count:) method to provide data for the buffer.  
	      * @see https://developer.apple.com/reference/scenekit/scnprogram/1524047-handlebinding
	     */

	  }, {
	    key: 'handleBindingOfBufferNamedHandler',
	    value: function handleBindingOfBufferNamedHandler(name, frequency, block) {}
	  }]);

	  return SCNProgram;
	}(_NSObject3.default);

	exports.default = SCNProgram;

/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _SCNProgram = __webpack_require__(39);

	var _SCNProgram2 = _interopRequireDefault(_SCNProgram);

	var _SCNRenderer = __webpack_require__(41);

	var _SCNRenderer2 = _interopRequireDefault(_SCNRenderer);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	/**
	 * The interface for tracking errors that occur when compiling shader source code.
	 * @interface
	 * @see https://developer.apple.com/reference/scenekit/scnprogramdelegate
	 */
	var SCNProgramDelegate = function () {
	  function SCNProgramDelegate() {
	    _classCallCheck(this, SCNProgramDelegate);
	  }

	  _createClass(SCNProgramDelegate, [{
	    key: 'init',


	    /**
	     * constructor
	     * @access public
	     * @returns {void}
	     */
	    value: function init() {}

	    // Handling Shader Compilation Errors

	    /**
	     * Tells the delegate that an error occurred when compiling GLSL source code.
	     * @access public
	     * @param {SCNProgram} program - The program that generated the compilation error.
	     * @param {Error} error - The compilation error that was raised.
	     * @returns {void}
	     * @desc Examine the error parameter for details of the compilation error provided by the GLSL compiler.
	     * @see https://developer.apple.com/reference/scenekit/scnprogramdelegate/1523007-program
	     */

	  }, {
	    key: 'programHandleError',
	    value: function programHandleError(program, error) {}

	    // Finding Fragment Opaqueness

	    /**
	     * Asks the delegate whether fragments rendered by a program are opaque.
	     * @deprecated
	     * @access public
	     * @param {SCNProgram} program - 
	     * @returns {boolean} - 
	     * @see https://developer.apple.com/reference/scenekit/scnprogramdelegate/1523068-programisopaque
	     */

	  }, {
	    key: 'programIsOpaque',
	    value: function programIsOpaque(program) {
	      return false;
	    }

	    // Binding and Unbinding Values

	    /**
	     * Invoked on the delegate to let it bind program values and/or associated graphics resources (such as textures) for symbols.
	     * @deprecated
	     * @access public
	     * @param {SCNProgram} program - The SCNProgram object to bind values for.
	     * @param {string} symbol - The name of the symbol to bind a value for.
	     * @param {number} location - The location of the symbol within the program object to be modified.
	     * @param {number} programID - The underlying OpenGL program object in which the binding is made.
	     * @param {SCNRenderer} renderer - The renderer that is currently rendering the scene.
	     * @returns {boolean} - 
	     * @desc If you use the handleBinding(ofSymbol:handler:) method to associate a handler block with a SceneKit object for a symbol, SceneKit will not call the delegate’s program(_:bindValueForSymbol:atLocation:programID:renderer:) method for that symbol when rendering that object.
	     * @see https://developer.apple.com/reference/scenekit/scnprogramdelegate/1524155-program
	     */

	  }, {
	    key: 'programBindValueForSymbolAtLocation',
	    value: function programBindValueForSymbolAtLocation(program, symbol, location, programID, renderer) {
	      return false;
	    }

	    /**
	     * Invoked on the delegate to let it unbind program values and/or also unbind associated graphic resources (such as textures).
	     * @deprecated
	     * @access public
	     * @param {SCNProgram} program - The SCNProgram object to unbind values for.
	     * @param {string} symbol - The name of the symbol to unbind a value for.
	     * @param {number} location - The location of the symbol within the program object to be modified.
	     * @param {number} programID - The underlying OpenGL program object in which the unbinding is done.
	     * @param {SCNRenderer} renderer - The renderer that is currently rendering the scene.
	      * @returns {void}
	     * @desc If you use the handleUnbinding(ofSymbol:handler:) method to associate a handler block with a SceneKit object for a symbol, SceneKit will not call the delegate’s program(_:unbindValueForSymbol:atLocation:programID:renderer:) method for that symbol when rendering that object.
	     * @see https://developer.apple.com/reference/scenekit/scnprogramdelegate/1523857-program
	     */

	  }, {
	    key: 'programUnbindValueForSymbolAtLocation',
	    value: function programUnbindValueForSymbolAtLocation(program, symbol, location, programID, renderer) {}
	  }]);

	  return SCNProgramDelegate;
	}();

	exports.default = SCNProgramDelegate;

/***/ },
/* 41 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _NSObject2 = __webpack_require__(13);

	var _NSObject3 = _interopRequireDefault(_NSObject2);

	var _SCNSceneRenderer = __webpack_require__(42);

	var _SCNSceneRenderer2 = _interopRequireDefault(_SCNSceneRenderer);

	var _SCNTechniqueSupport = __webpack_require__(76);

	var _SCNTechniqueSupport2 = _interopRequireDefault(_SCNTechniqueSupport);

	var _SCNScene = __webpack_require__(43);

	var _SCNScene2 = _interopRequireDefault(_SCNScene);

	var _CGRect = __webpack_require__(6);

	var _CGRect2 = _interopRequireDefault(_CGRect);

	var _CGSize = __webpack_require__(7);

	var _CGSize2 = _interopRequireDefault(_CGSize);

	var _SCNAntialiasingMode = __webpack_require__(79);

	var _SCNAntialiasingMode2 = _interopRequireDefault(_SCNAntialiasingMode);

	var _SCNNode = __webpack_require__(33);

	var _SCNNode2 = _interopRequireDefault(_SCNNode);

	var _SCNProgram = __webpack_require__(39);

	var _SCNProgram2 = _interopRequireDefault(_SCNProgram);

	var _SCNCamera = __webpack_require__(80);

	var _SCNCamera2 = _interopRequireDefault(_SCNCamera);

	var _SCNLight = __webpack_require__(81);

	var _SCNLight2 = _interopRequireDefault(_SCNLight);

	var _SCNVector = __webpack_require__(15);

	var _SCNVector2 = _interopRequireDefault(_SCNVector);

	var _SCNVector3 = __webpack_require__(16);

	var _SCNVector4 = _interopRequireDefault(_SCNVector3);

	var _SKColor = __webpack_require__(48);

	var _SKColor2 = _interopRequireDefault(_SKColor);

	var _SCNGeometrySource = __webpack_require__(83);

	var _SCNGeometrySource2 = _interopRequireDefault(_SCNGeometrySource);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * @access private
	 * @type {SCNProgram}
	 */
	//let __defaultProgram = null

	/**
	 * @access private
	 * @type {string}
	 */
	var _defaultVertexShader = '#version 300 es\n  precision mediump float;\n\n  uniform mat4 viewTransform;\n  uniform mat4 viewProjectionTransform;\n\n  uniform vec4 lightAmbient;\n  uniform vec4 lightDiffuse;\n  uniform vec3 lightDirection;\n\n  uniform vec4 materialAmbient;\n  uniform vec4 materialDiffuse;\n  uniform vec4 materialSpecular;\n  uniform vec4 materialEmission;\n\n  //uniform mat3x4[255] skinningJoints;\n  uniform vec4[765] skinningJoints;\n  //uniform bool useSkinner;\n  uniform int numSkinningJoints;\n\n  in vec3 position;\n  in vec3 normal;\n  in vec2 texcoord;\n  in vec4 boneIndices;\n  in vec4 boneWeights;\n\n  out vec2 v_texcoord;\n  out vec4 v_color;\n  //out vec3 v_eye;\n\n  void main() {\n    vec3 pos = vec3(0, 0, 0);\n    vec3 nom = vec3(0, 0, 0);\n    if(numSkinningJoints > 0){\n      for(int i=0; i<numSkinningJoints; i++){\n        float weight = boneWeights[i];\n        if(int(boneIndices[i]) < 0){\n          continue;\n        }\n        int idx = int(boneIndices[i]) * 3;\n        mat4 jointMatrix = transpose(mat4(skinningJoints[idx],\n                                          skinningJoints[idx+1],\n                                          skinningJoints[idx+2],\n                                          vec4(0, 0, 0, 1)));\n        pos += (jointMatrix * vec4(position, 1.0)).xyz * weight;\n        nom += (mat3(jointMatrix) * normal) * weight;\n      }\n    }else{\n      mat4 jointMatrix = transpose(mat4(skinningJoints[0],\n                                        skinningJoints[1],\n                                        skinningJoints[2],\n                                        vec4(0, 0, 0, 1)));\n      pos = (jointMatrix * vec4(position, 1.0)).xyz;\n      nom = mat3(jointMatrix) * normal;\n    }\n    //v_eye = viewTransform * vec4(pos, 1.0).xyz;\n    vec3 viewPos = vec3(-viewTransform[0][3], -viewTransform[1][3], -viewTransform[2][3]);\n    vec3 viewVec = normalize(vec3(viewPos - pos));\n    vec3 lightVec = normalize(-lightDirection);\n\n    float diffuse = dot(lightVec, nom);\n\n    v_color = lightAmbient * materialAmbient;\n    float shininess = 0.5;\n    if(diffuse > 0.0){\n      //vec3 halfway = normalize(lightVec + viewVec);\n      //float specular = pow(max(dot(nom, halfway), 0.0), shininess);\n      //v_color += lightSpecular * materialSpecular * specular;\n      v_color += lightDiffuse * materialDiffuse * diffuse;\n    }\n    v_color += materialEmission;\n\n    //v_color = materialDiffuse;\n    v_texcoord = texcoord;\n    gl_Position = viewProjectionTransform * vec4(pos, 1.0);\n  }\n';

	/**
	 * @access private
	 * @type {string}
	 */
	var _defaultFragmentShader = '#version 300 es\n  precision mediump float;\n\n  uniform sampler2D u_emissionTexture;\n  uniform bool u_useEmissionTexture;\n  uniform sampler2D u_ambientTexture;\n  uniform bool u_useAmbientTexture;\n  uniform sampler2D u_diffuseTexture;\n  uniform bool u_useDiffuseTexture;\n  uniform sampler2D u_specularTexture;\n  uniform bool u_useSpecularTexture;\n  uniform sampler2D u_reflectiveTexture;\n  uniform bool u_useReflectiveTexture;\n  uniform sampler2D u_transparentTexture;\n  uniform bool u_useTransparentTexture;\n  uniform sampler2D u_multiplyTexture;\n  uniform bool u_useMultiplyTexture;\n  uniform sampler2D u_normalTexture;\n  uniform bool u_useNormalTexture;\n\n  in vec2 v_texcoord;\n  in vec4 v_color;\n  //in vec3 v_eye;\n\n  out vec4 outColor;\n\n  void main() {\n    if(u_useDiffuseTexture){\n      vec4 color = texture(u_diffuseTexture, v_texcoord);\n      outColor = color * v_color;\n      //outColor = vec4(0, 1, 0, 1);\n      //outColor = color;\n    }else{\n      outColor = v_color;\n    }\n  }\n';

	/**
	 * A renderer for displaying SceneKit scene in an an existing Metal workflow or OpenGL context. 
	 * @access public
	 * @extends {NSObject}
	 * @implements {SCNSceneRenderer}
	 * @implements {SCNTechniqueSupport}
	 * @see https://developer.apple.com/reference/scenekit/scnrenderer
	 */

	var SCNRenderer = function (_NSObject) {
	  _inherits(SCNRenderer, _NSObject);

	  // Creating a Renderer

	  /**
	   * Creates a renderer with the specified Metal device.
	   * @access public
	   * @constructor
	   * @param {?MTLDevice} device - A Metal device.
	   * @param {?Map<AnyHashable, Object>} [options = null] - An optional dictionary for future extensions.
	   * @desc Use this initializer to create a SceneKit renderer that draws into the rendering targets your app already uses to draw other content. For the device parameter, pass the MTLDevice object your app uses for drawing. Then, to tell SceneKit to render your content, call the SCNRenderer method, providing a command buffer and render pass descriptor for SceneKit to use in its rendering.
	   * @see https://developer.apple.com/reference/scenekit/scnrenderer/1518404-init
	   */
	  function SCNRenderer(device) {
	    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

	    _classCallCheck(this, SCNRenderer);

	    // Specifying a Scene

	    /**
	     * The scene to be rendered.
	     * @type {?SCNScene}
	     * @see https://developer.apple.com/reference/scenekit/scnrenderer/1518400-scene
	     */
	    var _this = _possibleConstructorReturn(this, (SCNRenderer.__proto__ || Object.getPrototypeOf(SCNRenderer)).call(this));

	    _this.scene = null;

	    // Managing Animation Timing

	    _this._nextFrameTime = 0;

	    /**
	     * context to draw frame
	     * @type {WebGLRenderingContext}
	     */
	    _this._context = null;

	    /**
	     * @type {WebGLProgram}
	     */
	    //this.program = null

	    /**
	     *
	     * @access private
	     * @type {SKColor}
	     */
	    _this._backgroundColor = null;

	    //////////////////////
	    // SCNSceneRenderer //
	    //////////////////////

	    // Managing Scene Display

	    /**
	     * Required. The node from which the scene’s contents are viewed for rendering.
	     * @type {?SCNNode}
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1523982-pointofview
	     */
	    _this.pointOfView = null;

	    /**
	     * Required. A Boolean value that determines whether SceneKit automatically adds lights to a scene.
	     * @type {boolean}
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1523812-autoenablesdefaultlighting
	     */
	    _this.autoenablesDefaultLighting = false;

	    /**
	     * Required. A Boolean value that determines whether SceneKit applies jittering to reduce aliasing artifacts.
	     * @type {boolean}
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1524026-isjitteringenabled
	     */
	    _this.isJitteringEnabled = false;

	    /**
	     * Required. A Boolean value that determines whether SceneKit displays rendering performance statistics in an accessory view.
	     * @type {boolean}
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1522763-showsstatistics
	     */
	    _this.showsStatistics = false;

	    /**
	     * Required. Options for drawing overlay content in a scene that can aid debugging.
	     * @type {SCNDebugOptions}
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1523281-debugoptions
	     */
	    _this.debugOptions = null;

	    _this._renderingAPI = null;

	    // Managing Scene Animation Timing

	    /**
	     * Required. The current scene time.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1522680-scenetime
	     */
	    _this.sceneTime = 0;

	    /**
	     * Required. A Boolean value that determines whether the scene is playing.
	     * @type {boolean}
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1523401-isplaying
	     */
	    _this.isPlaying = false;

	    /**
	     * Required. A Boolean value that determines whether SceneKit restarts the scene time after all animations in the scene have played.
	     * @type {boolean}
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1522878-loops
	     */
	    _this.loops = false;

	    // Participating in the Scene Rendering Process

	    /**
	     * Required. A delegate object that receives messages about SceneKit’s rendering process.
	     * @type {?SCNSceneRendererDelegate}
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1522671-delegate
	     */
	    _this.delegate = null;

	    // Customizing Scene Rendering with Metal

	    _this._currentRenderCommandEncoder = null;
	    _this._device = null;
	    _this._commandQueue = null;
	    _this._colorPixelFormat = null;
	    _this._depthPixelFormat = null;
	    _this._stencilPixelFormat = null;

	    // Rendering Sprite Kit Content over a Scene

	    /**
	     * Required. A Sprite Kit scene to be rendered on top of the SceneKit content.
	     * @type {?SKScene}
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1524051-overlayskscene
	     */
	    //this.overlaySKScene = null


	    // Working With Positional Audio

	    /**
	     * Required. The node representing the listener’s position in the scene for use with positional audio effects.
	     * @type {?SCNNode}
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1523747-audiolistener
	     */
	    //this.audioListener = null
	    //this._audioEnvironmentNode = null
	    //this._audioEngine = null

	    // Instance Properties

	    /**
	     * Required. 
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1522854-currenttime
	     */
	    //this.currentTime = 0

	    /**
	     * @access private
	     * @type {WebGLProgram}
	     */
	    //this._defaultGLProgram = null
	    /**
	     * @access private
	     * @type {SCNProgram}
	     */
	    _this.__defaultProgram = null;

	    _this._location = new Map();

	    _this._defaultCameraNode = new _SCNNode2.default();
	    var camera = new _SCNCamera2.default();
	    _this._defaultCameraNode.camera = camera;
	    _this._defaultCameraNode.position = new _SCNVector2.default(0, 0, 10);

	    _this._defaultLightNode = new _SCNNode2.default();
	    var light = new _SCNLight2.default();
	    light.color = _SKColor2.default.white;
	    light.type = _SCNLight2.default.directional;
	    _this._defaultLightNode.light = light;

	    /**
	     * @access private
	     * @type {CGRect}
	     */
	    _this._viewRect = null;

	    /**
	     * @access private
	     * @type {WebGLTexture}
	     */
	    _this.__dummyTexture = null;
	    return _this;
	  }

	  /**
	   * Creates a renderer with the specified Metal device.
	   * @access public
	   * @param {?MTLDevice} device - A Metal device.
	   * @param {?Map<AnyHashable, Object>} [options = null] - An optional dictionary for future extensions.
	   * @returns {void}
	   * @desc Use this initializer to create a SceneKit renderer that draws into the rendering targets your app already uses to draw other content. For the device parameter, pass the MTLDevice object your app uses for drawing. Then, to tell SceneKit to render your content, call the SCNRenderer method, providing a command buffer and render pass descriptor for SceneKit to use in its rendering.
	   * @see https://developer.apple.com/reference/scenekit/scnrenderer/1518404-init
	   */


	  _createClass(SCNRenderer, [{
	    key: 'init',
	    value: function init(device) {
	      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
	    }

	    // Managing Animation Timing
	    /**
	     * The timestamp for the next frame to be rendered.
	     * @type {number}
	     * @desc If the renderer’s scene has any attached actions or animations, use this property to determine how long your app should wait before telling the renderer to draw another frame. If this property’s value matches that of the renderer’s currentTime property, the scene contains a continuous animation—schedule your next render at whatever time best maintains your app’s performance. If the value is infinite, the scene has no running actions or animations.
	     * @see https://developer.apple.com/reference/scenekit/scnrenderer/1518410-nextframetime
	     */

	  }, {
	    key: 'renderAtTimePassDescriptor',


	    // Rendering a Scene Using Metal

	    /**
	     * Renders the scene’s contents at the specified system time in the specified Metal command buffer.
	     * @access public
	     * @param {number} time - The timestamp, in seconds, at which to render the scene.
	     * @param {CGRect} viewport - The pixel dimensions in which to render.
	     * @param {MTLCommandBuffer} commandBuffer - The Metal command buffer in which SceneKit should schedule rendering commands.
	     * @param {MTLRenderPassDescriptor} renderPassDescriptor - The Metal render pass descriptor describing the rendering target.
	     * @returns {void}
	     * @desc This method can be used only with an SCNRenderer object created with the SCNRenderer initializer. Call this method to tell SceneKit to draw the renderer’s scene into the render target described by the renderPassDescriptor parameter, by encoding render commands into the commandBuffer parameter.When you call this method, SceneKit updates its hierarchy of presentation nodes based on the specified timestamp, and then draws the scene using the specified Metal objects. NoteBy default, the playback timing of actions and animations in a scene is based on the system time, not the scene time. Before using this method to control the playback of animations, set the usesSceneTimeBase property of each animation to true, or specify the playUsingSceneTimeBase option when loading a scene file that contains animations.
	     * @see https://developer.apple.com/reference/scenekit/scnrenderer/1518401-render
	     */
	    value: function renderAtTimePassDescriptor(time, viewport, commandBuffer, renderPassDescriptor) {}

	    // Rendering a Scene Using OpenGL

	    /**
	     * Renders the scene’s contents in the renderer’s OpenGL context.
	     * @deprecated
	     * @access public
	     * @returns {void}
	     * @desc This method can be used only with an SCNRenderer object created with the SCNRenderer initializer. Call this method to tell SceneKit to draw the renderer’s scene into the OpenGL context you created the renderer with.When you call this method, SceneKit updates its hierarchy of presentation nodes based on the current system time, and then draws the scene.
	     * @see https://developer.apple.com/reference/scenekit/scnrenderer/1518403-render
	     */

	  }, {
	    key: 'render',
	    value: function render() {
	      var _this2 = this;

	      if (this.scene === null) {
	        console.error('SCNRenderer.render(): scene is null');
	        return;
	      }
	      if (this.context === null) {
	        console.error('SCNRenderer.render(): context is null');
	        return;
	      }
	      var gl = this.context;
	      var program = this._defaultProgram._glProgram;
	      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);

	      // set camera node
	      var cameraNode = this.pointOfView || this._defaultCameraNode;
	      if (cameraNode !== this.pointOfView) {
	        console.error('pointOfView is null');
	      }
	      var camera = cameraNode.camera;
	      camera._updateProjectionTransform(this._viewRect);

	      // camera params
	      gl.uniformMatrix4fv(gl.getUniformLocation(program, 'viewTransform'), false, cameraNode.viewTransform.float32Array());
	      gl.uniformMatrix4fv(gl.getUniformLocation(program, 'viewProjectionTransform'), false, cameraNode.viewProjectionTransform.float32Array());

	      //console.log('cameraNode.position: ' + cameraNode.position.float32Array())
	      //console.log('viewTransform: ' + cameraNode.viewTransform.float32Array())
	      //console.log('projectionTransform: ' + cameraNode.camera.projectionTransform.float32Array())
	      //console.log('viewProjectionTransform: ' + cameraNode.viewProjectionTransform.float32Array())

	      // light params
	      var lights = this._createLightNodeArray();
	      if (lights.length === 0) {
	        lights.push(this._defaultLightNode);
	      }
	      //console.log('lights.length: ' + lights.length)

	      // FIXME: use all lights
	      var hasAmbient = false;
	      var hasDiffuse = false;
	      lights.forEach(function (lightNode) {
	        var light = lightNode.light;
	        if (light.type === _SCNLight2.default.LightType.ambient) {
	          //console.log('ambient: ' + light.color.float32Array())
	          hasAmbient = true;
	          gl.uniform4fv(gl.getUniformLocation(program, 'lightAmbient'), light.color.float32Array());
	        }
	        if (light.type === _SCNLight2.default.LightType.directional) {
	          //console.log('directional: ' + light.color.float32Array())
	          hasDiffuse = true;
	          gl.uniform4fv(gl.getUniformLocation(program, 'lightDiffuse'), light.color.float32Array());
	        }
	      });
	      if (!hasAmbient) {
	        gl.uniform4fv(gl.getUniformLocation(program, 'lightAmbient'), _SKColor2.default.black.float32Array());
	      }
	      if (!hasDiffuse) {
	        gl.uniform4fv(gl.getUniformLocation(program, 'lightDiffuse'), _SKColor2.default.black.float32Array());
	      }

	      // FIXME: use uniform var
	      var lightDirection = new Float32Array([0, -0.9, -0.1]);
	      gl.uniform3fv(gl.getUniformLocation(program, 'lightDirection'), lightDirection);

	      var renderingArray = this._createRenderingNodeArray();
	      //if(renderingArray.length === 0){
	      //  throw new Error('renderingArray.length: 0')
	      //}
	      renderingArray.forEach(function (node) {
	        _this2._renderNode(node);
	      });

	      gl.flush();
	    }

	    /**
	     *
	     * @access private
	     * @returns {SCNNode[]} -
	     */

	  }, {
	    key: '_createRenderingNodeArray',
	    value: function _createRenderingNodeArray() {
	      var arr = [this.scene.rootNode];
	      var targetNodes = [];
	      while (arr.length > 0) {
	        var node = arr.shift();
	        if (node.presentation.geometry !== null) {
	          targetNodes.push(node);
	        }
	        arr.push.apply(arr, _toConsumableArray(node.childNodes));
	      }
	      targetNodes.sort(function (a, b) {
	        return a.renderingOrder - b.renderingOrder;
	      });

	      return targetNodes;
	    }

	    /**
	     *
	     * @access private
	     * @returns {SCNNode[]} -
	     */

	  }, {
	    key: '_createLightNodeArray',
	    value: function _createLightNodeArray() {
	      var arr = [this.scene.rootNode];
	      var targetNodes = [];
	      while (arr.length > 0) {
	        var node = arr.shift();
	        if (node.presentation.light !== null) {
	          targetNodes.push(node.presentation);
	        }
	        arr.push.apply(arr, _toConsumableArray(node.childNodes));
	      }
	      return targetNodes;
	    }
	  }, {
	    key: 'prepareBuffer',
	    value: function prepareBuffer() {
	      var _this3 = this;

	      // FIXME: reuse renderingArray
	      var renderingArray = this._createRenderingNodeArray();
	      renderingArray.forEach(function (node) {
	        _this3._prepareBufferForNode(node);
	      });
	    }
	  }, {
	    key: '_prepareBufferForNode',
	    value: function _prepareBufferForNode(node) {
	      var gl = this.context;
	      var geometry = node.presentation.geometry;
	      var program = this._defaultProgram._glProgram;
	      if (geometry.program !== null) {
	        program = geometry.program._glProgram;
	      }
	      gl.useProgram(program);

	      if (geometry._vertexArrayObjects === null) {
	        this._initializeVAO(node, program);
	      }
	    }

	    /**
	     *
	     * @access private
	     * @param {SCNNode} node -
	     * @returns {void}
	     */

	  }, {
	    key: '_renderNode',
	    value: function _renderNode(node) {
	      var gl = this.context;
	      var geometry = node.presentation.geometry;
	      var program = this._defaultProgram._glProgram;
	      if (geometry.program !== null) {
	        program = geometry.program._glProgram;
	      }
	      gl.useProgram(program);

	      //if(geometry._vertexArrayObjects === null){
	      //  this._initializeVAO(node, program)
	      //}else if(node.morpher !== null){
	      //  //console.log(`node.morpher: ${node.morpher}`)
	      //  this._updateVAO(node)
	      //}
	      if (node.morpher !== null) {
	        this._updateVAO(node);
	      }

	      // TODO: use geometry setting
	      gl.disable(gl.CULL_FACE);

	      if (node.presentation.skinner !== null) {
	        gl.uniform1i(gl.getUniformLocation(program, 'numSkinningJoints'), node.presentation.skinner.numSkinningJoints);
	        gl.uniform4fv(gl.getUniformLocation(program, 'skinningJoints'), node.presentation.skinner.float32Array());
	      } else {
	        gl.uniform1i(gl.getUniformLocation(program, 'numSkinningJoints'), 0);
	        gl.uniform4fv(gl.getUniformLocation(program, 'skinningJoints'), node.presentation._worldTransform.float32Array3x4f());
	      }

	      // TODO: buffer dynamic vertex data

	      var geometryCount = node.presentation.geometry.geometryElements.length;
	      if (geometryCount === 0) {
	        throw new Error('geometryCount: 0');
	      }
	      for (var i = 0; i < geometryCount; i++) {
	        var vao = node.presentation.geometry._vertexArrayObjects[i];
	        var element = node.presentation.geometry.geometryElements[i];
	        var material = node.presentation.geometry.materials[i];

	        gl.bindVertexArray(vao);

	        gl.uniform4fv(gl.getUniformLocation(program, 'materialAmbient'), material.ambient.float32Array());
	        gl.uniform4fv(gl.getUniformLocation(program, 'materialDiffuse'), material.diffuse.float32Array());
	        gl.uniform4fv(gl.getUniformLocation(program, 'materialSpecular'), material.specular.float32Array());
	        gl.uniform4fv(gl.getUniformLocation(program, 'materialEmission'), material.emission.float32Array());

	        //console.log(`materialDiffuse: ${material.diffuse.float32Array()}`)

	        if (material.diffuse.contents instanceof Image) {
	          material.diffuse.contents = this._createTexture(material.diffuse.contents);
	        }
	        if (material.diffuse.contents instanceof WebGLTexture) {
	          gl.uniform1i(gl.getUniformLocation(program, 'u_useDiffuseTexture'), 1);
	          gl.activeTexture(gl.TEXTURE2);
	          gl.bindTexture(gl.TEXTURE_2D, material.diffuse.contents);
	          // FIXME: use material params
	          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
	          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
	          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
	          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
	        } else {
	          gl.uniform1i(gl.getUniformLocation(program, 'u_useDiffuseTexture'), 0);
	        }

	        gl.drawElements(gl.TRIANGLES, element._glData.length, gl.UNSIGNED_SHORT, 0);
	      }
	    }

	    /**
	     * Renders the scene’s contents at the specified system time in the renderer’s OpenGL context.
	     * @access public
	     * @param {number} time - The timestamp, in seconds, at which to render the scene.
	     * @returns {void}
	     * @desc This method can be used only with an SCNRenderer object created with the SCNRenderer initializer. Call this method to tell SceneKit to draw the renderer’s scene into the OpenGL context you created the renderer with.When you call this method, SceneKit updates its hierarchy of presentation nodes based on the specified timestamp, and then draws the scene.NoteBy default, the playback timing of actions and animations in a scene is based on the system time, not the scene time. Before using this method to control the playback of animations, set the usesSceneTimeBase property of each animation to true, or specify the playUsingSceneTimeBase option when loading a scene file that contains animations.
	     * @see https://developer.apple.com/reference/scenekit/scnrenderer/1518402-render
	     */

	  }, {
	    key: 'renderAtTime',
	    value: function renderAtTime(time) {}

	    // Capturing a Snapshot

	    /**
	     * Creates an image by drawing the renderer’s content at the specified system time.
	     * @access public
	     * @param {number} time - The timestamp, in seconds, at which to render the scene.
	     * @param {CGSize} size - The size, in pixels, of the image to create.
	     * @param {SCNAntialiasingMode} antialiasingMode - The antialiasing mode to use for the image output.
	     * @returns {Image} - 
	     * @desc When you call this method, SceneKit updates its hierarchy of presentation nodes based on the specified timestamp, and then draws the scene into a new image object of the specified size.
	     * @see https://developer.apple.com/reference/scenekit/scnrenderer/1641767-snapshot
	     */

	  }, {
	    key: 'snapshotAtTimeWith',
	    value: function snapshotAtTimeWith(time, size, antialiasingMode) {
	      return null;
	    }

	    // Instance Methods

	    /**
	     * 
	     * @access public
	     * @param {SCNNode[]} lightProbes - 
	     * @param {number} time - 
	     * @returns {void}
	     * @see https://developer.apple.com/reference/scenekit/scnrenderer/2097153-updateprobes
	     */

	  }, {
	    key: 'updateProbesAtTime',
	    value: function updateProbesAtTime(lightProbes, time) {}

	    //////////////////////
	    // SCNSceneRenderer //
	    //////////////////////

	    // Presenting a Scene

	    /**
	     * Required. Displays the specified scene with an animated transition.
	     * @access public
	     * @param {SCNScene} scene - The new scene to be displayed.
	     * @param {SKTransition} transition - An object that specifies the duration and style of the animated transition.
	     * @param {?SCNNode} pointOfView - The node to use as the pointOfView property when displaying the new scene.
	     * @param {?function(): void} [completionHandler = null] - A block that SceneKit calls after the transition animation has completed.This block takes no parameters and has no return value.
	     * @returns {void}
	     * @desc Use this method to change the scene displayed in a SceneKit view (or other renderer) with an animated transition. For details on transition styles, see SKTransition.
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1523028-present
	     */

	  }, {
	    key: 'presentWithIncomingPointOfView',
	    value: function presentWithIncomingPointOfView(scene, transition, pointOfView) {
	      var completionHandler = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
	    }

	    // Managing Scene Display
	    /**
	     * Required. The graphics technology SceneKit uses to render the scene.
	     * @type {SCNRenderingAPI}
	     * @desc You choose a graphics technology when initializing a scene renderer:When initializing a SCNView object, use the init(frame:options:) initializer and the preferredRenderingAPI key. Alternatively, create a view in Interface Builder and use the Rendering API control in the inspector. During initialization, the view will attempt to use the preferred API, but will fall back to a different API if the preferred one is not supported on the current hardware.To create a SCNRenderer object that renders into your own OpenGL contect, use the init(context:options:) initializer. To create a renderer for use in your own Metal workflow, use the init(device:options:) initializer.The rendering technology used by a SCNLayer object is determined by Core Animation.After initializing a renderer, this property reflects the rendering technology in use.
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1522616-renderingapi
	     */

	  }, {
	    key: 'prepareShouldAbortBlock',


	    // Preloading Renderer Resources

	    /**
	     * Required. Prepares a SceneKit object for rendering.
	     * @access public
	     * @param {Object} object - An SCNScene, SCNNode, SCNGeometry, or SCNMaterial instance.
	     * @param {?function(): boolean} [block = null] - A block that SceneKit calls periodically while preparing the object. The block takes no parameters.Your block should return false to tell SceneKit to continue preparing the object, or true to cancel preparation.Pass nil for this parameter if you do not need an opportunity to cancel preparing the object.
	     * @returns {boolean} - 
	     * @desc By default, SceneKit lazily loads resources onto the GPU for rendering. This approach uses memory and GPU bandwidth efficiently, but can lead to stutters in an otherwise smooth frame rate when you add large amounts of new content to an animated scene. To avoid such issues, use this method to prepare content for drawing before adding it to the scene. You can call this method on a secondary thread to prepare content asynchronously. SceneKit prepares all content associated with the object parameter you provide. If you provide an SCNMaterial object, SceneKit loads any texture images assigned to its material properties. If you provide an SCNGeometry object, SceneKit loads all materials attached to the geometry, as well as its vertex data. If you provide an SCNNode or SCNScene object, SceneKit loads all geometries and materials associated with the node and all its child nodes, or with the entire node hierarchy of the scene.You can use the block parameter to cancel preparation if content is no longer needed. For example, in a game you might use this method to preload areas of the game world the player is soon to enter, but if the player character dies before entering those areas, you can return true from the block to cancel preloading.You can observe the progress of this operation with the Progress class. For details, see Progress.
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1522798-prepare
	     */
	    value: function prepareShouldAbortBlock(object) {
	      var block = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

	      return false;
	    }

	    /**
	     * Required. Prepares the specified SceneKit objects for rendering, using a background thread.
	     * @access public
	     * @param {Object[]} objects - An array of containing one or more SCNScene, SCNNode, SCNGeometry, or SCNMaterial instances.
	     * @param {?function(arg1: boolean): void} [completionHandler = null] - A block that SceneKit calls when object preparation fails or completes.The block takes the following parameter:successtrue if all content was successfully prepared for rendering; otherwise, false.
	     * @returns {void}
	     * @desc By default, SceneKit lazily loads resources onto the GPU for rendering. This approach uses memory and GPU bandwidth efficiently, but can lead to stutters in an otherwise smooth frame rate when you add large amounts of new content to an animated scene. To avoid such issues, use this method to prepare content for drawing before adding it to the scene. SceneKit uses a secondary thread to prepare content asynchronously.SceneKit prepares all content associated with the objects you provide. If you provide an SCNMaterial object, SceneKit loads any texture images assigned to its material properties. If you provide an SCNGeometry object, SceneKit loads all materials attached to the geometry, as well as its vertex data. If you provide an SCNNode or SCNScene object, SceneKit loads all geometries and materials associated with the node and all its child nodes, or with the entire node hierarchy of the scene.You can observe the progress of this operation with the Progress class. For details, see Progress.
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1523375-prepare
	     */

	  }, {
	    key: 'prepare',
	    value: function prepare(objects) {
	      var completionHandler = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
	    }

	    // Working With Projected Scene Contents

	    /**
	     * Required. Searches the renderer’s scene for objects corresponding to a point in the rendered image.
	     * @access public
	     * @param {CGPoint} point - 
	     * @param {?Map<SCNHitTestOption, Object>} [options = null] - A dictionary of options affecting the search. See Hit Testing Options Keys for acceptable values.
	     * @returns {SCNHitTestResult[]} - 
	     * @desc A 2D point in the rendered screen coordinate space can refer to any point along a line segment in the 3D scene coordinate space. Hit-testing is the process of finding elements of a scene located along this line segment. For example, you can use this method to find the geometry corresponding to a click event in a SceneKit view.
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1522929-hittest
	     */

	  }, {
	    key: 'hitTest',
	    value: function hitTest(point) {
	      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

	      return null;
	    }

	    /**
	     * Required. Returns a Boolean value indicating whether a node might be visible from a specified point of view.
	     * @access public
	     * @param {SCNNode} node - The node whose visibility is to be tested.
	     * @param {SCNNode} pointOfView - A node defining a point of view, as used by the pointOfView property.
	     * @returns {boolean} - 
	     * @desc Any node containing a camera or spotlight may serve as a point of view (see the pointOfView property for details). Such a node defines a viewing frustum—a portion of the scene’s coordinate space, shaped like a truncated pyramid, that encloses all points visible from that point of view.Use this method to test whether a node lies within the viewing frustum defined by another node (which may or may not be the scene renderer’s current pointOfView node). For example, in a game scene containing multiple camera nodes, you could use this method to determine which camera is currently best for viewing a moving player character.Note that this method does not perform occlusion testing. That is, it returns true if the tested node lies within the specified viewing frustum regardless of whether that node’s contents are obscured by other geometry.
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1522647-isnode
	     */

	  }, {
	    key: 'isNodeInsideFrustumOf',
	    value: function isNodeInsideFrustumOf(node, pointOfView) {
	      return false;
	    }

	    /**
	     * Required. Returns all nodes that might be visible from a specified point of view.
	     * @access public
	     * @param {SCNNode} pointOfView - A node defining a point of view, as used by the pointOfView property.
	     * @returns {SCNNode[]} - 
	     * @desc Any node containing a camera or spotlight may serve as a point of view (see the pointOfView property for details). Such a node defines a viewing frustum—a portion of the scene’s coordinate space, shaped like a truncated pyramid, that encloses all points visible from that point of view.Use this method find all nodes whose content lies within the viewing frustum defined by another node (which may or may not be the scene renderer’s current pointOfView node).Note that this method does not perform occlusion testing. That is, the returned array includes any node that lies within the specified viewing frustum regardless of whether that node’s contents are obscured by other geometry.
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1522942-nodesinsidefrustum
	     */

	  }, {
	    key: 'nodesInsideFrustumOf',
	    value: function nodesInsideFrustumOf(pointOfView) {
	      return null;
	    }

	    /**
	     * Required. Projects a point from the 3D world coordinate system of the scene to the 2D pixel coordinate system of the renderer.
	     * @access public
	     * @param {SCNVector3} point - A point in the world coordinate system of the renderer’s scene.
	     * @returns {SCNVector3} - 
	     * @desc The z-coordinate of the returned point describes the depth of the projected point relative to the near and far clipping planes of the renderer’s viewing frustum (defined by its pointOfView node). Projecting a point on the near clipping plane returns a point whose z-coordinate is 0.0; projecting a point on the far clipping plane returns a point whose z-coordinate is 1.0.
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1524089-projectpoint
	     */

	  }, {
	    key: 'projectPoint',
	    value: function projectPoint(point) {
	      return null;
	    }

	    /**
	     * Required. Unprojects a point from the 2D pixel coordinate system of the renderer to the 3D world coordinate system of the scene.
	     * @access public
	     * @param {SCNVector3} point - A point in the screen-space (view, layer, or GPU viewport) coordinate system of the scene renderer.
	     * @returns {SCNVector3} - 
	     * @desc The z-coordinate of the point parameter describes the depth at which to unproject the point relative to the near and far clipping planes of the renderer’s viewing frustum (defined by its pointOfView node). Unprojecting a point whose z-coordinate is 0.0 returns a point on the near clipping plane; unprojecting a point whose z-coordinate is 1.0 returns a point on the far clipping plane.A 2D point in the rendered screen coordinate space can refer to any point along a line segment in the 3D scene coordinate space. To test for scene contents along this line—for example, to find the geometry corresponding to the location of a click event in a view—use the hitTest(_:options:) method.
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1522631-unprojectpoint
	     */

	  }, {
	    key: 'unprojectPoint',
	    value: function unprojectPoint(point) {
	      return null;
	    }

	    // Customizing Scene Rendering with Metal
	    /**
	     * Required. The Metal render command encoder in use for the current SceneKit rendering pass.
	     * @type {?MTLRenderCommandEncoder}
	     * @desc Use this render command encoder to encode additional rendering commands before or after SceneKit draws its own content.This property is valid only during the SceneKit rendering loop—that is, within one of the methods defined in the SCNSceneRendererDelegate protocol. Accessing this property at any other time returns nil.
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1522609-currentrendercommandencoder
	     */

	  }, {
	    key: '_setContext',
	    value: function _setContext(context) {
	      this._context = context;
	      this._createDummyTexture();
	    }

	    // Working With Positional Audio

	    /**
	     * Required. The 3D audio mixing node SceneKit uses for positional audio effects.
	     * @type {AVAudioEnvironmentNode}
	     * @desc SceneKit uses this audio node to spatialize sounds from SCNAudioPlayer objects attached to nodes in the scene. You can use this object in conjunction with the audioEngine property to rearrange the audio graph to add other, non-spatialized audio sources or mix in audio processing effects.
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1523582-audioenvironmentnode
	     */

	  }, {
	    key: '_initializeVAO',
	    value: function _initializeVAO(node, program) {
	      var gl = this.context;
	      var geometry = node.presentation.geometry;
	      var baseGeometry = node.geometry;

	      // prepare vertex array data
	      var vertexBuffer = geometry._createVertexBuffer(gl, baseGeometry);
	      // TODO: retain attribute locations
	      var positionLoc = gl.getAttribLocation(program, 'position');
	      var normalLoc = gl.getAttribLocation(program, 'normal');
	      var texcoordLoc = gl.getAttribLocation(program, 'texcoord');
	      var boneIndicesLoc = gl.getAttribLocation(program, 'boneIndices');
	      var boneWeightsLoc = gl.getAttribLocation(program, 'boneWeights');

	      geometry._vertexArrayObjects = [];
	      var elementCount = node.presentation.geometry.geometryElements.length;
	      for (var i = 0; i < elementCount; i++) {
	        var element = node.presentation.geometry.geometryElements[i];
	        var material = node.presentation.geometry.materials[i];
	        var vao = gl.createVertexArray();
	        gl.bindVertexArray(vao);

	        // initialize vertex buffer
	        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);

	        gl.bindAttribLocation(program, positionLoc, 'position');
	        gl.bindAttribLocation(program, normalLoc, 'normal');
	        gl.bindAttribLocation(program, texcoordLoc, 'texcoord');
	        gl.bindAttribLocation(program, boneIndicesLoc, 'boneIndices');
	        gl.bindAttribLocation(program, boneWeightsLoc, 'boneWeights');

	        // vertexAttribPointer(ulong idx, long size, ulong type, bool norm, long stride, ulong offset)

	        // position
	        var posSrc = geometry.getGeometrySourcesForSemantic(_SCNGeometrySource2.default.Semantic.vertex)[0];
	        if (posSrc) {
	          //console.log(`posSrc: ${positionLoc}, ${posSrc.componentsPerVector}, ${posSrc.dataStride}, ${posSrc.dataOffset}`)
	          gl.enableVertexAttribArray(positionLoc);
	          gl.vertexAttribPointer(positionLoc, posSrc.componentsPerVector, gl.FLOAT, false, posSrc.dataStride, posSrc.dataOffset);
	        } else {
	          gl.disableVertexAttribArray(positionLoc);
	        }

	        // normal
	        var nrmSrc = geometry.getGeometrySourcesForSemantic(_SCNGeometrySource2.default.Semantic.normal)[0];
	        if (nrmSrc) {
	          //console.log(`nrmSrc: ${normalLoc}, ${nrmSrc.componentsPerVector}, ${nrmSrc.dataStride}, ${nrmSrc.dataOffset}`)
	          gl.enableVertexAttribArray(normalLoc);
	          gl.vertexAttribPointer(normalLoc, nrmSrc.componentsPerVector, gl.FLOAT, false, nrmSrc.dataStride, nrmSrc.dataOffset);
	        } else {
	          gl.disableVertexAttribArray(normalLoc);
	        }

	        // texcoord
	        var texSrc = geometry.getGeometrySourcesForSemantic(_SCNGeometrySource2.default.Semantic.texcoord)[0];
	        if (texSrc) {
	          //console.log(`texSrc: ${texcoordLoc}, ${texSrc.componentsPerVector}, ${texSrc.dataStride}, ${texSrc.dataOffset}`)
	          gl.enableVertexAttribArray(texcoordLoc);
	          gl.vertexAttribPointer(texcoordLoc, texSrc.componentsPerVector, gl.FLOAT, false, texSrc.dataStride, texSrc.dataOffset);
	        } else {
	          gl.disableVertexAttribArray(texcoordLoc);
	        }

	        // boneIndices
	        var indSrc = geometry.getGeometrySourcesForSemantic(_SCNGeometrySource2.default.Semantic.boneIndices)[0];
	        if (indSrc) {
	          //console.log(`indSrc: ${boneIndicesLoc}, ${indSrc.componentsPerVector}, ${indSrc.dataStride}, ${indSrc.dataOffset}`)
	          gl.enableVertexAttribArray(boneIndicesLoc);
	          gl.vertexAttribPointer(boneIndicesLoc, indSrc.componentsPerVector, gl.FLOAT, false, indSrc.dataStride, indSrc.dataOffset);
	        } else {
	          gl.disableVertexAttribArray(boneIndicesLoc);
	        }

	        // boneWeights
	        var wgtSrc = geometry.getGeometrySourcesForSemantic(_SCNGeometrySource2.default.Semantic.boneWeights)[0];
	        if (wgtSrc) {
	          //console.log(`wgtSrc: ${boneWeightsLoc}, ${wgtSrc.componentsPerVector}, ${wgtSrc.dataStride}, ${wgtSrc.dataOffset}`)
	          gl.enableVertexAttribArray(boneWeightsLoc);
	          gl.vertexAttribPointer(boneWeightsLoc, wgtSrc.componentsPerVector, gl.FLOAT, false, wgtSrc.dataStride, wgtSrc.dataOffset);
	        } else {
	          gl.disableVertexAttribArray(boneWeightsLoc);
	        }

	        // FIXME: use setting
	        gl.disable(gl.CULL_FACE);

	        // initialize index buffer
	        // FIXME: check geometrySource semantic
	        var indexBuffer = element._createBuffer(gl);
	        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);

	        geometry._vertexArrayObjects.push(vao);
	      }
	    }
	  }, {
	    key: '_updateVAO',
	    value: function _updateVAO(node) {
	      var gl = this.context;
	      var geometry = node.presentation.geometry;
	      var baseGeometry = node.geometry;
	      //gl.bindVertexArray(vao)
	      //gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer)

	      geometry._updateVertexBuffer(gl, baseGeometry);
	    }
	  }, {
	    key: '_createDummyTexture',
	    value: function _createDummyTexture() {
	      var _this4 = this;

	      var gl = this.context;
	      var image = new Image();
	      image.width = 1;
	      image.height = 1;

	      var canvas = document.createElement('canvas');
	      canvas.width = 1;
	      canvas.height = 1;
	      var context = canvas.getContext('2d');
	      context.fillStyle = 'rgba(255, 255, 255, 1.0)';
	      context.fillRect(0, 0, 1, 1);

	      this.__dummyTexture = gl.createTexture();

	      image.onload = function () {
	        gl.bindTexture(gl.TEXTURE_2D, _this4.__dummyTexture);
	        // texImage2D(target, level, internalformat, width, height, border, format, type, source)
	        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, image);
	        gl.bindTexture(gl.TEXTURE_2D, null);
	        _this4._setDummyTextureAsDefault();
	      };
	      //console.log('canvas.toDataURL: ' + canvas.toDataURL())
	      image.src = canvas.toDataURL();
	    }
	  }, {
	    key: '_setDummyTextureAsDefault',
	    value: function _setDummyTextureAsDefault() {
	      var gl = this.context;
	      var p = this._defaultProgram;

	      var texNames = [gl.TEXTURE0, gl.TEXTURE1, gl.TEXTURE2, gl.TEXTURE3, gl.TEXTURE4, gl.TEXTURE5, gl.TEXTURE6, gl.TEXTURE7];
	      var texSymbols = ['u_emissionTexture', 'u_ambientTexture', 'u_diffuseTexture', 'u_specularTexture', 'u_reflectiveTexture', 'u_transparentTexture', 'u_multiplyTexture', 'u_normalTexture'];
	      for (var i = 0; i < texNames.length; i++) {
	        var texName = texNames[i];
	        var symbol = texSymbols[i];
	        gl.uniform1i(gl.getUniformLocation(p._glProgram, symbol), i);
	        gl.activeTexture(texName);
	        gl.bindTexture(gl.TEXTURE_2D, this.__dummyTexture);
	      }
	    }

	    /**
	     * @access private
	     * @param {Image} image -
	     * @returns {WebGLTexture} -
	     */

	  }, {
	    key: '_createTexture',
	    value: function _createTexture(image) {
	      var gl = this.context;
	      var texture = gl.createTexture();

	      //console.log(`_createTexture: size: ${image.width}, ${image.height}`)

	      gl.bindTexture(gl.TEXTURE_2D, texture);
	      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, image.width, image.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, image);
	      gl.bindTexture(gl.TEXTURE_2D, null);
	      return texture;
	    }
	  }, {
	    key: 'nextFrameTime',
	    get: function get() {
	      return this._nextFrameTime;
	    }
	  }, {
	    key: 'renderingAPI',
	    get: function get() {
	      return this._renderingAPI;
	    }
	  }, {
	    key: 'currentRenderCommandEncoder',
	    get: function get() {
	      return this._currentRenderCommandEncoder;
	    }

	    /**
	     * Required. The Metal device this renderer uses for rendering.
	     * @type {?MTLDevice}
	     * @desc Use this property to create or look up other Metal resources that use the same device as your SceneKit renderer.NoteThis property is valid only for scene renderers whose renderingAPI value is metal. You create a SceneKit view that renders using Metal with the preferredRenderingAPI initialization option or in Interface Builder, or an SCNRenderer that uses Metal with the init(device:options:) method. For OpenGL-based scene renderers, this property’s value is always nil.
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1523935-device
	     */

	  }, {
	    key: 'device',
	    get: function get() {
	      return this._device;
	    }

	    /**
	     * Required. The Metal command queue this renderer uses for rendering.
	     * @type {?MTLCommandQueue}
	     * @desc Use this property to schedule additional command buffers for the Metal device to execute as part of the render cycle. For example, you can use a compute command encoder to modify the vertex data in a Metal buffer for use by a SCNGeometrySource object.NoteThis property is valid only for scene renderers whose renderingAPI value is metal. You create a SceneKit view that renders using Metal with the preferredRenderingAPI initialization option or in Interface Builder, or an SCNRenderer that uses Metal with the init(device:options:) method. For OpenGL-based scene renderers, this property’s value is always nil.
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1523974-commandqueue
	     */

	  }, {
	    key: 'commandQueue',
	    get: function get() {
	      return this._commandQueue;
	    }

	    /**
	     * Required. The Metal pixel format for the renderer’s color output.
	     * @type {MTLPixelFormat}
	     * @desc Use this property, along with the depthPixelFormat and stencilPixelFormat properties, if you perform custom drawing with Metal (see the SCNSceneRendererDelegate and SCNNodeRendererDelegate classes) and need to create a new MTLRenderPipelineState object to change the GPU state as part of your rendering.NoteThis property is valid only for scene renderers whose renderingAPI value is metal. You create a SceneKit view that renders using Metal with the preferredRenderingAPI initialization option or in Interface Builder, or an SCNRenderer that uses Metal with the init(device:options:) method. For OpenGL-based scene renderers, this property’s value is always nil.
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1523701-colorpixelformat
	     */

	  }, {
	    key: 'colorPixelFormat',
	    get: function get() {
	      return this._colorPixelFormat;
	    }

	    /**
	     * Required. The Metal pixel format for the renderer’s depth buffer.
	     * @type {MTLPixelFormat}
	     * @desc Use this property, along with the colorPixelFormat and stencilPixelFormat properties, if you perform custom drawing with Metal (see the SCNSceneRendererDelegate and SCNNodeRendererDelegate classes) and need to create a new MTLRenderPipelineState object to change the GPU state as part of your rendering.NoteThis property is valid only for scene renderers whose renderingAPI value is metal. You create a SceneKit view that renders using Metal with the preferredRenderingAPI initialization option or in Interface Builder, or an SCNRenderer that uses Metal with the init(device:options:) method. For OpenGL-based scene renderers, this property’s value is always nil.
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1523780-depthpixelformat
	     */

	  }, {
	    key: 'depthPixelFormat',
	    get: function get() {
	      return this._depthPixelFormat;
	    }

	    /**
	     * Required. The Metal pixel format for the renderer’s stencil buffer.
	     * @type {MTLPixelFormat}
	     * @desc Use this property, along with the depthPixelFormat and colorPixelFormat properties, if you perform custom drawing with Metal (see the SCNSceneRendererDelegate and SCNNodeRendererDelegate classes) and need to create a new MTLRenderPipelineState object to change the GPU state as part of your rendering.NoteThis property is valid only for scene renderers whose renderingAPI value is metal. You create a SceneKit view that renders using Metal with the preferredRenderingAPI initialization option or in Interface Builder, or an SCNRenderer that uses Metal with the init(device:options:) method. For OpenGL-based scene renderers, this property’s value is always nil.
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1523315-stencilpixelformat
	     */

	  }, {
	    key: 'stencilPixelFormat',
	    get: function get() {
	      return this._stencilPixelFormat;
	    }

	    // Customizing Scene Rendering with OpenGL

	    /**
	     * Required. The OpenGL rendering context that SceneKit uses for rendering the scene.
	     * @type {?Object}
	     * @desc In macOS, the value of this property is a Core OpenGL cglContextObj object.In iOS, the value of this property is an EAGLContext object.
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1522840-context
	     */

	  }, {
	    key: 'context',
	    get: function get() {
	      return this._context;
	    }
	  }, {
	    key: 'audioEnvironmentNode',
	    get: function get() {
	      return this._audioEnvironmentNode;
	    }

	    /**
	     * Required. The audio engine SceneKit uses for playing scene sounds.
	     * @type {AVAudioEngine}
	     * @desc SceneKit uses this audio engine to play sounds from SCNAudioPlayer objects attached to nodes in the scene. You can use this object directly to add other sound sources not related to scene contents, or to add other sound processing nodes or mixing nodes to the audio engine. To identify the node SceneKit uses for spatializing scene sounds when connecting other nodes, use the audioEnvironmentNode property.
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1522686-audioengine
	     */

	  }, {
	    key: 'audioEngine',
	    get: function get() {
	      return this._audioEngine;
	    }

	    /**
	     * @access private
	     * @type {SCNProgram}
	     */

	  }, {
	    key: '_defaultProgram',
	    get: function get() {
	      if (this.__defaultProgram !== null) {
	        return this.__defaultProgram;
	      }
	      var p = new _SCNProgram2.default();
	      this.__defaultProgram = p;

	      var gl = this.context;
	      p._glProgram = gl.createProgram();

	      // initialize vertex shader
	      var vertexShader = gl.createShader(gl.VERTEX_SHADER);
	      gl.shaderSource(vertexShader, _defaultVertexShader);
	      gl.compileShader(vertexShader);
	      if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
	        var info = gl.getShaderInfoLog(vertexShader);
	        throw new Error('vertex shader compile error: ' + info);
	      }

	      // initialize fragment shader
	      var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
	      gl.shaderSource(fragmentShader, _defaultFragmentShader);
	      gl.compileShader(fragmentShader);
	      if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
	        var _info = gl.getShaderInfoLog(fragmentShader);
	        throw new Error('fragment shader compile error: ' + _info);
	      }

	      gl.attachShader(p._glProgram, vertexShader);
	      gl.attachShader(p._glProgram, fragmentShader);

	      // link program object
	      gl.linkProgram(p._glProgram);
	      if (!gl.getProgramParameter(p._glProgram, gl.LINK_STATUS)) {
	        var _info2 = gl.getProgramInfoLog(p._glProgram);
	        throw new Error('program link error: ' + _info2);
	      }

	      gl.useProgram(p._glProgram);
	      gl.clearColor(1, 1, 1, 1); // DEBUG
	      gl.clearDepth(1.0);
	      gl.clearStencil(0);

	      gl.enable(gl.DEPTH_TEST);
	      gl.depthFunc(gl.LEQUAL);
	      gl.enable(gl.BLEND);
	      gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
	      gl.enable(gl.CULL_FACE);
	      gl.cullFace(gl.BACK);

	      return this.__defaultProgram;
	    }
	  }, {
	    key: '_dummyTexture',
	    get: function get() {
	      return this.__dummyTexture;
	    }
	  }]);

	  return SCNRenderer;
	}(_NSObject3.default);

	exports.default = SCNRenderer;

/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _SCNScene = __webpack_require__(43);

	var _SCNScene2 = _interopRequireDefault(_SCNScene);

	var _SCNNode = __webpack_require__(33);

	var _SCNNode2 = _interopRequireDefault(_SCNNode);

	var _SCNDebugOptions = __webpack_require__(72);

	var _SCNDebugOptions2 = _interopRequireDefault(_SCNDebugOptions);

	var _SCNRenderingAPI = __webpack_require__(73);

	var _SCNRenderingAPI2 = _interopRequireDefault(_SCNRenderingAPI);

	var _SCNHitTestResult = __webpack_require__(58);

	var _SCNHitTestResult2 = _interopRequireDefault(_SCNHitTestResult);

	var _CGPoint = __webpack_require__(5);

	var _CGPoint2 = _interopRequireDefault(_CGPoint);

	var _SCNHitTestOption = __webpack_require__(74);

	var _SCNHitTestOption2 = _interopRequireDefault(_SCNHitTestOption);

	var _SCNVector = __webpack_require__(15);

	var _SCNVector2 = _interopRequireDefault(_SCNVector);

	var _SCNSceneRendererDelegate = __webpack_require__(75);

	var _SCNSceneRendererDelegate2 = _interopRequireDefault(_SCNSceneRendererDelegate);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	/**
	 * Methods and properties common to the SCNView, SCNLayer and SCNRenderer classes.
	 * @interface
	 * @see https://developer.apple.com/reference/scenekit/scnscenerenderer
	 */
	var SCNSceneRenderer = function () {
	  /**
	   * constructor
	   * @access public
	   * @returns {void}
	   */
	  function SCNSceneRenderer() {
	    _classCallCheck(this, SCNSceneRenderer);

	    // Presenting a Scene

	    /**
	     * Required. The scene to be displayed.
	     * @type {?SCNScene}
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1523956-scene
	     */
	    this.scene = null;

	    // Managing Scene Display

	    /**
	     * Required. The node from which the scene’s contents are viewed for rendering.
	     * @type {?SCNNode}
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1523982-pointofview
	     */
	    this.pointOfView = null;

	    /**
	     * Required. A Boolean value that determines whether SceneKit automatically adds lights to a scene.
	     * @type {boolean}
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1523812-autoenablesdefaultlighting
	     */
	    this.autoenablesDefaultLighting = false;

	    /**
	     * Required. A Boolean value that determines whether SceneKit applies jittering to reduce aliasing artifacts.
	     * @type {boolean}
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1524026-isjitteringenabled
	     */
	    this.isJitteringEnabled = false;

	    /**
	     * Required. A Boolean value that determines whether SceneKit displays rendering performance statistics in an accessory view.
	     * @type {boolean}
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1522763-showsstatistics
	     */
	    this.showsStatistics = false;

	    /**
	     * Required. Options for drawing overlay content in a scene that can aid debugging.
	     * @type {SCNDebugOptions}
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1523281-debugoptions
	     */
	    this.debugOptions = null;

	    this._renderingAPI = null;

	    // Managing Scene Animation Timing

	    /**
	     * Required. The current scene time.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1522680-scenetime
	     */
	    this.sceneTime = 0;

	    /**
	     * Required. A Boolean value that determines whether the scene is playing.
	     * @type {boolean}
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1523401-isplaying
	     */
	    this.isPlaying = false;

	    /**
	     * Required. A Boolean value that determines whether SceneKit restarts the scene time after all animations in the scene have played.
	     * @type {boolean}
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1522878-loops
	     */
	    this.loops = false;

	    // Participating in the Scene Rendering Process

	    /**
	     * Required. A delegate object that receives messages about SceneKit’s rendering process.
	     * @type {?SCNSceneRendererDelegate}
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1522671-delegate
	     */
	    this.delegate = null;

	    // Customizing Scene Rendering with Metal

	    this._currentRenderCommandEncoder = null;
	    this._device = null;
	    this._commandQueue = null;
	    this._colorPixelFormat = null;
	    this._depthPixelFormat = null;
	    this._stencilPixelFormat = null;

	    // Customizing Scene Rendering with OpenGL

	    this._context = null;

	    // Rendering Sprite Kit Content over a Scene

	    /**
	     * Required. A Sprite Kit scene to be rendered on top of the SceneKit content.
	     * @type {?SKScene}
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1524051-overlayskscene
	     */
	    this.overlaySKScene = null;

	    // Working With Positional Audio

	    /**
	     * Required. The node representing the listener’s position in the scene for use with positional audio effects.
	     * @type {?SCNNode}
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1523747-audiolistener
	     */
	    this.audioListener = null;

	    this._audioEnvironmentNode = null;
	    this._audioEngine = null;

	    // Instance Properties

	    /**
	     * Required. 
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1522854-currenttime
	     */
	    this.currentTime = 0;
	  }

	  // Presenting a Scene

	  /**
	   * Required. Displays the specified scene with an animated transition.
	   * @access public
	   * @param {SCNScene} scene - The new scene to be displayed.
	   * @param {SKTransition} transition - An object that specifies the duration and style of the animated transition.
	   * @param {?SCNNode} pointOfView - The node to use as the pointOfView property when displaying the new scene.
	   * @param {?function(): void} [completionHandler = null] - A block that SceneKit calls after the transition animation has completed.This block takes no parameters and has no return value.
	   * @returns {void}
	   * @desc Use this method to change the scene displayed in a SceneKit view (or other renderer) with an animated transition. For details on transition styles, see SKTransition.
	   * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1523028-present
	   */


	  _createClass(SCNSceneRenderer, [{
	    key: 'presentWithIncomingPointOfView',
	    value: function presentWithIncomingPointOfView(scene, transition, pointOfView) {
	      var completionHandler = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
	    }

	    // Managing Scene Display
	    /**
	     * Required. The graphics technology SceneKit uses to render the scene.
	     * @type {SCNRenderingAPI}
	     * @desc You choose a graphics technology when initializing a scene renderer:When initializing a SCNView object, use the init(frame:options:) initializer and the preferredRenderingAPI key. Alternatively, create a view in Interface Builder and use the Rendering API control in the inspector. During initialization, the view will attempt to use the preferred API, but will fall back to a different API if the preferred one is not supported on the current hardware.To create a SCNRenderer object that renders into your own OpenGL contect, use the init(context:options:) initializer. To create a renderer for use in your own Metal workflow, use the init(device:options:) initializer.The rendering technology used by a SCNLayer object is determined by Core Animation.After initializing a renderer, this property reflects the rendering technology in use.
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1522616-renderingapi
	     */

	  }, {
	    key: 'prepareShouldAbortBlock',


	    // Preloading Renderer Resources

	    /**
	     * Required. Prepares a SceneKit object for rendering.
	     * @access public
	     * @param {Object} object - An SCNScene, SCNNode, SCNGeometry, or SCNMaterial instance.
	     * @param {?function(): boolean} [block = null] - A block that SceneKit calls periodically while preparing the object. The block takes no parameters.Your block should return false to tell SceneKit to continue preparing the object, or true to cancel preparation.Pass nil for this parameter if you do not need an opportunity to cancel preparing the object.
	     * @returns {boolean} - 
	     * @desc By default, SceneKit lazily loads resources onto the GPU for rendering. This approach uses memory and GPU bandwidth efficiently, but can lead to stutters in an otherwise smooth frame rate when you add large amounts of new content to an animated scene. To avoid such issues, use this method to prepare content for drawing before adding it to the scene. You can call this method on a secondary thread to prepare content asynchronously. SceneKit prepares all content associated with the object parameter you provide. If you provide an SCNMaterial object, SceneKit loads any texture images assigned to its material properties. If you provide an SCNGeometry object, SceneKit loads all materials attached to the geometry, as well as its vertex data. If you provide an SCNNode or SCNScene object, SceneKit loads all geometries and materials associated with the node and all its child nodes, or with the entire node hierarchy of the scene.You can use the block parameter to cancel preparation if content is no longer needed. For example, in a game you might use this method to preload areas of the game world the player is soon to enter, but if the player character dies before entering those areas, you can return true from the block to cancel preloading.You can observe the progress of this operation with the Progress class. For details, see Progress.
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1522798-prepare
	     */
	    value: function prepareShouldAbortBlock(object) {
	      var block = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

	      return false;
	    }

	    /**
	     * Required. Prepares the specified SceneKit objects for rendering, using a background thread.
	     * @access public
	     * @param {Object[]} objects - An array of containing one or more SCNScene, SCNNode, SCNGeometry, or SCNMaterial instances.
	     * @param {?function(arg1: boolean): void} [completionHandler = null] - A block that SceneKit calls when object preparation fails or completes.The block takes the following parameter:successtrue if all content was successfully prepared for rendering; otherwise, false.
	     * @returns {void}
	     * @desc By default, SceneKit lazily loads resources onto the GPU for rendering. This approach uses memory and GPU bandwidth efficiently, but can lead to stutters in an otherwise smooth frame rate when you add large amounts of new content to an animated scene. To avoid such issues, use this method to prepare content for drawing before adding it to the scene. SceneKit uses a secondary thread to prepare content asynchronously.SceneKit prepares all content associated with the objects you provide. If you provide an SCNMaterial object, SceneKit loads any texture images assigned to its material properties. If you provide an SCNGeometry object, SceneKit loads all materials attached to the geometry, as well as its vertex data. If you provide an SCNNode or SCNScene object, SceneKit loads all geometries and materials associated with the node and all its child nodes, or with the entire node hierarchy of the scene.You can observe the progress of this operation with the Progress class. For details, see Progress.
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1523375-prepare
	     */

	  }, {
	    key: 'prepare',
	    value: function prepare(objects) {
	      var completionHandler = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
	    }

	    // Working With Projected Scene Contents

	    /**
	     * Required. Searches the renderer’s scene for objects corresponding to a point in the rendered image.
	     * @access public
	     * @param {CGPoint} point - 
	     * @param {?Map<SCNHitTestOption, Object>} [options = null] - A dictionary of options affecting the search. See Hit Testing Options Keys for acceptable values.
	     * @returns {SCNHitTestResult[]} - 
	     * @desc A 2D point in the rendered screen coordinate space can refer to any point along a line segment in the 3D scene coordinate space. Hit-testing is the process of finding elements of a scene located along this line segment. For example, you can use this method to find the geometry corresponding to a click event in a SceneKit view.
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1522929-hittest
	     */

	  }, {
	    key: 'hitTest',
	    value: function hitTest(point) {
	      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

	      return null;
	    }

	    /**
	     * Required. Returns a Boolean value indicating whether a node might be visible from a specified point of view.
	     * @access public
	     * @param {SCNNode} node - The node whose visibility is to be tested.
	     * @param {SCNNode} pointOfView - A node defining a point of view, as used by the pointOfView property.
	     * @returns {boolean} - 
	     * @desc Any node containing a camera or spotlight may serve as a point of view (see the pointOfView property for details). Such a node defines a viewing frustum—a portion of the scene’s coordinate space, shaped like a truncated pyramid, that encloses all points visible from that point of view.Use this method to test whether a node lies within the viewing frustum defined by another node (which may or may not be the scene renderer’s current pointOfView node). For example, in a game scene containing multiple camera nodes, you could use this method to determine which camera is currently best for viewing a moving player character.Note that this method does not perform occlusion testing. That is, it returns true if the tested node lies within the specified viewing frustum regardless of whether that node’s contents are obscured by other geometry.
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1522647-isnode
	     */

	  }, {
	    key: 'isNodeInsideFrustumOf',
	    value: function isNodeInsideFrustumOf(node, pointOfView) {
	      return false;
	    }

	    /**
	     * Required. Returns all nodes that might be visible from a specified point of view.
	     * @access public
	     * @param {SCNNode} pointOfView - A node defining a point of view, as used by the pointOfView property.
	     * @returns {SCNNode[]} - 
	     * @desc Any node containing a camera or spotlight may serve as a point of view (see the pointOfView property for details). Such a node defines a viewing frustum—a portion of the scene’s coordinate space, shaped like a truncated pyramid, that encloses all points visible from that point of view.Use this method find all nodes whose content lies within the viewing frustum defined by another node (which may or may not be the scene renderer’s current pointOfView node).Note that this method does not perform occlusion testing. That is, the returned array includes any node that lies within the specified viewing frustum regardless of whether that node’s contents are obscured by other geometry.
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1522942-nodesinsidefrustum
	     */

	  }, {
	    key: 'nodesInsideFrustumOf',
	    value: function nodesInsideFrustumOf(pointOfView) {
	      return null;
	    }

	    /**
	     * Required. Projects a point from the 3D world coordinate system of the scene to the 2D pixel coordinate system of the renderer.
	     * @access public
	     * @param {SCNVector3} point - A point in the world coordinate system of the renderer’s scene.
	     * @returns {SCNVector3} - 
	     * @desc The z-coordinate of the returned point describes the depth of the projected point relative to the near and far clipping planes of the renderer’s viewing frustum (defined by its pointOfView node). Projecting a point on the near clipping plane returns a point whose z-coordinate is 0.0; projecting a point on the far clipping plane returns a point whose z-coordinate is 1.0.
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1524089-projectpoint
	     */

	  }, {
	    key: 'projectPoint',
	    value: function projectPoint(point) {
	      return null;
	    }

	    /**
	     * Required. Unprojects a point from the 2D pixel coordinate system of the renderer to the 3D world coordinate system of the scene.
	     * @access public
	     * @param {SCNVector3} point - A point in the screen-space (view, layer, or GPU viewport) coordinate system of the scene renderer.
	     * @returns {SCNVector3} - 
	     * @desc The z-coordinate of the point parameter describes the depth at which to unproject the point relative to the near and far clipping planes of the renderer’s viewing frustum (defined by its pointOfView node). Unprojecting a point whose z-coordinate is 0.0 returns a point on the near clipping plane; unprojecting a point whose z-coordinate is 1.0 returns a point on the far clipping plane.A 2D point in the rendered screen coordinate space can refer to any point along a line segment in the 3D scene coordinate space. To test for scene contents along this line—for example, to find the geometry corresponding to the location of a click event in a view—use the hitTest(_:options:) method.
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1522631-unprojectpoint
	     */

	  }, {
	    key: 'unprojectPoint',
	    value: function unprojectPoint(point) {
	      return null;
	    }

	    // Customizing Scene Rendering with Metal
	    /**
	     * Required. The Metal render command encoder in use for the current SceneKit rendering pass.
	     * @type {?MTLRenderCommandEncoder}
	     * @desc Use this render command encoder to encode additional rendering commands before or after SceneKit draws its own content.This property is valid only during the SceneKit rendering loop—that is, within one of the methods defined in the SCNSceneRendererDelegate protocol. Accessing this property at any other time returns nil.
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1522609-currentrendercommandencoder
	     */

	  }, {
	    key: 'renderingAPI',
	    get: function get() {
	      return this._renderingAPI;
	    }
	  }, {
	    key: 'currentRenderCommandEncoder',
	    get: function get() {
	      return this._currentRenderCommandEncoder;
	    }

	    /**
	     * Required. The Metal device this renderer uses for rendering.
	     * @type {?MTLDevice}
	     * @desc Use this property to create or look up other Metal resources that use the same device as your SceneKit renderer.NoteThis property is valid only for scene renderers whose renderingAPI value is metal. You create a SceneKit view that renders using Metal with the preferredRenderingAPI initialization option or in Interface Builder, or an SCNRenderer that uses Metal with the init(device:options:) method. For OpenGL-based scene renderers, this property’s value is always nil.
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1523935-device
	     */

	  }, {
	    key: 'device',
	    get: function get() {
	      return this._device;
	    }

	    /**
	     * Required. The Metal command queue this renderer uses for rendering.
	     * @type {?MTLCommandQueue}
	     * @desc Use this property to schedule additional command buffers for the Metal device to execute as part of the render cycle. For example, you can use a compute command encoder to modify the vertex data in a Metal buffer for use by a SCNGeometrySource object.NoteThis property is valid only for scene renderers whose renderingAPI value is metal. You create a SceneKit view that renders using Metal with the preferredRenderingAPI initialization option or in Interface Builder, or an SCNRenderer that uses Metal with the init(device:options:) method. For OpenGL-based scene renderers, this property’s value is always nil.
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1523974-commandqueue
	     */

	  }, {
	    key: 'commandQueue',
	    get: function get() {
	      return this._commandQueue;
	    }

	    /**
	     * Required. The Metal pixel format for the renderer’s color output.
	     * @type {MTLPixelFormat}
	     * @desc Use this property, along with the depthPixelFormat and stencilPixelFormat properties, if you perform custom drawing with Metal (see the SCNSceneRendererDelegate and SCNNodeRendererDelegate classes) and need to create a new MTLRenderPipelineState object to change the GPU state as part of your rendering.NoteThis property is valid only for scene renderers whose renderingAPI value is metal. You create a SceneKit view that renders using Metal with the preferredRenderingAPI initialization option or in Interface Builder, or an SCNRenderer that uses Metal with the init(device:options:) method. For OpenGL-based scene renderers, this property’s value is always nil.
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1523701-colorpixelformat
	     */

	  }, {
	    key: 'colorPixelFormat',
	    get: function get() {
	      return this._colorPixelFormat;
	    }

	    /**
	     * Required. The Metal pixel format for the renderer’s depth buffer.
	     * @type {MTLPixelFormat}
	     * @desc Use this property, along with the colorPixelFormat and stencilPixelFormat properties, if you perform custom drawing with Metal (see the SCNSceneRendererDelegate and SCNNodeRendererDelegate classes) and need to create a new MTLRenderPipelineState object to change the GPU state as part of your rendering.NoteThis property is valid only for scene renderers whose renderingAPI value is metal. You create a SceneKit view that renders using Metal with the preferredRenderingAPI initialization option or in Interface Builder, or an SCNRenderer that uses Metal with the init(device:options:) method. For OpenGL-based scene renderers, this property’s value is always nil.
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1523780-depthpixelformat
	     */

	  }, {
	    key: 'depthPixelFormat',
	    get: function get() {
	      return this._depthPixelFormat;
	    }

	    /**
	     * Required. The Metal pixel format for the renderer’s stencil buffer.
	     * @type {MTLPixelFormat}
	     * @desc Use this property, along with the depthPixelFormat and colorPixelFormat properties, if you perform custom drawing with Metal (see the SCNSceneRendererDelegate and SCNNodeRendererDelegate classes) and need to create a new MTLRenderPipelineState object to change the GPU state as part of your rendering.NoteThis property is valid only for scene renderers whose renderingAPI value is metal. You create a SceneKit view that renders using Metal with the preferredRenderingAPI initialization option or in Interface Builder, or an SCNRenderer that uses Metal with the init(device:options:) method. For OpenGL-based scene renderers, this property’s value is always nil.
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1523315-stencilpixelformat
	     */

	  }, {
	    key: 'stencilPixelFormat',
	    get: function get() {
	      return this._stencilPixelFormat;
	    }

	    // Customizing Scene Rendering with OpenGL
	    /**
	     * Required. The OpenGL rendering context that SceneKit uses for rendering the scene.
	     * @type {?Object}
	     * @desc In macOS, the value of this property is a Core OpenGL cglContextObj object.In iOS, the value of this property is an EAGLContext object.
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1522840-context
	     */

	  }, {
	    key: 'context',
	    get: function get() {
	      return this._context;
	    }

	    // Working With Positional Audio

	    /**
	     * Required. The 3D audio mixing node SceneKit uses for positional audio effects.
	     * @type {AVAudioEnvironmentNode}
	     * @desc SceneKit uses this audio node to spatialize sounds from SCNAudioPlayer objects attached to nodes in the scene. You can use this object in conjunction with the audioEngine property to rearrange the audio graph to add other, non-spatialized audio sources or mix in audio processing effects.
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1523582-audioenvironmentnode
	     */

	  }, {
	    key: 'audioEnvironmentNode',
	    get: function get() {
	      return this._audioEnvironmentNode;
	    }

	    /**
	     * Required. The audio engine SceneKit uses for playing scene sounds.
	     * @type {AVAudioEngine}
	     * @desc SceneKit uses this audio engine to play sounds from SCNAudioPlayer objects attached to nodes in the scene. You can use this object directly to add other sound sources not related to scene contents, or to add other sound processing nodes or mixing nodes to the audio engine. To identify the node SceneKit uses for spatializing scene sounds when connecting other nodes, use the audioEnvironmentNode property.
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1522686-audioengine
	     */

	  }, {
	    key: 'audioEngine',
	    get: function get() {
	      return this._audioEngine;
	    }
	  }]);

	  return SCNSceneRenderer;
	}();

	exports.default = SCNSceneRenderer;

/***/ },
/* 43 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _NSObject2 = __webpack_require__(13);

	var _NSObject3 = _interopRequireDefault(_NSObject2);

	var _SCNNode = __webpack_require__(33);

	var _SCNNode2 = _interopRequireDefault(_SCNNode);

	var _SCNMaterialProperty = __webpack_require__(44);

	var _SCNMaterialProperty2 = _interopRequireDefault(_SCNMaterialProperty);

	var _SCNSceneExportDelegate = __webpack_require__(49);

	var _SCNSceneExportDelegate2 = _interopRequireDefault(_SCNSceneExportDelegate);

	var _SCNSceneExportProgressHandler = __webpack_require__(50);

	var _SCNSceneExportProgressHandler2 = _interopRequireDefault(_SCNSceneExportProgressHandler);

	var _SCNPhysicsWorld = __webpack_require__(51);

	var _SCNPhysicsWorld2 = _interopRequireDefault(_SCNPhysicsWorld);

	var _SCNParticleSystem = __webpack_require__(59);

	var _SCNParticleSystem2 = _interopRequireDefault(_SCNParticleSystem);

	var _SCNMatrix = __webpack_require__(17);

	var _SCNMatrix2 = _interopRequireDefault(_SCNMatrix);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var _Attribute = {
	  endTime: Symbol(),
	  frameRate: Symbol(),
	  startTime: Symbol(),
	  upAxis: Symbol()
	};

	/**
	 * A scene graph—a hierarchy of nodes with attached geometries, lights, cameras and other attributes that together form a displayable 3D scene.
	 * @access public
	 * @extends {NSObject}
	 * @see https://developer.apple.com/reference/scenekit/scnscene
	 */

	var SCNScene = function (_NSObject) {
	  _inherits(SCNScene, _NSObject);

	  /**
	   * Loads a scene from the specified URL.
	   * @access public
	   * @constructor
	   * @param {string} url - The URL to the scene file to load.
	   * @param {?Map<SCNSceneSource.LoadingOption, Object>} [options = null] - A dictionary of options affecting scene loading, or nil for default options. For available keys, see Scene Loading Options.
	   * @throws {Error}
	   * @desc This method provides a convenient way to load a complete scene from a file at an arbitrary URL. For more detailed options or to load only part of a file’s scene graph, use the SCNSceneSource class.Handling Errors in Swift:
	  In Swift, this method returns a nonoptional result and is marked with the throws keyword to indicate that it throws an error in cases of failure.
	  You call this method in a try expression and handle any errors in the catch clauses of a do statement, as described in Error Handling in The Swift Programming Language (Swift 3.1) and Error Handling in Using Swift with Cocoa and Objective-C (Swift 3.1).
	    * @see https://developer.apple.com/reference/scenekit/scnscene/1522660-init
	   */
	  function SCNScene(url) {
	    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

	    _classCallCheck(this, SCNScene);

	    // Managing Animated Effects in a Scene

	    /**
	     * A Boolean value that determines whether to run actions, animations, particle systems, and physics simulations in the scene graph.
	     * @type {boolean}
	     * @see https://developer.apple.com/reference/scenekit/scnscene/1523604-ispaused
	     */
	    var _this = _possibleConstructorReturn(this, (SCNScene.__proto__ || Object.getPrototypeOf(SCNScene)).call(this));

	    _this.isPaused = false;

	    // Accessing Scene Contents

	    _this._rootNode = new _SCNNode2.default();
	    _this._background = null;
	    _this._lightingEnvironment = null;

	    // Adding Fog to a Scene

	    /**
	     * The distance from a point of view at which the scene’s contents begin to be obscured by fog. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnscene/1522790-fogstartdistance
	     */
	    _this.fogStartDistance = 0;

	    /**
	     * The distance from a point of view at which the scene’s contents are completely obscured by fog. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnscene/1523836-fogenddistance
	     */
	    _this.fogEndDistance = 0;

	    /**
	     * The transition curve for the fog’s intensity between its start and end distances. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnscene/1523776-fogdensityexponent
	     */
	    _this.fogDensityExponent = 0;

	    /**
	     * The color of the fog effect to be rendered with the scene. Animatable.
	     * @type {Object}
	     * @see https://developer.apple.com/reference/scenekit/scnscene/1522774-fogcolor
	     */
	    _this.fogColor = null;

	    // Working With Physics in the Scene

	    _this._physicsWorld = null;

	    // Working with Particle Systems in the Scene

	    _this._particleSystems = null;
	    return _this;
	  }

	  // Creating or Loading a Scene

	  /**
	   * Loads a scene from a file with the specified name in the app’s main bundle.
	   * @access public
	   * @param {string} name - The name of a scene file in the app bundle’s resources directory.
	   * @returns {void}
	   * @desc This method provides a convenient way to load a complete scene from a file in the app’s main bundle. Calling this method is equivalent to using the Bundle class to locate the scene file and passing the resulting URL to the init(url:options:) method, specifying no options and no error handling.For more detailed options or to load only part of a file’s scene graph, use the SCNSceneSource class.
	   * @see https://developer.apple.com/reference/scenekit/scnscene/1523355-init
	   */


	  _createClass(SCNScene, [{
	    key: 'initNamed',
	    value: function initNamed(name) {}

	    /**
	     * Loads a scene from a file with the specified name in a specific subdirectory of the app’s main bundle.
	     * @access public
	     * @param {string} name - The name of a scene file in the app bundle.
	     * @param {?string} directory - The path to the subdirectory of the bundle’s resources directory containing the scene file.
	     * @param {?Map<SCNSceneSource.LoadingOption, Object>} [options = null] - A dictionary of options affecting scene loading, or nil for default options. For available keys, see Scene Loading Options.
	     * @returns {void}
	     * @desc This method provides a convenient way to load a complete scene from a file in the app’s main bundle. Calling this method is equivalent to using the Bundle class to locate the scene file and passing the resulting URL to the init(url:options:) method.For more detailed options or to load only part of a file’s scene graph, use the SCNSceneSource class.
	     * @see https://developer.apple.com/reference/scenekit/scnscene/1522851-init
	     */

	  }, {
	    key: 'initNamedInDirectory',
	    value: function initNamedInDirectory(name, directory) {
	      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
	    }

	    /**
	     * Loads a scene from the specified URL.
	     * @access public
	     * @param {string} url - The URL to the scene file to load.
	     * @param {?Map<SCNSceneSource.LoadingOption, Object>} [options = null] - A dictionary of options affecting scene loading, or nil for default options. For available keys, see Scene Loading Options.
	     * @returns {void}
	     * @throws {Error}
	     * @desc This method provides a convenient way to load a complete scene from a file at an arbitrary URL. For more detailed options or to load only part of a file’s scene graph, use the SCNSceneSource class.Handling Errors in Swift:
	    In Swift, this method returns a nonoptional result and is marked with the throws keyword to indicate that it throws an error in cases of failure.
	    You call this method in a try expression and handle any errors in the catch clauses of a do statement, as described in Error Handling in The Swift Programming Language (Swift 3.1) and Error Handling in Using Swift with Cocoa and Objective-C (Swift 3.1).
	      * @see https://developer.apple.com/reference/scenekit/scnscene/1522660-init
	     */

	  }, {
	    key: 'init',
	    value: function init(url) {
	      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
	    }

	    // Accessing Scene Contents
	    /**
	     * The root node of the scene graph.
	     * @type {SCNNode}
	     * @desc All scene content—nodes, geometries and their materials, lights, cameras, and related objects—is organized in a node hierarchy with a single common root node.Some scene files created using external tools may describe node hierarchies containing multiple root nodes. When SceneKit imports such files, their separate root nodes will be made children of a new, unique root node.Each child node’s coordinate system is defined relative to the transformation of its parent node. You should not modify the transform property of the root node.
	     * @see https://developer.apple.com/reference/scenekit/scnscene/1524029-rootnode
	     */

	  }, {
	    key: 'attributeForKey',


	    // Managing Scene Attributes

	    /**
	     * Returns the scene attribute for the specified key.
	     * @access public
	     * @param {string} key - One of the constants described in Scene Attributes that identifies the attribute to be read.
	     * @returns {?Object} - 
	     * @see https://developer.apple.com/reference/scenekit/scnscene/1522858-attribute
	     */
	    value: function attributeForKey(key) {
	      return null;
	    }

	    /**
	     * Sets a scene attribute for the specified key.
	     * @access public
	     * @param {?Object} attribute - An object that specifies the value of the attribute to be written.
	     * @param {string} key - One of the constants described in Scene Attributes that identifies the attribute to be written.
	     * @returns {void}
	     * @see https://developer.apple.com/reference/scenekit/scnscene/1524229-setattribute
	     */

	  }, {
	    key: 'setAttributeForKey',
	    value: function setAttributeForKey(attribute, key) {}

	    // Exporting a Scene File

	    /**
	     * Exports the scene and its contents to a file at the specified URL.
	     * @access public
	     * @param {string} url - The URL to write the scene file to. This URL must use the file scheme.
	     * @param {?Map<string, Object>} [options = null] - A dictionary of options affecting scene loading, or nil for default options. For available keys, see Scene Loading Options.
	     * @param {?SCNSceneExportDelegate} delegate - A delegate object to customize export of external resources used by the scene. Pass nil for default export of external resources.
	     * @param {?SCNSceneExportProgressHandler} [progressHandler = null] - A block that SceneKit calls repeatedly to report progress of the export operation.
	     * @returns {boolean} - 
	     * @desc SceneKit creates and writes a file containing the scene graph in the Digital Asset Exchange (DAE) format. The format of the file created depends on OS version and on the filename extension you specify:In iOS 10.0, tvOS 10.0, watchOS 3.0, OS X v10.11, and later versions, specify the .scn extension to save a file in SceneKit’s native format. This format supports all features of SceneKit (including physics, constraints, and particle systems), and reading files in this format is faster than importing from other scene file formats.In macOS only, specify the .dae extension to export in Digital Asset Exchange (DAE) format for use by other apps. Exported DAE files do not contain scene elements specific to SceneKit, such as physics bodies and fields, constraints, and particle systems.If the scene references external resources, such as image files used in material properties, SceneKit exports these files to a nearby location and references their URLs in the exported scene file. To override SceneKit’s exporting of external resources, provide an object implementing the SCNSceneExportDelegate protocol in the delegate parameter.
	     * @see https://developer.apple.com/reference/scenekit/scnscene/1523577-write
	     */

	  }, {
	    key: 'writeTo',
	    value: function writeTo(url) {
	      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
	      var delegate = arguments[2];
	      var progressHandler = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

	      return false;
	    }

	    // Working With Physics in the Scene
	    /**
	     * The physics simulation associated with the scene.
	     * @type {SCNPhysicsWorld}
	     * @desc Every scene automatically creates a physics world object to simulate physics on nodes in the scene. You use this property to access the scene’s global physics properties, such as gravity, and to manage physics interactions between nodes. To make a node in the scene participate in the physics simulation, use either or both of its physicsBody and physicsField properties.
	     * @see https://developer.apple.com/reference/scenekit/scnscene/1522643-physicsworld
	     */

	  }, {
	    key: 'addParticleSystem',


	    // Working with Particle Systems in the Scene

	    /**
	     * Attaches a particle system to the scene, using the specified transform.
	     * @access public
	     * @param {SCNParticleSystem} system - A particle system.
	     * @param {SCNMatrix4} transform - A transformation matrix that positions and orients the particle system relative to the world coordinate space of the scene.
	     * @returns {void}
	     * @desc A particle system directly attached to a scene is not related to the coordinate space of any node in the scene. To attach a particle system whose emitter location follows the movement of a node within the scene, use the corresponding SCNNode method.For details on particle systems, see SCNParticleSystem.
	     * @see https://developer.apple.com/reference/scenekit/scnscene/1523359-addparticlesystem
	     */
	    value: function addParticleSystem(system, transform) {}

	    /**
	     * Removes a particle system attached to the scene.
	     * @access public
	     * @param {SCNParticleSystem} system - A particle system.
	     * @returns {void}
	     * @desc This method has no effect if the system parameter does not reference a particle system directly attached to the scene.
	     * @see https://developer.apple.com/reference/scenekit/scnscene/1523498-removeparticlesystem
	     */

	  }, {
	    key: 'removeParticleSystem',
	    value: function removeParticleSystem(system) {}

	    /**
	     * Removes any particle systems directly attached to the scene.
	     * @access public
	     * @returns {void}
	     * @desc Calling this method does not remove particle systems attached to nodes within the scene.
	     * @see https://developer.apple.com/reference/scenekit/scnscene/1522786-removeallparticlesystems
	     */

	  }, {
	    key: 'removeAllParticleSystems',
	    value: function removeAllParticleSystems() {}

	    /**
	     * The particle systems attached to the scene.
	     * @type {?SCNParticleSystem[]}
	     * @desc An array of SCNParticleSystem objects directly attached to the scene. This array does not include particle systems attached to nodes within the scene.For details on particle systems, see SCNParticleSystem.
	     * @see https://developer.apple.com/reference/scenekit/scnscene/1522787-particlesystems
	     */

	  }, {
	    key: 'rootNode',
	    get: function get() {
	      return this._rootNode;
	    }
	    /**
	     * A background to be rendered before the rest of the scene.
	     * @type {SCNMaterialProperty}
	     * @desc If the material property’s contents object is nil, SceneKit does not draw any background before drawing the rest of the scene. (If the scene is presented in an SCNView instance, the view’s background color is visible behind the contents of the scene.)If you specify a cube map texture for the material property (see the discussion of the contents property), SceneKit renders the background as a skybox.
	     * @see https://developer.apple.com/reference/scenekit/scnscene/1523665-background
	     */

	  }, {
	    key: 'background',
	    get: function get() {
	      return this._background;
	    }
	    /**
	     * A cube map texture that depicts the environment surrounding the scene’s contents, used for advanced lighting effects.
	     * @type {SCNMaterialProperty}
	     * @desc When rendering materials with the physicallyBased lighting model, SceneKit illuminates surfaces differently according to the environment that surrounds them. For example, with physically based shading, even a diffuse surface takes on some color from the sky above it and the ground below it.TipFor realistic results, reuse the same contents for both the lighting environment and the background property.For information about defining cube maps, see the discussion of the contents property.
	     * @see https://developer.apple.com/reference/scenekit/scnscene/1639532-lightingenvironment
	     */

	  }, {
	    key: 'lightingEnvironment',
	    get: function get() {
	      return this._lightingEnvironment;
	    }
	  }, {
	    key: 'physicsWorld',
	    get: function get() {
	      return this._physicsWorld;
	    }
	  }, {
	    key: 'particleSystems',
	    get: function get() {
	      return this._particleSystems;
	    }

	    // Structures

	    /**
	     * @type {Object} Attribute
	     * @property {Symbol} endTime A floating-point value (in an NSNumber object) for the end time of the scene.
	     * @property {Symbol} frameRate A floating-point value (in an NSNumber object) for the frame rate of the scene.
	     * @property {Symbol} startTime A floating-point value (in an NSNumber object) for the start time of the scene.
	     * @property {Symbol} upAxis An SCNVector3 structure (in an NSValue object) specifying the orientation of the scene.
	     * @see https://developer.apple.com/reference/scenekit/scnscene.attribute
	     */

	  }], [{
	    key: 'Attribute',
	    get: function get() {
	      return _Attribute;
	    }
	  }]);

	  return SCNScene;
	}(_NSObject3.default);

	exports.default = SCNScene;

/***/ },
/* 44 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _NSObject2 = __webpack_require__(13);

	var _NSObject3 = _interopRequireDefault(_NSObject2);

	var _SCNAnimatable = __webpack_require__(35);

	var _SCNAnimatable2 = _interopRequireDefault(_SCNAnimatable);

	var _SCNMatrix = __webpack_require__(17);

	var _SCNMatrix2 = _interopRequireDefault(_SCNMatrix);

	var _SCNMatrix4MakeTranslation = __webpack_require__(45);

	var _SCNMatrix4MakeTranslation2 = _interopRequireDefault(_SCNMatrix4MakeTranslation);

	var _SCNWrapMode = __webpack_require__(46);

	var _SCNWrapMode2 = _interopRequireDefault(_SCNWrapMode);

	var _SCNFilterMode = __webpack_require__(47);

	var _SCNFilterMode2 = _interopRequireDefault(_SCNFilterMode);

	var _SKColor = __webpack_require__(48);

	var _SKColor2 = _interopRequireDefault(_SKColor);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * A container for the color or texture of one of a material’s visual properties. 
	 * @access public
	 * @extends {NSObject}
	 * @implements {SCNAnimatable}
	 * @see https://developer.apple.com/reference/scenekit/scnmaterialproperty
	 */
	var SCNMaterialProperty = function (_NSObject) {
	  _inherits(SCNMaterialProperty, _NSObject);

	  // Creating a Material Property

	  /**
	   * Creates a new material property object with the specified contents.
	   * @access public
	   * @constructor
	   * @param {Object} contents - The visual contents of the material property—a color, image, or source of animated content. For details, see the discussion of the  contents property.
	   * @desc Newly created SCNMaterial objects contain SCNMaterialProperty instances for all of their visual properties. To change a material’s visual properties, you modify those instances rather than creating new material property objects.You create new SCNMaterialProperty instances to provide textures for use with custom GLSL shaders—for details, see SCNShadable.
	   * @see https://developer.apple.com/reference/scenekit/scnmaterialproperty/1395386-init
	   */
	  function SCNMaterialProperty(contents) {
	    _classCallCheck(this, SCNMaterialProperty);

	    //if(typeof contents !== 'object'){
	    //  throw 'SCNMaterialProperty(contents): contents must be Object type: ' + (typeof contents)
	    //}

	    // Working with Material Property Contents

	    /**
	     * The visual contents of the material property—a color, image, or source of animated content. Animatable.
	     * @type {?Object}
	     * @see https://developer.apple.com/reference/scenekit/scnmaterialproperty/1395372-contents
	     */
	    var _this = _possibleConstructorReturn(this, (SCNMaterialProperty.__proto__ || Object.getPrototypeOf(SCNMaterialProperty)).call(this));

	    _this.contents = contents;

	    /**
	     * A number between 0.0 and 1.0 that modulates the effect of the material property. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnmaterialproperty/1395407-intensity
	     */
	    _this.intensity = 0;

	    // Configuring Texture Mapping Attributes

	    /**
	     * The transformation applied to the material property’s visual contents. Animatable.
	     * @type {SCNMatrix4}
	     * @see https://developer.apple.com/reference/scenekit/scnmaterialproperty/1395388-contentstransform
	     */
	    _this.contentsTransform = (0, _SCNMatrix4MakeTranslation2.default)(0, 0, 0);

	    /**
	     * The wrapping behavior for the S texture coordinate.
	     * @type {SCNWrapMode}
	     * @see https://developer.apple.com/reference/scenekit/scnmaterialproperty/1395384-wraps
	     */
	    _this.wrapS = _SCNWrapMode2.default.clamp;

	    /**
	     * The wrapping behavior for the T texture coordinate.
	     * @type {SCNWrapMode}
	     * @see https://developer.apple.com/reference/scenekit/scnmaterialproperty/1395382-wrapt
	     */
	    _this.wrapT = _SCNWrapMode2.default.clamp;

	    /**
	     * Texture filtering for rendering the material property’s image contents at a size smaller than that of the original image.
	     * @type {SCNFilterMode}
	     * @see https://developer.apple.com/reference/scenekit/scnmaterialproperty/1395390-minificationfilter
	     */
	    _this.minificationFilter = _SCNFilterMode2.default.linear;

	    /**
	     * Texture filtering for rendering the material property’s image contents at a size larger than that of the original image.
	     * @type {SCNFilterMode}
	     * @see https://developer.apple.com/reference/scenekit/scnmaterialproperty/1395378-magnificationfilter
	     */
	    _this.magnificationFilter = _SCNFilterMode2.default.linear;

	    /**
	     * Texture filtering for using mipmaps to render the material property’s image contents at a size smaller than that of the original image.
	     * @type {SCNFilterMode}
	     * @see https://developer.apple.com/reference/scenekit/scnmaterialproperty/1395398-mipfilter
	     */
	    _this.mipFilter = _SCNFilterMode2.default.nearest;

	    /**
	     * The amount of anisotropic texture filtering to be used when rendering the material property’s image contents.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnmaterialproperty/1395402-maxanisotropy
	     */
	    _this.maxAnisotropy = 0;

	    /**
	     * The source of texture coordinates for mapping the material property’s image contents.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnmaterialproperty/1395405-mappingchannel
	     */
	    _this.mappingChannel = 0;

	    /**
	     * A color used to fill in areas of a material’s surface not covered by the material property’s image contents.
	     * @type {?Object}
	     * @deprecated
	     * @see https://developer.apple.com/reference/scenekit/scnmaterialproperty/1395376-bordercolor
	     */
	    _this.borderColor = null;
	    return _this;
	  }

	  /**
	   * @access public
	   * @returns {Float32Array} -
	   */


	  _createClass(SCNMaterialProperty, [{
	    key: 'float32Array',
	    value: function float32Array() {
	      if (this.contents instanceof _SKColor2.default) {
	        return this.contents.float32Array();
	      }
	      return new Float32Array([1, 1, 1, 1]);
	    }
	  }]);

	  return SCNMaterialProperty;
	}(_NSObject3.default);

	exports.default = SCNMaterialProperty;

/***/ },
/* 45 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _SCNMatrix = __webpack_require__(17);

	var _SCNMatrix2 = _interopRequireDefault(_SCNMatrix);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Returns a matrix describing a translation transformation.
	 * @access public
	 * @param {number} tx - 
	 * @param {number} ty - 
	 * @param {number} tz - 
	 * @returns {SCNMatrix4} - 
	 * @see https://developer.apple.com/reference/scenekit/1409679-scnmatrix4maketranslation
	 */
	var SCNMatrix4MakeTranslation = function SCNMatrix4MakeTranslation(tx, ty, tz) {
	  return new _SCNMatrix2.default(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, tx, ty, tz, 1);
	};

	exports.default = SCNMatrix4MakeTranslation;

/***/ },
/* 46 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * Modes to apply to texture wrapping, used by the wrapT and wrapS properties.
	 * @typedef {Object} SCNWrapMode
	 * @property {Symbol} clamp - Texture coordinates are clamped to the range from 0.0 to 1.0, inclusive.
	 * @property {Symbol} repeat - Texture sampling uses only the fractional part of texture coordinates, passing through the range from 0.0 to (but not including) 1.0.
	 * @property {Symbol} clampToBorder - Texture sampling uses texture colors for coordinates in the range from 0.0 to 1.0 (inclusive) and the material property’s borderColor value otherwise.
	 * @property {Symbol} mirror - Texture sampling of texture coordinates outside range from 0.0 to 1.0 should behave as if the range reverses before repeating.
	 * @see https://developer.apple.com/reference/scenekit/scnwrapmode
	 */

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var SCNWrapMode = {
	  clamp: Symbol(),
	  repeat: Symbol(),
	  clampToBorder: Symbol(),
	  mirror: Symbol()
	};

	exports.default = SCNWrapMode;

/***/ },
/* 47 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * Texture filtering modes, used by the the minificationFilter, magnificationFilter, and mipFilter properties.
	 * @typedef {Object} SCNFilterMode
	 * @property {Symbol} none - No texture filtering is applied.
	 * @property {Symbol} nearest - Texture filtering returns the color from only one texel, whose location is nearest to the coordinates being sampled.
	 * @property {Symbol} linear - Texture filtering sample texels from the neighborhood of the coordinates being sampled and linearly interpolates their colors.
	 * @see https://developer.apple.com/reference/scenekit/scnfiltermode
	 */

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var SCNFilterMode = {
	  none: Symbol(),
	  nearest: Symbol(),
	  linear: Symbol()
	};

	exports.default = SCNFilterMode;

/***/ },
/* 48 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _NSObject2 = __webpack_require__(13);

	var _NSObject3 = _interopRequireDefault(_NSObject2);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * An object that stores color data and sometimes opacity (that is, alpha value). 
	 * @access public
	 * @extends {NSObject}
	 * @see https://developer.apple.com/reference/uikit/uicolor
	 */
	var SKColor = function (_NSObject) {
	  _inherits(SKColor, _NSObject);

	  // Initializers

	  /**
	   * 
	   * @access public
	   * @constructor
	   * @param {number} red - 
	   * @param {number} green - 
	   * @param {number} blue - 
	   * @param {number} alpha - 
	   * @see https://developer.apple.com/reference/uikit/uicolor/1625015-init
	   */
	  function SKColor(red, green, blue, alpha) {
	    _classCallCheck(this, SKColor);

	    /**
	     * @type {number}
	     */
	    var _this = _possibleConstructorReturn(this, (SKColor.__proto__ || Object.getPrototypeOf(SKColor)).call(this));

	    _this.red = red;

	    /**
	     * @type {number}
	     */
	    _this.green = green;

	    /**
	     * @type {number}
	     */
	    _this.blue = blue;

	    /**
	     * @type {number}
	     */
	    _this.alpha = alpha;
	    return _this;
	  }

	  // Creating a Color Object with a Predefined Color

	  /**
	   * A color object in the sRGB color space whose grayscale value is 0.0 and whose alpha value is 1.0.
	   * @type {SKColor}
	   * @desc 
	   * @see https://developer.apple.com/reference/uikit/uicolor/1621929-black
	   */


	  _createClass(SKColor, [{
	    key: 'withAlphaComponent',


	    // Creating a Custom UIColor Object in a Specific Color Space

	    /**
	     * Initializes and returns a color object using the specified opacity and grayscale values. 
	     * @access public
	     * @param {number} white - The grayscale value of the color object. On applications linked for iOS 10 or later, the color is specified in an extended color space, and the input value  is never clamped. On earlier versions of iOS, white values below 0.0 are interpreted as 0.0, and values above 1.0 are interpreted as 1.0.
	     * @param {number} alpha - The opacity value of the color object, specified as a value from 0.0 to 1.0. Alpha values below 0.0 are interpreted as 0.0, and values above 1.0 are interpreted as 1.0
	     * @returns {void}
	     * @desc On applications linked on iOS 10 or later, the input parameters are not clamped. On earlier versions of iOS, values below 0.0 are interpreted as 0.0, and values above 1.0 are interpreted as 1.0.
	     * @see https://developer.apple.com/reference/uikit/uicolor/1621944-init
	     */
	    //init(white, alpha) {
	    //}

	    // Creating a UIColor Object from another Representation of Color

	    /**
	     * Creates and returns a color object that has the same color space and component values as the receiver, but has the specified alpha component. 
	     * @access public
	     * @param {number} alpha - The opacity value of the new color object, specified as a value from 0.0 to 1.0. Alpha values below 0.0 are interpreted as 0.0, and values above 1.0 are interpreted as 1.0
	     * @returns {SKColor} - 
	     * @desc A subclass with explicit opacity components should override this method to return a color with the specified alpha.
	     * @see https://developer.apple.com/reference/uikit/uicolor/1621922-withalphacomponent
	     */
	    value: function withAlphaComponent(alpha) {
	      return new SKColor(this.red, this.green, this.blue, alpha);
	    }

	    // Creating a UIColor Object that Draws Using a Pattern

	    /**
	     * Initializes and returns a color object using the specified Quartz color reference. 
	     * @access public
	     * @param {Image} image - The image to use when creating the pattern color. 
	     * @returns {void}
	     * @desc You can use pattern colors to set the fill or stroke color just as you would a solid color. During drawing, the image in the pattern color is tiled as necessary to cover the given area. By default, the phase of the returned color is 0, which causes the top-left corner of the image to be aligned with the drawing origin. To change the phase, make the color the current color and then use the setPatternPhase(_:) function to change the phase.
	     * @see https://developer.apple.com/reference/uikit/uicolor/1621933-init
	     */

	  }, {
	    key: 'initPatternImage',
	    value: function initPatternImage(image) {}

	    // Setting the Graphics Context’s Drawing Color

	    /**
	     * Sets the color of subsequent stroke and fill operations to the color that the receiver represents. 
	     * @access public
	     * @returns {void}
	     * @desc If you subclass UIColor, you must implement this method in your subclass. Your custom implementation should modify both the stroke and fill color in the current graphics context by setting them both to the color represented by the receiver.
	     * @see https://developer.apple.com/reference/uikit/uicolor/1621928-set
	     */

	  }, {
	    key: 'set',
	    value: function set() {}

	    /**
	     * Sets the color of subsequent fill operations to the color that the receiver represents.
	     * @access public
	     * @returns {void}
	     * @desc If you subclass UIColor, you must implement this method in your subclass. Your custom implementation should modify the fill color in the current graphics context by setting it to the color represented by the receiver.
	     * @see https://developer.apple.com/reference/uikit/uicolor/1621926-setfill
	     */

	  }, {
	    key: 'setFill',
	    value: function setFill() {}

	    /**
	     * Sets the color of subsequent stroke operations to the color that the receiver represents.
	     * @access public
	     * @returns {void}
	     * @desc If you subclass UIColor, you must implement this method in your subclass. Your custom implementation should modify the stroke color in the current graphics context by setting it to the color represented by the receiver.
	     * @see https://developer.apple.com/reference/uikit/uicolor/1621948-setstroke
	     */

	  }, {
	    key: 'setStroke',
	    value: function setStroke() {}

	    // Retrieving Color Information

	    /**
	     * Returns the components that make up the color in the HSB color space.
	     * @access public
	     * @returns {Object} -
	     * @property {number} color.hue - On return, the hue component of the color object. On applications linked for iOS 10 or later, the hue component is specified in an extended range color space and can have any value. Values between 0.0 and 1.0 are inside the sRGB color gamut. On earlier versions of iOS, the specified value is always between 0.0 and 1.0.
	     * @property {number} color.saturation - On return, the saturation component of the color object. On applications linked for iOS 10 or later, the saturation component is specified in an extended range color space and can have any value. Values between 0.0 and 1.0 are inside the sRGB color gamut. On earlier versions of iOS, the specified value is always between 0.0 and 1.0.
	     * @property {number} color.brightness - On return, the brightness component of the color object. On applications linked for iOS 10 or later, the brightness component is specified in an extended range color space and can have any value. Values between 0.0 and 1.0 are inside the sRGB color gamut. On earlier versions of iOS, the specified value is always between 0.0 and 1.0.
	     * @property {number} color.alpha - On return, the opacity component of the color object, specified as a value between 0.0 and 1.0.
	     * @desc If the color is in a compatible color space, the color is converted into the HSB color space and its components are returned to your application. If the color is not in a compatible color space, the parameters are unchanged.
	     * @see https://developer.apple.com/reference/uikit/uicolor/1621949-gethue
	     */

	  }, {
	    key: 'getHSBA',
	    value: function getHSBA() {
	      var color = {
	        hue: 0,
	        saturation: 0,
	        brightness: 0,
	        alpha: 0
	      };
	      return color;
	    }

	    /**
	     * Returns the components that make up the color in the RGB color space.
	     * @access public
	     * @param {number} red -
	     * @param {number} green -
	     * @param {number} blue -
	     * @param {number} alpha -
	     * @returns {Object} -
	     * @property {number} color.red - On return, the red component of the color object. On applications linked for iOS 10 or later, the red component is specified in an extended range sRGB color space and can have any value. Values between 0.0 and 1.0 are inside the sRGB color gamut. On earlier versions of iOS, the specified value is always between 0.0 and 1.0.
	     * @property {number} color.green - On return, the green component of the color object. On applications linked for iOS 10 or later, the green component is specified in an extended range sRGB color space and can have any value. Values between 0.0 and 1.0 are inside the sRGB color gamut. On earlier versions of iOS, the specified value is always between 0.0 and 1.0.
	     * @property {number} color.blue - On return, the blue component of the color object. On applications linked for iOS 10 or later, the blue component is specified in an extended range sRGB color space and can have any value. Values between 0.0 and 1.0 are inside the sRGB color gamut. On earlier versions of iOS, the specified value is always between 0.0 and 1.0.
	     * @property {number} color.alpha - On return, the opacity component of the color object, specified as a value between 0.0 and 1.0.
	     * @desc If the color is in a compatible color space, the color is converted into RGB format and its components are returned to your application. If the color is not in a compatible color space, the parameters are unchanged.
	     * @see https://developer.apple.com/reference/uikit/uicolor/1621919-getred
	     */

	  }, {
	    key: 'getRGBA',
	    value: function getRGBA(red, green, blue, alpha) {
	      var color = {
	        red: this.red,
	        green: this.green,
	        blue: this.blue,
	        alpha: this.alpha
	      };
	      return color;
	    }

	    /**
	     * Returns the grayscale components of the color.
	     * @access public
	     * @param {?UnsafeMutablePointer<CGFloat>} white - On return, the grayscale component of the color object. On applications linked for iOS 10 or later, the grayscale component is specified in an extended range gray color space and can have any value. Values between 0.0 and 1.0 are inside the sRGB color gamut. On earlier versions of iOS, the specified value is always between 0.0 and 1.0.
	     * @param {?UnsafeMutablePointer<CGFloat>} alpha - On return, the opacity component of the color object, specified as a value between 0.0 and 1.0.
	     * @returns {boolean} - 
	     * @desc If the color is in a compatible color space, the color is converted into grayscale format and returned to your application. If the color is not in a compatible color space, the parameters are unchanged.
	     * @see https://developer.apple.com/reference/uikit/uicolor/1621927-getwhite
	     */
	    //getWhite(white, alpha) {
	    //  return false
	    //}

	    /**
	     * HTML color representation
	     * @access public
	     * @type {string}
	     */

	  }, {
	    key: 'float32Array',


	    /**
	     * @access public
	     * @returns {Float32Array} -
	     */
	    value: function float32Array() {
	      return new Float32Array([this.red, this.green, this.blue, this.alpha]);
	    }
	  }, {
	    key: 'htmlColor',
	    get: function get() {
	      var r = Math.round(this.red * 255);
	      var g = Math.round(this.green * 255);
	      var b = Math.round(this.blue * 255);
	      return 'rgba(' + r + ', ' + g + ', ' + b + ', ' + this.alpha + ')';
	    }
	  }], [{
	    key: 'black',
	    get: function get() {
	      return new SKColor(0.0, 0.0, 0.0, 1.0);
	    }

	    /**
	     * A color object whose RGB values are 0.0, 0.0, and 1.0 and whose alpha value is 1.0.
	     * @type {SKColor}
	     * @desc 
	     * @see https://developer.apple.com/reference/uikit/uicolor/1621947-blue
	     */

	  }, {
	    key: 'blue',
	    get: function get() {
	      return new SKColor(0.0, 0.0, 1.0, 1.0);
	    }

	    /**
	     * A color object whose RGB values are 0.6, 0.4, and 0.2 and whose alpha value is 1.0.
	     * @type {SKColor}
	     * @desc 
	     * @see https://developer.apple.com/reference/uikit/uicolor/1621950-brown
	     */

	  }, {
	    key: 'brown',
	    get: function get() {
	      return new SKColor(0.6, 0.4, 0.2, 1.0);
	    }

	    /**
	     * A color object whose grayscale and alpha values are both 0.0.
	     * @type {SKColor}
	     * @desc 
	     * @see https://developer.apple.com/reference/uikit/uicolor/1621945-clear
	     */

	  }, {
	    key: 'clear',
	    get: function get() {
	      return new SKColor(0.0, 0.0, 0.0, 0.0);
	    }

	    /**
	     * A color object whose RGB values are 0.0, 1.0, and 1.0 and whose alpha value is 1.0.
	     * @type {SKColor}
	     * @desc 
	     * @see https://developer.apple.com/reference/uikit/uicolor/1621942-cyan
	     */

	  }, {
	    key: 'cyan',
	    get: function get() {
	      return new SKColor(0.0, 1.0, 1.0, 1.0);
	    }

	    /**
	     * A color object whose grayscale value is 1/3 and whose alpha value is 1.0.
	     * @type {SKColor}
	     * @desc 
	     * @see https://developer.apple.com/reference/uikit/uicolor/1621952-darkgray
	     */

	  }, {
	    key: 'darkGray',
	    get: function get() {
	      var third = 1.0 / 3.0;
	      return new SKColor(third, third, third, 1.0);
	    }

	    /**
	     * A color object whose grayscale value is 0.5 and whose alpha value is 1.0.
	     * @type {SKColor}
	     * @desc 
	     * @see https://developer.apple.com/reference/uikit/uicolor/1621941-gray
	     */

	  }, {
	    key: 'gray',
	    get: function get() {
	      return new SKColor(0.5, 0.5, 0.5, 1.0);
	    }

	    /**
	     * A color object whose RGB values are 0.0, 1.0, and 0.0 and whose alpha value is 1.0.
	     * @type {SKColor}
	     * @desc 
	     * @see https://developer.apple.com/reference/uikit/uicolor/1621946-green
	     */

	  }, {
	    key: 'green',
	    get: function get() {
	      return new SKColor(0.0, 1.0, 0.0, 1.0);
	    }

	    /**
	     * A color object whose grayscale value is 2/3 and whose alpha value is 1.0.
	     * @type {SKColor}
	     * @desc 
	     * @see https://developer.apple.com/reference/uikit/uicolor/1621932-lightgray
	     */

	  }, {
	    key: 'lightGray',
	    get: function get() {
	      var twoThirds = 2.0 / 3.0;
	      return new SKColor(twoThirds, twoThirds, twoThirds, 1.0);
	    }

	    /**
	     * A color object whose RGB values are 1.0, 0.0, and 1.0 and whose alpha value is 1.0.
	     * @type {SKColor}
	     * @desc 
	     * @see https://developer.apple.com/reference/uikit/uicolor/1621934-magenta
	     */

	  }, {
	    key: 'magenta',
	    get: function get() {
	      return new SKColor(1.0, 0.0, 1.0, 1.0);
	    }

	    /**
	     * A color object whose RGB values are 1.0, 0.5, and 0.0 and whose alpha value is 1.0.
	     * @type {SKColor}
	     * @desc 
	     * @see https://developer.apple.com/reference/uikit/uicolor/1621956-orange
	     */

	  }, {
	    key: 'orange',
	    get: function get() {
	      return new SKColor(1.0, 0.5, 0.0, 1.0);
	    }

	    /**
	     * A color object whose RGB values are 0.5, 0.0, and 0.5 and whose alpha value is 1.0.
	     * @type {SKColor}
	     * @desc 
	     * @see https://developer.apple.com/reference/uikit/uicolor/1621923-purple
	     */

	  }, {
	    key: 'purple',
	    get: function get() {
	      return new SKColor(0.5, 0.0, 0.5, 1.0);
	    }

	    /**
	     * A color object whose RGB values are 1.0, 0.0, and 0.0 and whose alpha value is 1.0.
	     * @type {SKColor}
	     * @desc 
	     * @see https://developer.apple.com/reference/uikit/uicolor/1621924-red
	     */

	  }, {
	    key: 'red',
	    get: function get() {
	      return new SKColor(1.0, 0.0, 0.0, 1.0);
	    }

	    /**
	     * A color object whose grayscale value is 1.0 and whose alpha value is 1.0.
	     * @type {SKColor}
	     * @desc 
	     * @see https://developer.apple.com/reference/uikit/uicolor/1621920-white
	     */

	  }, {
	    key: 'white',
	    get: function get() {
	      return new SKColor(1.0, 0.0, 0.0, 1.0);
	    }

	    /**
	     * A color object whose RGB values are 1.0, 1.0, and 0.0 and whose alpha value is 1.0.
	     * @type {SKColor}
	     * @desc 
	     * @see https://developer.apple.com/reference/uikit/uicolor/1621953-yellow
	     */

	  }, {
	    key: 'yellow',
	    get: function get() {
	      return new SKColor(1.0, 1.0, 0.0, 1.0);
	    }
	  }]);

	  return SKColor;
	}(_NSObject3.default);

	exports.default = SKColor;

/***/ },
/* 49 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * Methods you can implement to participate in the process of exporting a scene to a file.
	 * @interface
	 * @see https://developer.apple.com/reference/scenekit/scnsceneexportdelegate
	 */

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var SCNSceneExportDelegate = function () {
	  function SCNSceneExportDelegate() {
	    _classCallCheck(this, SCNSceneExportDelegate);
	  }

	  _createClass(SCNSceneExportDelegate, [{
	    key: 'init',


	    /**
	     * constructor
	     * @access public
	     * @returns {void}
	     */
	    value: function init() {}

	    // Writing Image Attachments

	    /**
	     * Tells the delegate to export an image attached to a scene.
	     * @access public
	     * @param {Image} image - An image attached to the scene being exported.
	     * @param {string} documentURL - The URL the scene is being exported to.
	     * @param {?string} originalImageURL - The URL the image was originally loaded from, or nil if the image was not previously loaded from a URL.
	     * @returns {?string} - 
	     * @desc If you implement this method, Scene Kit calls it for each image (for example, a texture) attached to the scene. Your app can then save the image data in a location and format of your choice, returning a URL for the exported image file.If you do not provide a delegate when exporting a scene, or if your delegate returns nil from this method, Scene Kit exports the image in a default format to a default location.
	     * @see https://developer.apple.com/reference/scenekit/scnsceneexportdelegate/1524221-write
	     */

	  }, {
	    key: 'writeWithSceneDocumentURL',
	    value: function writeWithSceneDocumentURL(image, documentURL, originalImageURL) {
	      return null;
	    }
	  }]);

	  return SCNSceneExportDelegate;
	}();

	exports.default = SCNSceneExportDelegate;

/***/ },
/* 50 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * The signature for the block that SceneKit calls during scene export.
	 * @type {function(totalProgress: number, error: ?Error, stop: UnsafeMutablePointer<ObjCBool>): void}
	 * @param {number} totalProgress - A number between 0.0 and 1.0 that indicates the progress of the export operation, with 0.0 indicating that the operation has just begun and 1.0 indicating the operation has completed.
	 * @param {?Error} error - An error encountered during the export process, or nil if no errors have occurred.
	 * @param {UnsafeMutablePointer<ObjCBool>} stop - Set *stop to true inside the block to cancel export.
	 * @returns {void}
	 * @desc stopSet *stop to true inside the block to cancel export.
	 * @see https://developer.apple.com/reference/scenekit/scnsceneexportprogresshandler
	 */

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var SCNSceneExportProgressHandler = function SCNSceneExportProgressHandler(totalProgress, error, stop) {};

	exports.default = SCNSceneExportProgressHandler;

/***/ },
/* 51 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _NSObject2 = __webpack_require__(13);

	var _NSObject3 = _interopRequireDefault(_NSObject2);

	var _SCNVector = __webpack_require__(15);

	var _SCNVector2 = _interopRequireDefault(_SCNVector);

	var _SCNPhysicsBehavior = __webpack_require__(52);

	var _SCNPhysicsBehavior2 = _interopRequireDefault(_SCNPhysicsBehavior);

	var _SCNPhysicsContactDelegate = __webpack_require__(53);

	var _SCNPhysicsContactDelegate2 = _interopRequireDefault(_SCNPhysicsContactDelegate);

	var _SCNPhysicsContact = __webpack_require__(54);

	var _SCNPhysicsContact2 = _interopRequireDefault(_SCNPhysicsContact);

	var _SCNPhysicsBody = __webpack_require__(55);

	var _SCNPhysicsBody2 = _interopRequireDefault(_SCNPhysicsBody);

	var _SCNHitTestResult = __webpack_require__(58);

	var _SCNHitTestResult2 = _interopRequireDefault(_SCNHitTestResult);

	var _SCNPhysicsShape = __webpack_require__(57);

	var _SCNPhysicsShape2 = _interopRequireDefault(_SCNPhysicsShape);

	var _SCNMatrix = __webpack_require__(17);

	var _SCNMatrix2 = _interopRequireDefault(_SCNMatrix);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var _TestOption = {
	  backfaceCulling: Symbol(),
	  collisionBitMask: Symbol(),
	  searchMode: Symbol()
	};

	var _TestSearchMode = {
	  all: Symbol(),
	  any: Symbol(),
	  closest: Symbol()
	};

	/**
	 * The global simulation of collisions, gravity, joints, and other physics effects in a scene.
	 * @access public
	 * @extends {NSObject}
	 * @see https://developer.apple.com/reference/scenekit/scnphysicsworld
	 */

	var SCNPhysicsWorld = function (_NSObject) {
	  _inherits(SCNPhysicsWorld, _NSObject);

	  function SCNPhysicsWorld() {
	    _classCallCheck(this, SCNPhysicsWorld);

	    return _possibleConstructorReturn(this, (SCNPhysicsWorld.__proto__ || Object.getPrototypeOf(SCNPhysicsWorld)).apply(this, arguments));
	  }

	  _createClass(SCNPhysicsWorld, [{
	    key: 'init',


	    /**
	     * constructor
	     * @access public
	     * @returns {void}
	     */
	    value: function init() {

	      // Managing the Physics Simulation

	      /**
	       * A vector that specifies the gravitational acceleration applied to physics bodies in the physics world.
	       * @type {SCNVector3}
	       * @see https://developer.apple.com/reference/scenekit/scnphysicsworld/1512855-gravity
	       */
	      this.gravity = null;

	      /**
	       * The rate at which the simulation executes.
	       * @type {number}
	       * @see https://developer.apple.com/reference/scenekit/scnphysicsworld/1512851-speed
	       */
	      this.speed = 0;

	      /**
	       * The time interval between updates to the physics simulation.
	       * @type {number}
	       * @see https://developer.apple.com/reference/scenekit/scnphysicsworld/1512881-timestep
	       */
	      this.timeStep = 0;

	      // Registering Physics Behaviors

	      this._allBehaviors = null;

	      // Detecting Contacts Between Physics Bodies

	      /**
	       * A delegate that is called when two physics bodies come in contact with each other.
	       * @type {?SCNPhysicsContactDelegate}
	       * @see https://developer.apple.com/reference/scenekit/scnphysicsworld/1512843-contactdelegate
	       */
	      this.contactDelegate = null;
	    }

	    // Managing the Physics Simulation

	    /**
	     * Forces the physics engine to reevaluate possible collisions between physics bodies.
	     * @access public
	     * @returns {void}
	     * @desc By default, SceneKit checks for collisions between physics bodies only once per simulation step. If you directly change the positions of any physics bodies outside of a SCNPhysicsContactDelegate method, call the updateCollisionPairs() method before using any of the methods listed in Searching for Physics Bodies Detecting Contacts Between Physics Bodies.
	     * @see https://developer.apple.com/reference/scenekit/scnphysicsworld/1512877-updatecollisionpairs
	     */

	  }, {
	    key: 'updateCollisionPairs',
	    value: function updateCollisionPairs() {}

	    // Registering Physics Behaviors

	    /**
	     * Adds a behavior to the physics world.
	     * @access public
	     * @param {SCNPhysicsBehavior} behavior - The behavior to be added.
	     * @returns {void}
	     * @desc Physics behaviors constrain or modify the effects of the physics simulation on sets of physics bodies. For example, the SCNPhysicsHingeJoint behavior causes two bodies to move as if connected by a hinge that pivots around a specific axis, and the SCNPhysicsVehicle behavior causes a body to roll like a car or other wheeled vehicle.To use a behavior in your scene, follow these steps:Create SCNPhysicsBody objects and attach them to each node that participates in the behavior.Create and configure a behavior object joining the physics bodies. See SCNPhysicsBehavior for a list of behavior classes.Call addBehavior(_:) on your scene’s physics world object to add the behavior to the physics simulation.
	     * @see https://developer.apple.com/reference/scenekit/scnphysicsworld/1512839-addbehavior
	     */

	  }, {
	    key: 'addBehavior',
	    value: function addBehavior(behavior) {}

	    /**
	     * Removes a behavior from the physics world.
	     * @access public
	     * @param {SCNPhysicsBehavior} behavior - The behavior to be removed.
	     * @returns {void}
	     * @see https://developer.apple.com/reference/scenekit/scnphysicsworld/1512870-removebehavior
	     */

	  }, {
	    key: 'removeBehavior',
	    value: function removeBehavior(behavior) {}

	    /**
	     * Removes all behaviors affecting bodies in the physics world.
	     * @access public
	     * @returns {void}
	     * @see https://developer.apple.com/reference/scenekit/scnphysicsworld/1512849-removeallbehaviors
	     */

	  }, {
	    key: 'removeAllBehaviors',
	    value: function removeAllBehaviors() {}
	    /**
	     * The list of behaviors affecting bodies in the physics world.
	     * @type {SCNPhysicsBehavior[]}
	     * @desc 
	     * @see https://developer.apple.com/reference/scenekit/scnphysicsworld/1512853-allbehaviors
	     */

	  }, {
	    key: 'contactTestBetween',


	    // Detecting Contacts Between Physics Bodies

	    /**
	     * Checks for contacts between two physics bodies.
	     * @access public
	     * @param {SCNPhysicsBody} bodyA - The first body (to test for contact with the second).
	     * @param {SCNPhysicsBody} bodyB - The second body (to test for contact with the first).
	     * @param {?Map<SCNPhysicsWorld.TestOption, Object>} [options = null] - A dictionary of options affecting the test, or nil to use default options. For applicable keys and the possible values, see Physics Test Options Keys.
	     * @returns {SCNPhysicsContact[]} - 
	     * @desc SceneKit sends messages to the physics world’s contactDelegate object only when collisions occur between bodies whose collisionBitMask and categoryBitMask properties overlap, and only for collisions between certain types of bodies. (For details, see SCNPhysicsBodyType.) Use this method to directly test for contacts between any two bodies at a time of your choosing. For example, to implement a game where the player character can pick up an item, you might call this method when the player presses the “pick up” button to see if the player character is in contact with the item to be picked up.
	     * @see https://developer.apple.com/reference/scenekit/scnphysicsworld/1512875-contacttestbetween
	     */
	    value: function contactTestBetween(bodyA, bodyB) {
	      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

	      return null;
	    }

	    /**
	     * Checks for contacts between one physics body and any other bodies in the physics world.
	     * @access public
	     * @param {SCNPhysicsBody} body - The body to test for contact.
	     * @param {?Map<SCNPhysicsWorld.TestOption, Object>} [options = null] - A dictionary of options affecting the test, or nil to use default options. For applicable keys and the possible values, see Physics Test Options Keys.
	     * @returns {SCNPhysicsContact[]} - 
	     * @desc SceneKit sends messages to the physics world’s contactdelegate object only when collisions occur between bodies whose collisionBitMask and categoryBitMask properties overlap, and only for collisions between certain types of bodies. (For details, see SCNPhysicsBodyType.) Use this method to directly test for all contacts between one body and any other bodies at a time of your choosing. For example, to implement a game with a “wall jump” effect, you could call this method when the player presses the jump button to see if the player character is in contact with any walls.
	     * @see https://developer.apple.com/reference/scenekit/scnphysicsworld/1512841-contacttest
	     */

	  }, {
	    key: 'contactTestWith',
	    value: function contactTestWith(body) {
	      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

	      return null;
	    }

	    // Searching for Physics Bodies

	    /**
	     * Searches for physics bodies along a line segment between two points in the physics world.
	     * @access public
	     * @param {SCNVector3} origin - An endpoint of the line segment to search, specified in the scene’s world coordinate system.
	     * @param {SCNVector3} dest - The other endpoint of the line segment to search, specified in the scene’s world coordinate system.
	     * @param {?Map<SCNPhysicsWorld.TestOption, Object>} [options = null] - A dictionary of options affecting the test, or nil to use default options. For applicable keys and the possible values, see Physics Test Options Keys.
	     * @returns {SCNHitTestResult[]} - 
	     * @desc Use this method to implement concepts such as line of sight in your app. For example, in a game you might implement behavior for an enemy character by searching for physics bodies along a line between the enemy character’s position and the player character’s position, as illustrated below:// Options: Look only for the closest object along line of sight,
	    // and use the collision bitmask to avoid finding the enemy itself.
	    NSDictionary *options = @{ SCNPhysicsTestSearchModeKey : SCNPhysicsTestSearchModeClosest,
	                       SCNPhysicsTestCollisionBitMaskKey : @(kMyCategoryPlayer) };
	    NSArray *results = [physicsWorld rayTestWithSegmentFromPoint:enemy.position
	                                                       toPoint:player.position
	                                                       options:options];
	    if (results.firstObject.node == player) {
	      // Enemy can see player: begin pursuit.
	    } else {
	      // Enemy cannot see player: remain idle.
	    }
	    // Options: Look only for the closest object along line of sight,
	    // and use the collision bitmask to avoid finding the enemy itself.
	    NSDictionary *options = @{ SCNPhysicsTestSearchModeKey : SCNPhysicsTestSearchModeClosest,
	                       SCNPhysicsTestCollisionBitMaskKey : @(kMyCategoryPlayer) };
	    NSArray *results = [physicsWorld rayTestWithSegmentFromPoint:enemy.position
	                                                       toPoint:player.position
	                                                       options:options];
	    if (results.firstObject.node == player) {
	      // Enemy can see player: begin pursuit.
	    } else {
	      // Enemy cannot see player: remain idle.
	    }
	      * @see https://developer.apple.com/reference/scenekit/scnphysicsworld/1512857-raytestwithsegment
	     */

	  }, {
	    key: 'rayTestWithSegmentFromTo',
	    value: function rayTestWithSegmentFromTo(origin, dest) {
	      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

	      return null;
	    }

	    /**
	     * Searches for physics bodies in the space formed by moving a convex shape through the physics world.
	     * @access public
	     * @param {SCNPhysicsShape} shape - A physics shape. This shape must enclose a convex volume. For details on creating shapes that satisfy this requirement, see SCNPhysicsShape.
	     * @param {SCNMatrix4} from - A transform matrix representing the initial position and orientation of the shape.
	     * @param {SCNMatrix4} to - A transform matrix representing the final position and orientation of the shape.
	     * @param {?Map<SCNPhysicsWorld.TestOption, Object>} [options = null] - A dictionary of options affecting the test, or nil to use default options. For applicable keys and the possible values, see Physics Test Options Keys.
	     * @returns {SCNPhysicsContact[]} - 
	     * @desc Use this method when it’s important to plan for (or avoid) collisions ahead of the physics simulation. For example, in a game you might plan maneuvers for a flying character to fit through the gaps between static bodies in the physics world, as illustrated below:// Look for potential collisions along the spaceship's current path.
	    SCNMatrix4 current = spaceship.transform;
	    SCNMatrix4 upAhead = SCNMatrix4Translate(current, 0, 0, LOOK_AHEAD_DISTANCE);
	    NSArray *contacts = [physicsWorld convexSweepTestWithShape:spaceship.physicsBody.physicsShape
	                                               fromTransform:current
	                                                 toTransform:upAhead
	                                                     options:nil];
	    if (contacts.count == 0) {
	      // Flight path looks okay.
	    } else {
	      // Flight path will cause a collision: look for another way around.
	    }
	    // Look for potential collisions along the spaceship's current path.
	    SCNMatrix4 current = spaceship.transform;
	    SCNMatrix4 upAhead = SCNMatrix4Translate(current, 0, 0, LOOK_AHEAD_DISTANCE);
	    NSArray *contacts = [physicsWorld convexSweepTestWithShape:spaceship.physicsBody.physicsShape
	                                               fromTransform:current
	                                                 toTransform:upAhead
	                                                     options:nil];
	    if (contacts.count == 0) {
	      // Flight path looks okay.
	    } else {
	      // Flight path will cause a collision: look for another way around.
	    }
	      * @see https://developer.apple.com/reference/scenekit/scnphysicsworld/1512859-convexsweeptest
	     */

	  }, {
	    key: 'convexSweepTestWith',
	    value: function convexSweepTestWith(shape, from, to) {
	      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

	      return null;
	    }

	    // Structures
	    /**
	     * @type {Object} TestOption
	     * @property {Symbol} backfaceCulling The key for choosing whether to ignore back-facing polygons in physics shapes when searching for contacts.
	     * @property {Symbol} collisionBitMask The key for selecting which categories of physics bodies that SceneKit should test for contacts.
	     * @property {Symbol} searchMode The key for selecting the number and order of contacts to be tested.
	     * @see https://developer.apple.com/reference/scenekit/scnphysicsworld.testoption
	     */

	  }, {
	    key: 'allBehaviors',
	    get: function get() {
	      return this._allBehaviors;
	    }
	  }], [{
	    key: 'TestOption',
	    get: function get() {
	      return _TestOption;
	    }
	    /**
	     * @type {Object} TestSearchMode
	     * @property {Symbol} all Searches should return all contacts matching the search parameters.
	     * @property {Symbol} any Searches should return only the first contact found regardless of its position relative to the search parameters.
	     * @property {Symbol} closest Searches should return only the closest contact to the beginning of the search.
	     * @see https://developer.apple.com/reference/scenekit/scnphysicsworld.testsearchmode
	     */

	  }, {
	    key: 'TestSearchMode',
	    get: function get() {
	      return _TestSearchMode;
	    }
	  }]);

	  return SCNPhysicsWorld;
	}(_NSObject3.default);

	exports.default = SCNPhysicsWorld;

/***/ },
/* 52 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _NSObject2 = __webpack_require__(13);

	var _NSObject3 = _interopRequireDefault(_NSObject2);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * The abstract superclass for joints, vehicle simulations, and other high-level behaviors that incorporate multiple physics bodies.
	 * @access public
	 * @extends {NSObject}
	 * @see https://developer.apple.com/reference/scenekit/scnphysicsbehavior
	 */
	var SCNPhysicsBehavior = function (_NSObject) {
	  _inherits(SCNPhysicsBehavior, _NSObject);

	  function SCNPhysicsBehavior() {
	    _classCallCheck(this, SCNPhysicsBehavior);

	    return _possibleConstructorReturn(this, (SCNPhysicsBehavior.__proto__ || Object.getPrototypeOf(SCNPhysicsBehavior)).apply(this, arguments));
	  }

	  _createClass(SCNPhysicsBehavior, [{
	    key: 'init',


	    /**
	     * constructor
	     * @access public
	     * @returns {void}
	     */
	    value: function init() {}
	  }]);

	  return SCNPhysicsBehavior;
	}(_NSObject3.default);

	exports.default = SCNPhysicsBehavior;

/***/ },
/* 53 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _SCNPhysicsWorld = __webpack_require__(51);

	var _SCNPhysicsWorld2 = _interopRequireDefault(_SCNPhysicsWorld);

	var _SCNPhysicsContact = __webpack_require__(54);

	var _SCNPhysicsContact2 = _interopRequireDefault(_SCNPhysicsContact);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	/**
	 * Methods you can implement to respond when a contact or collision occurs between two physics bodies in a scene.
	 * @interface
	 * @see https://developer.apple.com/reference/scenekit/scnphysicscontactdelegate
	 */
	var SCNPhysicsContactDelegate = function () {
	  function SCNPhysicsContactDelegate() {
	    _classCallCheck(this, SCNPhysicsContactDelegate);
	  }

	  _createClass(SCNPhysicsContactDelegate, [{
	    key: 'init',


	    /**
	     * constructor
	     * @access public
	     * @returns {void}
	     */
	    value: function init() {}

	    // Responding to Contact Events

	    /**
	     * Tells the delegate that two bodies have come into contact.
	     * @access public
	     * @param {SCNPhysicsWorld} world - The physics world that is processing the contact.
	     * @param {SCNPhysicsContact} contact - An object that describes the contact.
	     * @returns {void}
	     * @see https://developer.apple.com/reference/scenekit/scnphysicscontactdelegate/1512835-physicsworld
	     */

	  }, {
	    key: 'physicsWorldDidBegin',
	    value: function physicsWorldDidBegin(world, contact) {}

	    /**
	     * Tells the delegate that new information is available about an ongoing contact.
	     * @access public
	     * @param {SCNPhysicsWorld} world - The physics world that is processing the contact.
	     * @param {SCNPhysicsContact} contact - An object that describes the contact.
	     * @returns {void}
	     * @desc SceneKit calls this method on each step of the physics simulation (see the timeStep property) if information about the contact changes—for example, if two bodies are sliding against one another.
	     * @see https://developer.apple.com/reference/scenekit/scnphysicscontactdelegate/1512865-physicsworld
	     */

	  }, {
	    key: 'physicsWorldDidUpdate',
	    value: function physicsWorldDidUpdate(world, contact) {}

	    /**
	     * Tells the delegate that a contact has ended.
	     * @access public
	     * @param {SCNPhysicsWorld} world - The physics world that is processing the contact.
	     * @param {SCNPhysicsContact} contact - An object that describes the contact.
	     * @returns {void}
	     * @see https://developer.apple.com/reference/scenekit/scnphysicscontactdelegate/1512883-physicsworld
	     */

	  }, {
	    key: 'physicsWorldDidEnd',
	    value: function physicsWorldDidEnd(world, contact) {}
	  }]);

	  return SCNPhysicsContactDelegate;
	}();

	exports.default = SCNPhysicsContactDelegate;

/***/ },
/* 54 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _NSObject2 = __webpack_require__(13);

	var _NSObject3 = _interopRequireDefault(_NSObject2);

	var _SCNNode = __webpack_require__(33);

	var _SCNNode2 = _interopRequireDefault(_SCNNode);

	var _SCNVector = __webpack_require__(15);

	var _SCNVector2 = _interopRequireDefault(_SCNVector);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * Detailed information about a contact between two physics bodies in a scene’s physics simulation. 
	 * @access public
	 * @extends {NSObject}
	 * @see https://developer.apple.com/reference/scenekit/scnphysicscontact
	 */
	var SCNPhysicsContact = function (_NSObject) {
	  _inherits(SCNPhysicsContact, _NSObject);

	  function SCNPhysicsContact() {
	    _classCallCheck(this, SCNPhysicsContact);

	    return _possibleConstructorReturn(this, (SCNPhysicsContact.__proto__ || Object.getPrototypeOf(SCNPhysicsContact)).apply(this, arguments));
	  }

	  _createClass(SCNPhysicsContact, [{
	    key: 'init',


	    /**
	     * constructor
	     * @access public
	     * @returns {void}
	     */
	    value: function init() {

	      // Inspecting the Contact Properties

	      this._nodeA = null;
	      this._nodeB = null;
	      this._contactPoint = null;
	      this._contactNormal = null;
	      this._collisionImpulse = 0;
	      this._penetrationDistance = 0;
	    }

	    // Inspecting the Contact Properties
	    /**
	     * The node containing the first body in the contact.
	     * @type {SCNNode}
	     * @desc Use the node’s physicsBody property to examine physics characteristics of the node.
	     * @see https://developer.apple.com/reference/scenekit/scnphysicscontact/1523445-nodea
	     */

	  }, {
	    key: 'nodeA',
	    get: function get() {
	      return this._nodeA;
	    }
	    /**
	     * The node containing the second body in the contact.
	     * @type {SCNNode}
	     * @desc Use the node’s physicsBody property to examine physics characteristics of the node.
	     * @see https://developer.apple.com/reference/scenekit/scnphysicscontact/1524232-nodeb
	     */

	  }, {
	    key: 'nodeB',
	    get: function get() {
	      return this._nodeB;
	    }
	    /**
	     * The contact point between the two physics bodies, in scene coordinates.
	     * @type {SCNVector3}
	     * @desc 
	     * @see https://developer.apple.com/reference/scenekit/scnphysicscontact/1523810-contactpoint
	     */

	  }, {
	    key: 'contactPoint',
	    get: function get() {
	      return this._contactPoint;
	    }
	    /**
	     * The normal vector at the contact point between the two physics bodies, in scene coordinates.
	     * @type {SCNVector3}
	     * @desc This vector tells you which direction the bodies were moving relative to one another at the time of the collision. For example, in a game you can examine this vector to have enemy characters take damage when struck from above by the player character but damage the player character instead when they collide side-to-side.
	     * @see https://developer.apple.com/reference/scenekit/scnphysicscontact/1522833-contactnormal
	     */

	  }, {
	    key: 'contactNormal',
	    get: function get() {
	      return this._contactNormal;
	    }
	    /**
	     * The force over time of the collision, in newton-seconds.
	     * @type {number}
	     * @desc This property’s value tells you how hard the bodies struck each other in a collision. For example, in a game you might allow a character to proceed unhindered after a minor collision, but take damage when struck with sufficient force.
	     * @see https://developer.apple.com/reference/scenekit/scnphysicscontact/1523944-collisionimpulse
	     */

	  }, {
	    key: 'collisionImpulse',
	    get: function get() {
	      return this._collisionImpulse;
	    }
	    /**
	     * The distance of overlap, in units of scene coordinate space, between the two physics bodies.
	     * @type {number}
	     * @desc 
	     * @see https://developer.apple.com/reference/scenekit/scnphysicscontact/1522870-penetrationdistance
	     */

	  }, {
	    key: 'penetrationDistance',
	    get: function get() {
	      return this._penetrationDistance;
	    }
	  }]);

	  return SCNPhysicsContact;
	}(_NSObject3.default);

	exports.default = SCNPhysicsContact;

/***/ },
/* 55 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _NSObject2 = __webpack_require__(13);

	var _NSObject3 = _interopRequireDefault(_NSObject2);

	var _SCNPhysicsBodyType = __webpack_require__(56);

	var _SCNPhysicsBodyType2 = _interopRequireDefault(_SCNPhysicsBodyType);

	var _SCNPhysicsShape = __webpack_require__(57);

	var _SCNPhysicsShape2 = _interopRequireDefault(_SCNPhysicsShape);

	var _SCNVector = __webpack_require__(15);

	var _SCNVector2 = _interopRequireDefault(_SCNVector);

	var _SCNVector3 = __webpack_require__(16);

	var _SCNVector4 = _interopRequireDefault(_SCNVector3);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * A set of physics simulation attributes attached to a scene graph node. 
	 * @access public
	 * @extends {NSObject}
	 * @see https://developer.apple.com/reference/scenekit/scnphysicsbody
	 */
	var SCNPhysicsBody = function (_NSObject) {
	  _inherits(SCNPhysicsBody, _NSObject);

	  // Creating Physics Bodies

	  /**
	   * Creates a physics body with the specified type and shape.
	   * @access public
	   * @constructor
	   * @param {SCNPhysicsBodyType} type - A constant that determines how a body responds to forces and collisions. See SCNPhysicsBodyType.
	   * @param {?SCNPhysicsShape} shape - A physics shape defining the volume of the body for collision detection purposes.
	   * @desc For the body to participate in collision detection or respond to forces, you must attach it to the physicsBody property of an SCNNode object in a scene.If you pass nil for the shape parameter, SceneKit automatically creates a physics shape for the body when you attach it to a node, based on that node’s geometry property. To create a physics shape that’s based on the geometries of a node and its hierarchy of children, or to control the level of detail in a physics shape, create the physics shape manually using an SCNPhysicsShape class method.NoteFor nodes containing custom geometry, the physics shape SceneKit automatically creates is a rough approximation of the geometry. This approximation, or convex hull, provides a compromise between accuracy and performance in collision detection. For the best collision detection performance, create an SCNPhysicsShape instance based on a basic geometry class (SCNBox, SCNSphere, SCNPyramid, SCNCone, SCNCylinder, or SCNCapsule).
	   * @see https://developer.apple.com/reference/scenekit/scnphysicsbody/1514797-init
	   */
	  function SCNPhysicsBody(type, shape) {
	    _classCallCheck(this, SCNPhysicsBody);

	    // Defining How Forces Affect a Physics Body

	    /**
	     * An object that defines the solid volume of the physics body for use in collision detection.
	     * @type {?SCNPhysicsShape}
	     * @see https://developer.apple.com/reference/scenekit/scnphysicsbody/1514789-physicsshape
	     */
	    var _this = _possibleConstructorReturn(this, (SCNPhysicsBody.__proto__ || Object.getPrototypeOf(SCNPhysicsBody)).call(this));

	    _this.physicsShape = shape;

	    /**
	     * A constant that determines how the physics body responds to forces and collisions.
	     * @type {SCNPhysicsBodyType}
	     * @see https://developer.apple.com/reference/scenekit/scnphysicsbody/1514787-type
	     */
	    _this.type = type;

	    /**
	     * A multiplier affecting how SceneKit applies translations computed by the physics simulation to the node containing the physics body.
	     * @type {SCNVector3}
	     * @see https://developer.apple.com/reference/scenekit/scnphysicsbody/1514753-velocityfactor
	     */
	    _this.velocityFactor = null;

	    /**
	     * A multiplier affecting how SceneKit applies rotations computed by the physics simulation to the node containing the physics body.
	     * @type {SCNVector3}
	     * @see https://developer.apple.com/reference/scenekit/scnphysicsbody/1514748-angularvelocityfactor
	     */
	    _this.angularVelocityFactor = null;

	    /**
	     * A Boolean value that determines whether the constant gravity of a scene accelerates the body.
	     * @type {boolean}
	     * @see https://developer.apple.com/reference/scenekit/scnphysicsbody/1514738-isaffectedbygravity
	     */
	    _this.isAffectedByGravity = false;

	    // Defining a Body’s Physical Properties

	    /**
	     * The mass of the body, in kilograms.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnphysicsbody/1514755-mass
	     */
	    _this.mass = 0;

	    /**
	     * The electric charge of the body, in coulombs.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnphysicsbody/1514786-charge
	     */
	    _this.charge = 0;

	    /**
	     * The body’s resistance to sliding motion.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnphysicsbody/1514794-friction
	     */
	    _this.friction = 0;

	    /**
	     * The body’s resistance to rolling motion.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnphysicsbody/1514737-rollingfriction
	     */
	    _this.rollingFriction = 0;

	    /**
	     * A factor that determines how much kinetic energy the body loses or gains in collisions.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnphysicsbody/1514740-restitution
	     */
	    _this.restitution = 0;

	    /**
	     * A factor that reduces the body’s linear velocity.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnphysicsbody/1514763-damping
	     */
	    _this.damping = 0;

	    /**
	     * A factor that reduces the body’s angular velocity.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnphysicsbody/1514792-angulardamping
	     */
	    _this.angularDamping = 0;

	    /**
	     * The body’s moment of inertia, expressed in the local coordinate system of the node that contains the body.
	     * @type {SCNVector3}
	     * @see https://developer.apple.com/reference/scenekit/scnphysicsbody/1514777-momentofinertia
	     */
	    _this.momentOfInertia = null;

	    /**
	     * A Boolean value that determines whether SceneKit automatically calculates the body’s moment of inertia or allows setting a custom value.
	     * @type {boolean}
	     * @see https://developer.apple.com/reference/scenekit/scnphysicsbody/1514761-usesdefaultmomentofinertia
	     */
	    _this.usesDefaultMomentOfInertia = false;

	    // Working with Contacts and Collisions

	    /**
	     * A mask that defines which categories this physics body belongs to.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnphysicsbody/1514768-categorybitmask
	     */
	    _this.categoryBitMask = 0;

	    /**
	     * A mask that defines which categories of bodies cause intersection notifications with this physics body.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnphysicsbody/1514746-contacttestbitmask
	     */
	    _this.contactTestBitMask = 0;

	    /**
	     * A mask that defines which categories of physics bodies can collide with this physics body.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnphysicsbody/1514772-collisionbitmask
	     */
	    _this.collisionBitMask = 0;

	    // Managing a Body’s Motion

	    /**
	     * A vector describing both the current speed (in meters per second) and direction of motion of the physics body.
	     * @type {SCNVector3}
	     * @see https://developer.apple.com/reference/scenekit/scnphysicsbody/1514757-velocity
	     */
	    _this.velocity = null;

	    /**
	     * A vector describing both the current rotation axis and rotational speed (in radians per second) of the physics body.
	     * @type {SCNVector4}
	     * @see https://developer.apple.com/reference/scenekit/scnphysicsbody/1514770-angularvelocity
	     */
	    _this.angularVelocity = null;

	    /**
	     * A Boolean value that specifies whether SceneKit can automatically mark the physics body at rest.
	     * @type {boolean}
	     * @see https://developer.apple.com/reference/scenekit/scnphysicsbody/1514742-allowsresting
	     */
	    _this.allowsResting = false;

	    _this._isResting = false;
	    return _this;
	  }

	  /**
	   * Creates a physics body that is unaffected by forces or collisions and that cannot move.
	   * @access public
	   * @returns {SCNPhysicsBody} - 
	   * @desc Use static bodies to construct fixtures in your scene that other bodies need to collide with but that do not themselves move, such as floors, walls, and terrain.For the body to participate in collision detection or respond to forces, you must attach it to the physicsBody property of an SCNNode object in a scene.SceneKit automatically creates a physics shape for the body when you attach it to a node, based on that node’s geometry property. To create a physics shape that’s based on the geometries of a node and its hierarchy of children, or to control the level of detail in a physics shape, create the physics shape manually using an SCNPhysicsShape class method.NoteFor nodes containing custom geometry, the physics shape SceneKit automatically creates is a rough approximation of the geometry. This approximation, or convex hull, provides a compromise between accuracy and performance in collision detection. For the best collision detection performance, create an SCNPhysicsShape instance based on a basic geometry class (SCNBox, SCNSphere, SCNPyramid, SCNCone, SCNCylinder, or SCNCapsule).
	   * @see https://developer.apple.com/reference/scenekit/scnphysicsbody/1514791-static
	   */


	  _createClass(SCNPhysicsBody, [{
	    key: 'applyForceAsImpulse',


	    // Applying Forces, Impulses, and Torques

	    /**
	     * Applies a force or impulse to the body at its center of mass.
	     * @access public
	     * @param {SCNVector3} direction - The direction and magnitude of the force (in newtons) or of the impulse (in newton-seconds).
	     * @param {boolean} impulse - true to apply an instantaneous change in momentum; false to apply a force that affects the body at the end of the simulation step.
	     * @returns {void}
	     * @desc Applying a force or impulse to a body imparts a linear acceleration proportional to its mass.The impulse parameter determines how this method contributes to the physics simulation:If you specify true, SceneKit treats the direction parameter as an impulse, measured in newton-seconds, and accelerates the physics body immediately. Use this option to simulate instantaneous effects such as launching a projectile.If you specify false, SceneKit treats the direction parameter as a force, measured in newtons. At the end of each simulation step (by default, a step occurs once for each frame in the rendering loop), SceneKit sums all forces applied to the physics body during that step and accelerates the body according to the net effect of those forces. Use this option when you want to simulate continuous forces on the body by calling applyForce(_:asImpulse:) on each simulation step.NoteThe impulse parameter effectively changes the unit of magnitude. A value that results in a certain acceleration when applied continuously on each frame of the simulation results in much less acceleration if applied only during a single frame.As with all physical quantities in SceneKit, you need not use realistic force measurements in your app—the effects of the physics simulation depend on the relative differences between forces, not on their absolute values. You may use whatever values produce the behavior or gameplay you’re looking for as long as you use them consistently.
	     * @see https://developer.apple.com/reference/scenekit/scnphysicsbody/1514801-applyforce
	     */
	    value: function applyForceAsImpulse(direction, impulse) {}

	    /**
	     * Applies a force or impulse to the body at a specific point.
	     * @access public
	     * @param {SCNVector3} direction - The direction and magnitude of the force (in newtons) or of the impulse (in newton-seconds).
	     * @param {SCNVector3} position - The point on the body where the force or impulse should be applied, in the local coordinate system of the SCNNode object containing the physics body.
	     * @param {boolean} impulse - true to apply an instantaneous change in momentum; false to apply a force that affects the body at the end of the simulation step.
	     * @returns {void}
	     * @desc Applying a force or impulse to a body at a position other than its center of mass may impart both linear and angular acceleration, depending on how the body is situated in the physics world and the other forces acting upon it.The impulse parameter determines how this method contributes to the physics simulation:If you specify true, SceneKit treats the direction parameter as an impulse, measured in newton-seconds, and accelerates the physics body immediately. Use this option to simulate instantaneous effects such as launching a projectile.If you specify false, SceneKit treats the direction parameter as a force, measured in newtons. At the end of each simulation step (by default, a step occurs once for each frame in the rendering loop), SceneKit sums all forces applied to the physics body during that step and accelerates the body according to the net effect of those forces. Use this option when you want to simulate continuous forces on the body by calling applyForce(_:at:asImpulse:) on each simulation step.NoteThe impulse parameter effectively changes the unit of magnitude. A value that results in a certain acceleration when applied continuously on each frame of the simulation results in much less acceleration if applied only during a single frame.As with all physical quantities in SceneKit, you need not use realistic force measurements in your app—the effects of the physics simulation depend on the relative differences between forces, not on their absolute values. You may use whatever values produce the behavior or gameplay you’re looking for as long as you use them consistently.
	     * @see https://developer.apple.com/reference/scenekit/scnphysicsbody/1514750-applyforce
	     */

	  }, {
	    key: 'applyForceAtAsImpulse',
	    value: function applyForceAtAsImpulse(direction, position, impulse) {}

	    /**
	     * Applies a net torque or a change in angular momentum to the body.
	     * @access public
	     * @param {SCNVector4} torque - The direction and magnitude of the torque (in newton-meters) or of the change of angular momentum (in newton-meter-seconds), relative to the world coordinate space of the scene. 
	     * @param {boolean} impulse - true to apply an instantaneous change in angular momentum; false to apply a torque that affects the body at the end of the simulation step.
	     * @returns {void}
	     * @desc Applying a torque to a body changes its angular velocity by an amount related to its mass and shape, rotating it without affecting its linear acceleration. Each component of the torque vector relates to rotation about the corresponding axis in the local coordinate system of the SCNNode object containing the physics body. For example, applying a torque of {0.0, 0.0, 1.0} causes a node to spin counterclockwise around the world-space z-axis.The impulse parameter determines how this method contributes to the physics simulation:If you specify true, SceneKit treats the direction parameter as an instantaneous change in angular momentum, measured in newton-meter-seconds.If you specify false, SceneKit treats the direction parameter as a torque, measured in newton-meters. At the end of each simulation step (by default, a step occurs once for each frame in the rendering loop), SceneKit sums all forces and torques applied to the physics body during that step and accelerates the body according to the net effect of those forces and torques. Use this option when you want to simulate gradual acceleration by calling applyTorque(_:asImpulse:) on each simulation step.NoteThe impulse parameter effectively changes the unit of magnitude. A value that results in a certain acceleration when applied continuously on each frame of the simulation results in much less acceleration if applied only during a single frame.As with all physical quantities in SceneKit, you need not use realistic force and torque measurements in your app—the effects of the physics simulation depend on the relative differences between forces, not on their absolute values. You may use whatever values produce the behavior or gameplay you’re looking for as long as you use them consistently.
	     * @see https://developer.apple.com/reference/scenekit/scnphysicsbody/1514752-applytorque
	     */

	  }, {
	    key: 'applyTorqueAsImpulse',
	    value: function applyTorqueAsImpulse(torque, impulse) {}

	    /**
	     * Cancels all continuous forces and torques acting on the physics body during the current simulation step.
	     * @access public
	     * @returns {void}
	     * @desc When you pass false for the impulse parameter in the applyForce(_:asImpulse:), applyForce(_:at:asImpulse:), or applyTorque(_:asImpulse:) method, SceneKit waits until the end of the current simulation step before applying its effect. At that time, SceneKit sums all forces and torques applied during that simulation step and changes the velocity or angular velocity of the body according to the net effect of those forces and torques.Call clearAllForces() to cancel any forces and torques previously applied during the current simulation step.
	     * @see https://developer.apple.com/reference/scenekit/scnphysicsbody/1514735-clearallforces
	     */

	  }, {
	    key: 'clearAllForces',
	    value: function clearAllForces() {}

	    // Managing a Body’s Motion
	    /**
	     * A Boolean value that indicates whether the physics body is at rest.
	     * @type {boolean}
	     * @desc This property’s default value is false, but SceneKit’s physics simulation may automatically set it to true if the body is not moving and not affected by any forces. A resting body does not participate in the simulation until another body collides with it or you change its position or velocity or apply a force to it.
	     * @see https://developer.apple.com/reference/scenekit/scnphysicsbody/1514795-isresting
	     */

	  }, {
	    key: 'resetTransform',


	    // Synchronizing a Physics Body with its Node

	    /**
	     * Updates the position and orientation of a body in the physics simulation to match that of the node to which the body is attached.
	     * @access public
	     * @returns {void}
	     * @desc If you change the position or orientation of a node with an attached static or dynamic physics body, call this method afterward to ensure that the physics simulation incorporates the change. You need not call this method for kinematic bodies.Note that dynamic and physics bodies are designed to be moved only by the physics simulation or not at all. You may use this method to move them regardless of this restriction, but at a cost to performance.
	     * @see https://developer.apple.com/reference/scenekit/scnphysicsbody/1514782-resettransform
	     */
	    value: function resetTransform() {}
	  }, {
	    key: 'isResting',
	    get: function get() {
	      return this._isResting;
	    }
	  }], [{
	    key: 'static',
	    value: function _static() {
	      return null;
	    }

	    /**
	     * Creates a physics body that can be affected by forces and collisions.
	     * @access public
	     * @returns {SCNPhysicsBody} - 
	     * @desc Use dynamic bodies for the elements of your scene that are moved by the physics simulation.For the body to participate in collision detection or respond to forces, you must attach it to the physicsBody property of an SCNNode object in a scene.SceneKit automatically creates a physics shape for the body when you attach it to a node, based on that node’s geometry property. To create a physics shape that’s based on the geometries of a node and its hierarchy of children, or to control the level of detail in a physics shape, create the physics shape manually using an SCNPhysicsShape class method.NoteFor nodes containing custom geometry, the physics shape SceneKit automatically creates is a rough approximation of the geometry. This approximation, or convex hull, provides a compromise between accuracy and performance in collision detection. For the best collision detection performance, create an SCNPhysicsShape instance based on a basic geometry class (SCNBox, SCNSphere, SCNPyramid, SCNCone, SCNCylinder, or SCNCapsule).
	     * @see https://developer.apple.com/reference/scenekit/scnphysicsbody/1514766-dynamic
	     */

	  }, {
	    key: 'dynamic',
	    value: function dynamic() {
	      return null;
	    }

	    /**
	     * Creates a physics body that is unaffected by forces or collisions but that can cause collisions affecting other bodies when moved.
	     * @access public
	     * @returns {SCNPhysicsBody} - 
	     * @desc Use kinematic bodies for scene elements that you want to control directly but whose movement manipulates other elements. For example, to allow the user to push objects around with a finger, you might create a kinematic body and attach it to an invisible node that you move follow touch events. (In macOS, use the same technique to allow the user to move objects with the mouse pointer.)For the body to participate in collision detection or respond to forces, you must attach it to the physicsBody property of an SCNNode object in a scene.SceneKit automatically creates a physics shape for the body when you attach it to a node, based on that node’s geometry property. To create a physics shape that’s based on the geometries of a node and its hierarchy of children, or to control the level of detail in a physics shape, create the physics shape manually using an SCNPhysicsShape class method.NoteFor nodes containing custom geometry, the physics shape SceneKit automatically creates is a rough approximation of the geometry. This approximation, or convex hull, provides a compromise between accuracy and performance in collision detection. For the best collision detection performance, create an SCNPhysicsShape instance based on a basic geometry class (SCNBox, SCNSphere, SCNPyramid, SCNCone, SCNCylinder, or SCNCapsule).
	     * @see https://developer.apple.com/reference/scenekit/scnphysicsbody/1514776-kinematic
	     */

	  }, {
	    key: 'kinematic',
	    value: function kinematic() {
	      return null;
	    }
	  }]);

	  return SCNPhysicsBody;
	}(_NSObject3.default);

	exports.default = SCNPhysicsBody;

/***/ },
/* 56 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * Constants that determine how a physics body interacts with forces and other bodies, used by the type property and when creating a physics body.
	 * @typedef {Object} SCNPhysicsBodyType
	 * @property {Symbol} static - A physics body that is unaffected by forces or collisions and cannot move.
	 * @property {Symbol} dynamic - A physics body that can be affected by forces and collisions.
	 * @property {Symbol} kinematic - A physics body that is unaffected by forces or collisions but that can cause collisions affecting other bodies when moved.
	 * @see https://developer.apple.com/reference/scenekit/scnphysicsbodytype
	 */

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var SCNPhysicsBodyType = {
	  static: Symbol(),
	  dynamic: Symbol(),
	  kinematic: Symbol()
	};

	exports.default = SCNPhysicsBodyType;

/***/ },
/* 57 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _NSObject2 = __webpack_require__(13);

	var _NSObject3 = _interopRequireDefault(_NSObject2);

	var _SCNGeometry = __webpack_require__(37);

	var _SCNGeometry2 = _interopRequireDefault(_SCNGeometry);

	var _SCNNode = __webpack_require__(33);

	var _SCNNode2 = _interopRequireDefault(_SCNNode);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var _Option = {
	  collisionMargin: Symbol(),
	  keepAsCompound: Symbol(),
	  scale: Symbol(),
	  type: Symbol()
	};

	var _ShapeType = {
	  boundingBox: Symbol(),
	  concavePolyhedron: Symbol(),
	  convexHull: Symbol()
	};

	/**
	 * An abstraction of a physics body’s solid volume for use in tuning or optimizing collision detection.
	 * @access public
	 * @extends {NSObject}
	 * @see https://developer.apple.com/reference/scenekit/scnphysicsshape
	 */

	var SCNPhysicsShape = function (_NSObject) {
	  _inherits(SCNPhysicsShape, _NSObject);

	  // Creating Physics Shapes

	  /**
	   * Creates a physics shape based on a geometry object.
	   * @access public
	   * @constructor
	   * @param {SCNGeometry} geometry - A geometry object.
	   * @param {?Map<SCNPhysicsShape.Option, Object>} [options = null] - A dictionary of options affecting the level of detail of the physics shape, or nil to use default options. For applicable keys and their possible values, see Shape Creation Options Keys.
	   * @desc If you create a physics shape using one of the basic geometry classes (SCNBox, SCNSphere, SCNPyramid, SCNCone, SCNCylinder, or SCNCapsule), SceneKit uses an idealized form of that geometry for the physics shape instead of using the geometry’s vertex data to simulate collisions. For example, if you create a physics shape from an SCNSphere object, SceneKit simulates collisions for any object that passes within the sphere’s radius. Because the idealized forms of simple geometries are computationally much simpler than the vertex data needed for displaying them, using basic geometries for physics shapes (or compound shapes created from basic geometries with the init(shapes:transforms:) method) often provides the best balance between simulation accuracy and performance. To use the newly created physics shape, create a physics body with the the init(type:shape:) method, or assign the shape to the physicsShape property of an existing body.
	   * @see https://developer.apple.com/reference/scenekit/scnphysicsshape/1508897-init
	   */
	  function SCNPhysicsShape(geometry) {
	    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

	    _classCallCheck(this, SCNPhysicsShape);

	    // Getting Information About a Shape
	    var _this = _possibleConstructorReturn(this, (SCNPhysicsShape.__proto__ || Object.getPrototypeOf(SCNPhysicsShape)).call(this));

	    _this._sourceObject = null;
	    _this._options = null;
	    _this._transforms = null;
	    return _this;
	  }

	  // Getting Information About a Shape

	  /**
	   * The object that was used to create the shape.
	   * @type {Object}
	   * @desc This property, along with the transforms and options properties, provides the information that was used to create the shape. You can use this information, for example, to draw editing or debugging UI in your scene.If the shape was created with the init(geometry:options:) method, the source object is an SCNGeometry object, and the options property contains the options affecting the shape’s construction from that geometry.If the shape was created with the init(node:options:) method, the source object is an SCNNode object, and the options property contains the options affecting the shape’s construction from that node.If the shape was created with the init(shapes:transforms:) method, the source object is an array of SCNPhysicsShape objects and the transforms property describes how those shapes combine to form a compound shape.
	   * @see https://developer.apple.com/reference/scenekit/scnphysicsshape/1508888-sourceobject
	   */


	  _createClass(SCNPhysicsShape, [{
	    key: 'sourceObject',
	    get: function get() {
	      return this._sourceObject;
	    }

	    /**
	     * The options dictionary that was used to create the shape.
	     * @type {?Map<SCNPhysicsShape.Option, Object>}
	     * @desc You provide this dictionary in the init(geometry:options:) or init(node:options:) method. Use this dictionary along with the sourceObject property to recover the information that was used to create the shape. If the shape was created with the init(shapes:transforms:) method, this property’s value is nil.
	     * @see https://developer.apple.com/reference/scenekit/scnphysicsshape/1508904-options
	     */

	  }, {
	    key: 'options',
	    get: function get() {
	      return this._options;
	    }

	    /**
	     * The array of transforms that was used to create a compound shape.
	     * @type {?NSValue[]}
	     * @desc You provide this array of NSValue objects, each containing an SCNMatrix4 value, in the init(shapes:transforms:) method to create a compound shape. Use this array along with the sourceObject property to recover the information that was used to create the shape. If the shape was created with the init(geometry:options:) or init(node:options:) method, this property's value is nil.
	     * @see https://developer.apple.com/reference/scenekit/scnphysicsshape/1508898-transforms
	     */

	  }, {
	    key: 'transforms',
	    get: function get() {
	      return this._transforms;
	    }

	    // Structures

	    /**
	     * @type {Object} Option
	     * @property {Symbol} collisionMargin 
	     * @property {Symbol} keepAsCompound An option for selecting whether to create a group of independent shapes or combine them into a single shape.
	     * @property {Symbol} scale An option for selecting the scale factor of the shape relative to the local coordinate space of the node containing it.
	     * @property {Symbol} type An option for selecting the level of detail at which to create shapes from geometry.
	     * @see https://developer.apple.com/reference/scenekit/scnphysicsshape.option
	     */

	  }], [{
	    key: 'Option',
	    get: function get() {
	      return _Option;
	    }

	    /**
	     * @type {Object} ShapeType
	     * @property {Symbol} boundingBox The physics shape is the smallest box containing the geometry.
	     * @property {Symbol} concavePolyhedron The physics shape is a concave polyhedron closely following the surface of the geometry.
	     * @property {Symbol} convexHull The physics shape is a convex polyhedron roughly enclosing the geometry.
	     * @see https://developer.apple.com/reference/scenekit/scnphysicsshape.shapetype
	     */

	  }, {
	    key: 'ShapeType',
	    get: function get() {
	      return _ShapeType;
	    }
	  }]);

	  return SCNPhysicsShape;
	}(_NSObject3.default);

	exports.default = SCNPhysicsShape;

/***/ },
/* 58 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _NSObject2 = __webpack_require__(13);

	var _NSObject3 = _interopRequireDefault(_NSObject2);

	var _SCNNode = __webpack_require__(33);

	var _SCNNode2 = _interopRequireDefault(_SCNNode);

	var _SCNVector = __webpack_require__(15);

	var _SCNVector2 = _interopRequireDefault(_SCNVector);

	var _SCNMatrix = __webpack_require__(17);

	var _SCNMatrix2 = _interopRequireDefault(_SCNMatrix);

	var _CGPoint = __webpack_require__(5);

	var _CGPoint2 = _interopRequireDefault(_CGPoint);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * Detailed information about a result from searching for elements of a scene located at a specified point, or along a specified line segment (or ray).
	 * @access public
	 * @extends {NSObject}
	 * @see https://developer.apple.com/reference/scenekit/scnhittestresult
	 */
	var SCNHitTestResult = function (_NSObject) {
	  _inherits(SCNHitTestResult, _NSObject);

	  function SCNHitTestResult() {
	    _classCallCheck(this, SCNHitTestResult);

	    return _possibleConstructorReturn(this, (SCNHitTestResult.__proto__ || Object.getPrototypeOf(SCNHitTestResult)).apply(this, arguments));
	  }

	  _createClass(SCNHitTestResult, [{
	    key: 'init',


	    /**
	     * constructor
	     * @access public
	     * @returns {void}
	     */
	    value: function init() {

	      // Retrieving Information About a Hit-Test Result

	      this._node = null;
	      this._geometryIndex = 0;
	      this._faceIndex = 0;
	      this._localCoordinates = null;
	      this._worldCoordinates = null;
	      this._localNormal = null;
	      this._worldNormal = null;
	      this._modelTransform = null;

	      // Instance Properties

	      this._boneNode = null;
	    }

	    // Retrieving Information About a Hit-Test Result

	    /**
	     * Returns the texture coordinates at the point of intersection for the specified texture mapping channel.
	     * @access public
	     * @param {number} channel - The index of the mapping channel in which to look up texture coordinates.
	     * @returns {CGPoint} - 
	     * @desc An SCNGeometry object can contain multiple sources of texture coordinates, or texture mapping channels. (With multiple channels, you can map texture images for different material properties in different ways.) To use the texture coordinates of a hit-test result, specify which texture coordinate source to look up coordinates in. For example, to add “scorch marks” to a game character hit by a laser, you might modify a texture image mapped to the multiply property of the geometry’s material. Use the mappingChannel index from that material property as the channel parameter when calling textureCoordinates(withMappingChannel:) to ensure that you modify the correct location in the texture image.
	     * @see https://developer.apple.com/reference/scenekit/scnhittestresult/1522771-texturecoordinates
	     */

	  }, {
	    key: 'textureCoordinatesWithMappingChannel',
	    value: function textureCoordinatesWithMappingChannel(channel) {
	      return null;
	    }
	    /**
	     * The node whose geometry intersects the search ray.
	     * @type {SCNNode}
	     * @desc 
	     * @see https://developer.apple.com/reference/scenekit/scnhittestresult/1523256-node
	     */

	  }, {
	    key: 'node',
	    get: function get() {
	      return this._node;
	    }
	    /**
	     * The index of the geometry element whose surface the search ray intersects.
	     * @type {number}
	     * @desc Every SCNGeometry object contains one or more SCNGeometryElement objects that define how its vertices connect to form a surface. This property provides the index of the geometry element intersecting the search ray. For more information about that geometry element, use the geometry’s geometryElement(at:) method.
	     * @see https://developer.apple.com/reference/scenekit/scnhittestresult/1522625-geometryindex
	     */

	  }, {
	    key: 'geometryIndex',
	    get: function get() {
	      return this._geometryIndex;
	    }
	    /**
	     * The index of the primitive in the geomety element intersected by the search ray.
	     * @type {number}
	     * @desc 
	     * @see https://developer.apple.com/reference/scenekit/scnhittestresult/1522888-faceindex
	     */

	  }, {
	    key: 'faceIndex',
	    get: function get() {
	      return this._faceIndex;
	    }
	    /**
	     * The point of intersection between the geometry and the search ray, in the local coordinate system of the node containing the geometry.
	     * @type {SCNVector3}
	     * @desc 
	     * @see https://developer.apple.com/reference/scenekit/scnhittestresult/1523032-localcoordinates
	     */

	  }, {
	    key: 'localCoordinates',
	    get: function get() {
	      return this._localCoordinates;
	    }
	    /**
	     * The point of intersection between the geometry and the search ray, in the scene’s world coordinate system.
	     * @type {SCNVector3}
	     * @desc 
	     * @see https://developer.apple.com/reference/scenekit/scnhittestresult/1523058-worldcoordinates
	     */

	  }, {
	    key: 'worldCoordinates',
	    get: function get() {
	      return this._worldCoordinates;
	    }
	    /**
	     * The surface normal vector at the point of intersection, in the local coordinate system of the node containing the geometry intersected by the search ray.
	     * @type {SCNVector3}
	     * @desc 
	     * @see https://developer.apple.com/reference/scenekit/scnhittestresult/1523953-localnormal
	     */

	  }, {
	    key: 'localNormal',
	    get: function get() {
	      return this._localNormal;
	    }
	    /**
	     * The surface normal vector at the point of intersection, in the scene’s world coordinate system.
	     * @type {SCNVector3}
	     * @desc 
	     * @see https://developer.apple.com/reference/scenekit/scnhittestresult/1524066-worldnormal
	     */

	  }, {
	    key: 'worldNormal',
	    get: function get() {
	      return this._worldNormal;
	    }
	    /**
	     * The world transform matrix of the node containing the intersection.
	     * @type {SCNMatrix4}
	     * @desc Use this matrix to transform vectors from the local coordinate space of the node whose geometry is intersected by the search ray to the scene’s world coordinate system.
	     * @see https://developer.apple.com/reference/scenekit/scnhittestresult/1523496-modeltransform
	     */

	  }, {
	    key: 'modelTransform',
	    get: function get() {
	      return this._modelTransform;
	    }

	    // Instance Properties
	    /**
	     * 
	     * @type {SCNNode}
	     * @desc 
	     * @see https://developer.apple.com/reference/scenekit/scnhittestresult/1823463-bonenode
	     */

	  }, {
	    key: 'boneNode',
	    get: function get() {
	      return this._boneNode;
	    }
	  }]);

	  return SCNHitTestResult;
	}(_NSObject3.default);

	exports.default = SCNHitTestResult;

/***/ },
/* 59 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _NSObject2 = __webpack_require__(13);

	var _NSObject3 = _interopRequireDefault(_NSObject2);

	var _SCNAnimatable = __webpack_require__(35);

	var _SCNAnimatable2 = _interopRequireDefault(_SCNAnimatable);

	var _SCNGeometry = __webpack_require__(37);

	var _SCNGeometry2 = _interopRequireDefault(_SCNGeometry);

	var _SCNParticleBirthLocation = __webpack_require__(60);

	var _SCNParticleBirthLocation2 = _interopRequireDefault(_SCNParticleBirthLocation);

	var _SCNParticleBirthDirection = __webpack_require__(61);

	var _SCNParticleBirthDirection2 = _interopRequireDefault(_SCNParticleBirthDirection);

	var _SCNVector = __webpack_require__(15);

	var _SCNVector2 = _interopRequireDefault(_SCNVector);

	var _SCNVector3 = __webpack_require__(16);

	var _SCNVector4 = _interopRequireDefault(_SCNVector3);

	var _SCNParticleImageSequenceAnimationMode = __webpack_require__(62);

	var _SCNParticleImageSequenceAnimationMode2 = _interopRequireDefault(_SCNParticleImageSequenceAnimationMode);

	var _SCNNode = __webpack_require__(33);

	var _SCNNode2 = _interopRequireDefault(_SCNNode);

	var _SCNParticleBlendMode = __webpack_require__(63);

	var _SCNParticleBlendMode2 = _interopRequireDefault(_SCNParticleBlendMode);

	var _SCNParticleOrientationMode = __webpack_require__(64);

	var _SCNParticleOrientationMode2 = _interopRequireDefault(_SCNParticleOrientationMode);

	var _SCNParticleSortingMode = __webpack_require__(65);

	var _SCNParticleSortingMode2 = _interopRequireDefault(_SCNParticleSortingMode);

	var _SCNParticleEvent = __webpack_require__(66);

	var _SCNParticleEvent2 = _interopRequireDefault(_SCNParticleEvent);

	var _SCNParticleEventBlock = __webpack_require__(67);

	var _SCNParticleEventBlock2 = _interopRequireDefault(_SCNParticleEventBlock);

	var _SCNParticlePropertyController = __webpack_require__(68);

	var _SCNParticlePropertyController2 = _interopRequireDefault(_SCNParticlePropertyController);

	var _SCNParticleModifierStage = __webpack_require__(70);

	var _SCNParticleModifierStage2 = _interopRequireDefault(_SCNParticleModifierStage);

	var _SCNParticleModifierBlock = __webpack_require__(71);

	var _SCNParticleModifierBlock2 = _interopRequireDefault(_SCNParticleModifierBlock);

	var _SKColor = __webpack_require__(48);

	var _SKColor2 = _interopRequireDefault(_SKColor);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var _ParticleProperty = {
	  angle: Symbol(),
	  angularVelocity: Symbol(),
	  bounce: Symbol(),
	  charge: Symbol(),
	  color: Symbol(),
	  contactNormal: Symbol(),
	  contactPoint: Symbol(),
	  frame: Symbol(),
	  frameRate: Symbol(),
	  friction: Symbol(),
	  life: Symbol(),
	  opacity: Symbol(),
	  position: Symbol(),
	  rotationAxis: Symbol(),
	  size: Symbol(),
	  velocity: Symbol()
	};

	/**
	 * Manages the animation and rendering of a system of small image sprites, or particles, using a high-level simulation whose general behavior you specify.
	 * @access public
	 * @extends {NSObject}
	 * @implements {SCNAnimatable}
	 * @see https://developer.apple.com/reference/scenekit/scnparticlesystem
	 */

	var SCNParticleSystem = function (_NSObject) {
	  _inherits(SCNParticleSystem, _NSObject);

	  function SCNParticleSystem() {
	    _classCallCheck(this, SCNParticleSystem);

	    return _possibleConstructorReturn(this, (SCNParticleSystem.__proto__ || Object.getPrototypeOf(SCNParticleSystem)).apply(this, arguments));
	  }

	  _createClass(SCNParticleSystem, [{
	    key: 'init',


	    /**
	     * constructor
	     * @access public
	     * @returns {void}
	     */
	    value: function init() {

	      // Managing Particle Emission Timing

	      /**
	       * The duration, in seconds, over which the system spawns new particles. Animatable.
	       * @type {number}
	       * @see https://developer.apple.com/reference/scenekit/scnparticlesystem/1523998-emissionduration
	       */
	      this.emissionDuration = 0;

	      /**
	       * The range, in seconds, of randomized emission duration values. Animatable.
	       * @type {number}
	       * @see https://developer.apple.com/reference/scenekit/scnparticlesystem/1523842-emissiondurationvariation
	       */
	      this.emissionDurationVariation = 0;

	      /**
	       * The duration, in seconds, of periods when the system emits no particles. Animatable.
	       * @type {number}
	       * @see https://developer.apple.com/reference/scenekit/scnparticlesystem/1522998-idleduration
	       */
	      this.idleDuration = 0;

	      /**
	       * The range, in seconds, of randomized idle duration values. Animatable.
	       * @type {number}
	       * @see https://developer.apple.com/reference/scenekit/scnparticlesystem/1523018-idledurationvariation
	       */
	      this.idleDurationVariation = 0;

	      /**
	       * A Boolean value that determines whether the system repeats its emission and idle periods.
	       * @type {boolean}
	       * @see https://developer.apple.com/reference/scenekit/scnparticlesystem/1522618-loops
	       */
	      this.loops = false;

	      /**
	       * The duration, in seconds, for which particles are spawned before the system is first rendered. Animatable.
	       * @type {number}
	       * @see https://developer.apple.com/reference/scenekit/scnparticlesystem/1522597-warmupduration
	       */
	      this.warmupDuration = 0;

	      /**
	       * The number of particles spawned during each emission period. Animatable.
	       * @type {number}
	       * @see https://developer.apple.com/reference/scenekit/scnparticlesystem/1522857-birthrate
	       */
	      this.birthRate = 0;

	      /**
	       * The range of randomized particle birth rate values. Animatable.
	       * @type {number}
	       * @see https://developer.apple.com/reference/scenekit/scnparticlesystem/1524147-birthratevariation
	       */
	      this.birthRateVariation = 0;

	      // Managing Particle Emission Locations

	      /**
	       * The shape of the region of space where the system spawns new particles.
	       * @type {?SCNGeometry}
	       * @see https://developer.apple.com/reference/scenekit/scnparticlesystem/1522737-emittershape
	       */
	      this.emitterShape = null;

	      /**
	       * The possible locations for newly spawned particles, relative to the emitter shape.
	       * @type {SCNParticleBirthLocation}
	       * @see https://developer.apple.com/reference/scenekit/scnparticlesystem/1522899-birthlocation
	       */
	      this.birthLocation = null;

	      /**
	       * The possible initial directions for newly spawned particles, relative to the emitter shape.
	       * @type {SCNParticleBirthDirection}
	       * @see https://developer.apple.com/reference/scenekit/scnparticlesystem/1523361-birthdirection
	       */
	      this.birthDirection = null;

	      /**
	       * The initial direction for newly spawned particles. Animatable.
	       * @type {SCNVector3}
	       * @see https://developer.apple.com/reference/scenekit/scnparticlesystem/1523600-emittingdirection
	       */
	      this.emittingDirection = null;

	      /**
	       * The range, in degrees, of randomized initial particle directions. Animatable.
	       * @type {number}
	       * @see https://developer.apple.com/reference/scenekit/scnparticlesystem/1522862-spreadingangle
	       */
	      this.spreadingAngle = 0;

	      // Managing Particle Motion

	      /**
	       * The rotation angle, in degrees, of newly spawned particles. Animatable.
	       * @type {number}
	       * @see https://developer.apple.com/reference/scenekit/scnparticlesystem/1523896-particleangle
	       */
	      this.particleAngle = 0;

	      /**
	       * The range, in degrees of randomized initial particle angles. Animatable.
	       * @type {number}
	       * @see https://developer.apple.com/reference/scenekit/scnparticlesystem/1522828-particleanglevariation
	       */
	      this.particleAngleVariation = 0;

	      /**
	       * The initial speed, in units per second, for newly spawned particles. Animatable.
	       * @type {number}
	       * @see https://developer.apple.com/reference/scenekit/scnparticlesystem/1523946-particlevelocity
	       */
	      this.particleVelocity = 0;

	      /**
	       * The range, in units per second, of randomized initial particle speeds. Animatable.
	       * @type {number}
	       * @see https://developer.apple.com/reference/scenekit/scnparticlesystem/1524157-particlevelocityvariation
	       */
	      this.particleVelocityVariation = 0;

	      /**
	       * The initial spin rate, in degrees per second, of newly spawned particles. Animatable.
	       * @type {number}
	       * @see https://developer.apple.com/reference/scenekit/scnparticlesystem/1522757-particleangularvelocity
	       */
	      this.particleAngularVelocity = 0;

	      /**
	       * The range, in degrees per second, of randomized initial angular velocities for particles. Animatable.
	       * @type {number}
	       * @see https://developer.apple.com/reference/scenekit/scnparticlesystem/1523590-particleangularvelocityvariation
	       */
	      this.particleAngularVelocityVariation = 0;

	      /**
	       * The duration, in seconds, for which each particle is rendered before being removed from the scene. Animatable.
	       * @type {number}
	       * @see https://developer.apple.com/reference/scenekit/scnparticlesystem/1523575-particlelifespan
	       */
	      this.particleLifeSpan = 0;

	      /**
	       * The range, in seconds, of randomized particle life spans. Animatable.
	       * @type {number}
	       * @see https://developer.apple.com/reference/scenekit/scnparticlesystem/1523567-particlelifespanvariation
	       */
	      this.particleLifeSpanVariation = 0;

	      // Specifying Particle Appearance

	      /**
	       * The rendered size, in units of the scene’s world coordinate space, of the particle image. Animatable.
	       * @type {number}
	       * @see https://developer.apple.com/reference/scenekit/scnparticlesystem/1523508-particlesize
	       */
	      this.particleSize = 0;

	      /**
	       * The range of randomized particle sizes. Animatable.
	       * @type {number}
	       * @see https://developer.apple.com/reference/scenekit/scnparticlesystem/1522716-particlesizevariation
	       */
	      this.particleSizeVariation = 0;

	      /**
	       * The color of newly spawned particles. Animatable.
	       * @type {SKColor}
	       * @see https://developer.apple.com/reference/scenekit/scnparticlesystem/1523248-particlecolor
	       */
	      this.particleColor = null;

	      /**
	       * The ranges of randomized particle color components. Animatable.
	       * @type {SCNVector4}
	       * @see https://developer.apple.com/reference/scenekit/scnparticlesystem/1523639-particlecolorvariation
	       */
	      this.particleColorVariation = null;

	      /**
	       * The texture image SceneKit uses to render each particle.
	       * @type {?Object}
	       * @see https://developer.apple.com/reference/scenekit/scnparticlesystem/1524153-particleimage
	       */
	      this.particleImage = null;

	      /**
	       * The reflectivity exponent SceneKit uses when rendering the particle’s image as a cube map. Animatable.
	       * @type {number}
	       * @see https://developer.apple.com/reference/scenekit/scnparticlesystem/1523317-fresnelexponent
	       */
	      this.fresnelExponent = 0;

	      /**
	       * A multiplier for stretching particle images along their direction of motion. Animatable.
	       * @type {number}
	       * @see https://developer.apple.com/reference/scenekit/scnparticlesystem/1523338-stretchfactor
	       */
	      this.stretchFactor = 0;

	      // Animating Particle Images

	      /**
	       * The number of rows for treating the particle image as a grid of animation frames.
	       * @type {number}
	       * @see https://developer.apple.com/reference/scenekit/scnparticlesystem/1523340-imagesequencerowcount
	       */
	      this.imageSequenceRowCount = 0;

	      /**
	       * The number of columns for treating the particle image as a grid of animation frames.
	       * @type {number}
	       * @see https://developer.apple.com/reference/scenekit/scnparticlesystem/1523462-imagesequencecolumncount
	       */
	      this.imageSequenceColumnCount = 0;

	      /**
	       * The index of the first frame in a particle image animation. Animatable.
	       * @type {number}
	       * @see https://developer.apple.com/reference/scenekit/scnparticlesystem/1523511-imagesequenceinitialframe
	       */
	      this.imageSequenceInitialFrame = 0;

	      /**
	       * The range of randomized initial frames for particle image animation. Animatable.
	       * @type {number}
	       * @see https://developer.apple.com/reference/scenekit/scnparticlesystem/1523821-imagesequenceinitialframevariati
	       */
	      this.imageSequenceInitialFrameVariation = 0;

	      /**
	       * The rate, in frames per second, of particle image animation. Animatable.
	       * @type {number}
	       * @see https://developer.apple.com/reference/scenekit/scnparticlesystem/1524075-imagesequenceframerate
	       */
	      this.imageSequenceFrameRate = 0;

	      /**
	       * The range, in frames per second, of randomized frame rates for particle image animation. Animatable.
	       * @type {number}
	       * @see https://developer.apple.com/reference/scenekit/scnparticlesystem/1523667-imagesequenceframeratevariation
	       */
	      this.imageSequenceFrameRateVariation = 0;

	      /**
	       * The animation mode for particle image animation.
	       * @type {SCNParticleImageSequenceAnimationMode}
	       * @see https://developer.apple.com/reference/scenekit/scnparticlesystem/1522816-imagesequenceanimationmode
	       */
	      this.imageSequenceAnimationMode = null;

	      // Simulating Physics for Particles

	      /**
	       * A Boolean value that determines whether gravity, as defined by the scene’s physics simulation, affects the motion of particles.
	       * @type {boolean}
	       * @see https://developer.apple.com/reference/scenekit/scnparticlesystem/1523452-isaffectedbygravity
	       */
	      this.isAffectedByGravity = false;

	      /**
	       * A Boolean value that determines whether physics fields in the scene affect the motion of particles.
	       * @type {boolean}
	       * @see https://developer.apple.com/reference/scenekit/scnparticlesystem/1523353-isaffectedbyphysicsfields
	       */
	      this.isAffectedByPhysicsFields = false;

	      /**
	       * The nodes whose geometry the system’s particles can collide with.
	       * @type {?SCNNode[]}
	       * @see https://developer.apple.com/reference/scenekit/scnparticlesystem/1523516-collidernodes
	       */
	      this.colliderNodes = null;

	      /**
	       * A Boolean value that determines whether particles are removed from the scene upon colliding with another object.
	       * @type {boolean}
	       * @see https://developer.apple.com/reference/scenekit/scnparticlesystem/1523357-particlediesoncollision
	       */
	      this.particleDiesOnCollision = false;

	      /**
	       * The constant acceleration vector, in units per second per second, applied to all particles in the system. Animatable.
	       * @type {SCNVector3}
	       * @see https://developer.apple.com/reference/scenekit/scnparticlesystem/1522766-acceleration
	       */
	      this.acceleration = null;

	      /**
	       * A factor that slows particles relative to their velocity. Animatable.
	       * @type {number}
	       * @see https://developer.apple.com/reference/scenekit/scnparticlesystem/1522931-dampingfactor
	       */
	      this.dampingFactor = 0;

	      /**
	       * The mass, in kilograms, of each particle in the system. Animatable.
	       * @type {number}
	       * @see https://developer.apple.com/reference/scenekit/scnparticlesystem/1522607-particlemass
	       */
	      this.particleMass = 0;

	      /**
	       * The range, in kilograms, of randomized particle masses. Animatable.
	       * @type {number}
	       * @see https://developer.apple.com/reference/scenekit/scnparticlesystem/1523408-particlemassvariation
	       */
	      this.particleMassVariation = 0;

	      /**
	       * The electric charge, in coulombs, of each particle in the system. Animatable.
	       * @type {number}
	       * @see https://developer.apple.com/reference/scenekit/scnparticlesystem/1523156-particlecharge
	       */
	      this.particleCharge = 0;

	      /**
	       * The range, in coulombs, of randomized particle charges. Animatable.
	       * @type {number}
	       * @see https://developer.apple.com/reference/scenekit/scnparticlesystem/1523377-particlechargevariation
	       */
	      this.particleChargeVariation = 0;

	      /**
	       * The restitution coefficient of each particle in the system. Animatable.
	       * @type {number}
	       * @see https://developer.apple.com/reference/scenekit/scnparticlesystem/1522637-particlebounce
	       */
	      this.particleBounce = 0;

	      /**
	       * The range of randomized restitution coefficients for particles. Animatable.
	       * @type {number}
	       * @see https://developer.apple.com/reference/scenekit/scnparticlesystem/1522662-particlebouncevariation
	       */
	      this.particleBounceVariation = 0;

	      /**
	       * The friction coefficient of each particle in the system. Animatable.
	       * @type {number}
	       * @see https://developer.apple.com/reference/scenekit/scnparticlesystem/1524010-particlefriction
	       */
	      this.particleFriction = 0;

	      /**
	       * The range of randomized friction coefficients for particles. Animatable.
	       * @type {number}
	       * @see https://developer.apple.com/reference/scenekit/scnparticlesystem/1522868-particlefrictionvariation
	       */
	      this.particleFrictionVariation = 0;

	      // Spawning Additional Particle Systems

	      /**
	       * Another particle system to be added to the scene when a particle collides with scene geometry.
	       * @type {?SCNParticleSystem}
	       * @see https://developer.apple.com/reference/scenekit/scnparticlesystem/1524068-systemspawnedoncollision
	       */
	      this.systemSpawnedOnCollision = null;

	      /**
	       * Another particle system to be added to the scene when a particle dies.
	       * @type {?SCNParticleSystem}
	       * @see https://developer.apple.com/reference/scenekit/scnparticlesystem/1524091-systemspawnedondying
	       */
	      this.systemSpawnedOnDying = null;

	      /**
	       * Another particle system to be added to the scene for each living particle in the system.
	       * @type {?SCNParticleSystem}
	       * @see https://developer.apple.com/reference/scenekit/scnparticlesystem/1522751-systemspawnedonliving
	       */
	      this.systemSpawnedOnLiving = null;

	      // Managing Particle Rendering

	      /**
	       * The blending mode for compositing particle images into the rendered scene.
	       * @type {SCNParticleBlendMode}
	       * @see https://developer.apple.com/reference/scenekit/scnparticlesystem/1523728-blendmode
	       */
	      this.blendMode = null;

	      /**
	       * The mode defining whether and how particles may rotate.
	       * @type {SCNParticleOrientationMode}
	       * @see https://developer.apple.com/reference/scenekit/scnparticlesystem/1523131-orientationmode
	       */
	      this.orientationMode = null;

	      /**
	       * The mode defining the order in which SceneKit renders the system’s particles.
	       * @type {SCNParticleSortingMode}
	       * @see https://developer.apple.com/reference/scenekit/scnparticlesystem/1522795-sortingmode
	       */
	      this.sortingMode = null;

	      /**
	       * A Boolean value that determines whether SceneKit applies lighting to particle images when rendering.
	       * @type {boolean}
	       * @see https://developer.apple.com/reference/scenekit/scnparticlesystem/1522794-islightingenabled
	       */
	      this.isLightingEnabled = false;

	      /**
	       * A Boolean value that determines whether SceneKit renders particles in black before rendering the particle image.
	       * @type {boolean}
	       * @see https://developer.apple.com/reference/scenekit/scnparticlesystem/1523901-isblackpassenabled
	       */
	      this.isBlackPassEnabled = false;

	      // Controlling Particle Simulation

	      /**
	       * A Boolean value that specifies whether the particle simulation runs in the local coordinate space of the node containing it.
	       * @type {boolean}
	       * @see https://developer.apple.com/reference/scenekit/scnparticlesystem/1522855-islocal
	       */
	      this.isLocal = false;

	      /**
	       * A multiplier for the speed at which SceneKit runs the particle simulation. Animatable.
	       * @type {number}
	       * @see https://developer.apple.com/reference/scenekit/scnparticlesystem/1522988-speedfactor
	       */
	      this.speedFactor = 0;

	      // Modifying Particles Over Time

	      /**
	       * A dictionary that optionally associates particle properties with objects that animate a property’s value for each particle.
	       * @type {?Map<SCNParticleSystem.ParticleProperty, SCNParticlePropertyController>}
	       * @see https://developer.apple.com/reference/scenekit/scnparticlesystem/1522775-propertycontrollers
	       */
	      this.propertyControllers = null;
	    }

	    // Creating a Particle System

	    /**
	     * Loads a particle system from a file in the app’s bundle resources.
	     * @access public
	     * @param {string} name - The name of a particle system file in the app’s bundle resources directory, with or without the .scnp extension.
	     * @param {?string} directory - The subdirectory path in the app’s bundle resources directory.
	     * @returns {void}
	     * @desc A SceneKit particle file created by Xcode contains an archived SCNParticleSystem instance, so you can also use the NSKeyedArchiver and NSKeyedUnarchiver classes to write and read particle files.
	     * @see https://developer.apple.com/reference/scenekit/scnparticlesystem/1522772-init
	     */

	  }, {
	    key: 'initNamedInDirectory',
	    value: function initNamedInDirectory(name, directory) {}

	    // Controlling Particle Simulation

	    /**
	     * Returns the particle system to its initial state.
	     * @access public
	     * @returns {void}
	     * @desc Calling this method removes all currently live particles from the scene.
	     * @see https://developer.apple.com/reference/scenekit/scnparticlesystem/1522968-reset
	     */

	  }, {
	    key: 'reset',
	    value: function reset() {}

	    // Modifying Particles in Response to Particle System Events

	    /**
	     * Adds a block that modifies particle properties, to be executed at a specified event in the lifetimes of particles in the system.
	     * @access public
	     * @param {SCNParticleEvent} event - The event at which to call the block. See SCNParticleEvent for allowed values.
	     * @param {SCNParticleSystem.ParticleProperty[]} properties - An array containing one or more of the constants listed in Particle Property Keys, each of which specifies a property of the appearance or behaviors of particles in the particle system.
	     * @param {SCNParticleEventBlock} block - A SCNParticleEventBlock block to be called every time SceneKit renders a frame. In this block you can modify the properties of particles in the system.
	     * @returns {void}
	     * @desc By associating a block with one or more particle properties, you can run arbitrary code that modifies those properties when a significant event in the particle simulation occurs for one or more particles. For example, you can use the following code with a confetti effect to randomly switch between two distinct colors for each spawned particle:[system handleEvent:SCNParticleEventBirth
	        forProperties:@[SCNParticlePropertyColor]
	            withBlock:^(void **data, size_t *dataStride, uint32_t *indices , NSInteger count) {
	                for (NSInteger i = 0; i < count; ++i) {
	                    float *color = (float *)((char *)data[0] + dataStride[0] * i);
	                    if (rand() & 0x1) { // Switch the green and red color components.
	                        color[0] = color[1];
	                        color[1] = 0;
	                    }
	                }
	            }];
	    [system handleEvent:SCNParticleEventBirth
	        forProperties:@[SCNParticlePropertyColor]
	            withBlock:^(void **data, size_t *dataStride, uint32_t *indices , NSInteger count) {
	                for (NSInteger i = 0; i < count; ++i) {
	                    float *color = (float *)((char *)data[0] + dataStride[0] * i);
	                    if (rand() & 0x1) { // Switch the green and red color components.
	                        color[0] = color[1];
	                        color[1] = 0;
	                    }
	                }
	            }];
	      * @see https://developer.apple.com/reference/scenekit/scnparticlesystem/1523251-handle
	     */

	  }, {
	    key: 'handleForPropertiesHandler',
	    value: function handleForPropertiesHandler(event, properties, block) {}

	    // Modifying Particles Over Time

	    /**
	     * Adds a block that modifies particle properties, to be executed each time SceneKit renders a frame.
	     * @access public
	     * @param {SCNParticleSystem.ParticleProperty[]} properties - An array containing one or more of the constants listed in Particle Property Keys, each of which specifies a property of the appearance or behaviors of particles in the particle system.
	     * @param {SCNParticleModifierStage} stage - The stage of SceneKit’s particle simulation during which to call the block. See SCNParticleModifierStage for allowed values.
	     * @param {SCNParticleModifierBlock} block - A SCNParticleModifierBlock block to be called every time SceneKit renders a frame. In this block you can modify the properties of all particles in the system.
	     * @returns {void}
	     * @desc By associating a block with one or more particle properties, you can run arbitrary code that modifies those properties during each frame of animation. This option provides maximum flexibility for changing the appearance or behavior of particles over time. ImportantRunning your own code to update particle properties every frame can have a severe impact on rendering performance. If the behavior over time that you want for your particle system can be described more declaratively, use the propertyControllers property and SCNParticlePropertyController class instead. If you need to change particle properties only at certain times (rather than continuously), add a handler block for an event using the handle(_:forProperties:handler:) method.
	     * @see https://developer.apple.com/reference/scenekit/scnparticlesystem/1522635-addmodifier
	     */

	  }, {
	    key: 'addModifierForPropertiesAtModifier',
	    value: function addModifierForPropertiesAtModifier(properties, stage, block) {}

	    /**
	     * Removes particle modifier blocks for the specified stage of the particle simulation.
	     * @access public
	     * @param {SCNParticleModifierStage} stage - The stage of SceneKit’s particle simulation during which to call the block. See SCNParticleModifierStage for allowed values.
	     * @returns {void}
	     * @see https://developer.apple.com/reference/scenekit/scnparticlesystem/1524077-removemodifiers
	     */

	  }, {
	    key: 'removeModifiersAt',
	    value: function removeModifiersAt(stage) {}

	    /**
	     * Removes all particle modifier blocks associated with the particle system.
	     * @access public
	     * @returns {void}
	     * @see https://developer.apple.com/reference/scenekit/scnparticlesystem/1523614-removeallmodifiers
	     */

	  }, {
	    key: 'removeAllModifiers',
	    value: function removeAllModifiers() {}

	    // Structures
	    /**
	     * @type {Object} ParticleProperty
	     * @property {Symbol} angle The rotation angle, in radians, of the particle about its axis.
	     * @property {Symbol} angularVelocity The particle’s angular velocity (or rate of spin), in radians per second.
	     * @property {Symbol} bounce The particle’s restitution coefficient.
	     * @property {Symbol} charge The particle’s electric charge, in coulombs.
	     * @property {Symbol} color The particle’s tint color, as a vector of red, green, blue, and alpha component values.
	     * @property {Symbol} contactNormal The normal vector, in scene coordinate space, of a collision between a particle and a geometry in the scene.
	     * @property {Symbol} contactPoint The location, in scene coordinate space, of a collision between a particle and a geometry in the scene.
	     * @property {Symbol} frame The current frame index of the particle’s image animation.
	     * @property {Symbol} frameRate The rate, in frames per second, of the particle’s image animation.
	     * @property {Symbol} friction The particle’s friction coefficient.
	     * @property {Symbol} life The remaining time in the particle’s life span, in seconds.
	     * @property {Symbol} opacity The particle’s opacity (or alpha value).
	     * @property {Symbol} position The particle’s position vector in scene coordinate space.
	     * @property {Symbol} rotationAxis The particle’s axis of rotation, expressed as a vector in the particle’s local coordinate space.
	     * @property {Symbol} size The width and height of the rendered particle image, in units of scene coordinate space.
	     * @property {Symbol} velocity The particle’s velocity vector in units (of scene coordinate space) per second.
	     * @see https://developer.apple.com/reference/scenekit/scnparticlesystem.particleproperty
	     */

	  }], [{
	    key: 'ParticleProperty',
	    get: function get() {
	      return _ParticleProperty;
	    }
	  }]);

	  return SCNParticleSystem;
	}(_NSObject3.default);

	exports.default = SCNParticleSystem;

/***/ },
/* 60 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * Options for the initial location of each emitted particle, used by the birthLocation property.
	 * @typedef {Object} SCNParticleBirthLocation
	 * @property {Symbol} surface - New particles can be created at any location on the surface of the emitter shape.
	 * @property {Symbol} volume - New particles can be created at any location within the volume of the emitter shape.
	 * @property {Symbol} vertex - New particles can be created at only at the locations of the vertices in the emitter shape.
	 * @see https://developer.apple.com/reference/scenekit/scnparticlebirthlocation
	 */

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var SCNParticleBirthLocation = {
	  surface: Symbol(),
	  volume: Symbol(),
	  vertex: Symbol()
	};

	exports.default = SCNParticleBirthLocation;

/***/ },
/* 61 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * Options for the initial direction of each emitted particle, used by the birthDirection property.
	 * @typedef {Object} SCNParticleBirthDirection
	 * @property {Symbol} constant - The emitting direction is the same for all particles.
	 * @property {Symbol} surfaceNormal - The emitting direction for each particle is along the surface normal vector at the point where the particle is emitted.
	 * @property {Symbol} random - SceneKit randomizes the emitting direction for each particle.
	 * @see https://developer.apple.com/reference/scenekit/scnparticlebirthdirection
	 */

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var SCNParticleBirthDirection = {
	  constant: Symbol(),
	  surfaceNormal: Symbol(),
	  random: Symbol()
	};

	exports.default = SCNParticleBirthDirection;

/***/ },
/* 62 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * Options for animating each particle with a sequence of images, used by the imageSequenceAnimationMode property.
	 * @typedef {Object} SCNParticleImageSequenceAnimationMode
	 * @property {Symbol} repeat - The animation loops after displaying all of its images.
	 * @property {Symbol} clamp - The animation stops after displaying all of its images.
	 * @property {Symbol} autoReverse - After the animation displays all of its images, it plays again in reverse order.
	 * @see https://developer.apple.com/reference/scenekit/scnparticleimagesequenceanimationmode
	 */

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var SCNParticleImageSequenceAnimationMode = {
	  repeat: Symbol(),
	  clamp: Symbol(),
	  autoReverse: Symbol()
	};

	exports.default = SCNParticleImageSequenceAnimationMode;

/***/ },
/* 63 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * Options for combining source and destination pixel colors when compositing particles during rendering, used by the blendMode property.
	 * @typedef {Object} SCNParticleBlendMode
	 * @property {Symbol} additive - The source and destination colors are added together.
	 * @property {Symbol} subtract - The source color is subtracted from the destination color.
	 * @property {Symbol} multiply - The source color is multiplied by the destination color.
	 * @property {Symbol} screen - The source color is added to the destination color times the inverted source color.
	 * @property {Symbol} alpha - The source and destination colors are blended by multiplying the source alpha value.
	 * @property {Symbol} replace - The source color replaces the destination color.
	 * @see https://developer.apple.com/reference/scenekit/scnparticleblendmode
	 */

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var SCNParticleBlendMode = {
	  additive: Symbol(),
	  subtract: Symbol(),
	  multiply: Symbol(),
	  screen: Symbol(),
	  alpha: Symbol(),
	  replace: Symbol()
	};

	exports.default = SCNParticleBlendMode;

/***/ },
/* 64 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * Options for restricting the orientation of particles, used by the orientationMode property.
	 * @typedef {Object} SCNParticleOrientationMode
	 * @property {Symbol} billboardScreenAligned - Each particle’s orientation is always fixed with respect to the point of view camera.
	 * @property {Symbol} billboardViewAligned - Each particle always faces the point of view camera (but may rotate about an axis parallel to the view direction).
	 * @property {Symbol} free - Particle orientations are not restricted; they may rotate freely in all axes.
	 * @property {Symbol} billboardYAligned - The y-axis direction of each particle is always fixed with respect to the point of view camera.
	 * @see https://developer.apple.com/reference/scenekit/scnparticleorientationmode
	 */

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var SCNParticleOrientationMode = {
	  billboardScreenAligned: Symbol(),
	  billboardViewAligned: Symbol(),
	  free: Symbol(),
	  billboardYAligned: Symbol()
	};

	exports.default = SCNParticleOrientationMode;

/***/ },
/* 65 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * Options for the rendering order of particles, used by the sortingMode property.
	 * @typedef {Object} SCNParticleSortingMode
	 * @property {Symbol} none - Particles are not sorted; they may be rendered in any order.
	 * @property {Symbol} projectedDepth - Particles farther from the point of view (as measured using projected depth) are rendered before closer particles.
	 * @property {Symbol} distance - Particles farther from the point of view (as measured using distance from the camera in scene space) are rendered before closer particles.
	 * @property {Symbol} oldestFirst - Particles emitted earlier are rendered before particles emitted more recently.
	 * @property {Symbol} youngestFirst - Particles emitted more recently are rendered before particles emitted earlier.
	 * @see https://developer.apple.com/reference/scenekit/scnparticlesortingmode
	 */

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var SCNParticleSortingMode = {
	  none: Symbol(),
	  projectedDepth: Symbol(),
	  distance: Symbol(),
	  oldestFirst: Symbol(),
	  youngestFirst: Symbol()
	};

	exports.default = SCNParticleSortingMode;

/***/ },
/* 66 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * Significant events in the life spans of simulate particles, used by the handle(_:forProperties:handler:) method.
	 * @typedef {Object} SCNParticleEvent
	 * @property {Symbol} birth - Occurs when new particles spawn.
	 * @property {Symbol} death - Occurs when particles reach the end of their life span.
	 * @property {Symbol} collision - Occurs when particles collide with scene geometry.
	 * @see https://developer.apple.com/reference/scenekit/scnparticleevent
	 */

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var SCNParticleEvent = {
	  birth: Symbol(),
	  death: Symbol(),
	  collision: Symbol()
	};

	exports.default = SCNParticleEvent;

/***/ },
/* 67 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * The signature for blocks called by SceneKit in response to significant events during particle simulation, used by the handle(_:forProperties:handler:) method.
	 * @type {function(data: UnsafeMutablePointer<UnsafeMutableRawPointer>, dataStride: UnsafeMutablePointer<Int>, indices: ?UnsafeMutablePointer<UInt32>, count: number): void}
	 * @param {UnsafeMutablePointer<UnsafeMutableRawPointer>} data - An array of floating-point values containing stripes of property data for the system’s particles. The width and format of each data stripe depend on the properties you specify when calling the handle(_:forProperties:handler:) method.
	 * @param {UnsafeMutablePointer<Int>} dataStride - An array identifying the offset, in bytes, of each property’s value in the data stripe for each particle. The order of offsets in this array corresponds to the order of the properties array you specify when calling the handle(_:forProperties:handler:) method.
	 * @param {?UnsafeMutablePointer<UInt32>} indices - An array in which each element is an index that identifies (in the data array) the data stripe for each particle affected by the event that caused SceneKit to call the handler block.When SceneKit calls your handler block for the birth event, you need not use this parameter—at that time, the affected particles are indexed from 0 to the count parameter’s value.
	 * @param {number} count - The number of particles affected by the current event.
	 * @returns {void}
	 * @desc Use this block to change properties of individual particles when they are spawned, when they collide with scene geometry, or when they die (that is, reach the end of their life spans and are removed from the scene). The following example illustrates setting up a handler block for particle collision events:[system handleEvent:SCNParticleEventCollision
	      forProperties:@[SCNParticlePropertyAngle,
	                      SCNParticlePropertyRotationAxis,
	                      SCNParticlePropertyContactNormal]
	          withBlock:^(void **data, size_t *dataStride, uint32_t *indices, NSInteger count) {
	              // For each particle affected by the collision event,
	              // calculate pointers in the data to each property's value.
	              for (NSInteger i = 0; i < count; ++i) {
	                  // SCNParticlePropertyAngle (float)
	                  float *angle = (float *)((char *)data[0] + dataStride[0] * indices[i]);
	                  // angle[0] is the particle's rotation angle in radians.
	 
	                  // SCNParticlePropertyRotationAxis (float3)
	                  float *axis = (float *)((char *)data[1] + dataStride[1] * indices[i]);
	                  // axis[0..2] are the xyz components of the particle's rotation axis.
	 
	                  // SCNParticlePropertyContactNormal (float3)
	                  float *norm = (float *)((char *)data[2] + dataStride[2] * indices[i]);
	                  // norm[0..2] are the xyz components of the contact normal vector.
	 
	                  // Now, use the norm vector to rotate the particle's axis/angle (not shown).
	              }
	          }];

	 * @see https://developer.apple.com/reference/scenekit/scnparticleeventblock
	 */

	Object.defineProperty(exports, "__esModule", {
	                 value: true
	});
	var SCNParticleEventBlock = function SCNParticleEventBlock(data, dataStride, indices, count) {};

	exports.default = SCNParticleEventBlock;

/***/ },
/* 68 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _NSObject2 = __webpack_require__(13);

	var _NSObject3 = _interopRequireDefault(_NSObject2);

	var _CAAnimation = __webpack_require__(19);

	var _CAAnimation2 = _interopRequireDefault(_CAAnimation);

	var _SCNParticleInputMode = __webpack_require__(69);

	var _SCNParticleInputMode2 = _interopRequireDefault(_SCNParticleInputMode);

	var _SCNNode = __webpack_require__(33);

	var _SCNNode2 = _interopRequireDefault(_SCNNode);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * An animation for a single property of the individual particles rendered by a particle system.
	 * @access public
	 * @extends {NSObject}
	 * @see https://developer.apple.com/reference/scenekit/scnparticlepropertycontroller
	 */
	var SCNParticlePropertyController = function (_NSObject) {
	  _inherits(SCNParticlePropertyController, _NSObject);

	  // Creating a Property Controller

	  /**
	   * Creates a particle property controller with the specified Core Animation animation.
	   * @access public
	   * @constructor
	   * @param {CAAnimation} animation - A Core Animation object specifying the behavior of the property animation. Must not be nil.You can use different CAAnimation subclasses to animate effects in different ways. For example, a CABasicAnimation instance transitions a property from one value to another, and a CAKeyframeAnimation instance transitions a property through a series of values. You use properties of the animation object to define its timing curve, repeat mode, and other options.SceneKit ignores the keyPath, duration, and repeatCount properties of this animation object.
	   * @desc To set up a particle property animation:Create a CAAnimation object defining how a property of each particle in the system changes over time.Create a particle property controller using the init(animation:) method.Attach the property controller to a particle system using the propertyControllers dictionary, choosing a key listed in Particle Property Keys to identify the particle property it animates.For example, the following code sets up a controller to animate particle sizes:// 1. Create and configure an animation object.
	  CAKeyframeAnimation *animation = [CAKeyframeAnimation animation];
	  animation.values = @[ @0.1, @1.0, @3.0, @0.5 ];
	  // 2. Create a property controller from the animation object.
	  SCNParticlePropertyController *controller =
	    [SCNParticlePropertyController controllerWithAnimation:animation];
	  // 3. Assign the controller to a particle system, associating it with a particle property.
	  particleSystem.propertyControllers = @{ SCNParticlePropertySize: controller };
	  // 1. Create and configure an animation object.
	  CAKeyframeAnimation *animation = [CAKeyframeAnimation animation];
	  animation.values = @[ @0.1, @1.0, @3.0, @0.5 ];
	  // 2. Create a property controller from the animation object.
	  SCNParticlePropertyController *controller =
	    [SCNParticlePropertyController controllerWithAnimation:animation];
	  // 3. Assign the controller to a particle system, associating it with a particle property.
	  particleSystem.propertyControllers = @{ SCNParticlePropertySize: controller };
	    * @see https://developer.apple.com/reference/scenekit/scnparticlepropertycontroller/1523579-init
	   */
	  function SCNParticlePropertyController(animation) {
	    _classCallCheck(this, SCNParticlePropertyController);

	    // Managing the Controller’s Animation

	    /**
	     * The Core Animation object defining the behavior of the property animation.
	     * @type {CAAnimation}
	     * @see https://developer.apple.com/reference/scenekit/scnparticlepropertycontroller/1523707-animation
	     */
	    var _this = _possibleConstructorReturn(this, (SCNParticlePropertyController.__proto__ || Object.getPrototypeOf(SCNParticlePropertyController)).call(this));

	    _this.animation = null;

	    /**
	     * The mode that determines input values for the property controller’s animation.
	     * @type {SCNParticleInputMode}
	     * @see https://developer.apple.com/reference/scenekit/scnparticlepropertycontroller/1522852-inputmode
	     */
	    _this.inputMode = null;

	    /**
	     * An offset to add to the input value of the controller’s animation.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnparticlepropertycontroller/1523994-inputbias
	     */
	    _this.inputBias = 0;

	    /**
	     * A factor for multiplying the input value of the controller’s animation. 
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnparticlepropertycontroller/1522903-inputscale
	     */
	    _this.inputScale = 0;

	    /**
	     * A node whose distance to each particle provides input values for the controller’s animation.
	     * @type {?SCNNode}
	     * @see https://developer.apple.com/reference/scenekit/scnparticlepropertycontroller/1522895-inputorigin
	     */
	    _this.inputOrigin = null;

	    /**
	     * A particle property that provides input values for this property controller’s animation.
	     * @type {?SCNParticleSystem.ParticleProperty}
	     * @see https://developer.apple.com/reference/scenekit/scnparticlepropertycontroller/1522973-inputproperty
	     */
	    _this.inputProperty = null;
	    return _this;
	  }

	  return SCNParticlePropertyController;
	}(_NSObject3.default);

	exports.default = SCNParticlePropertyController;

/***/ },
/* 69 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * Options for the input value of the property controller’s animation, used by the inputMode property.
	 * @typedef {Object} SCNParticleInputMode
	 * @property {Symbol} overLife - The controller’s effect on a particle property is a function of the time since the particle’s birth.
	 * @property {Symbol} overDistance - The controller’s effect on a particle property is a function of the particle’s distance from the position of a specified node.
	 * @property {Symbol} overOtherProperty - The controller’s effect on a particle property is a function of another of the particle’s properties.
	 * @see https://developer.apple.com/reference/scenekit/scnparticleinputmode
	 */

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var SCNParticleInputMode = {
	  overLife: Symbol(),
	  overDistance: Symbol(),
	  overOtherProperty: Symbol()
	};

	exports.default = SCNParticleInputMode;

/***/ },
/* 70 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * Stages of SceneKit’s particle simulation process into which you can insert modifier blocks, used by the addModifier(forProperties:at:modifier:) method.
	 * @typedef {Object} SCNParticleModifierStage
	 * @property {Symbol} preDynamics - The stage before SceneKit simulates the motion of particles.
	 * @property {Symbol} postDynamics - The stage after SceneKit simulates the motion of particles.
	 * @property {Symbol} preCollision - The stage before SceneKit simulates the results of collisions between particles and scene geometry.
	 * @property {Symbol} postCollision - The stage after SceneKit simulates the results of collisions between particles and scene geometry.
	 * @see https://developer.apple.com/reference/scenekit/scnparticlemodifierstage
	 */

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var SCNParticleModifierStage = {
	  preDynamics: Symbol(),
	  postDynamics: Symbol(),
	  preCollision: Symbol(),
	  postCollision: Symbol()
	};

	exports.default = SCNParticleModifierStage;

/***/ },
/* 71 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * The signature for blocks called by SceneKit to modify particle properties on each frame of simulation, used by the addModifier(forProperties:at:modifier:) method.
	 * @type {function(data: UnsafeMutablePointer<UnsafeMutableRawPointer>, dataStride: UnsafeMutablePointer<Int>, start: number, end: number, deltaTime: number): void}
	 * @param {UnsafeMutablePointer<UnsafeMutableRawPointer>} data - An array of floating-point values containing stripes of property data for the system’s particles. The width and format of each data stripe depend on the properties you specify when calling the addModifier(forProperties:at:modifier:) method.
	 * @param {UnsafeMutablePointer<Int>} dataStride - An array identifying the offset, in bytes, of each property’s value in the data stripe for each particle. The order of offsets in this array corresponds to the order of the properties array you specify when calling the addModifier(forProperties:at:modifier:) method.
	 * @param {number} start - The index of the first particle’s data stripe in the data array.
	 * @param {number} end - The index of the last particle’s data stripe in the data array.
	 * @param {number} deltaTime - The elapsed time, in seconds, since the last frame of simulation.
	 * @returns {void}
	 * @desc Use this block to change properties of individual particles on each frame of simulation.ImportantRunning your own code to update particle properties every frame can have a severe impact on rendering performance. If the behavior over time that you want for your particle system can be described more declaratively, use the propertyControllers property and SCNParticlePropertyController class instead. If you need to change particle properties only at certain times (rather than continuously), add a handler block for an event using the handle(_:forProperties:handler:) method.The following example illustrates setting up a modifier block that alters particle’s position and velocity:[system addModifierForProperties:@[SCNParticlePropertyPosition,
	                                   SCNParticlePropertyVelocity]
	                         atStage:SCNParticleModifierStagePostDynamics
	                       withBlock:^(void **data, size_t *dataStride, NSInteger start, NSInteger end, float deltaTime) {
	                           // For each particle to be processed,
	                           // calculate pointers in the data to each property's value:
	                           for (NSInteger i = start; i < end; ++i) {
	                               // SCNParticlePropertyPosition (float3)
	                               float *pos = (float *)((char *)data[0] + dataStride[0] * i);
	                               // pos[0..2] are the xyz components of the particle's position.
	 
	                               // SCNParticlePropertyVelocity (float3)
	                               float *vel = (float *)((char *)data[1] + dataStride[1] * i);
	                               // vel[0..2] are the xyz components of the particle's position.
	 
	                               // Now, compute a new position and velocity (not shown).
	                           }
	                       }];

	 * @see https://developer.apple.com/reference/scenekit/scnparticlemodifierblock
	 */

	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	var SCNParticleModifierBlock = function SCNParticleModifierBlock(data, dataStride, start, end, deltaTime) {};

	exports.default = SCNParticleModifierBlock;

/***/ },
/* 72 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * Options for drawing overlays with SceneKit content that can aid in debugging, used with the debugOptions property.
	 * @access public
	 * @see https://developer.apple.com/reference/scenekit/scndebugoptions
	 */

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var SCNDebugOptions = function () {
	  function SCNDebugOptions() {
	    _classCallCheck(this, SCNDebugOptions);
	  }

	  _createClass(SCNDebugOptions, [{
	    key: 'init',


	    // Initializers

	    /**
	     * 
	     * @access public
	     * @param {number} rawValue - 
	     * @returns {void}
	     * @see https://developer.apple.com/reference/scenekit/scndebugoptions/1523870-init
	     */
	    value: function init(rawValue) {

	      // Constants

	      this._showPhysicsShapes = null;
	      this._showBoundingBoxes = null;
	      this._showLightInfluences = null;
	      this._showLightExtents = null;
	      this._showPhysicsFields = null;
	      this._showWireframe = null;
	    }
	  }, {
	    key: 'showPhysicsShapes',


	    // Constants
	    /**
	     * Display the physics shapes for any nodes with attached SCNPhysicsBody objects.
	     * @type {SCNDebugOptions}
	     * @desc 
	     * @see https://developer.apple.com/reference/scenekit/scndebugoptions/1522896-showphysicsshapes
	     */
	    get: function get() {
	      return this._showPhysicsShapes;
	    }
	    /**
	     * Display the bounding boxes for any nodes with content.
	     * @type {SCNDebugOptions}
	     * @desc 
	     * @see https://developer.apple.com/reference/scenekit/scndebugoptions/1523258-showboundingboxes
	     */

	  }, {
	    key: 'showBoundingBoxes',
	    get: function get() {
	      return this._showBoundingBoxes;
	    }
	    /**
	     * Display the locations of each SCNLight object in the scene.
	     * @type {SCNDebugOptions}
	     * @desc 
	     * @see https://developer.apple.com/reference/scenekit/scndebugoptions/1522606-showlightinfluences
	     */

	  }, {
	    key: 'showLightInfluences',
	    get: function get() {
	      return this._showLightInfluences;
	    }
	    /**
	     * Display the regions affected by each SCNLight object in the scene.
	     * @type {SCNDebugOptions}
	     * @desc Only lights whose type is omni or spot have an area of effect; directional and ambient lights affect the entire scene.
	     * @see https://developer.apple.com/reference/scenekit/scndebugoptions/1522894-showlightextents
	     */

	  }, {
	    key: 'showLightExtents',
	    get: function get() {
	      return this._showLightExtents;
	    }
	    /**
	     * Display the regions affected by each SCNPhysicsField object in the scene.
	     * @type {SCNDebugOptions}
	     * @desc 
	     * @see https://developer.apple.com/reference/scenekit/scndebugoptions/1523589-showphysicsfields
	     */

	  }, {
	    key: 'showPhysicsFields',
	    get: function get() {
	      return this._showPhysicsFields;
	    }
	    /**
	     * Display geometries in the scene with wireframe rendering.
	     * @type {SCNDebugOptions}
	     * @desc When this option is enabled, SceneKit still renders scene geometry with all associated materials, then overlays a wireframe rendering of the same geometry. You can use this option, for example, to debug material rendering issues.
	     * @see https://developer.apple.com/reference/scenekit/scndebugoptions/1523384-showwireframe
	     */

	  }, {
	    key: 'showWireframe',
	    get: function get() {
	      return this._showWireframe;
	    }
	  }]);

	  return SCNDebugOptions;
	}();

	exports.default = SCNDebugOptions;

/***/ },
/* 73 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * Options for choosing the graphics technology for an SCNView object (or other SceneKit renderer) to use for drawing its contents. Used by the renderingAPI property and the preferredRenderingAPI option when initializing an SCNView object.
	 * @typedef {Object} SCNRenderingAPI
	 * @property {Symbol} metal - Use the Metal framework for SceneKit rendering.
	 * @property {Symbol} openGLES2 - Use the OpenGL ES 2.0 API for SceneKit rendering in iOS.
	 * @property {Symbol} openGLLegacy - Use the Legacy OpenGL API for SceneKit rendering in macOS.
	 * @property {Symbol} openGLCore32 - Use the OpenGL 3.2 Core Profile API for SceneKit rendering in macOS.
	 * @property {Symbol} openGLCore41 - Use the OpenGL 4.1 Core Profile API for SceneKit rendering in macOS.
	 * @see https://developer.apple.com/reference/scenekit/scnrenderingapi
	 */

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var SCNRenderingAPI = {
	  metal: Symbol(),
	  openGLES2: Symbol(),
	  openGLLegacy: Symbol(),
	  openGLCore32: Symbol(),
	  openGLCore41: Symbol(),
	  webGL: Symbol()
	};

	exports.default = SCNRenderingAPI;

/***/ },
/* 74 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * 
	 * @typedef {Object} SCNHitTestOption
	 * @property {Symbol} backFaceCulling - An option to ignore faces not oriented toward the camera.
	 * @property {Symbol} boundingBoxOnly - An option to search for objects by bounding box only.
	 * @property {Symbol} categoryBitMask - 
	 * @property {Symbol} clipToZRange - An option to search for objects only within the depth range of the current point of view.
	 * @property {Symbol} firstFoundOnly - An option to return only the first object found.
	 * @property {Symbol} ignoreChildNodes - An option to ignore child nodes when searching.
	 * @property {Symbol} ignoreHiddenNodes - An option to ignore hidden nodes when searching.
	 * @property {Symbol} rootNode - The root of the node hierarchy to be searched.
	 * @property {Symbol} sortResults - An option to sort the results of a hit-test.
	 * @see https://developer.apple.com/reference/scenekit/scnhittestoption
	 */

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var SCNHitTestOption = {
	  backFaceCulling: Symbol(),
	  boundingBoxOnly: Symbol(),
	  categoryBitMask: Symbol(),
	  clipToZRange: Symbol(),
	  firstFoundOnly: Symbol(),
	  ignoreChildNodes: Symbol(),
	  ignoreHiddenNodes: Symbol(),
	  rootNode: Symbol(),
	  sortResults: Symbol()
	};

	exports.default = SCNHitTestOption;

/***/ },
/* 75 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _SCNSceneRenderer = __webpack_require__(42);

	var _SCNSceneRenderer2 = _interopRequireDefault(_SCNSceneRenderer);

	var _SCNScene = __webpack_require__(43);

	var _SCNScene2 = _interopRequireDefault(_SCNScene);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	/**
	 * Methods your app can implement to participate in SceneKit’s animation loop or perform additional rendering. 
	 * @interface
	 * @see https://developer.apple.com/reference/scenekit/scnscenerendererdelegate
	 */
	var SCNSceneRendererDelegate = function () {
	  function SCNSceneRendererDelegate() {
	    _classCallCheck(this, SCNSceneRendererDelegate);
	  }

	  _createClass(SCNSceneRendererDelegate, [{
	    key: 'init',


	    /**
	     * constructor
	     * @access public
	     * @returns {void}
	     */
	    value: function init() {}

	    // Adding Custom Logic to the Rendering Loop

	    /**
	     * Tells the delegate to perform any updates that need to occur before actions, animations, and physics are evaluated.
	     * @access public
	     * @param {SCNSceneRenderer} renderer - 
	     * @param {number} time - The current system time, in seconds. Use this parameter for any time-based elements of your game logic.
	     * @returns {void}
	     * @desc SceneKit calls this method exactly once per frame, so long as the SCNView object (or other SCNSceneRenderer object) displaying the scene is not paused. Implement this method to add game logic to the rendering loop. Any changes you make to the scene graph during this method are immediately reflected in the displayed scene. That is, SceneKit immediately updates the hierarchy of presentation nodes it uses to render the scene (instead of using the SCNTransaction class to “batch” your changes).
	      * @see https://developer.apple.com/reference/scenekit/scnscenerendererdelegate/1522937-renderer
	     */

	  }, {
	    key: 'rendererUpdateAtTime',
	    value: function rendererUpdateAtTime(renderer, time) {}

	    /**
	     * Tells the delegate to perform any updates that need to occur after actions and animations are evaluated.
	     * @access public
	     * @param {SCNSceneRenderer} renderer - 
	     * @param {number} time - The current system time, in seconds. Use this parameter for any time-based elements of your game logic.
	     * @returns {void}
	     * @desc SceneKit calls this method exactly once per frame, so long as the SCNView object (or other SCNSceneRenderer object) displaying the scene is not paused. Implement this method to add game logic to the rendering loop. Any changes you make to the scene graph during this method are immediately reflected in the displayed scene. That is, SceneKit immediately updates the hierarchy of presentation nodes it uses to render the scene (instead of using the SCNTransaction class to “batch” your changes).
	      * @see https://developer.apple.com/reference/scenekit/scnscenerendererdelegate/1523038-renderer
	     */

	  }, {
	    key: 'rendererDidApplyAnimationsAtTime',
	    value: function rendererDidApplyAnimationsAtTime(renderer, time) {}

	    /**
	     * Tells the delegate to perform any updates that need to occur after physics simulations are performed.
	     * @access public
	     * @param {SCNSceneRenderer} renderer - 
	     * @param {number} time - The current system time, in seconds. Use this parameter for any time-based elements of your game logic.
	     * @returns {void}
	     * @desc SceneKit calls this method exactly once per frame, so long as the SCNView object (or other SCNSceneRenderer object) displaying the scene is not paused. Implement this method to add game logic to the rendering loop. Any changes you make to the scene graph during this method are immediately reflected in the displayed scene. That is, SceneKit immediately updates the hierarchy of presentation nodes it uses to render the scene (instead of using the SCNTransaction class to “batch” your changes).
	    This method is the last opportunity SceneKit provides for you to change the scene graph before rendering.
	     * @see https://developer.apple.com/reference/scenekit/scnscenerendererdelegate/1522738-renderer
	     */

	  }, {
	    key: 'rendererDidSimulatePhysicsAtTime',
	    value: function rendererDidSimulatePhysicsAtTime(renderer, time) {}

	    // Rendering Custom Scene Content

	    /**
	     * Tells the delegate that the renderer has cleared the viewport and is about to render the scene.
	     * @access public
	     * @param {SCNSceneRenderer} renderer - 
	     * @param {SCNScene} scene - The SCNScene object to be rendered.
	     * @param {number} time - The current system time, in seconds. If your custom rendering involves animation, use this parameter to compute your own animation state.
	     * @returns {void}
	     * @desc Implement this method to perform custom drawing before SceneKit renders a scene—for example, to draw backdrop content underneath SceneKit content. You should only execute Metal or OpenGL drawing commands (and any setup required to perform them) in this method—the results of modifying SceneKit objects during this method are undefined.To render using Metal, use the renderer parameter to retrieve the scene renderer’s currentRenderCommandEncoder object and encode your own drawing commands. If you need to reference other Metal state, see the properties listed in SCNSceneRenderer.To render using OpenGL, simply call the relevant OpenGL drawing commands—SceneKit automatically makes its OpenGL context the current context before calling this method. If you need to reference the OpenGL context being rendered into, examine the context property of the renderer parameter.You must draw using the appropriate graphics technology for the view currently being rendered. Use the renderingAPI property of the renderer object to determine whether Metal or OpenGL is in use. 
	     * @see https://developer.apple.com/reference/scenekit/scnscenerendererdelegate/1523483-renderer
	     */

	  }, {
	    key: 'rendererWillRenderSceneAtTime',
	    value: function rendererWillRenderSceneAtTime(renderer, scene, time) {}

	    /**
	     * Tells the delegate that the renderer has rendered the scene.
	     * @access public
	     * @param {SCNSceneRenderer} renderer - 
	     * @param {SCNScene} scene - The scene object that was rendered.
	     * @param {number} time - The current system time, in seconds. If your custom rendering involves animation, use this parameter to compute your own animation state.
	     * @returns {void}
	     * @desc Implement this method to perform custom drawing after SceneKit has rendered a scene—for example, to draw overlay content on top of SceneKit content. You should only execute Metal or OpenGL drawing commands (and any setup required to perform them) in this method—the results of modifying SceneKit objects in this method are undefined.To render using Metal, use the renderer parameter to retrieve the scene renderer’s currentRenderCommandEncoder object and encode your own drawing commands. If you need to reference other Metal state, see the properties listed in SCNSceneRenderer.To render using OpenGL, simply call the relevant OpenGL drawing commands—SceneKit automatically makes its OpenGL context the current context before calling this method. If you need to reference the OpenGL context being rendered into, examine the context property of the renderer parameter.You must draw using the appropriate graphics technology for the view currently being rendered. Use the renderingAPI property of the renderer object to determine whether Metal or OpenGL is in use. 
	     * @see https://developer.apple.com/reference/scenekit/scnscenerendererdelegate/1524233-renderer
	     */

	  }, {
	    key: 'rendererDidRenderSceneAtTime',
	    value: function rendererDidRenderSceneAtTime(renderer, scene, time) {}
	  }]);

	  return SCNSceneRendererDelegate;
	}();

	exports.default = SCNSceneRendererDelegate;

/***/ },
/* 76 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _SCNTechnique = __webpack_require__(77);

	var _SCNTechnique2 = _interopRequireDefault(_SCNTechnique);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	/**
	 * The common interface for SceneKit objects that support multipass rendering using SCNTechnique objects.
	 * @interface
	 * @see https://developer.apple.com/reference/scenekit/scntechniquesupport
	 */
	var SCNTechniqueSupport = function () {
	  function SCNTechniqueSupport() {
	    _classCallCheck(this, SCNTechniqueSupport);
	  }

	  _createClass(SCNTechniqueSupport, [{
	    key: 'init',


	    /**
	     * constructor
	     * @access public
	     * @returns {void}
	     */
	    value: function init() {

	      // Specifying a Technique

	      /**
	       * Required. The technique SceneKit uses when rendering the object.
	       * @type {?SCNTechnique}
	       * @see https://developer.apple.com/reference/scenekit/scntechniquesupport/1520496-technique
	       */
	      this.technique = null;
	    }
	  }]);

	  return SCNTechniqueSupport;
	}();

	exports.default = SCNTechniqueSupport;

/***/ },
/* 77 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _NSObject2 = __webpack_require__(13);

	var _NSObject3 = _interopRequireDefault(_NSObject2);

	var _SCNAnimatable = __webpack_require__(35);

	var _SCNAnimatable2 = _interopRequireDefault(_SCNAnimatable);

	var _SCNBindingBlock = __webpack_require__(78);

	var _SCNBindingBlock2 = _interopRequireDefault(_SCNBindingBlock);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * A specification for augmenting or postprocessing SceneKit's rendering of a scene using additional drawing passes with custom Metal or OpenGL shaders.
	 * @access public
	 * @extends {NSObject}
	 * @implements {SCNAnimatable}
	 * @see https://developer.apple.com/reference/scenekit/scntechnique
	 */
	var SCNTechnique = function (_NSObject) {
	  _inherits(SCNTechnique, _NSObject);

	  function SCNTechnique() {
	    _classCallCheck(this, SCNTechnique);

	    return _possibleConstructorReturn(this, (SCNTechnique.__proto__ || Object.getPrototypeOf(SCNTechnique)).apply(this, arguments));
	  }

	  _createClass(SCNTechnique, [{
	    key: 'init',


	    // Creating a Technique

	    /**
	     * Creates a technique from a technique definition dictionary.,
	     * @access public
	     * @param {Map<string, Object>} dictionary - A dictionary defining the series of rendering passes that comprise the technique.
	     * @returns {void}
	     * @desc See the class overview for details of a technique definition dictionary.
	     * @see https://developer.apple.com/reference/scenekit/scntechnique/1520494-init
	     */
	    value: function init(dictionary) {

	      // Retrieving a Technique’s Definition

	      this._dictionaryRepresentation = null;
	    }

	    // Combining Techniques

	    /**
	     * Creates a new rendering technique that combines a series of techniques.
	     * @access public
	     * @param {SCNTechnique[]} techniques - An array of SCNTechnique objects.
	     * @returns {void}
	     * @desc The new technique applies the effects of the techniques in the order specified in the techniques array. Each output of a technique in the array becomes an input to the next technique in the array.
	     * @see https://developer.apple.com/reference/scenekit/scntechnique/1520497-init
	     */

	  }, {
	    key: 'initBySequencingTechniques',
	    value: function initBySequencingTechniques(techniques) {

	      // Retrieving a Technique’s Definition

	      this._dictionaryRepresentation = null;
	    }

	    // Retrieving a Technique’s Definition
	    /**
	     * The dictionary defining the rendering technique.
	     * @type {Map<string, Object>}
	     * @desc Read this property when you want to save a property list file containing the definition of a technique.See the class overview for details of a technique definition dictionary.
	     * @see https://developer.apple.com/reference/scenekit/scntechnique/1520492-dictionaryrepresentation
	     */

	  }, {
	    key: 'handleBindingOfSymbolUsing',


	    // Handling Parameters for a Technique’s Shader Programs

	    /**
	     * Specifies a block to be called before rendering using programs with the specified GLSL uniform variable or attribute name.
	     * @access public
	     * @param {string} symbol - A GLSL uniform variable or attribute name used in one of the technique’s shader programs.
	     * @param {?SCNBindingBlock} [block = null] - A block that SceneKit calls.
	     * @returns {void}
	     * @desc This method associates a block for handling setup of an attribute or uniform variable in the shader programs associated with the technique. SceneKit calls your block before any performing any rendering passes that use that symbol. In the block, you can execute any OpenGL commands or other code necessary for preparing your custom shader.NoteYou must associate a handler block with a technique before assigning that technique to a SceneKit object. The result of calling this method on a technique currently in use is undefined.Use this method when you need to update a value in a shader program every time SceneKit renders a frame. To set a value infrequently, or only once, use the setObject(_:forKeyedSubscript:) or setValue(_:forKey:) method instead.If you associate a block with a symbol using this method, SceneKit ignores values set using the setObject(_:forKeyedSubscript:) method.
	     * @see https://developer.apple.com/reference/scenekit/scntechnique/1520490-handlebinding
	     */
	    value: function handleBindingOfSymbolUsing(symbol) {
	      var block = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
	    }

	    /**
	     * Sets a value for the specified shader  variable or attribute name, using subscript syntax.
	     * @access public
	     * @param {?Object} obj - An object containing a new value for the shader symbol.
	     * @param {NSCopying} key - A shader variable or attribute name used in one of the technique’s shader programs.
	     * @returns {void}
	     * @desc The value parameter should be an object appropriate to the type of the shader symbol being set. For example, use an NSNumber object to set the value of a float uniform variable, or use an NSValue object containing an SCNVector3 structure to set the value of a GLSL vec3 uniform variable or a Metal float3 variable.Use this method when you need to set a value infrequently or only once. To update a shader value every time SceneKit renders a frame, use the handleBinding(ofSymbol:using:) method instead.If you use the handleBinding(ofSymbol:using:) method to associate a handler block for a symbol, SceneKit ignores values set for the symbol using the setObject(_:forKeyedSubscript:) method.
	     * @see https://developer.apple.com/reference/scenekit/scntechnique/1520495-setobject
	     */

	  }, {
	    key: 'setObjectForKeyedSubscript',
	    value: function setObjectForKeyedSubscript(obj, key) {}
	  }, {
	    key: 'dictionaryRepresentation',
	    get: function get() {
	      return this._dictionaryRepresentation;
	    }
	  }]);

	  return SCNTechnique;
	}(_NSObject3.default);

	exports.default = SCNTechnique;

/***/ },
/* 78 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _SCNNode = __webpack_require__(33);

	var _SCNNode2 = _interopRequireDefault(_SCNNode);

	var _SCNRenderer = __webpack_require__(41);

	var _SCNRenderer2 = _interopRequireDefault(_SCNRenderer);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * The signature for a block called for binding or unbinding a GLSL symbol in a custom program.
	 * @type {function(programID: number, location: number, renderedNode: ?SCNNode, renderer: SCNRenderer): void}
	 * @param {number} programID - The OpenGL program identifier for the current SCNProgram instance, as used by OpenGL functions such as glValidateProgram.
	 * @param {number} location - The OpenGL location index for the symbol to be bound or unbound, as used by OpenGL functions such as glUniform.
	 * @param {?SCNNode} renderedNode - The SCNNode object being rendered.
	 * @param {SCNRenderer} renderer - The SCNRenderer object responsible for rendering.
	 * @returns {void}
	 * @desc Call handleBinding(ofSymbol:handler:) or handleUnbinding(ofSymbol:handler:) to associate a handler block with a GLSL symbol for a SceneKit geometry or material.
	 * @see https://developer.apple.com/reference/scenekit/scnbindingblock
	 */
	var SCNBindingBlock = function SCNBindingBlock(programID, location, renderedNode, renderer) {};

	exports.default = SCNBindingBlock;

/***/ },
/* 79 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * Modes for antialiased rendering of the view’s scene, used by the SCNView property.
	 * @typedef {Object} SCNAntialiasingMode
	 * @property {Symbol} none - Disables antialiased rendering.
	 * @property {Symbol} multisampling2X - Enables multisample antialiasing, with two samples per screen pixel.
	 * @property {Symbol} multisampling4X - Enables multisample antialiasing, with four samples per screen pixel.
	 * @property {Symbol} multisampling8X - Enables multisample antialiasing, with eight samples per screen pixel.
	 * @property {Symbol} multisampling16X - Enables multisample antialiasing, with sixteen samples per screen pixel.
	 * @see https://developer.apple.com/reference/scenekit/scnantialiasingmode
	 */

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var SCNAntialiasingMode = {
	  none: Symbol(),
	  multisampling2X: Symbol(),
	  multisampling4X: Symbol(),
	  multisampling8X: Symbol(),
	  multisampling16X: Symbol()
	};

	exports.default = SCNAntialiasingMode;

/***/ },
/* 80 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _NSObject2 = __webpack_require__(13);

	var _NSObject3 = _interopRequireDefault(_NSObject2);

	var _SCNAnimatable = __webpack_require__(35);

	var _SCNAnimatable2 = _interopRequireDefault(_SCNAnimatable);

	var _SCNTechniqueSupport = __webpack_require__(76);

	var _SCNTechniqueSupport2 = _interopRequireDefault(_SCNTechniqueSupport);

	var _SCNMaterialProperty = __webpack_require__(44);

	var _SCNMaterialProperty2 = _interopRequireDefault(_SCNMaterialProperty);

	var _SCNMatrix = __webpack_require__(17);

	var _SCNMatrix2 = _interopRequireDefault(_SCNMatrix);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * A set of camera attributes that can be attached to a node to provide a point of view for displaying the scene.
	 * @access public
	 * @extends {NSObject}
	 * @implements {SCNAnimatable}
	 * @implements {SCNTechniqueSupport}
	 * @see https://developer.apple.com/reference/scenekit/scncamera
	 */
	var SCNCamera = function (_NSObject) {
	  _inherits(SCNCamera, _NSObject);

	  /**
	   * constructor
	   * @access public
	   * @returns {void}
	   */
	  function SCNCamera() {
	    _classCallCheck(this, SCNCamera);

	    // Managing Camera Attributes

	    /**
	     * A name associated with the camera object.
	     * @type {?string}
	     * @see https://developer.apple.com/reference/scenekit/scncamera/1436623-name
	     */
	    var _this = _possibleConstructorReturn(this, (SCNCamera.__proto__ || Object.getPrototypeOf(SCNCamera)).call(this));

	    _this.name = null;

	    // Adjusting Camera Perspective

	    /**
	     * The camera's near depth limit. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scncamera/1436592-znear
	     */
	    _this.zNear = 1.0;

	    /**
	     * The camera’s far depth limit. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scncamera/1436596-zfar
	     */
	    _this.zFar = 100.0;

	    /**
	     * The camera’s field of view, in degrees, on the vertical axis. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scncamera/1436598-yfov
	     */
	    _this.yFov = 0;

	    /**
	     * The camera's field of view, in degrees, on the horizontal axis. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scncamera/1436608-xfov
	     */
	    _this.xFov = 0;

	    /**
	     * A Boolean value that determines whether the camera automatically adjusts its zNear and zFar depth limits.
	     * @type {boolean}
	     * @see https://developer.apple.com/reference/scenekit/scncamera/1436610-automaticallyadjustszrange
	     */
	    _this.automaticallyAdjustsZRange = false;

	    // Managing the Camera Projection

	    /**
	     * A Boolean value that determines whether the camera uses an orthographic projection.
	     * @type {boolean}
	     * @see https://developer.apple.com/reference/scenekit/scncamera/1436621-usesorthographicprojection
	     */
	    _this.usesOrthographicProjection = false;

	    /**
	     * Specifies the camera’s magnification factor when using an orthographic projection.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scncamera/1436612-orthographicscale
	     */
	    _this.orthographicScale = 1.0;

	    // Choosing Nodes to Be Visible to the Camera

	    /**
	     * A mask that defines which categories this camera belongs to.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scncamera/1436625-categorybitmask
	     */
	    _this.categoryBitMask = -1;

	    // Adding Depth of Field and Blur Effects

	    /**
	     * The distance from the camera at which objects appear in sharp focus. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scncamera/1436600-focaldistance
	     */
	    _this.focalDistance = 10.0;

	    /**
	     * The width of the distance range at which objects appear in sharp focus. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scncamera/1436604-focalsize
	     */
	    _this.focalSize = 0.0;

	    /**
	     * The maximum amount of blurring, in pixels, applied to areas outside the camera’s depth of field. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scncamera/1436606-focalblurradius
	     */
	    _this.focalBlurRadius = 0.0;

	    /**
	     * A factor that determines the transition between in-focus and out-of-focus areas. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scncamera/1436594-aperture
	     */
	    _this.aperture = 0.125;

	    /**
	     * A factor that determines the intensity of motion blur effects. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scncamera/1644099-motionblurintensity
	     */
	    _this.motionBlurIntensity = 0.0;

	    // Adding High Dynamic Range Effects

	    /**
	     * A Boolean value that determines whether SceneKit applies High Dynamic Range (HDR) postprocessing effects to a scene.
	     * @type {boolean}
	     * @see https://developer.apple.com/reference/scenekit/scncamera/1644101-wantshdr
	     */
	    _this.wantsHDR = false;

	    /**
	     * A logarithmic bias that adjusts the results of SceneKit’s tone mapping operation, brightening or darkening the visible scene.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scncamera/1644105-exposureoffset
	     */
	    _this.exposureOffset = 0;

	    /**
	     * The luminance level to use as the midpoint of a tone mapping curve.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scncamera/1644097-averagegray
	     */
	    _this.averageGray = 0.18;

	    /**
	     * The luminance level to use as the upper end of a tone mapping curve.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scncamera/1644110-whitepoint
	     */
	    _this.whitePoint = 1.0;

	    /**
	     * The minimum exposure value to use in tone mapping.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scncamera/1644103-minimumexposure
	     */
	    _this.minimumExposure = -15.0;

	    /**
	     * The minimum exposure value to use in tone mapping.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scncamera/1644120-maximumexposure
	     */
	    _this.maximumExposure = 15.0;

	    // Adding Automatic HDR Exposure Adaptation

	    /**
	     * A Boolean value that determines whether SceneKit automatically adjusts the exposure level.
	     * @type {boolean}
	     * @see https://developer.apple.com/reference/scenekit/scncamera/1644117-wantsexposureadaptation
	     */
	    _this.wantsExposureAdaptation = false;

	    /**
	     * The relative duration of automatically animated exposure transitions from dark to bright areas.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scncamera/1644093-exposureadaptationbrighteningspe
	     */
	    _this.exposureAdaptationBrighteningSpeedFactor = 0.4;

	    /**
	     * The relative duration of automatically animated exposure transitions from bright to dark areas.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scncamera/1644094-exposureadaptationdarkeningspeed
	     */
	    _this.exposureAdaptationDarkeningSpeedFactor = 0.6;

	    // Adjusting Rendered Colors

	    /**
	     * An adjustment factor to apply to the overall visual contrast of the rendered scene.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scncamera/1644112-contrast
	     */
	    _this.contrast = 0.0;

	    /**
	     * An adjustment factor to apply to the overall color saturation of the rendered scene.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scncamera/1644100-saturation
	     */
	    _this.saturation = 1.0;

	    _this._colorGrading = new _SCNMaterialProperty2.default();

	    // Adding Stylistic Visual Effects

	    /**
	     * The magnitude of bloom effect to apply to highlights in the rendered scene. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scncamera/1644104-bloomintensity
	     */
	    _this.bloomIntensity = 0.0;

	    /**
	     * The brightness threshold at which to apply a bloom effect to highlights in the rendered scene. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scncamera/1644098-bloomthreshold
	     */
	    _this.bloomThreshold = 0.5;

	    /**
	     * The radius, in pixels, for the blurring portion of the bloom effect applied to highlights in the rendered scene. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scncamera/1644096-bloomblurradius
	     */
	    _this.bloomBlurRadius = 4.0;

	    /**
	     * The blend factor for fading the color fringing effect applied to the rendered scene.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scncamera/1644108-colorfringeintensity
	     */
	    _this.colorFringeIntensity = 1.0;

	    /**
	     * The magnitude of color fringing effect to apply to the rendered scene.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scncamera/1644113-colorfringestrength
	     */
	    _this.colorFringeStrength = 0.0;

	    /**
	     * The magnitude of vignette (darkening around edges) effect to apply to the rendered scene.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scncamera/1644106-vignettingintensity
	     */
	    _this.vignettingIntensity = 1.0;

	    /**
	     * The amount of the rendered scene to darken with a vignette effect.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scncamera/1644118-vignettingpower
	     */
	    _this.vignettingPower = 0.0;

	    // Instance Properties

	    /**
	     * 
	     * @type {SCNMatrix4}
	     * @see https://developer.apple.com/reference/scenekit/scncamera/1690501-projectiontransform
	     */
	    _this.projectionTransform = null;

	    return _this;
	  }

	  // Creating a Camera

	  /**
	   * Creates a camera from the specified Model I/O camera object.
	   * @access public
	   * @param {MDLCamera} mdlCamera - A Model I/O camera object.
	   * @returns {void}
	   * @desc The Model I/O framework provides universal support for import, export, description, and processing of several 3D asset file formats and related resources. (For details, see Model I/O.) The MDLCamera class is a generic description of a viewpoint on a scene, supporting a superset of the attributes described by the SCNCamera class.
	   * @see https://developer.apple.com/reference/scenekit/scncamera/1419839-init
	   */


	  _createClass(SCNCamera, [{
	    key: 'init',
	    value: function init(mdlCamera) {}

	    // Adjusting Rendered Colors
	    /**
	     * A texture for applying color grading effects to the entire rendered scene.
	     * @type {SCNMaterialProperty}
	     * @desc The contents value for this material property must be a 3D color lookup table, or a 2D texture image that represents such a table arranged in a horizontal strip. A lookup table is a cube of color values: the red, green, and blue components of an input color map to the x, y, and z coordinates of a location in that cube, and at that location in the cube is a corresponding output color. You can provide data in this cubic format as a Metal texture with the type3D texture type.The 2D representation of a 3D color cube is an arrangement of slices: for example, a 16 x 16 x 16 color cube becomes a horizontal strip of 16 squares, each 16 x 16 pixels (that is, a 256 x 16 image). Each square contains a gradation of red and green components, and together the 16 squares form a gradation for the blue component. To provide a 2D representation of a color cube, set this material property’s contents value to an image.By using a color table, you can easily create custom color effects that apply to an entire rendered scene:Create a basic color table image such as Figure 1, where the color value for each R, G, and B coordinate in the cube is the corresponding RGB color.Figure 1 Basic color table imageUse an image editor to create the color effect you want using some other image—such as a screenshot of your game. Apply only effects that affect pixel colors without modifying pixel positions. (For example, you can use hue/saturation, color curves, or color matrix filters, but not blur or distort filters.)Figure 2 Creating a color grading effectApply the same color effect you created in step 2 to your basic color table image. You can even perform these steps together: paste the basic color table into your game screenshot, apply an effect to the combined picture, then crop the picture to just the modified color table. Figure 2 shows an example effect.Assign your customized color table image (such as the example in Figure 3) to this property. When rendering, SceneKit looks up the RGB values for each pixel in the rendered scene, and displays the corresponding color values from the color table.Figure 3 Custom color table image for color gradingBasic color table imageCreating a color grading effectCustom color table image for color grading
	     * @see https://developer.apple.com/reference/scenekit/scncamera/1644114-colorgrading
	     */

	  }, {
	    key: '_updateProjectionTransform',


	    /**
	     * @access private
	     * @param {CGRect} viewRect -
	     * @returns {void}
	     */
	    value: function _updateProjectionTransform(viewRect) {
	      var m = new _SCNMatrix2.default();
	      var left = viewRect.minX;
	      var right = viewRect.maxX;
	      var top = viewRect.maxY;
	      var bottom = viewRect.minY;
	      var aspect = viewRect.size.width / viewRect.size.height;

	      if (this.usesOrthographicProjection) {
	        //this.orthographicScale
	        m.m11 = 2 / (right - left);
	        m.m12 = 0;
	        m.m13 = 0;
	        m.m14 = -(right + left) / (right - left);
	        m.m21 = 0;
	        m.m22 = 2 / (top - bottom);
	        m.m23 = 0;
	        m.m24 = -(top + bottom) / (top - bottom);
	        m.m31 = 0;
	        m.m32 = 0;
	        m.m33 = -2 / (this.zFar - this.zNear);
	        m.m34 = -(this.zFar + this.zNear) / (this.zFar - this.zNear);
	        m.m41 = 0;
	        m.m42 = 0;
	        m.m43 = 0;
	        m.m44 = 1;
	      } else {
	        // perspective
	        //this.yFov
	        //this.xFov
	        //this.automaticallyAdjustsZRange
	        var yfov = 60.0;
	        if (this.yFov > 0) {
	          yfov = this.yFov;
	        }
	        // FIXME: use xFov

	        var cot = 1.0 / Math.tan(yfov * Math.PI / 360.0);
	        m.m11 = cot / aspect;
	        m.m12 = 0;
	        m.m13 = 0;
	        m.m14 = 0;
	        m.m21 = 0;
	        m.m22 = cot;
	        m.m23 = 0;
	        m.m24 = 0;
	        m.m31 = 0;
	        m.m32 = 0;
	        m.m33 = -(this.zFar + this.zNear) / (this.zFar - this.zNear);
	        m.m34 = -2 * this.zFar * this.zNear / (this.zFar - this.zNear);
	        m.m41 = 0;
	        m.m42 = 0;
	        m.m43 = -1;
	        m.m44 = 0;
	      }
	      this.projectionTransform = m;
	    }
	  }, {
	    key: 'colorGrading',
	    get: function get() {
	      return this._colorGrading;
	    }
	  }]);

	  return SCNCamera;
	}(_NSObject3.default);

	exports.default = SCNCamera;

/***/ },
/* 81 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _NSObject2 = __webpack_require__(13);

	var _NSObject3 = _interopRequireDefault(_NSObject2);

	var _SCNAnimatable = __webpack_require__(35);

	var _SCNAnimatable2 = _interopRequireDefault(_SCNAnimatable);

	var _SCNTechniqueSupport = __webpack_require__(76);

	var _SCNTechniqueSupport2 = _interopRequireDefault(_SCNTechniqueSupport);

	var _SCNMaterialProperty = __webpack_require__(44);

	var _SCNMaterialProperty2 = _interopRequireDefault(_SCNMaterialProperty);

	var _CGSize = __webpack_require__(7);

	var _CGSize2 = _interopRequireDefault(_CGSize);

	var _SKColor = __webpack_require__(48);

	var _SKColor2 = _interopRequireDefault(_SKColor);

	var _SCNShadowMode = __webpack_require__(82);

	var _SCNShadowMode2 = _interopRequireDefault(_SCNShadowMode);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var _LightType = {
	  IES: Symbol(),
	  ambient: Symbol(),
	  directional: Symbol(),
	  omni: Symbol(),
	  probe: Symbol(),
	  spot: Symbol()
	};

	/**
	 * A light source that can be attached to a node to illuminate the scene.
	 * @access public
	 * @extends {NSObject}
	 * @implements {SCNAnimatable}
	 * @implements {SCNTechniqueSupport}
	 * @see https://developer.apple.com/reference/scenekit/scnlight
	 */

	var SCNLight = function (_NSObject) {
	  _inherits(SCNLight, _NSObject);

	  /**
	   * constructor
	   * @access public
	   * @returns {void}
	   */
	  function SCNLight() {
	    _classCallCheck(this, SCNLight);

	    // Modifying a Light’s Appearance

	    /**
	     * A constant identifying the general behavior of the light.
	     * @type {SCNLight.LightType}
	     * @see https://developer.apple.com/reference/scenekit/scnlight/1522919-type
	     */
	    var _this = _possibleConstructorReturn(this, (SCNLight.__proto__ || Object.getPrototypeOf(SCNLight)).call(this));

	    _this.type = _LightType.omni;

	    /**
	     * The color of the light. Animatable.
	     * @type {SKColor}
	     * @see https://developer.apple.com/reference/scenekit/scnlight/1523627-color
	     */
	    _this.color = new _SKColor2.default(1, 1, 1, 1);

	    /**
	     * The color temperature, in degrees Kelvin, of the light source. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnlight/1640545-temperature
	     */
	    _this.temperature = 6500.0;

	    /**
	     * The luminous flux, in lumens, or total brightness of the light. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnlight/1640548-intensity
	     */
	    _this.intensity = 1000.0;

	    // Managing Light Attributes

	    /**
	     * A name associated with the light.
	     * @type {?string}
	     * @see https://developer.apple.com/reference/scenekit/scnlight/1522839-name
	     */
	    _this.name = null;

	    // Managing Light Attenuation

	    /**
	     * The distance from the light at which its intensity begins to diminish. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnlight/1524223-attenuationstartdistance
	     */
	    _this.attenuationStartDistance = 0;

	    /**
	     * The distance from the light at which its intensity is completely diminished. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnlight/1524140-attenuationenddistance
	     */
	    _this.attenuationEndDistance = 0;

	    /**
	     * The transition curve for the light’s intensity between its attenuation start and end distances. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnlight/1522879-attenuationfalloffexponent
	     */
	    _this.attenuationFalloffExponent = 0;

	    // Managing Spotlight Extent

	    /**
	     * The angle, in degrees, of the area fully lit by a spotlight. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnlight/1522797-spotinnerangle
	     */
	    _this.spotInnerAngle = 0;

	    /**
	     * The angle, in degrees, of the area partially lit by a spotlight. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnlight/1523382-spotouterangle
	     */
	    _this.spotOuterAngle = 45.0;

	    _this._gobo = new _SCNMaterialProperty2.default();

	    // Managing Shadows Cast by the Light

	    /**
	     * A Boolean value that determines whether the light casts shadows.
	     * @type {boolean}
	     * @see https://developer.apple.com/reference/scenekit/scnlight/1523816-castsshadow
	     */
	    _this.castsShadow = false;

	    /**
	     * A number that specifies the amount of blurring around the edges of shadows cast by the light. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnlight/1523724-shadowradius
	     */
	    _this.shadowRadius = 3.0;

	    /**
	     * The color of shadows cast by the light. Animatable.
	     * @type {SKColor}
	     * @see https://developer.apple.com/reference/scenekit/scnlight/1522864-shadowcolor
	     */
	    _this.shadowColor = new _SKColor2.default(0, 0, 0, 1);

	    /**
	     * The size of the shadow map image that SceneKit renders when creating shadows.
	     * @type {CGSize}
	     * @see https://developer.apple.com/reference/scenekit/scnlight/1524127-shadowmapsize
	     */
	    _this.shadowMapSize = new _CGSize2.default(0, 0);

	    /**
	     * The number of samples from the shadow map that SceneKit uses to render each pixel.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnlight/1523300-shadowsamplecount
	     */
	    _this.shadowSampleCount = 0;

	    /**
	     * The mode SceneKit uses to render shadows.
	     * @type {SCNShadowMode}
	     * @see https://developer.apple.com/reference/scenekit/scnlight/1522847-shadowmode
	     */
	    _this.shadowMode = null;

	    /**
	     * The amount of correction to apply to the shadow to prevent rendering artifacts.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnlight/1522849-shadowbias
	     */
	    _this.shadowBias = 1.0;

	    /**
	     * The orthographic scale SceneKit uses when rendering the shadow map for a directional light.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnlight/1523951-orthographicscale
	     */
	    _this.orthographicScale = 1.0;

	    /**
	     * The maximum distance between the light and a visible surface for casting shadows.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnlight/1522845-zfar
	     */
	    _this.zFar = 100.0;

	    /**
	     * The minimum distance between the light and a visible surface for casting shadows. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnlight/1522630-znear
	     */
	    _this.zNear = 1.0;

	    // Choosing Nodes to be Illuminated by the Light

	    /**
	     * A mask that defines which categories this light belongs to.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnlight/1523669-categorybitmask
	     */
	    _this.categoryBitMask = -1;

	    // Managing Photometric Lights

	    /**
	     * The URL for a file that contains photometry data describing the intended appearance of the light.
	     * @type {?string}
	     * @see https://developer.apple.com/reference/scenekit/scnlight/1640546-iesprofileurl
	     */
	    _this.iesProfileURL = null;
	    return _this;
	  }

	  // Creating a Light

	  /**
	   * Creates a light from the specified Model I/O light object.
	   * @access public
	   * @param {MDLLight} mdlLight - A Model I/O light object.
	   * @returns {void}
	   * @desc The Model I/O framework provides universal support for import, export, description, and processing of several 3D asset file formats and related resources. (For details, see Model I/O.) The MDLLight class is a generic description of a light source in a scene, supporting a superset of the attributes described by the SCNLight class.
	   * @see https://developer.apple.com/reference/scenekit/scnlight/1419849-init
	   */


	  _createClass(SCNLight, [{
	    key: 'init',
	    value: function init(mdlLight) {}

	    // Managing Light Attributes

	    /**
	     * Returns the value of a lighting attribute.
	     * @deprecated
	     * @access public
	     * @param {string} key - A constant specifying a lighting attribute. See Lighting Attribute Keys for available keys and their possible values.
	     * @returns {?Object} - 
	     * @desc A light’s type property determines its set of available attributes.You can also get the values of lighting attributes using Key-value coding. The key path for each lighting attribute is listed in Lighting Attribute Keys.
	     * @see https://developer.apple.com/reference/scenekit/scnlight/1523345-attribute
	     */

	  }, {
	    key: 'attributeForKey',
	    value: function attributeForKey(key) {
	      return null;
	    }

	    /**
	     * Sets the value for a lighting attribute.
	     * @deprecated
	     * @access public
	     * @param {?Object} attribute - The value for the lighting attribute.
	     * @param {string} key - A constant specifying a lighting attribute. See Lighting Attribute Keys for available keys and their possible values.
	     * @returns {void}
	     * @desc A light’s type property determines its set of available attributes.You can also set or animate changes to the values of lighting attributes using Key-value coding. The key path for each lighting attribute is listed in Lighting Attribute Keys.
	     * @see https://developer.apple.com/reference/scenekit/scnlight/1523148-setattribute
	     */

	  }, {
	    key: 'setAttributeForKey',
	    value: function setAttributeForKey(attribute, key) {}

	    // Managing Spotlight Extent
	    /**
	     * An image or other visual content affecting the shape and color of a light’s illuminated area.
	     * @type {?SCNMaterialProperty}
	     * @desc In photographic and stage lighting terminology, a gobo (also known as a flag or cookie) is a stencil, gel, or other object placed just in front of a light source, shaping or coloring the beam of light.You alter the appearance of a spotlight by changing the contents property of the object permanently assigned to this property. As with other material properties, you can use a color or image, or a Core Animation layer containing animated content, as a lighting gobo.This property applies only to lights whose type property is spot.
	     * @see https://developer.apple.com/reference/scenekit/scnlight/1523524-gobo
	     */

	  }, {
	    key: 'gobo',
	    get: function get() {
	      return this._gobo;
	    }

	    // Structures
	    /**
	     * @type {Object} LightType
	     * @property {Symbol} IES A light source whose shape, direction, and intensity of illumination is determined by a photometric profile.
	     * @property {Symbol} ambient A light that illuminates all objects in the scene from all directions.
	     * @property {Symbol} directional A light source with a uniform direction and constant intensity.
	     * @property {Symbol} omni An omnidirectional light, also known as a point light. 
	     * @property {Symbol} probe A sample of the environment around a point in a scene to be used in environment-based lighting.
	     * @property {Symbol} spot A light source that illuminates a cone-shaped area.
	     * @see https://developer.apple.com/reference/scenekit/scnlight.lighttype
	     */

	  }], [{
	    key: 'LightType',
	    get: function get() {
	      return _LightType;
	    }
	  }]);

	  return SCNLight;
	}(_NSObject3.default);

	exports.default = SCNLight;

/***/ },
/* 82 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * Options for SceneKit’s rendering of shadows cast by a light, used by the shadowMode property.
	 * @typedef {Object} SCNShadowMode
	 * @property {Symbol} forward - SceneKit renders shadows during lighting computations.
	 * @property {Symbol} deferred - SceneKit renders shadows in a postprocessing pass.
	 * @property {Symbol} modulated - SceneKit renders shadows by projecting the light’s gobo image. The light does not illuminate the scene.
	 * @see https://developer.apple.com/reference/scenekit/scnshadowmode
	 */

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var SCNShadowMode = {
	  forward: Symbol(),
	  deferred: Symbol(),
	  modulated: Symbol()
	};

	exports.default = SCNShadowMode;

/***/ },
/* 83 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _NSObject2 = __webpack_require__(13);

	var _NSObject3 = _interopRequireDefault(_NSObject2);

	var _SCNVector = __webpack_require__(15);

	var _SCNVector2 = _interopRequireDefault(_SCNVector);

	var _SCNVector3 = __webpack_require__(16);

	var _SCNVector4 = _interopRequireDefault(_SCNVector3);

	var _CGPoint = __webpack_require__(5);

	var _CGPoint2 = _interopRequireDefault(_CGPoint);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var _Semantic = {
	  boneIndices: Symbol(),
	  boneWeights: Symbol(),
	  color: Symbol(),
	  edgeCrease: Symbol(),
	  normal: Symbol(),
	  tangent: Symbol(),
	  texcoord: Symbol(),
	  vertex: Symbol(),
	  vertexCrease: Symbol()
	};

	/**
	 * A container for vertex data forming part of the definition for a three-dimensional object, or geometry.
	 * @access public
	 * @extends {NSObject}
	 * @see https://developer.apple.com/reference/scenekit/scngeometrysource
	 */

	var SCNGeometrySource = function (_NSObject) {
	  _inherits(SCNGeometrySource, _NSObject);

	  /**
	   * Creates a geometry source from the specified data and options.
	   * @access public
	   * @constructor
	   * @param {number[]} data - The data for the geometry source.
	   * @param {SCNGeometrySource.Semantic} semantic - The semantic value (or attribute) that the geometry source describes for each vertex. See Geometry Semantic Identifiers for available values.
	   * @param {number} vectorCount - The number of geometry source vectors.
	   * @param {boolean} floatComponents - A Boolean value that indicates whether vector components are floating-point values. Specify true for floating-point values, or false for integer values.
	   * @param {number} componentsPerVector - The number of scalar components in each vector.
	   * @param {number} bytesPerComponent - The size, in bytes, of each vector component.
	   * @param {number} offset - The offset, in bytes, from the beginning of the data to the first vector component to be used in the geometry source.
	   * @param {number} stride - The number of bytes from each vector to the next in the data.
	   * @desc A geometry source’s data is an array of vectors, each of which represents a particular attribute (or semantic) of a vertex in the geometry. The other parameters determine how SceneKit interprets this data. For example, an array of vertex positions may have three 32-bit floating-point components per vector, but an array of texture coordinates may have two 8-bit integer coponents per vector. You can use the offset and stride parameters together to interleave data for multiple geometry sources in the same array, improving rendering performance. See SCNGeometrySource for details.To create a custom SCNGeometry object from the geometry source, use the init(sources:elements:) method.
	   * @see https://developer.apple.com/reference/scenekit/scngeometrysource/1523320-init
	   */
	  function SCNGeometrySource(data, semantic, vectorCount, floatComponents, componentsPerVector, bytesPerComponent, offset, stride) {
	    _classCallCheck(this, SCNGeometrySource);

	    // Inspecting a Geometry Source
	    var _this = _possibleConstructorReturn(this, (SCNGeometrySource.__proto__ || Object.getPrototypeOf(SCNGeometrySource)).call(this));

	    _this._data = data;
	    _this._semantic = semantic;
	    _this._vectorCount = vectorCount;
	    _this._usesFloatComponents = floatComponents;
	    _this._componentsPerVector = componentsPerVector;
	    _this._bytesPerComponent = bytesPerComponent;
	    _this._dataOffset = offset;
	    _this._dataStride = stride;

	    /**
	     * @type {TypedArray}
	     * @access private
	     */
	    _this._glData = null;
	    if (_this._hasTypedArrayData()) {
	      _this._glData = _this._data;
	    } else {
	      if (floatComponents) {
	        if (bytesPerComponent === 4) {
	          _this._glData = new Float32Array(data);
	        } else if (bytesPerComponent === 8) {
	          _this._glData = new Float64Array(data);
	        }
	      } else {
	        if (bytesPerComponent === 1) {
	          _this._glData = new Uint8Array(data);
	        } else if (bytesPerComponent === 2) {
	          _this._glData = new Uint16Array(data);
	        } else if (bytesPerComponent === 4) {
	          _this._glData = new Uint32Array(data);
	        }
	      }
	    }

	    if (_this._glData === null) {
	      throw new Error('unknown buffer data type: float: ' + floatComponents + ', size: ' + bytesPerComponent);
	    }

	    _this._buffer = null;
	    return _this;
	  }

	  _createClass(SCNGeometrySource, [{
	    key: '_createBuffer',
	    value: function _createBuffer(context) {
	      var gl = context;
	      this._buffer = gl.createBuffer();
	      gl.bindBuffer(gl.ARRAY_BUFFER, this._buffer);
	      // FIXME: dynamic data
	      gl.bufferData(gl.ARRAY_BUFFER, this._glData, gl.STATIC_DRAW);
	      return this._buffer;
	    }

	    /**
	     * @access private
	     * @returns {boolean} -
	     */

	  }, {
	    key: '_hasTypedArrayData',
	    value: function _hasTypedArrayData() {
	      if (this._usesFloatComponents) {
	        if (this._bytesPerComponent === 4) {
	          return this._data instanceof Float32Array;
	        } else if (this._bytesPerComponent === 8) {
	          return this._data instanceof Float64Array;
	        }
	      } else {
	        if (this._bytesPerComponent === 1) {
	          return this._data instanceof Uint8Array;
	        } else if (this._bytesPerComponent === 2) {
	          return this._data instanceof Uint16Array;
	        } else if (this._bytesPerComponent === 4) {
	          return this._data instanceof Uint32Array;
	        }
	      }
	      return false;
	    }

	    // Creating Geometry Sources

	    /**
	     * Creates a geometry source from the specified data and options.
	     * @access public
	     * @param {number[]} data - The data for the geometry source.
	     * @param {SCNGeometrySource.Semantic} semantic - The semantic value (or attribute) that the geometry source describes for each vertex. See Geometry Semantic Identifiers for available values.
	     * @param {number} vectorCount - The number of geometry source vectors.
	     * @param {boolean} floatComponents - A Boolean value that indicates whether vector components are floating-point values. Specify true for floating-point values, or false for integer values.
	     * @param {number} componentsPerVector - The number of scalar components in each vector.
	     * @param {number} bytesPerComponent - The size, in bytes, of each vector component.
	     * @param {number} dataOffset - The offset, in bytes, from the beginning of the data to the first vector component to be used in the geometry source.
	     * @param {number} dataStride - The number of bytes from each vector to the next in the data.
	     * @returns {SCNGeometrySource} -
	     * @desc A geometry source’s data is an array of vectors, each of which represents a particular attribute (or semantic) of a vertex in the geometry. The other parameters determine how SceneKit interprets this data. For example, an array of vertex positions may have three 32-bit floating-point components per vector, but an array of texture coordinates may have two 8-bit integer coponents per vector. You can use the offset and stride parameters together to interleave data for multiple geometry sources in the same array, improving rendering performance. See SCNGeometrySource for details.To create a custom SCNGeometry object from the geometry source, use the init(sources:elements:) method.
	     * @see https://developer.apple.com/reference/scenekit/scngeometrysource/1523320-init
	     */

	  }, {
	    key: 'vectorAt',


	    /**
	     * @access public
	     * @param {number} index -
	     * @returns {number[]} -
	     */
	    value: function vectorAt(index) {
	      if (index < 0 || index >= this.vectorCount) {
	        throw new Error('index out of range: ' + index + ' (0 - ' + (this.vectorCount - 1) + ')');
	      }
	      var indexStride = this._dataStride / this._bytesPerComponent;
	      var ind = index * indexStride + this._dataOffset / this._bytesPerComponent;
	      var arr = [];
	      for (var i = 0; i < this._componentsPerVector; i++) {
	        arr.push(this._data[ind + i]);
	      }
	      return arr;
	    }

	    /**
	     * @access public
	     * @param {number[]|SCNVector3|SCNVector4} v -
	     * @param {number} index -
	     * @returns {void}
	     */

	  }, {
	    key: 'setVectorAt',
	    value: function setVectorAt(v, index) {
	      if (index < 0 || index >= this.vectorCount) {
	        throw new Error('index out of range: ' + index + ' (0 - ' + (this.vectorCount - 1) + ')');
	      }
	      var data = v;
	      if (v instanceof _SCNVector2.default) {
	        data = [v.x, v.y, v.z];
	      } else if (v instanceof _SCNVector4.default) {
	        data = [v.x, v.y, v.z, v.w];
	      }
	      if (data.length !== this._componentsPerVector) {
	        throw new Error('vector size inconsistent: ' + data.length + ' != ' + this._componentsPerVector);
	      }

	      var indexStride = this._dataStride / this._bytesPerComponent;
	      var ind = index * indexStride + this._dataOffset / this._bytesPerComponent;
	      for (var i = 0; i < this._componentsPerVector; i++) {
	        this._data[ind + i] = v[i];
	      }
	    }

	    /**
	     * 
	     * @access public
	     * @param {number} value -
	     * @returns {void}
	     */

	  }, {
	    key: 'fill',
	    value: function fill(value) {
	      var index = this._dataOffset / this._bytesPerComponent;
	      var stride = this._dataStride / this._bytesPerComponent;
	      for (var i = 0; i < this._vectorCount; i++) {
	        for (var j = 0; j < this._componentsPerVector; j++) {
	          this._data[index + j] = value;
	        }
	        index += stride;
	      }
	    }
	  }, {
	    key: 'copy',
	    value: function copy() {
	      var source = new SCNGeometrySource(this._data.slice(0), this._semantic, this._vectorCount, this._usesFloatComponents, this._componentsPerVector, this._bytesPerComponent, this._dataOffset, this._dataStride);
	      return source;
	    }
	  }, {
	    key: 'data',


	    // Inspecting a Geometry Source

	    /**
	     * The data for the geometry source.
	     * @type {Data}
	     * @desc A geometry source’s data is an array of vectors, each of which represents a particular attribute (or semantic) of a vertex in the geometry. The other properties of the geometry source determine how SceneKit interprets this data. For example, an array of vertex positions may have three 32-bit floating-point components per vector, but an array of texture coordinates may have two 8-bit integer coponents per vector.
	     * @see https://developer.apple.com/reference/scenekit/scngeometrysource/1522881-data
	     */
	    get: function get() {
	      return this._data.slice(0);
	    }

	    /**
	     * The semantic value (or attribute) the geometry source describes for each vertex.
	     * @type {SCNGeometrySource.Semantic}
	     * @desc A semantic describes an attribute for each vertex, such as position, color, surface normal vector, or texture coordinates.See Geometry Semantic Identifiers for available values.
	     * @see https://developer.apple.com/reference/scenekit/scngeometrysource/1523071-semantic
	     */

	  }, {
	    key: 'semantic',
	    get: function get() {
	      return this._semantic;
	    }

	    /**
	     * The number of vectors in the data.
	     * @type {number}
	     * @desc 
	     * @see https://developer.apple.com/reference/scenekit/scngeometrysource/1522648-vectorcount
	     */

	  }, {
	    key: 'vectorCount',
	    get: function get() {
	      return this._vectorCount;
	    }

	    /**
	     * A Boolean value that indicates whether vector components are floating-point values.
	     * @type {boolean}
	     * @desc If true, SceneKit interprets the geometry source’s data as an array of vectors whose components are floating-point values. The type of floating-point value is determined by the SCNGeometrySource property: 4 bytes for float values or 8 bytes for double values. If false, SceneKit interprets the geometry source’s data as an array of vectors whose components are integer values. The type of integer value is determined by the SCNGeometrySource property; for example, 2 bytes for unsigned short values or 4 bytes for unsigned int values.
	     * @see https://developer.apple.com/reference/scenekit/scngeometrysource/1522920-usesfloatcomponents
	     */

	  }, {
	    key: 'usesFloatComponents',
	    get: function get() {
	      return this._usesFloatComponents;
	    }

	    /**
	     * The number of scalar components in each vector.
	     * @type {number}
	     * @desc 
	     * @see https://developer.apple.com/reference/scenekit/scngeometrysource/1522832-componentspervector
	     */

	  }, {
	    key: 'componentsPerVector',
	    get: function get() {
	      return this._componentsPerVector;
	    }

	    /**
	     * The size, in bytes, of each vector component.
	     * @type {number}
	     * @desc 
	     * @see https://developer.apple.com/reference/scenekit/scngeometrysource/1522633-bytespercomponent
	     */

	  }, {
	    key: 'bytesPerComponent',
	    get: function get() {
	      return this._bytesPerComponent;
	    }

	    /**
	     * The offset, in bytes, from the beginning of the data to the first vector component to be used in the geometry source.
	     * @type {number}
	     * @desc You can use the SCNGeometrySource and SCNGeometrySource parameters can together to interleave data for multiple geometry sources in the same array, improving rendering performance. See SCNGeometrySource for details.
	     * @see https://developer.apple.com/reference/scenekit/scngeometrysource/1522834-dataoffset
	     */

	  }, {
	    key: 'dataOffset',
	    get: function get() {
	      return this._dataOffset;
	    }

	    /**
	     * The number of bytes from a vector to the next one in the data.
	     * @type {number}
	     * @desc You can use the SCNGeometrySource and SCNGeometrySource parameters can together to interleave data for multiple geometry sources in the same array, improving rendering performance. See SCNGeometrySource for details.
	     * @see https://developer.apple.com/reference/scenekit/scngeometrysource/1524197-datastride
	     */

	  }, {
	    key: 'dataStride',
	    get: function get() {
	      return this._dataStride;
	    }

	    // Creating GPU-Mutable Geometry Sources

	    /**
	     * Creates a geometry source whose vertex data resides in the specified Metal buffer, allowing modification through a Metal compute shader.
	     * @access public
	     * @param {MTLBuffer} mtlBuffer - A Metal buffer containing per-vertex data for the geometry source.
	     * @param {MTLVertexFormat} vertexFormat - The type of per-vertex data in the buffer. A MTLVertexFormat value defines the number of components for each vector in the geometry source and the data type and size of each component.
	     * @param {SCNGeometrySource.Semantic} semantic - The semantic value (or attribute) that the geometry source describes for each vertex. See Geometry Semantic Identifiers for available values.
	     * @param {number} vertexCount - The number of vertices in the geometry source.
	     * @param {number} offset - The offset, in bytes, from the beginning of the data to the first vector component to be used in the geometry source.
	     * @param {number} stride - The number of bytes from each vector to the next in the data.
	     * @returns {SCNGeometrySource} -
	     * @desc Use this method to create a geometry source whose underlying data can be modified at render time by a Metal compute shader running on the GPU. To create a MTLBuffer object for use with a geometry source, use the device property of the SceneKit view (or other renderer) responsible for drawing your scene.// Create and fill a buffer.
	    id <MTLDevice> device = self.scnView.device;
	    self.geometryBuffer = [device newBufferWithBytes:myData length:myLength options:myOptions];
	    // Create a geometry source from the buffer.
	    SCNGeometrySource *source = [SCNGeometrySource geometrySourceWithBuffer:buffer
	                               vertexFormat:myVertexFormat
	                                   semantic:SCNGeometrySourceSemanticVertex
	                                vertexCount:myVertexCount
	                                 dataOffset:0
	                                 dataStride:0];
	    Then, to modify the buffer’s contents at render time, implement a scene renderer delegate and schedule a compute command encoder during a render delegate method such as renderer(_:willRenderScene:atTime:).- (void)renderer:(id <SCNSceneRenderer>)aRenderer willRenderScene:(SCNScene *)scene atTime:(NSTimeInterval)time {
	       // Get a command buffer and compute encoder from the view (or other renderer).
	       id<MTLCommandBuffer> myCommandBuffer = [aRenderer.commandQueue commandBuffer];
	       id<MTLComputeCommandEncoder> myComputeEncoder = [myCommandBuffer computeCommandEncoder];
	         // Configure the compute command encoder.
	       // (Note pipeline state is preconfigured outside of the render loop.)
	       [myComputeEncoder setComputePipelineState:self.pipelineState];
	       [myComputeEncoder setBuffer:self.geometryBuffer offset:0 atIndex:0];
	         // Schedule the compute command and commit the command buffer.
	       [myComputeEncoder dispatchThreadgroups:myThreadgroupCount
	                        threadsPerThreadgroup:myThreadCount];
	       [myComputeEncoder endEncoding];
	       [myCommandBuffer commit];
	    }
	    NoteGeometry sources backed by a Metal buffer are available only with SceneKit views (or other renderers) whose renderingAPI property is metal. Metal commands that modify the buffer’s contents must be enqueued from within one of the render loop methods defined in the SCNSceneRendererDelegate protocol. The result of attempting to modify a buffer at any other time is undefined.// Create and fill a buffer.
	    id <MTLDevice> device = self.scnView.device;
	    self.geometryBuffer = [device newBufferWithBytes:myData length:myLength options:myOptions];
	    // Create a geometry source from the buffer.
	    SCNGeometrySource *source = [SCNGeometrySource geometrySourceWithBuffer:buffer
	                               vertexFormat:myVertexFormat
	                                   semantic:SCNGeometrySourceSemanticVertex
	                                vertexCount:myVertexCount
	                                 dataOffset:0
	                                 dataStride:0];
	    - (void)renderer:(id <SCNSceneRenderer>)aRenderer willRenderScene:(SCNScene *)scene atTime:(NSTimeInterval)time {
	       // Get a command buffer and compute encoder from the view (or other renderer).
	       id<MTLCommandBuffer> myCommandBuffer = [aRenderer.commandQueue commandBuffer];
	       id<MTLComputeCommandEncoder> myComputeEncoder = [myCommandBuffer computeCommandEncoder];
	         // Configure the compute command encoder.
	       // (Note pipeline state is preconfigured outside of the render loop.)
	       [myComputeEncoder setComputePipelineState:self.pipelineState];
	       [myComputeEncoder setBuffer:self.geometryBuffer offset:0 atIndex:0];
	         // Schedule the compute command and commit the command buffer.
	       [myComputeEncoder dispatchThreadgroups:myThreadgroupCount
	                        threadsPerThreadgroup:myThreadCount];
	       [myComputeEncoder endEncoding];
	       [myCommandBuffer commit];
	    }
	      * @see https://developer.apple.com/reference/scenekit/scngeometrysource/1522873-init
	     */

	  }], [{
	    key: 'geometrySourceWithDataSemanticVectorCountFloatComponentsComponentsPerVectorBytesPerComponentDataOffsetDataStride',
	    value: function geometrySourceWithDataSemanticVectorCountFloatComponentsComponentsPerVectorBytesPerComponentDataOffsetDataStride(data, semantic, vectorCount, floatComponents, componentsPerVector, bytesPerComponent, dataOffset, dataStride) {
	      var instance = new SCNGeometrySource(data, semantic, vectorCount, floatComponents, componentsPerVector, bytesPerComponent, dataOffset, dataStride);

	      return instance;
	    }

	    /**
	     * Creates a geometry source from an array of vertex positions. 
	     * @access public
	     * @param {SCNVector3[]} vertices - An array of three-component vectors, each of which represents a vertex position for the geometry source.
	     * @param {number} count - The number of vertices
	     * @returns {SCNGeometrySource} -
	     * @desc SceneKit converts this data to its own format to optimize rendering performance. To read the converted data, examine the properties of the created SCNGeometrySource object.To create a custom SCNGeometry object from the geometry source, use the init(sources:elements:) method.
	     * @see https://developer.apple.com/reference/scenekit/scngeometrysource/2034708-init
	     */

	  }, {
	    key: 'geometrySourceWithVerticesCount',
	    value: function geometrySourceWithVerticesCount(vertices, count) {
	      var data = [];
	      for (var i = 0; i < count; i++) {
	        data.push(vertices[i].x, vertices[i].y, vertices[i].z);
	      }

	      var instance = new SCNGeometrySource(data, // data
	      SCNGeometrySource.Semantic.vertex, // semantic
	      count, // vectorCount
	      true, // floatComponents
	      3, // componentsPerVector
	      4, // bytesPerComponent
	      0, // offset
	      12 // stride
	      );
	      return instance;
	    }

	    /**
	     * Creates a geometry source from an array of texture coordinate points.
	     * @access public
	     * @param {CGPoint[]} texcoord - An array of points, each of which represents a texture coordinate pair for the geometry source.
	     * @param {number} count - The number of texture coordinate points.
	     * @returns {SCNGeometrySource} -
	     * @desc SceneKit converts this data to its own format to optimize rendering performance. To read the converted data, examine the properties of the created SCNGeometrySource object.To create a custom SCNGeometry object from the geometry source, use the init(sources:elements:) method.
	     * @see https://developer.apple.com/reference/scenekit/scngeometrysource/1522718-init
	     */

	  }, {
	    key: 'geometrySourceWithTextureCoordinatesCount',
	    value: function geometrySourceWithTextureCoordinatesCount(texcoord, count) {
	      var data = [];
	      for (var i = 0; i < count; i++) {
	        data.push(texcoord[i].x, texcoord[i].y);
	      }

	      var instance = new SCNGeometrySource(data, // data
	      SCNGeometrySource.Semantic.texcoord, // semantic
	      count, // vectorCount
	      true, // floatComponents
	      2, // componentsPerVector
	      4, // bytesPerComponent
	      0, // offset
	      8 // stride
	      );
	      return instance;
	    }

	    /**
	     * Creates a geometry source from an array of normal vertices.
	     * @access public
	     * @param {SCNVector3[]} normals - An array of vectors, which represents a normal vector for the geometry source.
	     * @param {number} count - The number of normals
	     * @returns {SCNGeometrySource} -
	     */

	  }, {
	    key: 'geometrySourceWithNormalsCount',
	    value: function geometrySourceWithNormalsCount(normals, count) {
	      var data = [];
	      for (var i = 0; i < count; i++) {
	        data.push(normals[i].x, normals[i].y, normals[i].z);
	      }

	      var instance = new SCNGeometrySource(data, // data
	      SCNGeometrySource.Semantic.normal, // semantic
	      count, // vectorCount
	      true, // floatComponents
	      3, // componentsPerVector
	      4, // bytesPerComponent
	      0, // offset
	      12 // stride
	      );
	      return instance;
	    }
	  }, {
	    key: 'initBufferDataOffsetDataStride',
	    value: function initBufferDataOffsetDataStride(mtlBuffer, vertexFormat, semantic, vertexCount, offset, stride) {}

	    // Structures

	    /**
	     * @type {Object} Semantic
	     * @property {Symbol} boneIndices The semantic for bone index data, used for skeletal animation of skinned surfaces.
	     * @property {Symbol} boneWeights The semantic for bone weight data, used for skeletal animation of skinned surfaces.
	     * @property {Symbol} color The semantic for per-vertex color data.
	     * @property {Symbol} edgeCrease The semantic for edge crease data, used for subdividing surfaces.
	     * @property {Symbol} normal The semantic for surface normal data.
	     * @property {Symbol} tangent The semantic for surface tangent vector data.
	     * @property {Symbol} texcoord The semantic for texture coordinate data.
	     * @property {Symbol} vertex The semantic for vertex position data.
	     * @property {Symbol} vertexCrease The semantic for vertex crease data, used for subdividing surfaces.
	     * @see https://developer.apple.com/reference/scenekit/scngeometrysource.semantic
	     */

	  }, {
	    key: 'Semantic',
	    get: function get() {
	      return _Semantic;
	    }
	  }]);

	  return SCNGeometrySource;
	}(_NSObject3.default);

	exports.default = SCNGeometrySource;

/***/ },
/* 84 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * Options for how often SceneKit should execute the binding handler you provide with the handleBinding(ofBufferNamed:frequency:handler:) method.
	 * @typedef {Object} SCNBufferFrequency
	 * @property {Symbol} perFrame - Execute the binding handler once for each frame to be rendered using the shader.
	 * @property {Symbol} perNode - Execute the binding handler once for each frame, for each node to be rendered using the shader.
	 * @property {Symbol} perShadable - Execute the binding handler once for each frame, for each node, for each material or geometry to be rendered using the shader.
	 * @see https://developer.apple.com/reference/scenekit/scnbufferfrequency
	 */

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var SCNBufferFrequency = {
	  perFrame: Symbol(),
	  perNode: Symbol(),
	  perShadable: Symbol()
	};

	exports.default = SCNBufferFrequency;

/***/ },
/* 85 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _SCNBufferStream = __webpack_require__(86);

	var _SCNBufferStream2 = _interopRequireDefault(_SCNBufferStream);

	var _SCNNode = __webpack_require__(33);

	var _SCNNode2 = _interopRequireDefault(_SCNNode);

	var _SCNShadable = __webpack_require__(38);

	var _SCNShadable2 = _interopRequireDefault(_SCNShadable);

	var _SCNRenderer = __webpack_require__(41);

	var _SCNRenderer2 = _interopRequireDefault(_SCNRenderer);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * A block SceneKit calls at render time for working with buffers in a Metal shader, used by the handleBinding(ofBufferNamed:frequency:handler:) method.
	 * @type {function(buffer: SCNBufferStream, node: SCNNode, shadable: SCNShadable, renderer: SCNRenderer): void}
	 * @param {SCNBufferStream} buffer - An object that provides write access to the buffer. Use the writeBytes(_:count:) method on this object to write data for use by the shader.
	 * @param {SCNNode} node - The node to be rendered using the shader program.
	 * @param {SCNShadable} shadable - The material or geometry to be rendered using the shader program.
	 * @param {SCNRenderer} renderer - The view (or other SceneKit renderer) responsible for rendering.
	 * @returns {void}
	 * @see https://developer.apple.com/reference/scenekit/scnbufferbindingblock
	 */
	var SCNBufferBindingBlock = function SCNBufferBindingBlock(buffer, node, shadable, renderer) {};

	exports.default = SCNBufferBindingBlock;

/***/ },
/* 86 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * An object that manages a Metal buffer used by a custom shader program. 
	 * @interface
	 * @see https://developer.apple.com/reference/scenekit/scnbufferstream
	 */

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var SCNBufferStream = function () {
	  function SCNBufferStream() {
	    _classCallCheck(this, SCNBufferStream);
	  }

	  _createClass(SCNBufferStream, [{
	    key: 'init',


	    /**
	     * constructor
	     * @access public
	     * @returns {void}
	     */
	    value: function init() {}

	    // Writing Data to a Buffer

	    /**
	     * Required. Copies the specified data bytes into the underlying Metal buffer for use by a shader.
	     * @access public
	     * @param {Object} bytes - The memory address from which to copy data.
	     * @param {number} length - The number of bytes to copy into the Metal buffer.
	     * @returns {void}
	     * @see https://developer.apple.com/reference/scenekit/scnbufferstream/1523175-writebytes
	     */

	  }, {
	    key: 'writeBytesCount',
	    value: function writeBytesCount(bytes, length) {}
	  }]);

	  return SCNBufferStream;
	}();

	exports.default = SCNBufferStream;

/***/ },
/* 87 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * 
	 * @typedef {Object} SCNShaderModifierEntryPoint
	 * @property {Symbol} fragment - Use this entry point to change the color of a fragment after all other shading has been performed.
	 * @property {Symbol} geometry - Use this entry point to deform a geometry’s surface or alter its vertex attributes.
	 * @property {Symbol} lightingModel - Use this entry point to provide a custom lighting equation.
	 * @property {Symbol} surface - Use this entry point to modify the surface properties of a material before lighting is computed.
	 * @see https://developer.apple.com/reference/scenekit/scnshadermodifierentrypoint
	 */

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var SCNShaderModifierEntryPoint = {
	  fragment: Symbol(),
	  geometry: Symbol(),
	  lightingModel: Symbol(),
	  surface: Symbol()
	};

	exports.default = SCNShaderModifierEntryPoint;

/***/ },
/* 88 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _NSObject2 = __webpack_require__(13);

	var _NSObject3 = _interopRequireDefault(_NSObject2);

	var _SCNGeometryPrimitiveType = __webpack_require__(89);

	var _SCNGeometryPrimitiveType2 = _interopRequireDefault(_SCNGeometryPrimitiveType);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * A container for index data describing how vertices connect to define a three-dimensional object, or geometry.
	 * @access public
	 * @extends {NSObject}
	 * @see https://developer.apple.com/reference/scenekit/scngeometryelement
	 */
	var SCNGeometryElement = function (_NSObject) {
	  _inherits(SCNGeometryElement, _NSObject);

	  // Creating a Geometry Element

	  /**
	   * Creates a geometry element from the specified array of index values. 
	   * @access public
	   * @constructor
	   * @param {IndexType[]} indices - An array of index values, each of which identifies a vertex in a geometry source.
	   * @param {SCNGeometryPrimitiveType} primitiveType - The drawing primitive that connects vertices when rendering the geometry element. For possible values, see SCNGeometryPrimitiveType.
	   * @desc SceneKit connects the vertices in the order specified by the indices array, arranged according to the primitiveType parameter.This initializer is equivalent to the init(data:primitiveType:primitiveCount:bytesPerIndex:) initializer, but does not require an intermediary Data object; instead, it automatically infers the necessary allocation size and bytesPerIndex values based on the contents of the indices array. To create a custom SCNGeometry object from the geometry element, use the init(sources:elements:) initializer.
	   * @see https://developer.apple.com/reference/scenekit/scngeometryelement/1523191-init
	   */
	  function SCNGeometryElement(indices, primitiveType) {
	    _classCallCheck(this, SCNGeometryElement);

	    // Inspecting a Geometry Element

	    var _this = _possibleConstructorReturn(this, (SCNGeometryElement.__proto__ || Object.getPrototypeOf(SCNGeometryElement)).call(this));

	    _this._data = indices;
	    _this._primitiveType = primitiveType;
	    _this._primitiveCount = indices.length / 3; // FIXME: calculate from primitiveType
	    _this._bytesPerIndex = 2;

	    /**
	     * @type {TypedArray}
	     * @access private
	     */
	    _this._glData = new Uint16Array(_this._data);
	    return _this;
	  }

	  /**
	   * Creates a geometry element from the specified Model I/O submesh object.
	   * @access public
	   * @param {MDLSubmesh} mdlSubMesh - 
	   * @returns {void}
	   * @desc The Model I/O framework provides universal support for import, export, description, and processing of several 3D asset file formats and related resources. (For details, see Model I/O.) The MDLSubmesh class is a generic description of an index buffer to be used in rendering a 3D object, along with an assigned material. In SceneKit, materials are assigned to a geometry rather than to its elements, so importing a submesh as a geometry element does not import its material assignment. To import a Model I/O mesh along with its materials, use the SCNGeometry init(mdlMesh:) method.
	   * @see https://developer.apple.com/reference/scenekit/scngeometryelement/1419843-init
	   */


	  _createClass(SCNGeometryElement, [{
	    key: 'initMdlSubmesh',
	    value: function initMdlSubmesh(mdlSubMesh) {}

	    // Inspecting a Geometry Element

	    /**
	     * The drawing primitive that connects vertices when rendering the geometry element.
	     * @type {SCNGeometryPrimitiveType}
	     * @desc For possible values, see SCNGeometryPrimitiveType.
	     * @see https://developer.apple.com/reference/scenekit/scngeometryelement/1522917-primitivetype
	     */

	  }, {
	    key: '_createBuffer',
	    value: function _createBuffer(context) {
	      var gl = context;
	      this._buffer = gl.createBuffer();
	      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._buffer);
	      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this._glData, gl.STATIC_DRAW);

	      return this._buffer;
	    }
	  }, {
	    key: 'copy',
	    value: function copy() {
	      var element = new SCNGeometryElement(this._data.slice(0), this._primitiveType);
	      return element;
	    }
	  }, {
	    key: 'primitiveType',
	    get: function get() {
	      return this._primitiveType;
	    }

	    /**
	     * The number of primitives in the element.
	     * @type {number}
	     * @desc 
	     * @see https://developer.apple.com/reference/scenekit/scngeometryelement/1523404-primitivecount
	     */

	  }, {
	    key: 'primitiveCount',
	    get: function get() {
	      return this._primitiveCount;
	    }

	    /**
	     * The data describing the geometry element.
	     * @type {Data}
	     * @desc An element’s data is an array of index values identifying vertices in a geometry source. SceneKit interprets the data as an array of unsigned integers, whose size is specified by the bytesPerIndex property.
	     * @see https://developer.apple.com/reference/scenekit/scngeometryelement/1523367-data
	     */

	  }, {
	    key: 'data',
	    get: function get() {
	      return this._data;
	    }

	    /**
	     * The number of bytes that represent each index value in the element’s data.
	     * @type {number}
	     * @desc An element’s data property holds an array of index values identifying vertices in a geometry source. SceneKit interprets the data as an array of unsigned integers, whose size is specified by the bytesPerIndex property.
	     * @see https://developer.apple.com/reference/scenekit/scngeometryelement/1522720-bytesperindex
	     */

	  }, {
	    key: 'bytesPerIndex',
	    get: function get() {
	      return this._bytesPerIndex;
	    }
	  }]);

	  return SCNGeometryElement;
	}(_NSObject3.default);

	exports.default = SCNGeometryElement;

/***/ },
/* 89 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * The drawing primitive that connects vertices when rendering a geometry element, used by the primitiveType property to specify how SceneKit interprets the geometry element’s data.
	 * @typedef {Object} SCNGeometryPrimitiveType
	 * @property {Symbol} triangles - The geometry element’s data is a sequence of triangles, with each triangle described by three new vertices.
	 * @property {Symbol} triangleStrip - The geometry element’s data is a sequence of triangles, with each triangle described by one new vertex and two vertices from the previous triangle. 
	 * @property {Symbol} line - The geometry element’s data is a sequence of line segments, with each line segment described by two new vertices. 
	 * @property {Symbol} point - The geometry element’s data is a sequence of unconnected points.
	 * @property {Symbol} polygon - 
	 * @see https://developer.apple.com/reference/scenekit/scngeometryprimitivetype
	 */

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var SCNGeometryPrimitiveType = {
	  triangles: Symbol(),
	  triangleStrip: Symbol(),
	  line: Symbol(),
	  point: Symbol(),
	  polygon: Symbol()
	};

	exports.default = SCNGeometryPrimitiveType;

/***/ },
/* 90 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _NSObject2 = __webpack_require__(13);

	var _NSObject3 = _interopRequireDefault(_NSObject2);

	var _SCNGeometry = __webpack_require__(37);

	var _SCNGeometry2 = _interopRequireDefault(_SCNGeometry);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * An object that defines alternate resolutions for a geometry that SceneKit can automatically substitute to improve rendering performance.
	 * @access public
	 * @extends {NSObject}
	 * @see https://developer.apple.com/reference/scenekit/scnlevelofdetail
	 */
	var SCNLevelOfDetail = function (_NSObject) {
	  _inherits(SCNLevelOfDetail, _NSObject);

	  function SCNLevelOfDetail() {
	    _classCallCheck(this, SCNLevelOfDetail);

	    return _possibleConstructorReturn(this, (SCNLevelOfDetail.__proto__ || Object.getPrototypeOf(SCNLevelOfDetail)).apply(this, arguments));
	  }

	  _createClass(SCNLevelOfDetail, [{
	    key: 'init',


	    /**
	     * constructor
	     * @access public
	     * @returns {void}
	     */
	    value: function init() {

	      // Inspecting a Level of Detail

	      this._geometry = null;
	      this._screenSpaceRadius = 0;
	      this._worldSpaceDistance = 0;
	    }

	    // Creating a Level of Detail

	    /**
	     * Creates a level of detail with the specified geometry and threshold pixel radius.
	     * @access public
	     * @param {?SCNGeometry} geometry - The geometry to render for this level of detail.
	     * @param {number} radius - The maximum radius (in pixels) of the geometry’s bounding sphere for this level of detail to appear.
	     * @returns {void}
	     * @desc When rendering a geometry with associated levels of detail, SceneKit calculates the radius in pixels of the circle covered by a geometry’s bounding sphere, then renders the geometry for the SCNLevelOfDetail object with the largest radius parameter smaller than that circle.If you pass nil for the geometry parameter, SceneKit renders no geometry for the level of detail. Creating a level-of-detail object with no geometry allows you to skip rendering costs entirely for an object when it would appear very far away or very small.
	     * @see https://developer.apple.com/reference/scenekit/scnlevelofdetail/1523557-init
	     */

	  }, {
	    key: 'initScreenSpaceRadius',
	    value: function initScreenSpaceRadius(geometry, radius) {}

	    /**
	     * Creates a level of detail with the specified geometry and threshold camera distance.
	     * @access public
	     * @param {?SCNGeometry} geometry - The geometry to render for this level of detail, or nil if SceneKit should render no geometry at this level of detail.
	     * @param {number} distance - The minimum distance from the current point of view for this level of detail to appear.
	     * @returns {void}
	     * @desc When rendering a geometry with associated levels of detail, SceneKit calculates the distance from the current point of view to the geometry’s parent node, then renders the geometry for the SCNLevelOfDetail object with the smallest distance parameter greater than that distance.If you pass nil for the geometry parameter, SceneKit renders no geometry for the level of detail. Creating a level-of-detail object with no geometry allows you to skip rendering costs entirely for an object when it would appear very far away or very small.
	     * @see https://developer.apple.com/reference/scenekit/scnlevelofdetail/1522802-init
	     */

	  }, {
	    key: 'initWorldSpaceDistance',
	    value: function initWorldSpaceDistance(geometry, distance) {}

	    // Inspecting a Level of Detail
	    /**
	     * The geometry associated with this level of detail.
	     * @type {?SCNGeometry}
	     * @desc SceneKit renders this geometry instead of the original geometry when the level of detail is appropriate. Generally, levels of detail with larger worldSpaceDistance values or smaller screenSpaceRadius values should contain less complex geometries.If the value of this property is nil, SceneKit renders no geometry at this level of detail.
	     * @see https://developer.apple.com/reference/scenekit/scnlevelofdetail/1522819-geometry
	     */

	  }, {
	    key: 'geometry',
	    get: function get() {
	      return this._geometry;
	    }
	    /**
	     * The maximum radius (in pixels) of the geometry’s bounding sphere for this level of detail to appear.
	     * @type {number}
	     * @desc When rendering a geometry with associated levels of detail, SceneKit calculates the radius in pixels of the circle covered by a geometry’s bounding sphere, then renders the geometry for the SCNLevelOfDetail object with the smallest radius parameter larger than that circle.
	     * @see https://developer.apple.com/reference/scenekit/scnlevelofdetail/1523554-screenspaceradius
	     */

	  }, {
	    key: 'screenSpaceRadius',
	    get: function get() {
	      return this._screenSpaceRadius;
	    }
	    /**
	     * The minimum distance from the current point of view for this level of detail to appear.
	     * @type {number}
	     * @desc When rendering a geometry with associated levels of detail, SceneKit calculates the distance from the current point of view to the geometry’s parent node, then renders the geometry for the SCNLevelOfDetail object with the largest distance parameter less than that distance.
	     * @see https://developer.apple.com/reference/scenekit/scnlevelofdetail/1524159-worldspacedistance
	     */

	  }, {
	    key: 'worldSpaceDistance',
	    get: function get() {
	      return this._worldSpaceDistance;
	    }
	  }]);

	  return SCNLevelOfDetail;
	}(_NSObject3.default);

	exports.default = SCNLevelOfDetail;

/***/ },
/* 91 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _NSObject2 = __webpack_require__(13);

	var _NSObject3 = _interopRequireDefault(_NSObject2);

	var _SCNAnimatable = __webpack_require__(35);

	var _SCNAnimatable2 = _interopRequireDefault(_SCNAnimatable);

	var _SCNShadable = __webpack_require__(38);

	var _SCNShadable2 = _interopRequireDefault(_SCNShadable);

	var _SCNMaterialProperty = __webpack_require__(44);

	var _SCNMaterialProperty2 = _interopRequireDefault(_SCNMaterialProperty);

	var _SCNTransparencyMode = __webpack_require__(92);

	var _SCNTransparencyMode2 = _interopRequireDefault(_SCNTransparencyMode);

	var _SCNCullMode = __webpack_require__(93);

	var _SCNCullMode2 = _interopRequireDefault(_SCNCullMode);

	var _SCNBlendMode = __webpack_require__(94);

	var _SCNBlendMode2 = _interopRequireDefault(_SCNBlendMode);

	var _SKColor = __webpack_require__(48);

	var _SKColor2 = _interopRequireDefault(_SKColor);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var _LightingModel = {
	  blinn: Symbol(),
	  constant: Symbol(),
	  lambert: Symbol(),
	  phong: Symbol(),
	  physicallyBased: Symbol()
	};

	/**
	 * A set of shading attributes that define the appearance of a geometry's surface when rendered.
	 * @access public
	 * @extends {NSObject}
	 * @implements {SCNAnimatable}
	 * @implements {SCNShadable}
	 * @see https://developer.apple.com/reference/scenekit/scnmaterial
	 */

	var SCNMaterial = function (_NSObject) {
	  _inherits(SCNMaterial, _NSObject);

	  // Creating a Material

	  /**
	   * Creates a material from the specified Model I/O material object.
	   * @access public
	   * @constructor
	   * @param {MDLMaterial} mdlMaterial - A Model I/O material object.
	   * @desc The Model I/O framework provides universal support for import, export, description, and processing of several 3D asset file formats and related resources. (For details, see Model I/O.) The MDLMaterial class is a generic description of surface rendering to be used in rendering 3D object, supporting a superset of the attributes described by the SCNMaterial class. 
	   * @see https://developer.apple.com/reference/scenekit/scnmaterial/1419835-init
	   */
	  function SCNMaterial(mdlMaterial) {
	    _classCallCheck(this, SCNMaterial);

	    // Configuring a Material’s Visual Properties

	    var _this = _possibleConstructorReturn(this, (SCNMaterial.__proto__ || Object.getPrototypeOf(SCNMaterial)).call(this));

	    _this._diffuse = new _SCNMaterialProperty2.default(_SKColor2.default.white);
	    _this._ambient = new _SCNMaterialProperty2.default(new _SKColor2.default(0.485, 0.485, 0.485, 1.0));
	    _this._specular = new _SCNMaterialProperty2.default(_SKColor2.default.black);
	    _this._normal = new _SCNMaterialProperty2.default(_SKColor2.default.white);
	    _this._reflective = new _SCNMaterialProperty2.default(_SKColor2.default.black);
	    _this._emission = new _SCNMaterialProperty2.default(_SKColor2.default.black);
	    _this._transparent = new _SCNMaterialProperty2.default(_SKColor2.default.white);
	    _this._multiply = new _SCNMaterialProperty2.default(_SKColor2.default.white);
	    _this._ambientOcclusion = new _SCNMaterialProperty2.default(_SKColor2.default.white);
	    _this._selfIllumination = new _SCNMaterialProperty2.default(_SKColor2.default.black);
	    _this._metalness = new _SCNMaterialProperty2.default(_SKColor2.default.black);
	    _this._roughness = new _SCNMaterialProperty2.default(new _SKColor2.default(0.485, 0.485, 0.485, 1.0));

	    // Customizing a Material

	    /**
	     * A name associated with the material.
	     * @type {?string}
	     * @see https://developer.apple.com/reference/scenekit/scnmaterial/1462525-name
	     */
	    _this.name = null;

	    /**
	     * The sharpness of specular highlights. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnmaterial/1462533-shininess
	     */
	    _this.shininess = 1.0;

	    /**
	     * A factor affecting the material’s reflectivity. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnmaterial/1462587-fresnelexponent
	     */
	    _this.fresnelExponent = 0.0;

	    /**
	     * The uniform transparency of the material. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnmaterial/1462567-transparency
	     */
	    _this.transparency = 1.0;

	    /**
	     * The mode SceneKit uses to calculate transparency for the material.
	     * @type {SCNTransparencyMode}
	     * @see https://developer.apple.com/reference/scenekit/scnmaterial/1462549-transparencymode
	     */
	    _this.transparencyMode = _SCNTransparencyMode2.default.aOne;

	    /**
	     * The lighting formula that SceneKit uses to render the material.
	     * @type {SCNMaterial.LightingModel}
	     * @see https://developer.apple.com/reference/scenekit/scnmaterial/1462518-lightingmodel
	     */
	    _this.lightingModel = _LightingModel.blinn;

	    /**
	     * A Boolean value that determines whether SceneKit performs lighting calculations per vertex or per pixel. Animatable.
	     * @type {boolean}
	     * @see https://developer.apple.com/reference/scenekit/scnmaterial/1462580-islitperpixel
	     */
	    _this.isLitPerPixel = true;

	    /**
	     * A Boolean value that determines whether SceneKit should render both front and back faces of a surface. Animatable.
	     * @type {boolean}
	     * @see https://developer.apple.com/reference/scenekit/scnmaterial/1462531-isdoublesided
	     */
	    _this.isDoubleSided = false;

	    /**
	     * The mode determining which faces of a surface SceneKit renders. Animatable.
	     * @type {SCNCullMode}
	     * @see https://developer.apple.com/reference/scenekit/scnmaterial/1462571-cullmode
	     */
	    _this.cullMode = _SCNCullMode2.default.back;

	    /**
	     * The mode that determines how pixel colors rendered using this material blend with other pixel colors in the rendering target.
	     * @type {SCNBlendMode}
	     * @see https://developer.apple.com/reference/scenekit/scnmaterial/1462585-blendmode
	     */
	    _this.blendMode = _SCNBlendMode2.default.alpha;

	    /**
	     * A Boolean value that determines whether the material responds identically to both ambient and diffuse lighting. Animatable.
	     * @type {boolean}
	     * @see https://developer.apple.com/reference/scenekit/scnmaterial/1462522-locksambientwithdiffuse
	     */
	    _this.locksAmbientWithDiffuse = true;

	    /**
	     * A Boolean value that determines whether SceneKit produces depth information when rendering the material.
	     * @type {boolean}
	     * @see https://developer.apple.com/reference/scenekit/scnmaterial/1462545-writestodepthbuffer
	     */
	    _this.writesToDepthBuffer = true;

	    /**
	     * A Boolean value that determines whether SceneKit uses depth information when rendering the material.
	     * @type {boolean}
	     * @see https://developer.apple.com/reference/scenekit/scnmaterial/1462562-readsfromdepthbuffer
	     */
	    _this.readsFromDepthBuffer = true;

	    /////////////////
	    // SCNShadable //
	    /////////////////

	    // Assigning a Custom Shader Program

	    /**
	     * A program used when rendering the object.
	     * @type {?SCNProgram}
	     * @see https://developer.apple.com/reference/scenekit/scnshadable/1523689-program
	     */
	    _this.program = null;

	    // Customizing SceneKit’s Shader Programs

	    /**
	     * A dictionary of GLSL source code snippets for customizing the shader programs provided by SceneKit.
	     * @type {?Map<SCNShaderModifierEntryPoint, string>}
	     * @see https://developer.apple.com/reference/scenekit/scnshadable/1523348-shadermodifiers
	     */
	    _this.shaderModifiers = null;

	    ///////////////////
	    // SCNAnimatable //
	    ///////////////////

	    // Managing Animations
	    _this._animationKeys = null;
	    return _this;
	  }

	  // Configuring a Material’s Visual Properties

	  /**
	   * An object that manages the material’s diffuse response to lighting.
	   * @type {SCNMaterialProperty}
	   * @desc Diffuse shading describes the amount and color of light reflected equally in all directions from each point on the material’s surface. The diffuse color of a pixel is independent of the point of view, so it can be thought of as a material’s “base” color or texture. By default, the diffuse property’s contents object is a white color. Figure 1 shows the effect of setting the diffuse property’s contents to a texture image on a material whose other properties have default contents.Figure 1 Adding a diffuse texture to a materialThe material’s lightingModel property determines the formula SceneKit uses to combine its diffuse color and other visual properties with lights and other contents in a scene to produce the final color for each rendered pixel in the rendered scene. For details, see Lighting Models.Adding a diffuse texture to a material
	   * @see https://developer.apple.com/reference/scenekit/scnmaterial/1462589-diffuse
	   */


	  _createClass(SCNMaterial, [{
	    key: 'handleBindingOfSymbolHandler',


	    /////////////////
	    // SCNShadable //
	    /////////////////

	    // Handling Parameters in Custom OpenGL Shader Programs

	    /**
	     * Specifies a block to be called before rendering with programs with the specified GLSL uniform variable or attribute name.
	     * @access public
	     * @param {string} symbol - A GLSL uniform variable or attribute name.
	     * @param {?SCNBindingBlock} [block = null] - A block to be called by SceneKit.
	     * @returns {void}
	     * @desc Use this method to associate a block with a SceneKit object (geometry or material) to handle setup of an attribute or uniform variable in a custom SCNProgram shader associated with that object. SceneKit calls your block before rendering the object. In the block, you can execute any OpenGL commands or other code necessary for preparing your custom shader. For example, the following block updates the time uniform variable in a custom fragment shader for producing animated effects:CFTimeInterval startTime = CFAbsoluteTimeGetCurrent();
	    [myNode.geometry.firstMaterial handleBindingOfSymbol:@"time" usingBlock:
	      ^(unsigned int programID, unsigned int location, SCNNode *renderedNode, SCNRenderer *renderer) {
	          glUniform1f(location, CFAbsoluteTimeGetCurrent() - startTime);
	      }];
	    This method is for OpenGL shader programs only. To bind custom variable data for Metal shader programs, use the handleBinding(ofBufferNamed:frequency:handler:) method.CFTimeInterval startTime = CFAbsoluteTimeGetCurrent();
	    [myNode.geometry.firstMaterial handleBindingOfSymbol:@"time" usingBlock:
	      ^(unsigned int programID, unsigned int location, SCNNode *renderedNode, SCNRenderer *renderer) {
	          glUniform1f(location, CFAbsoluteTimeGetCurrent() - startTime);
	      }];
	      * @see https://developer.apple.com/reference/scenekit/scnshadable/1523063-handlebinding
	     */
	    value: function handleBindingOfSymbolHandler(symbol) {
	      var block = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
	    }

	    /**
	     * Specifies a block to be called after rendering with programs with the specified GLSL uniform variable or attribute name.
	     * @access public
	     * @param {string} symbol - A GLSL uniform variable or attribute name.
	     * @param {?SCNBindingBlock} [block = null] - A block to be called by SceneKit.
	     * @returns {void}
	     * @desc Use this method to associate a block with a SceneKit object (geometry or material) to handle cleanup related to an attribute or uniform variable in a custom SCNProgram shader associated with that object. SceneKit will call your block after rendering the object. In the block, you can execute any OpenGL commands or other code necessary for post-rendering tasks.This method is for OpenGL shader programs only. To bind custom variable data for Metal shader programs, use the handleBinding(ofBufferNamed:frequency:handler:) method.
	     * @see https://developer.apple.com/reference/scenekit/scnshadable/1522783-handleunbinding
	     */

	  }, {
	    key: 'handleUnbindingOfSymbolHandler',
	    value: function handleUnbindingOfSymbolHandler(symbol) {
	      var block = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
	    }

	    ///////////////////
	    // SCNAnimatable //
	    ///////////////////

	    // Managing Animations

	    /**
	     * Required. Adds an animation object for the specified key.
	     * @access public
	     * @param {CAAnimation} animation - The animation object to be added.
	     * @param {?string} key - An string identifying the animation for later retrieval. You may pass nil if you don’t need to reference the animation later.
	     * @returns {void}
	     * @desc Newly added animations begin executing after the current run loop cycle ends.SceneKit does not define any requirements for the contents of the key parameter—it need only be unique among the keys for other animations you add. If you add an animation with an existing key, this method overwrites the existing animation.
	     * @see https://developer.apple.com/reference/scenekit/scnanimatable/1523386-addanimation
	     */

	  }, {
	    key: 'addAnimationForKey',
	    value: function addAnimationForKey(animation, key) {}

	    /**
	     * Required. Returns the animation with the specified key.
	     * @access public
	     * @param {string} key - A string identifying a previously added animation.
	     * @returns {?CAAnimation} - 
	     * @desc Attempting to modify any properties of the returned object results in undefined behavior.
	     * @see https://developer.apple.com/reference/scenekit/scnanimatable/1524020-animation
	     */

	  }, {
	    key: 'animationForKey',
	    value: function animationForKey(key) {
	      return null;
	    }

	    /**
	     * Required. Removes all the animations currently attached to the object.
	     * @access public
	     * @returns {void}
	     * @see https://developer.apple.com/reference/scenekit/scnanimatable/1522762-removeallanimations
	     */

	  }, {
	    key: 'removeAllAnimations',
	    value: function removeAllAnimations() {}

	    /**
	     * Required. Removes the animation attached to the object with the specified key.
	     * @access public
	     * @param {string} key - A string identifying an attached animation to remove.
	     * @returns {void}
	     * @see https://developer.apple.com/reference/scenekit/scnanimatable/1522880-removeanimation
	     */

	  }, {
	    key: 'removeAnimationForKey',
	    value: function removeAnimationForKey(key) {}

	    /**
	     * Required. Removes the animation attached to the object with the specified key, smoothly transitioning out of the animation’s effect.
	     * @access public
	     * @param {string} key - A string identifying an attached animation to remove.
	     * @param {number} duration - The duration for transitioning out of the animation’s effect before it is removed.
	     * @returns {void}
	     * @desc Use this method to create smooth transitions between the effects of multiple animations. For example, the geometry loaded from a scene file for a game character may have associated animations for player actions such as walking and jumping. When the player lands from a jump, you remove the jump animation so the character continues walking. If you use the removeAnimation(forKey:) method to remove the jump animation, SceneKit abruptly switches from the current frame of the jump animation to the current frame of the walk animation. If you use the removeAnimation(forKey:fadeOutDuration:) method instead, SceneKit plays both animations at once during that duration and interpolates vertex positions from one animation to the other, creating a smooth transition.
	     * @see https://developer.apple.com/reference/scenekit/scnanimatable/1522841-removeanimation
	     */

	  }, {
	    key: 'removeAnimationForKeyFadeOutDuration',
	    value: function removeAnimationForKeyFadeOutDuration(key, duration) {}
	    /**
	     * Required. An array containing the keys of all animations currently attached to the object.
	     * @type {string[]}
	     * @desc This array contains all keys for which animations are attached to the object, or is empty if there are no attached animations. The ordering of animation keys in the array is arbitrary.
	     * @see https://developer.apple.com/reference/scenekit/scnanimatable/1523610-animationkeys
	     */

	  }, {
	    key: 'pauseAnimationForKey',


	    // Pausing and Resuming Animations

	    /**
	     * Required. Pauses the animation attached to the object with the specified key.
	     * @access public
	     * @param {string} key - A string identifying an attached animation.
	     * @returns {void}
	     * @desc This method has no effect if no animation is attached to the object with the specified key.
	     * @see https://developer.apple.com/reference/scenekit/scnanimatable/1523592-pauseanimation
	     */
	    value: function pauseAnimationForKey(key) {}

	    /**
	     * Required. Resumes a previously paused animation attached to the object with the specified key.
	     * @access public
	     * @param {string} key - A string identifying an attached animation.
	     * @returns {void}
	     * @desc This method has no effect if no animation is attached to the object with the specified key or if the specified animation is not currently paused.
	     * @see https://developer.apple.com/reference/scenekit/scnanimatable/1523332-resumeanimation
	     */

	  }, {
	    key: 'resumeAnimationForKey',
	    value: function resumeAnimationForKey(key) {}

	    /**
	     * Required. Returns a Boolean value indicating whether the animation attached to the object with the specified key is paused.
	     * @access public
	     * @param {string} key - A string identifying an attached animation.
	     * @returns {boolean} - 
	     * @see https://developer.apple.com/reference/scenekit/scnanimatable/1523703-isanimationpaused
	     */

	  }, {
	    key: 'isAnimationPausedForKey',
	    value: function isAnimationPausedForKey(key) {
	      return false;
	    }

	    // Instance Methods

	    /**
	     * Required. 
	     * @access public
	     * @param {number} speed - 
	     * @param {string} key - 
	     * @returns {void}
	     * @see https://developer.apple.com/reference/scenekit/scnanimatable/1778343-setanimationspeed
	     */

	  }, {
	    key: 'setAnimationSpeedForKey',
	    value: function setAnimationSpeedForKey(speed, key) {}
	  }, {
	    key: 'diffuse',
	    get: function get() {
	      return this._diffuse;
	    }

	    /**
	     * An object that manages the material’s response to ambient lighting.
	     * @type {SCNMaterialProperty}
	     * @desc Ambient shading describes the amount and color of ambient light reflected by the material. Ambient shading is uniform in all directions at all points on a surface. If a scene does not contain lights whose type is ambient, this property has no effect on a material’s appearance. By default, the ambient property’s contents object is a dark gray color. Changing the ambient property’s contents lets you specify a different color or texture for the areas of a surface not directly illuminated by lights in a scene. To make the material respond identically to both ambient and diffuse light, set its locksAmbientWithDiffuse property to true. Figure 1 shows a material (with a texture for its diffuse property) before and after setting the ambient property’s contents to a solid color.Figure 1 Adding an ambient color to a materialThe material’s lightingModel property determines the formula SceneKit uses to combine its ambient color and other visual properties with lights and other contents in a scene to produce the final color for each rendered pixel in the rendered scene. For details, see Lighting Models.This material property does not apply to physically-based materials (see physicallyBased).Adding an ambient color to a material
	     * @see https://developer.apple.com/reference/scenekit/scnmaterial/1462558-ambient
	     */

	  }, {
	    key: 'ambient',
	    get: function get() {
	      return this._ambient;
	    }

	    /**
	     * An object that manages the material’s specular response to lighting.
	     * @type {SCNMaterialProperty}
	     * @desc Specular shading describes the amount and color of light reflected by the material directly toward the viewer, forming a bright highlight on the surface and simulating a glossy or shiny appearance. You adjust the sharpness of specular highlights using the material’s shininess property.By default, the specular property’s contents object is a black color, causing the material to appear dull or matte. Changing the specular property’s contents to a brighter color causes specular highlights to appear in that color, making the surface appear shiny. When you apply a texture to the specular property, the texture image becomes a specular map—the brightness of each pixel in the image determines the tendency of each point on the material’s surface to create specular highlights when lit. Figure 1 shows a material (with a texture for its diffuse property) before and after providing a specular map image. Notice that the bright specular highlights appear only on portions of the surface where the specular map image is white.Figure 1 Adding a specular map to a materialThe material’s lightingModel property determines the formula SceneKit uses to combine its specularity and other visual properties with lights and other contents in a scene to produce the final color for each rendered pixel in the rendered scene. For details, see Lighting Models.This material property does not apply to physically-based materials (see physicallyBased).Adding a specular map to a material
	     * @see https://developer.apple.com/reference/scenekit/scnmaterial/1462516-specular
	     */

	  }, {
	    key: 'specular',
	    get: function get() {
	      return this._specular;
	    }

	    /**
	     * An object that defines the nominal orientation of the surface at each point for use in lighting.
	     * @type {SCNMaterialProperty}
	     * @desc Simulating the interaction of lights with a material requires information about the orientation of the surface at each point. Typically, normal vectors provided by a geometry object provide this information. However, this limits the level of detail for surface contours because a geometry can only provide one unique surface normal vector per vertex (and increasing vertex count to model a highly detailed surface exacts a high performance cost).Alternatively, you can use a texture image as a normal map that describes the orientation of a surface for each pixel in the texture. When SceneKit uses an image, it treats the R, G, and B components of each as the X, Y, and Z components of a surface normal vector. Because a normal map texture can store much more detailed surface information than a geometry, you can use a material’s normal property to simulate rough surfaces such as stone or add embossed or engraved designs to an otherwise smooth surface.By default, the normal property’s contents object is a white color. Setting the normal property’s contents to any solid color disables normal mapping, causing SceneKit to shade the material using only the surface normal information provided by its geometry. Setting the normal property’s contents to an image or other texture-mapped content enables normal mapping, which also automatically sets the material’s isLitPerPixel property to true. Figure 1 shows the effect of setting the normal property’s contents to a texture image on a material whose other properties have default contents.Figure 1 Adding a normal map to a materialThe material’s lightingModel property determines the formula SceneKit uses to combine its surface normals and other visual properties with lights and other contents in a scene to produce the final color for each rendered pixel in the rendered scene. For details, see Lighting Models.Adding a normal map to a material
	     * @see https://developer.apple.com/reference/scenekit/scnmaterial/1462542-normal
	     */

	  }, {
	    key: 'normal',
	    get: function get() {
	      return this._normal;
	    }

	    /**
	     * An object that defines the reflected color for each point on a surface.
	     * @type {SCNMaterialProperty}
	     * @desc You can simulate a mirrored or chromed finish on a surface by causing it to reflect its environment. SceneKit does not render real-time reflections of the objects in a scene, but it can use an environment map texture to simulate reflection of a static or animated image. When rendering each pixel on the surface, SceneKit traces the light from that point to a pixel in the environment map as if the surface was reflecting that image.By default, the reflective property’s contents object is a white color, causing the property to have no visible effect. Setting the reflective property’s contents to any solid color adds uniform shading to the material. To create a reflective effect, set the property’s contents to an image or other texture-mapped content.To produce a mirror-finish effect using an environment map, the texture image should take one of two forms:A sphere map, a square image whose content depicts an environment as reflected by a mirrored sphere.A cube map, an array of six square images which together form an imaginary cube enclosing the scene, whose inner surfaces are reflected by the material. You create a cube map by setting the reflective property’s contents object to an NSArray instance containing six images, each corresponding to a direction in the scene’s world coordinate space in the following order: +X, -X, +Y, -Y, +Z, -Z (or Right, Left, Top, Bottom, Near, Far).Figure 1 shows a material (with a texture for its normal property) before and after providing a cube map for the reflective property.Figure 1 Adding a reflective cube map to a materialThis material property does not apply to physically-based materials (see physicallyBased). Instead, such materials reflect environment-based lighting (see the SCNScene lightingEnvironment property) based on their metalness and roughness properties.Adding a reflective cube map to a material
	     * @see https://developer.apple.com/reference/scenekit/scnmaterial/1462520-reflective
	     */

	  }, {
	    key: 'reflective',
	    get: function get() {
	      return this._reflective;
	    }

	    /**
	     * An object that defines the color emitted by each point on a surface.
	     * @type {SCNMaterialProperty}
	     * @desc You can use an emissive map texture to simulate parts of a surface that glow with their own light. SceneKit does not treat the material as a light source—rather, the emission property determines colors for a material independent of lighting. (To create an object that appears to glow, you may wish to combine a geometry with an emissive map and additional SCNLight objects added to the scene.)By default, the emissive property’s contents object is a black color, causing the property to have no visible effect. Setting the emissive property’s contents to any solid color adds a uniform color to the material independent of lighting. To create a selective glow effect, set the property’s contents to an image or other texture-mapped content whose glowing areas use bright colors and whose other areas use darker colors. In the darker-colored portions of the emissive map (and portions with reduced opacity), the other visual properties of the material contribute to its appearance under scene lighting.Figure 1 shows a material (with a texture for its diffuse property) before and after providing an emissive map image.Figure 1 Adding an emissive map to a materialAdding an emissive map to a material
	     * @see https://developer.apple.com/reference/scenekit/scnmaterial/1462527-emission
	     */

	  }, {
	    key: 'emission',
	    get: function get() {
	      return this._emission;
	    }

	    /**
	     * An object that determines the opacity of each point in a material.
	     * @type {SCNMaterialProperty}
	     * @desc Use this property to selectively make parts of a material appear transparent. You can uniformly adjust the opacity of a material using its transparency property, or of all the content attached to a node using the node’s opacity property.By default, the transparent property’s contents object is a fully opaque black color, causing the property to have no visible effect. Setting the transparent property’s contents to any solid color uniformly fades the opacity of the material based on that color’s opacity value. To make parts of a material appear transparent, set the property’s contents to an image or other texture-mapped content whose alpha channel defines areas of full or partial opacity.Figure 1 shows a semitransparent material before and after providing a texture image for its transparent property. (To make the transparency effect more visible, a blue sphere is shown behind the transparent material.)Figure 1 Adding a transparent texture to a materialThe transparencyMode property controls how SceneKit interprets color information from the transparent property’s contents.Adding a transparent texture to a material
	     * @see https://developer.apple.com/reference/scenekit/scnmaterial/1462583-transparent
	     */

	  }, {
	    key: 'transparent',
	    get: function get() {
	      return this._transparent;
	    }

	    /**
	     * An object that provides color values that are multiplied with pixels in a material after all other shading is complete.
	     * @type {SCNMaterialProperty}
	     * @desc After combining a material’s other visual properties with lighting and other information about a scene, Scene kit multiplies the color of each rendered pixel by the color this property provides. You can use this property to darken or tint a surface independent of the effects of lighting and other properties, or to add precomputed lighting to a scene via a shadow map.By default, the multiply property’s contents object is a white color, causing the property to have no visible effect.Figure 1 shows a material (with textures for its diffuse and emission properties) before and after setting the multiply property’s contents to a solid color. Notice that the multiply color modulates even the bright areas added by the emissive map.Figure 1 Adding a multiply color to a materialAdding a multiply color to a material
	     * @see https://developer.apple.com/reference/scenekit/scnmaterial/1462575-multiply
	     */

	  }, {
	    key: 'multiply',
	    get: function get() {
	      return this._multiply;
	    }

	    /**
	     * An object that provides color values to be multiplied with the ambient light affecting the material.
	     * @type {SCNMaterialProperty}
	     * @desc Use this property to assign an ambient occlusion texture map to a surface. This property has no effect if there is no ambient light in the scene. If this property is not nil, SceneKit ignores the ambient property.When using physically-based shading (see physicallyBased), ambient occlusion approximates large-scale surface details that obscure global illumination.
	     * @see https://developer.apple.com/reference/scenekit/scnmaterial/1462579-ambientocclusion
	     */

	  }, {
	    key: 'ambientOcclusion',
	    get: function get() {
	      return this._ambientOcclusion;
	    }

	    /**
	     * An object that provides color values representing the global illumination of the surface.
	     * @type {SCNMaterialProperty}
	     * @desc Self-illumination applies to all materials, but is especially useful for those using physically-based shading (see physicallyBased). Physically-based materials work best with environment-based lighting (see the SCNScene property lightingEnvironment), but for some materials it can be useful to let a surface itself define part of its lighting—for example, an object whose position obscures it from the “sky” that provides the main lighting environment. When you assign contents to this property, they override the environmental lighting contribution to diffuse shading, but environmental lighting still contributes to specular effects.
	     * @see https://developer.apple.com/reference/scenekit/scnmaterial/1462524-selfillumination
	     */

	  }, {
	    key: 'selfIllumination',
	    get: function get() {
	      return this._selfIllumination;
	    }

	    /**
	     * An object that provides color values to determine how metallic the material’s surface appears.
	     * @type {SCNMaterialProperty}
	     * @desc This property measures only the total intensity of color values; texture contents are best defined in grayscale.This property generally approximates aspects of a physical surface—such as index of refraction, tendency to produce sharp reflections, and tendency to produce Fresnel reflections at grazing angles—that together produce an overall metallic or nonmetallic (also called dielectric) appearance. Lower values (darker colors) cause the material to appear more like a dielectric surface. Higher values (brighter colors) cause the surface to appear more metallic.This property applies only when the material’s lightingModel value is physicallyBased.
	     * @see https://developer.apple.com/reference/scenekit/scnmaterial/1640554-metalness
	     */

	  }, {
	    key: 'metalness',
	    get: function get() {
	      return this._metalness;
	    }

	    /**
	     * An object that provides color values to determine the apparent smoothness of the surface.
	     * @type {SCNMaterialProperty}
	     * @desc This property measures only the total intensity of color values; texture contents are best defined in grayscale.This property approximates the level of microscopic detail—for example tiny bumps and cracks—in a surface. By approximating these “microfacets” as a single term, this property helps produce lighting calculations that resemble the energy-conserving laws of real-world physics, resulting in more realistic variation between matte and shiny surfaces. Lower values (darker colors) cause the material to appear shiny, with well-defined specular highlights. Higher values (brighter colors) cause specular highlights to spread out and the diffuse color of the material to become more retroreflective.This property applies only when the material’s lightingModel value is physicallyBased.
	     * @see https://developer.apple.com/reference/scenekit/scnmaterial/1640555-roughness
	     */

	  }, {
	    key: 'roughness',
	    get: function get() {
	      return this._roughness;
	    }

	    // Structures

	    /**
	     * @type {Object} LightingModel
	     * @property {Symbol} blinn Shading that incorporates ambient, diffuse, and specular properties, where specular highlights are calculated using the Blinn-Phong  formula.
	     * @property {Symbol} constant Uniform shading that incorporates ambient lighting only.
	     * @property {Symbol} lambert Shading that incorporates ambient and diffuse properties only.
	     * @property {Symbol} phong Shading that incorporates ambient, diffuse, and specular properties, where specular highlights are calculated using the Phong  formula.
	     * @property {Symbol} physicallyBased Shading based on a realistic abstraction of physical lights and materials.
	     * @see https://developer.apple.com/reference/scenekit/scnmaterial.lightingmodel
	     */

	  }, {
	    key: 'animationKeys',
	    get: function get() {
	      return this._animationKeys;
	    }
	  }], [{
	    key: 'LightingModel',
	    get: function get() {
	      return _LightingModel;
	    }
	  }]);

	  return SCNMaterial;
	}(_NSObject3.default);

	exports.default = SCNMaterial;

/***/ },
/* 92 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * The modes SceneKit uses to calculate the opacity of pixels rendered with a material, used by the transparencyMode property.
	 * @typedef {Object} SCNTransparencyMode
	 * @property {Symbol} aOne - SceneKit derives transparency information from the alpha channel of colors. The value 1.0 is opaque.
	 * @property {Symbol} rgbZero - SceneKit derives transparency information from the luminance of colors. The value 0.0 is opaque.
	 * @see https://developer.apple.com/reference/scenekit/scntransparencymode
	 */

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var SCNTransparencyMode = {
	  aOne: Symbol(),
	  rgbZero: Symbol()
	};

	exports.default = SCNTransparencyMode;

/***/ },
/* 93 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * The modes SceneKit uses to determine which polygons to render in a surface, used by the cullMode property.
	 * @typedef {Object} SCNCullMode
	 * @property {Symbol} back - 
	 * @property {Symbol} front - 
	 * @see https://developer.apple.com/reference/scenekit/scncullmode
	 */

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var SCNCullMode = {
	  back: Symbol(),
	  front: Symbol()
	};

	exports.default = SCNCullMode;

/***/ },
/* 94 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * Modes that describe how SceneKit blends source colors rendered using a material with destination colors already in a rendering target, used by the blendMode property.
	 * @typedef {Object} SCNBlendMode
	 * @property {Symbol} alpha - Blend by multiplying source and destination color values by their corresponding alpha values.
	 * @property {Symbol} add - Blend by adding the source color to the destination color.
	 * @property {Symbol} subtract - Blend by subtracting the source color from the destination color.
	 * @property {Symbol} multiply - Blend by multiplying the source color with the background color.
	 * @property {Symbol} screen - Blend by multiplying the inverse of the source color with the inverse of the destination color.
	 * @property {Symbol} replace - Blend by replacing the destination color with the source color, ignoring alpha.
	 * @see https://developer.apple.com/reference/scenekit/scnblendmode
	 */

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var SCNBlendMode = {
	  alpha: Symbol(),
	  add: Symbol(),
	  subtract: Symbol(),
	  multiply: Symbol(),
	  screen: Symbol(),
	  replace: Symbol()
	};

	exports.default = SCNBlendMode;

/***/ },
/* 95 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

	var _NSObject2 = __webpack_require__(13);

	var _NSObject3 = _interopRequireDefault(_NSObject2);

	var _SCNAnimatable = __webpack_require__(35);

	var _SCNAnimatable2 = _interopRequireDefault(_SCNAnimatable);

	var _SCNGeometry = __webpack_require__(37);

	var _SCNGeometry2 = _interopRequireDefault(_SCNGeometry);

	var _SCNMorpherCalculationMode = __webpack_require__(96);

	var _SCNMorpherCalculationMode2 = _interopRequireDefault(_SCNMorpherCalculationMode);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var _weightsPattern = new RegExp(/^weights\[(\d+)\]$/);

	/**
	 * An object that manages smooth transitions between a node's base geometry and one or more target geometries.
	 * @access public
	 * @extends {NSObject}
	 * @implements {SCNAnimatable}
	 * @see https://developer.apple.com/reference/scenekit/scnmorpher
	 */

	var SCNMorpher = function (_NSObject) {
	  _inherits(SCNMorpher, _NSObject);

	  /**
	   * constructor
	   * @access public
	   * @constructor
	   */
	  function SCNMorpher() {
	    _classCallCheck(this, SCNMorpher);

	    // Specifying Morph Targets

	    /**
	     * The array of target geometries to morph between.
	     * @type {SCNGeometry[]}
	     * @see https://developer.apple.com/reference/scenekit/scnmorpher/1523572-targets
	     */
	    var _this = _possibleConstructorReturn(this, (SCNMorpher.__proto__ || Object.getPrototypeOf(SCNMorpher)).call(this));

	    _this.targets = [];

	    /**
	     * @type {number[]}
	     */
	    _this._weights = [];

	    // Changing Interpolation Mode

	    /**
	     * The interpolation formula for blending between target geometries.
	     * @type {SCNMorpherCalculationMode}
	     * @see https://developer.apple.com/reference/scenekit/scnmorpher/1523754-calculationmode
	     */
	    _this.calculationMode = _SCNMorpherCalculationMode2.default.normalized;
	    return _this;
	  }

	  // Blending between Morph Targets

	  /**
	   * Returns the weight value for the specified target index.
	   * @access public
	   * @param {number} targetIndex - The index of a geometry in the morpher’s targets array.
	   * @returns {number} - 
	   * @desc Target geometries and their weights determine the current form of the surface produced by the morpher. For example, if a morpher has one target whose weight is 0.5, the form of the resulting surface will be halfway between those of the base geometry and the target geometry.
	   * @see https://developer.apple.com/reference/scenekit/scnmorpher/1522940-weight
	   */


	  _createClass(SCNMorpher, [{
	    key: 'weightForTargetAt',
	    value: function weightForTargetAt(targetIndex) {
	      return this._weights[targetIndex];
	    }

	    /**
	     * Specifies a weight value at a specified target index.
	     * @access public
	     * @param {number} weight - A number specifying the contribution of the target geometry to the blended surface, generally between 0.0 and 1.0.
	     * @param {number} targetIndex - The index of a geometry in the morpher’s targets array.
	     * @returns {void}
	     * @desc Target geometries and their weights determine the current form of the surface produced by the morpher. For example, if a morpher has one target whose weight is 0.5, the form of the resulting surface will be halfway between those of the base geometry and the target geometry.You can also animate weights implicitly or explicitly using the keypath weights[index], where index corresponds to the targetIndex parameter of this method.
	     * @see https://developer.apple.com/reference/scenekit/scnmorpher/1522886-setweight
	     */

	  }, {
	    key: 'setWeightForTargetAt',
	    value: function setWeightForTargetAt(weight, targetIndex) {
	      this._weights[targetIndex] = weight;
	    }
	  }, {
	    key: 'setValueForKey',
	    value: function setValueForKey(value, key) {
	      //console.log(`SCNMorpher.setValueForKey: ${key}: ${value}`)
	      var weightsMatch = key.match(_weightsPattern);
	      if (weightsMatch !== null) {
	        if (weightsMatch.length > 1) {
	          var index = weightsMatch[1];
	          if (typeof this._weights[index] !== 'undefined') {
	            //console.log(`_weights[ ${index} ] = ${value}`)
	            this._weights[index] = value;
	          }
	        }
	        return;
	      }

	      _get(SCNMorpher.prototype.__proto__ || Object.getPrototypeOf(SCNMorpher.prototype), 'setValueForKey', this).call(this, value, key);
	    }

	    /*
	    setValueForKeyPath(value, keyPath) {
	      console.log(`SCNMorpher.setValueForKeyPath: ${keyPath}: ${value}`)
	      const paths = keyPath.split('.')
	      const key = paths.shift()
	      const restPath = paths.join('.')
	       const weightsMatch = key.match(_weightsPattern)
	      if(weightsMatch !== null){
	        if(weightsMatch.length > 1){
	          //const targetIndex = this.targets.findIndex((target) => target.name === restPath)
	          //if(targetIndex >= 0){
	          //  this._weights[targetIndex] = value
	          //}
	          const index = weightsMatch[1]
	          if(typeof this._weights[index] !== 'undefined'){
	            console.log(`_weights[ ${index} ] = ${value}`)
	            this._weights[index] = value
	          }
	        }
	      }else{
	        super.setValueForKeyPath(value, keyPath)
	      }
	    }
	    */

	    /**
	     * @access private
	     * @param {SCNNode} node -
	     */

	  }, {
	    key: '_morph',
	    value: function _morph(node) {
	      var _this2 = this;

	      //console.log(`SCNMorpher._morph ${node.name}`)
	      var p = node.presentation;
	      if (node.geometry === null || p === null || p.geometry === null) {
	        // data is not ready
	        return;
	      }
	      var pg = p.geometry;
	      var totalWeightForSemantic = new Map();

	      // reset presentation geometry
	      node.geometry.geometrySources.forEach(function (source) {
	        // FIXME: copy more than 1 source.
	        var pSource = pg.getGeometrySourcesForSemantic(source.semantic)[0];
	        pSource.fill(0);
	        //newData.set(source.semantic, Array(source._data.length).fill(0))
	        totalWeightForSemantic.set(source.semantic, 0.0);
	      });

	      // should I morph elements?
	      //node.geometry.geometryElements().forEach((element) => {
	      //})

	      var targetCount = this.targets.length;
	      //console.log(`targetCount: ${targetCount}`)

	      var _loop = function _loop(i) {
	        var target = _this2.targets[i];
	        var weight = _this2._weights[i];
	        if (weight === 0 || typeof weight === 'undefined') {
	          return 'continue';
	        }
	        //console.log(`morph ${target.name} weight ${weight}`)
	        target.geometrySources.forEach(function (source) {
	          var pSource = pg.getGeometrySourcesForSemantic(source.semantic)[0];
	          if (typeof pSource === 'undefined') {
	            return;
	          }
	          totalWeightForSemantic.set(source.semantic, totalWeightForSemantic.get(source.semantic) + weight);

	          // FIXME: don't access private properties
	          var srcIndex = source._dataOffset / source._bytesPerComponent;
	          var srcStride = source._dataStride / source._bytesPerComponent;
	          var dstIndex = pSource._dataOffset / pSource._bytesPerComponent;
	          var dstStride = pSource._dataStride / pSource._bytesPerComponent;
	          var componentCount = source._componentsPerVector;
	          var vectorCount = source._vectorCount;
	          for (var j = 0; j < vectorCount; j++) {
	            for (var k = 0; k < componentCount; k++) {
	              pSource._data[dstIndex + k] += source._data[srcIndex + k] * weight;
	            }
	            srcIndex += srcStride;
	            dstIndex += dstStride;
	          }
	        });
	      };

	      for (var i = 0; i < targetCount; i++) {
	        var _ret = _loop(i);

	        if (_ret === 'continue') continue;
	      }

	      //console.log(`node.geometry.geometrySources.length: ${node.geometry.geometrySources.length}`)
	      node.geometry.geometrySources.forEach(function (source) {
	        //console.log(`add baseGeometry`)
	        // FIXME: copy more than 1 source.
	        var pSource = pg.getGeometrySourcesForSemantic(source.semantic)[0];
	        var srcIndex = source._dataOffset / source._bytesPerComponent;
	        var srcStride = source._dataStride / source._bytesPerComponent;
	        var dstIndex = pSource._dataOffset / pSource._bytesPerComponent;
	        var dstStride = pSource._dataStride / pSource._bytesPerComponent;
	        var componentCount = source._componentsPerVector;
	        var vectorCount = source._vectorCount;

	        if (_this2.calculationMode === _SCNMorpherCalculationMode2.default.normalized) {
	          var _weight = 1.0 - totalWeightForSemantic.get(source.semantic);
	          // FIXME: don't access private properties
	          for (var i = 0; i < vectorCount; i++) {
	            for (var j = 0; j < componentCount; j++) {
	              pSource._data[dstIndex + j] += source._data[srcIndex + j] * _weight;
	            }
	            srcIndex += srcStride;
	            dstIndex += dstStride;
	          }
	        } else {
	          //console.log(`additive: vector: ${vectorCount}, component: ${componentCount}`)
	          // calculationMode: additive
	          // FIXME: don't access private properties
	          for (var _i = 0; _i < vectorCount; _i++) {
	            for (var _j = 0; _j < componentCount; _j++) {
	              pSource._data[dstIndex + _j] += source._data[srcIndex + _j];
	            }
	            srcIndex += srcStride;
	            dstIndex += dstStride;
	          }
	        }
	      });

	      // TODO: needs to update normal vector?

	      //console.log(`_morph done`)
	    }
	  }]);

	  return SCNMorpher;
	}(_NSObject3.default);

	exports.default = SCNMorpher;

/***/ },
/* 96 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * The interpolation formulas for blending between target geometries.
	 * @typedef {Object} SCNMorpherCalculationMode
	 * @property {Symbol} normalized - Target weights must be in the range between 0.0 and 1.0, and the contribution of the base geometry to the morphed surface is related to the sum of target weights. This is the default mode.
	 * @property {Symbol} additive - Target weights may take on any value, and weighted contributions for each target are added to the base geometry,
	 * @see https://developer.apple.com/reference/scenekit/scnmorphercalculationmode
	 */

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var SCNMorpherCalculationMode = {
	  normalized: Symbol(),
	  additive: Symbol()
	};

	exports.default = SCNMorpherCalculationMode;

/***/ },
/* 97 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _NSObject2 = __webpack_require__(13);

	var _NSObject3 = _interopRequireDefault(_NSObject2);

	var _SCNGeometry = __webpack_require__(37);

	var _SCNGeometry2 = _interopRequireDefault(_SCNGeometry);

	var _SCNNode = __webpack_require__(33);

	var _SCNNode2 = _interopRequireDefault(_SCNNode);

	var _SCNGeometrySource = __webpack_require__(83);

	var _SCNGeometrySource2 = _interopRequireDefault(_SCNGeometrySource);

	var _SCNMatrix = __webpack_require__(17);

	var _SCNMatrix2 = _interopRequireDefault(_SCNMatrix);

	var _SCNMatrix4MakeTranslation = __webpack_require__(45);

	var _SCNMatrix4MakeTranslation2 = _interopRequireDefault(_SCNMatrix4MakeTranslation);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * An object that manages the relationship between skeletal animations and the nodes and geometries they animate.
	 * @access public
	 * @extends {NSObject}
	 * @see https://developer.apple.com/reference/scenekit/scnskinner
	 */
	var SCNSkinner = function (_NSObject) {
	  _inherits(SCNSkinner, _NSObject);

	  // Creating a Skinner Object

	  /**
	   * Creates a skinner object with the specified visible geometry and skeleton information.
	   * @access public
	   * @constructor
	   * @param {?SCNGeometry} baseGeometry - The geometry whose surface the skinner’s animation skeleton deforms.
	   * @param {SCNNode[]} bones - An array of SCNNode objects, each representing a bone or control point for the animation skeleton.
	   * @param {?NSValue[]} boneInverseBindTransforms - An array of NSValue objects containing SCNMatrix4 transforms, each of which corresponds to a node in the bones array. Each value is the inverse matrix (see SCNMatrix4Invert(_:)) of that node’s transform property for the skeleton’s default pose.
	   * @param {SCNGeometrySource} boneWeights - The geometry source defining the influence of each bone on the positions of vertices in the geometry. For details, see the boneWeights property.
	   * @param {SCNGeometrySource} boneIndices - The geometry source defining the mapping from bone indices in skeleton data to the skinner’s bones array. For details, see the boneIndices property.
	   * @desc To use the skinner object in a scene, assign it to the skinner property of a node. That node’s geometry property should reference the same SCNGeometry object as the skinner’s baseGeometry property.
	   * @see https://developer.apple.com/reference/scenekit/scnskinner/1523964-init
	   */
	  function SCNSkinner(baseGeometry, bones, boneInverseBindTransforms, boneWeights, boneIndices) {
	    _classCallCheck(this, SCNSkinner);

	    // data length consistency check
	    var _this = _possibleConstructorReturn(this, (SCNSkinner.__proto__ || Object.getPrototypeOf(SCNSkinner)).call(this));

	    var boneLen = bones.length;
	    //const vectorLen = baseGeometry.getGeometrySourcesForSemantic(SCNGeometrySource.Semantic.vertex).vectorCount
	    if (boneInverseBindTransforms.length !== boneLen) {
	      throw new Error('SCNSkinner: bones.length (' + boneLen + ') !== boneInverseBindTransforms.length (' + boneInverseBindTransforms.length + ')');
	    }
	    //if(boneWeights.vectorCount !== vectorLen){
	    //  throw new Error(`SCNSkinner: vertices.length (${vectorLen}) !== boneWeights.vectorCount (${boneWeights.vectorCount})`)
	    //}
	    //if(boneIndices.vectorCount !== vectorLen){
	    //  throw new Error(`SCNSkinner: vertices.length (${vectorLen}) !== boneIndices.vectorCount (${boneIndices.vectorCount})`)
	    //}
	    if (boneWeights.componentsPerVector !== boneIndices.componentsPerVector) {
	      throw new Error('SCNSkinner: boneWeights.componentsPerVector (' + boneWeights.componentsPerVector + ') !== boneIndices.componentsPerVector (' + boneWeights.componentsPerVector + ')');
	    }

	    // Working with a Skinned Geometry

	    /**
	     * The geometry whose surface the skinner’s animation skeleton deforms.
	     * @type {?SCNGeometry}
	     * @see https://developer.apple.com/reference/scenekit/scnskinner/1522823-basegeometry
	     */
	    _this.baseGeometry = baseGeometry;

	    /**
	     * The coordinate transformation for the skinner’s geometry in its default state.
	     * @type {SCNMatrix4}
	     * @see https://developer.apple.com/reference/scenekit/scnskinner/1523160-basegeometrybindtransform
	     */
	    _this.baseGeometryBindTransform = (0, _SCNMatrix4MakeTranslation2.default)(0, 0, 0);

	    // Working with an Animation Skeleton

	    /**
	     * The root node of the skinner object’s animation skeleton.
	     * @type {?SCNNode}
	     * @see https://developer.apple.com/reference/scenekit/scnskinner/1523048-skeleton
	     */
	    _this.skeleton = null;

	    /**
	     * @access private
	     * @type {SCNNode[]}
	     */
	    _this._bones = bones;

	    /**
	     * @access private
	     * @type {SCNMatrix4[]}
	     */
	    _this._boneInverseBindTransforms = boneInverseBindTransforms;

	    /**
	     * @access private
	     * @type {SCNGeometrySource}
	     */
	    _this._boneWeights = boneWeights;

	    /**
	     * @access private
	     * @type {SCNGeometrySource}
	     */
	    _this._boneIndices = boneIndices;

	    // add geometrySources to baseGeometry
	    baseGeometry._geometrySources.push(boneWeights);
	    baseGeometry._geometrySources.push(boneIndices);
	    return _this;
	  }

	  // Working with an Animation Skeleton

	  /**
	   * The control nodes of the animation skeleton.
	   * @type {SCNNode[]}
	   * @desc An array of SCNNode objects, each of which represents a control point of the animation skeleton. Moving a node deforms the surface of the skinner’s geometry, based on the skeleton data from which the skinner object was created.
	   * @see https://developer.apple.com/reference/scenekit/scnskinner/1522732-bones
	   */


	  _createClass(SCNSkinner, [{
	    key: 'float32Array',


	    /**
	     * returns Float32Array of 3x4 matrices
	     * @access public
	     * @returns {Float32Array} -
	     */
	    value: function float32Array() {
	      var arr = [];
	      var len = this._bones.length;
	      for (var i = 0; i < len; i++) {
	        var bone = this._bones[i];
	        // TODO: implement appropriate matrix multiplication.
	        //       it doesn't consider the rotation of initial pose so far.
	        var mat = this._boneInverseBindTransforms[i].mult(bone._presentation._worldTransform);
	        //const mat = bone._presentation._worldTransform.mult(this._boneInverseBindTransforms[i])
	        //mat = bone.presentation.transform.mult(mat)
	        //if(bone._parent !== null){
	        //  mat = mat.mult(bone._parent.presentation._worldTransform)
	        //  //mat = bone._parent.presentation._worldTransform.mult(mat)
	        //}
	        //mat = bone.presentation.transform.mult(mat)
	        //mat = mat.mult(bone.presentation.transform)
	        arr.push.apply(arr, _toConsumableArray(mat.floatArray3x4f()));

	        if (i === 21) {
	          var p = bone._presentation;
	          //console.log(`skinner bone ${i} ${p.name} (${p.position.x}, ${p.position.y}, ${p.position.z}`)
	          //console.log(`mat ${mat.floatArray3x4f()}`)
	        }

	        /*
	        if(!mat.isIdentity()){
	          console.warn(`inverse: ${this._boneInverseBindTransforms[i].floatArray3x4f()}`)
	          console.warn(`presentation.worldTransform: ${bone.presentation._worldTransform.floatArray3x4f()}`)
	          console.warn(`parent.presentation.world: ${bone._parent.presentation._worldTransform.floatArray3x4f()}`)
	          console.warn(`presentation.transform: ${bone.presentation.transform.floatArray3x4f()}`)
	          console.warn(`worldTransform: ${bone._worldTransform.floatArray3x4f()}`)
	          console.warn(`transfrom: ${bone.transform.floatArray3x4f()}`)
	          console.warn(`presentation.position.y: ${bone.presentation.position.y}`)
	          console.warn(`position.y: ${bone.position.y}`)
	          console.warn(`mat: ${mat.floatArray3x4f()}`)
	          throw new Error(`mat ${i} ${bone.name} is not identity`)
	        }
	        */
	      }

	      // DEBUG
	      /*
	      console.log('boneInverseBindTransforms')
	      for(let i=0; i<4; i++){
	        const mat = this._boneInverseBindTransforms[i]
	        console.log(mat.floatArray3x4f())
	      }
	      console.log('bone._presentation._worldTransform')
	      for(let i=0; i<4; i++){
	        const mat = this._bones[i]._presentation._worldTransform
	        console.log(mat.floatArray3x4f())
	      }
	      */

	      return new Float32Array(arr);
	    }
	  }, {
	    key: 'bones',
	    get: function get() {
	      return this._bones.slice(0);
	    }

	    /**
	     * The default transforms for the animation skeleton’s bone nodes.
	     * @type {?SCNMatrix4[]}
	     * @desc An array of NSValue objects containing SCNMatrix4 transforms, each of which corresponds to a node in the bones array. Each value is the inverse matrix (see SCNMatrix4Invert(_:)) of that node’s transform property for the skeleton’s default pose.
	     * @see https://developer.apple.com/reference/scenekit/scnskinner/1523802-boneinversebindtransforms
	     */

	  }, {
	    key: 'boneInverseBindTransforms',
	    get: function get() {
	      return this._boneInverseBindTransforms.slice(0);
	    }

	    /**
	     * The geometry source that defines the influence of each bone on the positions the geometry’s vertices.
	     * @type {SCNGeometrySource}
	     l* @desc This geometry source’s semantic property must be boneWeights. Its data is an array of floating-point vectors, whose componentsPerVector count is the number of bones influencing each vertex. Each vector corresponds to a vertex in the geometry’s vertex geometry source, and each component in a vector specifies the influence of a bone on that vertex’s position. The boneIndices source determines which nodes in the bones array correspond to each component in the vector. A component value of 0.0 means that the bone has no influence on that vertex; positive or negative values scale the transformation of a bone node before SceneKit applies that transformation to the vertex.NoteSceneKit performs skeletal animation on the GPU only if the componentsPerVector count in this geometry source is 4 or less. Larger vectors result in CPU-based animation and drastically reduced rendering performance.
	     * @see https://developer.apple.com/reference/scenekit/scnskinner/1522986-boneweights
	     */

	  }, {
	    key: 'boneWeights',
	    get: function get() {
	      return this._boneWeights;
	    }

	    /**
	     * The geometry source defining the mapping from bone indices in skeleton data to the skinner’s bones array.
	     * @type {SCNGeometrySource}
	     * @desc This geometry source’s semantic property must be boneIndices. Its data is an array of integer vectors, each of which corresponds to a weight vector in the boneWeights geometry source. Each component in a vector specifies the index of the node in the bones array for the corresponding bone weight component.
	     * @see https://developer.apple.com/reference/scenekit/scnskinner/1524117-boneindices
	     */

	  }, {
	    key: 'boneIndices',
	    get: function get() {
	      return this._boneIndices;
	    }

	    /**
	     * @access public
	     * @returns {number} -
	     */

	  }, {
	    key: 'numSkinningJoints',
	    get: function get() {
	      return this._boneWeights.componentsPerVector;
	    }
	  }]);

	  return SCNSkinner;
	}(_NSObject3.default);

	exports.default = SCNSkinner;

/***/ },
/* 98 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _NSObject2 = __webpack_require__(13);

	var _NSObject3 = _interopRequireDefault(_NSObject2);

	var _SCNAnimatable = __webpack_require__(35);

	var _SCNAnimatable2 = _interopRequireDefault(_SCNAnimatable);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * The abstract superclass for objects that automatically adjust the position, rotation, or scale of a node based on rules you define.
	 * @access public
	 * @extends {NSObject}
	 * @implements {SCNAnimatable}
	 * @see https://developer.apple.com/reference/scenekit/scnconstraint
	 */
	var SCNConstraint = function (_NSObject) {
	  _inherits(SCNConstraint, _NSObject);

	  function SCNConstraint() {
	    _classCallCheck(this, SCNConstraint);

	    return _possibleConstructorReturn(this, (SCNConstraint.__proto__ || Object.getPrototypeOf(SCNConstraint)).apply(this, arguments));
	  }

	  _createClass(SCNConstraint, [{
	    key: 'init',


	    /**
	     * constructor
	     * @access public
	     * @returns {void}
	     */
	    value: function init() {

	      // Tuning a Constraint’s Effect on Nodes

	      /**
	       * The influence of the constraint on the node’s transformation.
	       * @type {number}
	       * @see https://developer.apple.com/reference/scenekit/scnconstraint/1468692-influencefactor
	       */
	      this.influenceFactor = 0;
	    }
	  }]);

	  return SCNConstraint;
	}(_NSObject3.default);

	exports.default = SCNConstraint;

/***/ },
/* 99 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * Values that inform SceneKit’s rendering for movement-related effects, used by the movabilityHint property.
	 * @typedef {Object} SCNMovabilityHint
	 * @property {Symbol} fixed - The node is not expected to move over time.
	 * @property {Symbol} movable - The node is expected to move over time.
	 * @see https://developer.apple.com/reference/scenekit/scnmovabilityhint
	 */

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var SCNMovabilityHint = {
	  fixed: Symbol(),
	  movable: Symbol()
	};

	exports.default = SCNMovabilityHint;

/***/ },
/* 100 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _SCNNode = __webpack_require__(33);

	var _SCNNode2 = _interopRequireDefault(_SCNNode);

	var _SCNRenderer = __webpack_require__(41);

	var _SCNRenderer2 = _interopRequireDefault(_SCNRenderer);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	/**
	 * Methods you can implement to use your own custom Metal or OpenGL drawing code to render content for a node. 
	 * @interface
	 * @see https://developer.apple.com/reference/scenekit/scnnoderendererdelegate
	 */
	var SCNNodeRendererDelegate = function () {
	  function SCNNodeRendererDelegate() {
	    _classCallCheck(this, SCNNodeRendererDelegate);
	  }

	  _createClass(SCNNodeRendererDelegate, [{
	    key: 'init',


	    /**
	     * constructor
	     * @access public
	     * @returns {void}
	     */
	    value: function init() {}

	    // Customizing the Rendering of a Node

	    /**
	     * Tells the delegate to perform rendering for a node.
	     * @access public
	     * @param {SCNNode} node - The node to render.
	     * @param {SCNRenderer} renderer - The SceneKit object (such as an SCNView instance) responsible for rendering the scene. 
	     * @param {Map<string, Object>} _arguments - 
	     * @returns {void}
	     * @desc Implement this method to perform custom rendering for a node. You should only execute Metal or OpenGL drawing commands (and any setup required to perform them) in this method—the results of modifying SceneKit objects in this method are undefined.To render using Metal, use the renderer parameter to retrieve the scene renderer’s currentRenderCommandEncoder object and encode your own drawing commands. If you need to reference other Metal state, see the properties listed in SCNSceneRenderer.To render using OpenGL, simply call the relevant OpenGL drawing commands—SceneKit automatically makes its OpenGL context the current context before calling this method. If you need to reference the OpenGL context being rendered into, examine the context property of the renderer parameter.You must draw using the appropriate graphics technology for the view currently being rendered. Use the renderingAPI property of the renderer object to determine whether Metal or OpenGL is in use. 
	     * @see https://developer.apple.com/reference/scenekit/scnnoderendererdelegate/1407993-rendernode
	     */

	  }, {
	    key: 'renderNode',
	    value: function renderNode(node, renderer, _arguments) {}
	  }]);

	  return SCNNodeRendererDelegate;
	}();

	exports.default = SCNNodeRendererDelegate;

/***/ },
/* 101 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _NSObject2 = __webpack_require__(13);

	var _NSObject3 = _interopRequireDefault(_NSObject2);

	var _SCNFieldForceEvaluator = __webpack_require__(102);

	var _SCNFieldForceEvaluator2 = _interopRequireDefault(_SCNFieldForceEvaluator);

	var _SCNVector = __webpack_require__(15);

	var _SCNVector2 = _interopRequireDefault(_SCNVector);

	var _SCNPhysicsFieldScope = __webpack_require__(103);

	var _SCNPhysicsFieldScope2 = _interopRequireDefault(_SCNPhysicsFieldScope);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * An object that applies forces, such as gravitation, electromagnetism, and turbulence, to physics bodies within a certain area of effect. 
	 * @access public
	 * @extends {NSObject}
	 * @see https://developer.apple.com/reference/scenekit/scnphysicsfield
	 */
	var SCNPhysicsField = function (_NSObject) {
	  _inherits(SCNPhysicsField, _NSObject);

	  function SCNPhysicsField() {
	    _classCallCheck(this, SCNPhysicsField);

	    return _possibleConstructorReturn(this, (SCNPhysicsField.__proto__ || Object.getPrototypeOf(SCNPhysicsField)).apply(this, arguments));
	  }

	  _createClass(SCNPhysicsField, [{
	    key: 'init',


	    /**
	     * constructor
	     * @access public
	     * @returns {void}
	     */
	    value: function init() {

	      // Specifying a Field’s Area of Effect

	      /**
	       * A location marking the end of the field’s area of effect.
	       * @type {SCNVector3}
	       * @see https://developer.apple.com/reference/scenekit/scnphysicsfield/1388138-halfextent
	       */
	      this.halfExtent = null;

	      /**
	       * The area affected by the field, either inside or outside its region.
	       * @type {SCNPhysicsFieldScope}
	       * @see https://developer.apple.com/reference/scenekit/scnphysicsfield/1388136-scope
	       */
	      this.scope = null;

	      /**
	       * A Boolean value that determines whether the field’s area of effect is shaped like a box or ellipsoid.
	       * @type {boolean}
	       * @see https://developer.apple.com/reference/scenekit/scnphysicsfield/1388158-usesellipsoidalextent
	       */
	      this.usesEllipsoidalExtent = false;

	      /**
	       * The offset of the field’s center within its area of effect.
	       * @type {SCNVector3}
	       * @see https://developer.apple.com/reference/scenekit/scnphysicsfield/1388154-offset
	       */
	      this.offset = null;

	      /**
	       * The field’s directional axis.
	       * @type {SCNVector3}
	       * @see https://developer.apple.com/reference/scenekit/scnphysicsfield/1388128-direction
	       */
	      this.direction = null;

	      // Specifying a Field’s Behavior

	      /**
	       * A multiplier for the force that the field applies to objects in its area of effect.
	       * @type {number}
	       * @see https://developer.apple.com/reference/scenekit/scnphysicsfield/1388132-strength
	       */
	      this.strength = 0;

	      /**
	       * An exponent that determines how the field’s strength diminishes with distance.
	       * @type {number}
	       * @see https://developer.apple.com/reference/scenekit/scnphysicsfield/1388146-falloffexponent
	       */
	      this.falloffExponent = 0;

	      /**
	       * The minimum value for distance-based effects.
	       * @type {number}
	       * @see https://developer.apple.com/reference/scenekit/scnphysicsfield/1388148-minimumdistance
	       */
	      this.minimumDistance = 0;

	      /**
	       * A Boolean value that determines whether the field’s effect is enabled.
	       * @type {boolean}
	       * @see https://developer.apple.com/reference/scenekit/scnphysicsfield/1388117-isactive
	       */
	      this.isActive = false;

	      /**
	       * A Boolean value that determines whether the field overrides other fields whose areas of effect it overlaps.
	       * @type {boolean}
	       * @see https://developer.apple.com/reference/scenekit/scnphysicsfield/1388126-isexclusive
	       */
	      this.isExclusive = false;

	      // Choosing Physics Bodies to Be Affected by the Field

	      /**
	       * A mask that defines which categories this physics field belongs to.
	       * @type {number}
	       * @see https://developer.apple.com/reference/scenekit/scnphysicsfield/1388119-categorybitmask
	       */
	      this.categoryBitMask = 0;
	    }

	    // Creating Physics Fields

	    /**
	     * Creates a field that slows any object in its area of effect with a force proportional to the object’s velocity.
	     * @access public
	     * @returns {SCNPhysicsField} - 
	     * @desc Like the damping and angularDamping properties of a physics body, drag fields can simulate effects such as fluid friction or air resistance. Unlike those properties, drag fields can simulate different intensities of fluid friction in different areas of your scene. For example, you can use a drag field to represent underwater areas.The default falloffExponent value for a drag field is 0.0, indicating that the field’s effect is constant throughout its area of effect.
	     * @see https://developer.apple.com/reference/scenekit/scnphysicsfield/1388164-drag
	     */

	  }], [{
	    key: 'drag',
	    value: function drag() {
	      return null;
	    }

	    /**
	     * Creates a field whose forces circulate around an axis.
	     * @access public
	     * @returns {SCNPhysicsField} - 
	     * @desc The force on an object in a vortex field is tangential to the line from the object’s position to the field’s axis and proportional to the object’s mass. (The field’s axis is a line that is parallel to its direction vector and that passes through its center. For details, see the offset property.) For example, when a vortex field’s area of effect contains many objects, the resulting scene resembles a tornado: The objects simultaneously revolve around and fly away from the field’s center.By default, a vortex circulates counterclockwise relative to its direction vector. To make it circulate clockwise, set the field’s strength property to a negative value.The default falloffExponent value for a vortex field is 0.0, indicating that the field’s effect is constant throughout its area of effect.
	     * @see https://developer.apple.com/reference/scenekit/scnphysicsfield/1388160-vortex
	     */

	  }, {
	    key: 'vortex',
	    value: function vortex() {
	      return null;
	    }

	    /**
	     * Creates a field that accelerates objects toward its center.
	     * @access public
	     * @returns {SCNPhysicsField} - 
	     * @desc Because the force of gravity on an object is proportional to the object’s mass, this force accelerates all objects at the same distance from the field’s center by the same amount. The field’s strength property measures this acceleration in meters per second per second.By default, a radial gravity field attracts objects toward its center. To make it repel objects instead, set the field’s strength property to a negative value.The default falloffExponent value for a radial gravity field is 2.0, indicating that the field’s effect diminishes with the square of distance from its center.
	     * @see https://developer.apple.com/reference/scenekit/scnphysicsfield/1388115-radialgravity
	     */

	  }, {
	    key: 'radialGravity',
	    value: function radialGravity() {
	      return null;
	    }

	    /**
	     * Creates a field that accelerates objects in a specific direction.
	     * @access public
	     * @returns {SCNPhysicsField} - 
	     * @desc Because the force of gravity on an object is proportional to the object’s mass, this force accelerates all objects in the field’s area of affect by the same amount. The field’s strength property measures this acceleration in meters per second per second.By default, a linear gravity field accelerates objects in along its direction vector. To make it accelerate objects in the opposite direction, set the field’s strength property to a negative value.The default falloffExponent value for a linear gravity field is 0.0, indicating that the field’s effect is constant throughout its area of effect.
	     * @see https://developer.apple.com/reference/scenekit/scnphysicsfield/1388130-lineargravity
	     */

	  }, {
	    key: 'linearGravity',
	    value: function linearGravity() {
	      return null;
	    }

	    /**
	     * Creates a field that applies random forces to objects in its area of effect.
	     * @access public
	     * @param {number} smoothness - The amount of randomness in the field. A value of 0.0 specifies maximum noise, and a value of 1.0 specifies no noise at all.
	     * @param {number} speed - The field’s variation over time. Specify 0.0 for a static field.
	     * @returns {SCNPhysicsField} - 
	     * @desc Use this field type to simulate effects involving random motion, such as fireflies or gently falling snow.In calculating the direction and strength of the field’s effect on an object, SceneKit uses a Perlin simplex noise function. This function produces a velocity field that varies over time.The default falloffExponent value for a noise field is 0.0, indicating that the field’s effect is constant throughout its area of effect. This field type ignores the field’s direction property.
	     * @see https://developer.apple.com/reference/scenekit/scnphysicsfield/1388150-noisefield
	     */

	  }, {
	    key: 'noiseFieldAnimationSpeed',
	    value: function noiseFieldAnimationSpeed(smoothness, speed) {
	      return null;
	    }

	    /**
	     * Creates a field that applies random forces to objects in its area of effect, with magnitudes proportional to those objects’ velocities.
	     * @access public
	     * @param {number} smoothness - The amount of randomness in the field. A value of 0.0 specifies maximum noise, and a value of 1.0 specifies no noise at all.
	     * @param {number} speed - The field’s variation over time. Specify 0.0 for a static field.
	     * @returns {SCNPhysicsField} - 
	     * @desc Like a noise field, a turbulence field applies forces in random directions to the objects that it affects. Unlike a noise field, a turbulence field applies a force whose magnitude is proportional to the speed of each affected object. For example, an object passing through a noise field shakes as it travels through the field, but an object passing through a turbulence field shakes more violently the faster it travels. The field’s strength property scales the magnitude of the turbulence effect.The default falloffExponent value for a turbulence field is 0.0, indicating that the field’s effect is constant throughout its area of effect.
	     * @see https://developer.apple.com/reference/scenekit/scnphysicsfield/1388162-turbulencefield
	     */

	  }, {
	    key: 'turbulenceFieldAnimationSpeed',
	    value: function turbulenceFieldAnimationSpeed(smoothness, speed) {
	      return null;
	    }

	    /**
	     * Creates a field that pulls objects toward its center with a spring-like force.
	     * @access public
	     * @returns {SCNPhysicsField} - 
	     * @desc The force a spring field applies to objects in its area of effect is linearly proportional to the distance from the object to the center of the field. (That is, the field behaves according to Hooke’s Law of real-world spring forces.) An object placed at the center of the field and moved away will oscillate around the center, with a period of oscillation that is proportional to the object’s mass. The field’s strength property scales the magnitude of the spring effect—a larger strength simulates a stiffer spring.The default falloffExponent value for a spring field is 1.0, indicating that the field’s effect diminishes linearly with distance from its center.
	     * @see https://developer.apple.com/reference/scenekit/scnphysicsfield/1388134-spring
	     */

	  }, {
	    key: 'spring',
	    value: function spring() {
	      return null;
	    }

	    /**
	     * Creates a field that attracts or repels objects based on their electrical charge and on their distance from the field’s center.
	     * @access public
	     * @returns {SCNPhysicsField} - 
	     * @desc Use this field type to make objects behave differently from one another when they enter a region, or to make an object's behavior different from its mass-based behavior. An electric field behaves according to the first part of the Lorentz force equation modeling real-world electromagnetic forces—the field applies a force whose magnitude is proportional to electric charge and distance.By default, physics bodies and particle systems have no electric charge, so they are unaffected by electric and magnetic fields. Use the charge property of a physics body or the particleCharge property of a particle system to add charge-based behavior.When the field’s strength value is positive (the default), it attracts bodies whose charge is negative and repels bodies whose charge is positive. To reverse this behavior, set the field’s strength property to a negative value.The default falloffExponent value for an electric field is 2.0, indicating that the field’s effect diminishes with the square of its distance from its center.
	     * @see https://developer.apple.com/reference/scenekit/scnphysicsfield/1388152-electric
	     */

	  }, {
	    key: 'electric',
	    value: function electric() {
	      return null;
	    }

	    /**
	     * Creates a field that attracts or repels objects based on their electrical charge, velocity, and distance from the field’s axis.
	     * @access public
	     * @returns {SCNPhysicsField} - 
	     * @desc Use this field type to make objects behave differently from one another when they enter a region, or to make an object's behavior different from its mass based behavior. A magnetic field behaves according to the second part of the Lorentz force equation modeling real-world electromagnetic forces—the field applies a force determined by the cross product of an object’s velocity vector and the magnetic field vector at the object’s location, with magnitude proportional to the object’s electric charge. By default, physics bodies and particle systems have no electric charge, so they are unaffected by electric and magnetic fields. Use the charge property of a physics body or the particleCharge property of a particle system to add charge-based behavior.When the field’s strength value is positive (the default), the magnetic field vectors circulate counterclockwise relative to the field’s direction vector. (That is, the magnetic field models a real-world magnetic field created by current in a wire oriented in the field’s direction.) To make field vectors circulate clockwise, set the field’s strength property to a negative value.NoteThis SCNPhysicsField option models the real-world physics effect of magnetic fields on moving, electrically charged bodies, not the behavior of permanent magnets or electromagnets. To make objects in your scene simply attract or repel one another, use a different field type. For example, a field created by the radialGravity() method attracts or repels all dynamic bodies near it according to its strength property, and a field created by the electric() method selectively attracts or repels bodies according to their electric charge.The default falloffExponent value for a magnetic field is 2.0, indicating that the field’s effect diminishes with the square of distance from its center.
	     * @see https://developer.apple.com/reference/scenekit/scnphysicsfield/1388168-magnetic
	     */

	  }, {
	    key: 'magnetic',
	    value: function magnetic() {
	      return null;
	    }

	    // Creating Custom Physics Fields

	    /**
	     * Creates a field that runs the specified block to determine the force a field applies to each object in its area of effect.
	     * @access public
	     * @param {SCNFieldForceEvaluator} block - A block that SceneKit runs for each object in the field’s area of effect. See SCNFieldForceEvaluator. 
	     * @returns {SCNPhysicsField} - 
	     * @desc For custom physics fields, SceneKit ignores the direction, strength, falloffExponent, and minimumDistance properties. Instead, SceneKit calls your block to determine the direction and magnitude of force to apply to each physics body or particle in the field’s area of effect.
	     * @see https://developer.apple.com/reference/scenekit/scnphysicsfield/1388140-customfield
	     */

	  }, {
	    key: 'customFieldEvaluationBlock',
	    value: function customFieldEvaluationBlock(block) {
	      return null;
	    }
	  }]);

	  return SCNPhysicsField;
	}(_NSObject3.default);

	exports.default = SCNPhysicsField;

/***/ },
/* 102 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _SCNVector = __webpack_require__(15);

	var _SCNVector2 = _interopRequireDefault(_SCNVector);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * The signature for a block that SceneKit calls to determine the effect of a custom field on an object.
	 * @type {function(position: SCNVector3, velocity: SCNVector3, mass: number, charge: number, time: number): SCNVector3}
	 * @param {SCNVector3} position - The position of the object affected by the field, in the local coordinate space of the node containing the field.
	 * @param {SCNVector3} velocity - The velocity of the object affected by the field, relative to the local coordinate space of the node containing the field.
	 * @param {number} mass - The mass of the object affected by the field. (See the mass property for physics bodies and the particleMass property for particle systems.) 
	 * @param {number} charge - The electrical charge of the object affected by the field. (See the charge property for physics bodies and the particleCharge property for particle systems.)
	 * @param {number} time - The elapsed time, in seconds, since the last simulation step.
	 * @returns {SCNVector3} -
	 * @desc Your block uses these parameters to compute and return an SCNVector3 force vector, which SceneKit then applies to the object affected by the field.
	 * @see https://developer.apple.com/reference/scenekit/scnfieldforceevaluator
	 */
	var SCNFieldForceEvaluator = function SCNFieldForceEvaluator(position, velocity, mass, charge, time) {};

	exports.default = SCNFieldForceEvaluator;

/***/ },
/* 103 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * Options for defining the region of space affected by a physics field, used by the scope property.
	 * @typedef {Object} SCNPhysicsFieldScope
	 * @property {Symbol} insideExtent - The field’s effect applies only to objects within the region of space defined by its position and extent.
	 * @property {Symbol} outsideExtent - The field’s effect applies only to objects outside the region of space defined by its position and extent.
	 * @see https://developer.apple.com/reference/scenekit/scnphysicsfieldscope
	 */

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var SCNPhysicsFieldScope = {
	  insideExtent: Symbol(),
	  outsideExtent: Symbol()
	};

	exports.default = SCNPhysicsFieldScope;

/***/ },
/* 104 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _NSObject2 = __webpack_require__(13);

	var _NSObject3 = _interopRequireDefault(_NSObject2);

	var _SCNAudioSource = __webpack_require__(32);

	var _SCNAudioSource2 = _interopRequireDefault(_SCNAudioSource);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * A controller for playback of a positional audio source in a SceneKit scene.
	 * @access public
	 * @extends {NSObject}
	 * @see https://developer.apple.com/reference/scenekit/scnaudioplayer
	 */
	var SCNAudioPlayer = function (_NSObject) {
	  _inherits(SCNAudioPlayer, _NSObject);

	  function SCNAudioPlayer() {
	    _classCallCheck(this, SCNAudioPlayer);

	    return _possibleConstructorReturn(this, (SCNAudioPlayer.__proto__ || Object.getPrototypeOf(SCNAudioPlayer)).apply(this, arguments));
	  }

	  _createClass(SCNAudioPlayer, [{
	    key: 'init',


	    // Creating an Audio Player

	    /**
	     * Initializes an audio player for playing the specified simple audio source.
	     * @access public
	     * @param {SCNAudioSource} source - An audio source object.
	     * @returns {void}
	     * @desc Using this initializer is typically not necessary. Instead, call the audioPlayerWithSource: method, which returns a cached audio player object if one for the specified audio source has already been created and is available for use.
	     * @see https://developer.apple.com/reference/scenekit/scnaudioplayer/1522736-init
	     */
	    value: function init(source) {

	      // Working with Audio Sources

	      this._audioSource = null;
	      this._audioNode = null;

	      // Responding to Playback

	      /**
	       * A block called by SceneKit when playback of the player’s audio source is about to begin.
	       * @type {?function(): void}
	       * @see https://developer.apple.com/reference/scenekit/scnaudioplayer/1524115-willstartplayback
	       */
	      this.willStartPlayback = null;

	      /**
	       * A block called by SceneKit when playback of the player’s audio source has completed.
	       * @type {?function(): void}
	       * @see https://developer.apple.com/reference/scenekit/scnaudioplayer/1522818-didfinishplayback
	       */
	      this.didFinishPlayback = null;
	    }

	    /**
	     * Initializes an audio player for playing the specified AVFoundation audio node.
	     * @access public
	     * @param {AVAudioNode} audioNode - An audio node object.
	     * @returns {void}
	     * @desc Using this initializer is typically not necessary. Instead, call the audioPlayerWithAVAudioNode: method, which returns a cached audio player object if one for the specified AVAudioNode object has already been created and is available for use.
	     * @see https://developer.apple.com/reference/scenekit/scnaudioplayer/1523010-init
	     */

	  }, {
	    key: 'initAvAudioNode',
	    value: function initAvAudioNode(audioNode) {

	      // Working with Audio Sources

	      this._audioSource = null;
	      this._audioNode = null;

	      // Responding to Playback

	      /**
	       * A block called by SceneKit when playback of the player’s audio source is about to begin.
	       * @type {?function(): void}
	       * @see https://developer.apple.com/reference/scenekit/scnaudioplayer/1524115-willstartplayback
	       */
	      this.willStartPlayback = null;

	      /**
	       * A block called by SceneKit when playback of the player’s audio source has completed.
	       * @type {?function(): void}
	       * @see https://developer.apple.com/reference/scenekit/scnaudioplayer/1522818-didfinishplayback
	       */
	      this.didFinishPlayback = null;
	    }

	    // Working with Audio Sources
	    /**
	     * The source of audio played by this player.
	     * @type {?SCNAudioSource}
	     * @desc An SCNAudioSource object represents a distinct source of audio—for example, a sound file—that can be reused and shared by many player objects. Use a player’s audio source to configure the default values for playback parameters such as volume and reverb. To vary those parameters in real time during playback, use the audioNode property to work with the underlying AVAudioNode object.If the player was created with the audioPlayerWithAVAudioNode: method, this property’s value is nil.
	     * @see https://developer.apple.com/reference/scenekit/scnaudioplayer/1523059-audiosource
	     */

	  }, {
	    key: 'audioSource',
	    get: function get() {
	      return this._audioSource;
	    }
	    /**
	     * The audio node SceneKit uses for mixing audio from this player.
	     * @type {?AVAudioNode}
	     * @desc SceneKit uses this AVAudioNode object to perform 3D positional mixing during playback. Use this object to vary parameters such as volume and reverb in real time during playback. To set default values for those parameters, use the audioSource property.
	     * @see https://developer.apple.com/reference/scenekit/scnaudioplayer/1522747-audionode
	     */

	  }, {
	    key: 'audioNode',
	    get: function get() {
	      return this._audioNode;
	    }
	  }]);

	  return SCNAudioPlayer;
	}(_NSObject3.default);

	exports.default = SCNAudioPlayer;

/***/ },
/* 105 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * Constants affecting the animation curve of an action, used by the timingMode property.
	 * @typedef {Object} SCNActionTimingMode
	 * @property {Symbol} linear - Linear pacing. The animation progresses evenly throughout its duration.
	 * @property {Symbol} easeIn - Ease-in pacing. The animation begins slowly, and then speeds up as it progresses.
	 * @property {Symbol} easeOut - Ease-out pacing. The animation begins quickly, and then slows as it completes.
	 * @property {Symbol} easeInEaseOut - Ease-in ease-out pacing. The animation begins slowly, accelerates through the middle of its duration, and then slows again before completing.
	 * @see https://developer.apple.com/reference/scenekit/scnactiontimingmode
	 */

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var SCNActionTimingMode = {
	  linear: Symbol(),
	  easeIn: Symbol(),
	  easeOut: Symbol(),
	  easeInEaseOut: Symbol()
	};

	exports.default = SCNActionTimingMode;

/***/ },
/* 106 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * The signature for a block that manages animation timing, used by the timingFunction property.
	 * @type {function(time: number): number}
	 * @param {number} time - A fraction of the action’s The input value for the timing function, as determined by the timingMode property and the action’s current progress.
	 * @returns {number} -
	 * @desc Your block must return a floating-point value between 0.0 and 1.0, where 0.0 represents the starting state of the action’s animation and 1.0 represents the end state.
	 * @see https://developer.apple.com/reference/scenekit/scnactiontimingfunction
	 */

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var SCNActionTimingFunction = function SCNActionTimingFunction(time) {};

	exports.default = SCNActionTimingFunction;

/***/ },
/* 107 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * Options for locking the orientation of nodes affected by a billboard constraint.
	 * @access public
	 * @see https://developer.apple.com/reference/scenekit/scnbillboardaxis
	 */

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var SCNBillboardAxis = function () {
	  function SCNBillboardAxis() {
	    _classCallCheck(this, SCNBillboardAxis);
	  }

	  _createClass(SCNBillboardAxis, [{
	    key: 'init',


	    // Initializers

	    /**
	     * 
	     * @access public
	     * @param {number} rawValue - 
	     * @returns {void}
	     * @see https://developer.apple.com/reference/scenekit/scnbillboardaxis/1524212-init
	     */
	    value: function init(rawValue) {

	      // Constants

	      this._X = null;
	      this._Y = null;
	      this._Z = null;
	      this._all = null;
	    }
	  }, {
	    key: 'X',


	    // Constants
	    /**
	     * Align an affected node such that its x-axis is always parallel to that of the view, leaving it free to rotate otherwise.
	     * @type {SCNBillboardAxis}
	     * @desc 
	     * @see https://developer.apple.com/reference/scenekit/scnbillboardaxis/1468664-x
	     */
	    get: function get() {
	      return this._X;
	    }
	    /**
	     * Align an affected node such that its y-axis is always parallel to that of the view, leaving it free to rotate otherwise.
	     * @type {SCNBillboardAxis}
	     * @desc 
	     * @see https://developer.apple.com/reference/scenekit/scnbillboardaxis/1468668-y
	     */

	  }, {
	    key: 'Y',
	    get: function get() {
	      return this._Y;
	    }
	    /**
	     * Align an affected node such that its z-axis is always perpendicular to the viewing plane, leaving it free to rotate otherwise.
	     * @type {SCNBillboardAxis}
	     * @desc 
	     * @see https://developer.apple.com/reference/scenekit/scnbillboardaxis/1468647-z
	     */

	  }, {
	    key: 'Z',
	    get: function get() {
	      return this._Z;
	    }
	    /**
	     * Align an affected node such that its orientation always matches that of the view.
	     * @type {SCNBillboardAxis}
	     * @desc This is the default option for newly created billboard constraints.
	     * @see https://developer.apple.com/reference/scenekit/scnbillboardaxis/1468666-all
	     */

	  }, {
	    key: 'all',
	    get: function get() {
	      return this._all;
	    }
	  }]);

	  return SCNBillboardAxis;
	}();

	exports.default = SCNBillboardAxis;

/***/ },
/* 108 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _SCNConstraint2 = __webpack_require__(98);

	var _SCNConstraint3 = _interopRequireDefault(_SCNConstraint2);

	var _SCNBillboardAxis = __webpack_require__(107);

	var _SCNBillboardAxis2 = _interopRequireDefault(_SCNBillboardAxis);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * A constraint that orients a node to always point toward the current camera.
	 * @access public
	 * @extends {SCNConstraint}
	 * @see https://developer.apple.com/reference/scenekit/scnbillboardconstraint
	 */
	var SCNBillboardConstraint = function (_SCNConstraint) {
	  _inherits(SCNBillboardConstraint, _SCNConstraint);

	  function SCNBillboardConstraint() {
	    _classCallCheck(this, SCNBillboardConstraint);

	    return _possibleConstructorReturn(this, (SCNBillboardConstraint.__proto__ || Object.getPrototypeOf(SCNBillboardConstraint)).apply(this, arguments));
	  }

	  _createClass(SCNBillboardConstraint, [{
	    key: 'init',


	    /**
	     * constructor
	     * @access public
	     * @returns {void}
	     */
	    value: function init() {

	      // Working with a Constraint’s Degrees of Freedom

	      /**
	       * An option that specifies which degrees of freedom the constraint affects.
	       * @type {SCNBillboardAxis}
	       * @see https://developer.apple.com/reference/scenekit/scnbillboardconstraint/1468685-freeaxes
	       */
	      this.freeAxes = null;
	    }
	  }]);

	  return SCNBillboardConstraint;
	}(_SCNConstraint3.default);

	exports.default = SCNBillboardConstraint;

/***/ },
/* 109 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _SCNGeometry2 = __webpack_require__(37);

	var _SCNGeometry3 = _interopRequireDefault(_SCNGeometry2);

	var _SCNGeometrySource = __webpack_require__(83);

	var _SCNGeometrySource2 = _interopRequireDefault(_SCNGeometrySource);

	var _SCNGeometryElement = __webpack_require__(88);

	var _SCNGeometryElement2 = _interopRequireDefault(_SCNGeometryElement);

	var _SCNGeometryPrimitiveType = __webpack_require__(89);

	var _SCNGeometryPrimitiveType2 = _interopRequireDefault(_SCNGeometryPrimitiveType);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * A six-sided polyhedron geometry whose faces are all rectangles, optionally with rounded edges and corners.
	 * @access public
	 * @extends {SCNGeometry}
	 * @see https://developer.apple.com/reference/scenekit/scnbox
	 */
	var SCNBox = function (_SCNGeometry) {
	  _inherits(SCNBox, _SCNGeometry);

	  /**
	   * Creates a box geometry with the specified width, height, length, and chamfer radius.
	   * @access public
	   * @constructor
	   * @param {number} [width = 1.0] - The width of the box along the x-axis of its local coordinate space.
	   * @param {number} [height = 1.0] - The height of the box along the y-axis of its local coordinate space.
	   * @param {number} [length = 1.0] - The length of the box along the z-axis of its local coordinate space.
	   * @param {number} [chamferRadius = 0.0] - The radius of curvature for the edges and corners of the box.
	   * @desc The box is centered in its local coordinate system. For example, if you create a box whose width, height and length are all 10.0, it extends from -5.0 to 5.0 along in each of the x-, y-, and z-axes.
	   * @see https://developer.apple.com/reference/scenekit/scnbox/1522620-init
	   */
	  function SCNBox() {
	    var width = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1.0;
	    var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1.0;
	    var length = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1.0;
	    var chamferRadius = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0.0;

	    _classCallCheck(this, SCNBox);

	    // Adjusting a Box’s Dimensions

	    /**
	     * The extent of the box along its x-axis. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnbox/1523898-width
	     */
	    var _this = _possibleConstructorReturn(this, (SCNBox.__proto__ || Object.getPrototypeOf(SCNBox)).call(this, [], []));

	    _this.width = width;

	    /**
	     * The extent of the box along its y-axis. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnbox/1522901-height
	     */
	    _this.height = height;

	    /**
	     * The extent of the box along its z-axis. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnbox/1523514-length
	     */
	    _this.length = length;

	    // Configuring Box Properties

	    /**
	     * The number of subdivisions in each face of the box along its x-axis. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnbox/1523559-widthsegmentcount
	     */
	    _this.widthSegmentCount = 1;

	    /**
	     * The number of subdivisions in each face of the box along its y-axis. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnbox/1522869-heightsegmentcount
	     */
	    _this.heightSegmentCount = 1;

	    /**
	     * The number of subdivisions in each face of the box along its z-axis. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnbox/1523721-lengthsegmentcount
	     */
	    _this.lengthSegmentCount = 1;

	    // Adding Rounded Edges and Corners

	    /**
	     * The radius of curvature for the edges and corners of the box. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnbox/1523302-chamferradius
	     */
	    _this.chamferRadius = chamferRadius;

	    /**
	     * The number of line segments used to create each rounded edge of the box. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnbox/1522976-chamfersegmentcount
	     */
	    _this.chamferSegmentCount = 10;

	    _this._createGeometry();
	    return _this;
	  }

	  _createClass(SCNBox, [{
	    key: '_createGeometry',
	    value: function _createGeometry() {
	      var sourceData = [];
	      var indexData = [];

	      var left = -this.width * 0.5;
	      var right = this.width * 0.5;
	      var top = this.height * 0.5;
	      var bottom = -this.height * 0.5;
	      var front = this.length * 0.5;
	      var back = -this.length * 0.5;

	      // front
	      /*
	      this._createFace(sourceData, indexData,
	        new SCNVector3(left, bottom, front),
	        new SCNVector3(left, top, front),
	        new SCNVector3(right, bottom, front),
	        new SCNVector3(right, top, front),
	        this.heightSegmentCount,
	        this.widthSegmentCount)
	       // right
	      this._createFace(sourceData, indexData,
	        new SCNVector3(right, bottom, front),
	        new SCNVector3(right, top, front),
	        new SCNVector3(right, bottom, back),
	        new SCNVector3(right, top, back),
	        this.heightSegmentCount,
	        this.lengthSegmentCount)
	       // back
	      this._createFace(sourceData, indexData,
	        new SCNVector3(right, bottom, back),
	        new SCNVector3(right, top, back),
	        new SCNVector3(left, bottom, back),
	        new SCNVector3(left, top, back),
	        this.heightSegmentCount,
	        this.widthSegmentCount)
	       // left
	      this._createFace(sourceData, indexData,
	        new SCNVector3(left, bottom, back),
	        new SCNVector3(left, top, back),
	        new SCNVector3(left, bottom, front),
	        new SCNVector3(left, top, front),
	        this.heightSegmentCount,
	        this.lengthSegmentCount)
	       // top
	      this._createFace(sourceData, indexData,
	        new SCNVector3(left, top, front),
	        new SCNVector3(left, top, back),
	        new SCNVector3(right, top, front),
	        new SCNVector3(right, top, back),
	        this.lengthSegmentCount,
	        this.widthSegmentCount)
	       // bottom
	      this._createFace(sourceData, indexData,
	        new SCNVector3(left, bottom, back),
	        new SCNVector3(left, bottom, front),
	        new SCNVector3(right, bottom, back),
	        new SCNVector3(right, bottom, front),
	        this.lengthSegmentCount,
	        this.widthSegmentCount)
	      */

	      // front
	      sourceData.push(left, bottom, front); // position
	      sourceData.push(0, 0, 1); // normal
	      sourceData.push(0, 1); // texcoord
	      //sourceData.push(0, -1, -1, -1) // boneIndices
	      //sourceData.push(1, 0, 0, 0) // boneWeights

	      sourceData.push(left, top, front);
	      sourceData.push(0, 0, 1);
	      sourceData.push(0, 0);
	      //sourceData.push(0, -1, -1, -1)
	      //sourceData.push(1, 0, 0, 0)

	      sourceData.push(right, bottom, front);
	      sourceData.push(0, 0, 1);
	      sourceData.push(1, 1);
	      //sourceData.push(0, -1, -1, -1)
	      //sourceData.push(1, 0, 0, 0)

	      sourceData.push(right, top, front);
	      sourceData.push(0, 0, 1);
	      sourceData.push(1, 0);
	      //sourceData.push(0, -1, -1, -1)
	      //sourceData.push(1, 0, 0, 0)

	      indexData.push(0, 3, 1);
	      indexData.push(0, 2, 3);

	      // right
	      sourceData.push(right, bottom, front);
	      sourceData.push(1, 0, 0);
	      sourceData.push(0, 1);
	      //sourceData.push(0, -1, -1, -1)
	      //sourceData.push(1, 0, 0, 0)

	      sourceData.push(right, top, front);
	      sourceData.push(1, 0, 0);
	      sourceData.push(0, 0);
	      //sourceData.push(0, -1, -1, -1)
	      //sourceData.push(1, 0, 0, 0)

	      sourceData.push(right, bottom, back);
	      sourceData.push(1, 0, 0);
	      sourceData.push(1, 1);
	      //sourceData.push(0, -1, -1, -1)
	      //sourceData.push(1, 0, 0, 0)

	      sourceData.push(right, top, back);
	      sourceData.push(1, 0, 0);
	      sourceData.push(1, 0);
	      //sourceData.push(0, -1, -1, -1)
	      //sourceData.push(1, 0, 0, 0)

	      indexData.push(4, 7, 5);
	      indexData.push(4, 6, 7);

	      // back
	      sourceData.push(right, bottom, back);
	      sourceData.push(0, 0, -1);
	      sourceData.push(0, 1);
	      //sourceData.push(0, -1, -1, -1)
	      //sourceData.push(1, 0, 0, 0)

	      sourceData.push(right, top, back);
	      sourceData.push(0, 0, -1);
	      sourceData.push(0, 0);
	      //sourceData.push(0, -1, -1, -1)
	      //sourceData.push(1, 0, 0, 0)

	      sourceData.push(left, bottom, back);
	      sourceData.push(0, 0, -1);
	      sourceData.push(1, 1);
	      //sourceData.push(0, -1, -1, -1)
	      //sourceData.push(1, 0, 0, 0)

	      sourceData.push(left, top, back);
	      sourceData.push(0, 0, -1);
	      sourceData.push(1, 0);
	      //sourceData.push(0, -1, -1, -1)
	      //sourceData.push(1, 0, 0, 0)

	      indexData.push(8, 11, 9);
	      indexData.push(8, 10, 11);

	      // left
	      sourceData.push(left, bottom, back);
	      sourceData.push(-1, 0, 0);
	      sourceData.push(0, 1);
	      //sourceData.push(0, -1, -1, -1)
	      //sourceData.push(1, 0, 0, 0)

	      sourceData.push(left, top, back);
	      sourceData.push(-1, 0, 0);
	      sourceData.push(0, 0);
	      //sourceData.push(0, -1, -1, -1)
	      //sourceData.push(1, 0, 0, 0)

	      sourceData.push(left, bottom, front);
	      sourceData.push(-1, 0, 0);
	      sourceData.push(1, 1);
	      //sourceData.push(0, -1, -1, -1)
	      //sourceData.push(1, 0, 0, 0)

	      sourceData.push(left, top, front);
	      sourceData.push(-1, 0, 0);
	      sourceData.push(1, 0);
	      //sourceData.push(0, -1, -1, -1)
	      //sourceData.push(1, 0, 0, 0)

	      indexData.push(12, 15, 13);
	      indexData.push(12, 14, 15);

	      // top
	      sourceData.push(left, top, front);
	      sourceData.push(0, 1, 0);
	      sourceData.push(0, 1);
	      //sourceData.push(0, -1, -1, -1)
	      //sourceData.push(1, 0, 0, 0)

	      sourceData.push(left, top, back);
	      sourceData.push(0, 1, 0);
	      sourceData.push(0, 0);
	      //sourceData.push(0, -1, -1, -1)
	      //sourceData.push(1, 0, 0, 0)

	      sourceData.push(right, top, front);
	      sourceData.push(0, 1, 0);
	      sourceData.push(1, 1);
	      //sourceData.push(0, -1, -1, -1)
	      //sourceData.push(1, 0, 0, 0)

	      sourceData.push(right, top, back);
	      sourceData.push(0, 1, 0);
	      sourceData.push(1, 0);
	      //sourceData.push(0, -1, -1, -1)
	      //sourceData.push(1, 0, 0, 0)

	      indexData.push(16, 19, 17);
	      indexData.push(16, 18, 19);

	      // bottom
	      sourceData.push(left, bottom, back);
	      sourceData.push(0, -1, 0);
	      sourceData.push(0, 1);
	      //sourceData.push(0, -1, -1, -1)
	      //sourceData.push(1, 0, 0, 0)

	      sourceData.push(left, bottom, front);
	      sourceData.push(0, -1, 0);
	      sourceData.push(0, 0);
	      //sourceData.push(0, -1, -1, -1)
	      //sourceData.push(1, 0, 0, 0)

	      sourceData.push(right, bottom, back);
	      sourceData.push(0, -1, 0);
	      sourceData.push(1, 1);
	      //sourceData.push(0, -1, -1, -1)
	      //sourceData.push(1, 0, 0, 0)

	      sourceData.push(right, bottom, front);
	      sourceData.push(0, -1, 0);
	      sourceData.push(1, 0);
	      //sourceData.push(0, -1, -1, -1)
	      //sourceData.push(1, 0, 0, 0)

	      indexData.push(20, 23, 21);
	      indexData.push(20, 22, 23);

	      var vertexSource = new _SCNGeometrySource2.default(sourceData, // data
	      _SCNGeometrySource2.default.Semantic.vertex, // semantic
	      24, // vectorCount
	      true, // floatComponents
	      3, // componentsPerVector
	      4, // bytesPerComponent
	      0, // offset
	      32 // sride
	      );

	      var normalSource = new _SCNGeometrySource2.default(sourceData, // data
	      _SCNGeometrySource2.default.Semantic.normal, // semantic
	      24, // vectorCount
	      true, // floatComponents
	      3, // componentsPerVector
	      4, // bytesPerComponent
	      12, // offset
	      32 // stride
	      );

	      var texcoordSource = new _SCNGeometrySource2.default(sourceData, // data
	      _SCNGeometrySource2.default.Semantic.texcoord, // semantic
	      24, // vectorCount
	      true, // floatComponents
	      2, // componentsPerVector
	      4, // bytesPerComponent
	      24, // offset
	      32 // stride
	      );

	      var element = new _SCNGeometryElement2.default(indexData, _SCNGeometryPrimitiveType2.default.triangles);

	      this._geometryElements = [element];
	      this._geometrySources = [vertexSource, normalSource, texcoordSource];
	    }

	    /**
	     * @access private
	     * @param {number[]} sourceData -
	     * @param {number[]} indexData -
	     * @param {SCNVector3} v1 - position 1
	     * @param {SCNVector3} v2 - position 2
	     * @param {SCNVector3} v3 - position 3
	     * @param {SCNVector3} v4 - position 4
	     * @param {number} s1 - segmentCount 1
	     * @param {number} s2 - segmentCount 2
	     * @returns {void}
	     */

	  }, {
	    key: '_createFace',
	    value: function _createFace(sourceData, indexData, v1, v2, v3, v4, s1, s2) {}
	  }]);

	  return SCNBox;
	}(_SCNGeometry3.default);

	exports.default = SCNBox;

/***/ },
/* 110 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _SCNGeometry2 = __webpack_require__(37);

	var _SCNGeometry3 = _interopRequireDefault(_SCNGeometry2);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * A right circular cylinder geometry whose ends are capped with hemispheres.
	 * @access public
	 * @extends {SCNGeometry}
	 * @see https://developer.apple.com/reference/scenekit/scncapsule
	 */
	var SCNCapsule = function (_SCNGeometry) {
	  _inherits(SCNCapsule, _SCNGeometry);

	  // Creating a Capsule

	  /**
	   * Creates a capsule geometry with the specified radius and height.
	   * @access public
	   * @constructor
	   * @param {number} capRadius - The radius both of the capsule’s cylindrical body and of its hemispherical ends.
	   * @param {number} height - The height of the capsule along the y-axis of its local coordinate space.
	   * @desc The capsule is centered in its local coordinate system. For example, if you create a capsule whose cap radius is 5.0 and height is 20.0, it extends from -10.0 to 10.0 in the y-axis, and the circular cross section at the center of its body extends from -5.0 to 5.0 along the x- and z-axes.
	   * @see https://developer.apple.com/reference/scenekit/scncapsule/1523790-init
	   */
	  function SCNCapsule(capRadius, height) {
	    _classCallCheck(this, SCNCapsule);

	    // Adjusting a Capsule’s Dimensions

	    /**
	     * The radius both of the capsule’s circular center cross section and of its hemispherical ends. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scncapsule/1523926-capradius
	     */
	    var _this = _possibleConstructorReturn(this, (SCNCapsule.__proto__ || Object.getPrototypeOf(SCNCapsule)).call(this));

	    _this.capRadius = capRadius;

	    /**
	     * The extent of the capsule along its y-axis. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scncapsule/1522789-height
	     */
	    _this.height = height;

	    // Adjusting Geometric Detail

	    /**
	     * The number of subdivisions around the lateral circumference of the capsule. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scncapsule/1522735-radialsegmentcount
	     */
	    _this.radialSegmentCount = 0;

	    /**
	     * The number of subdivisions in the height of each hemispherical end of the capsule. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scncapsule/1523561-capsegmentcount
	     */
	    _this.capSegmentCount = 0;

	    /**
	     * The number of subdivisions in the sides of the capsule along its y-axis. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scncapsule/1523697-heightsegmentcount
	     */
	    _this.heightSegmentCount = 0;
	    return _this;
	  }

	  return SCNCapsule;
	}(_SCNGeometry3.default);

	exports.default = SCNCapsule;

/***/ },
/* 111 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * Options for which edges of an extruded shape are chamfered, used by the chamferMode property.
	 * @typedef {Object} SCNChamferMode
	 * @property {Symbol} both - Apply a chamfer to both front and back edges of the extruded shape.
	 * @property {Symbol} front - Apply a chamfer to only the front edge of the extruded shape.
	 * @property {Symbol} back - Apply a chamfer to only the back edge of the extruded shape.
	 * @see https://developer.apple.com/reference/scenekit/scnchamfermode
	 */

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var SCNChamferMode = {
	  both: Symbol(),
	  front: Symbol(),
	  back: Symbol()
	};

	exports.default = SCNChamferMode;

/***/ },
/* 112 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _SCNGeometry2 = __webpack_require__(37);

	var _SCNGeometry3 = _interopRequireDefault(_SCNGeometry2);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * A right circular cone or frustum geometry.
	 * @access public
	 * @extends {SCNGeometry}
	 * @see https://developer.apple.com/reference/scenekit/scncone
	 */
	var SCNCone = function (_SCNGeometry) {
	  _inherits(SCNCone, _SCNGeometry);

	  function SCNCone() {
	    _classCallCheck(this, SCNCone);

	    return _possibleConstructorReturn(this, (SCNCone.__proto__ || Object.getPrototypeOf(SCNCone)).apply(this, arguments));
	  }

	  _createClass(SCNCone, [{
	    key: 'init',


	    /**
	     * constructor
	     * @access public
	     * @returns {void}
	     */
	    value: function init() {

	      // Adjusting a Cone’s Dimensions

	      /**
	       * The radius of the cone’s circular top. Animatable.
	       * @type {number}
	       * @see https://developer.apple.com/reference/scenekit/scncone/1524240-topradius
	       */
	      this.topRadius = 0;

	      /**
	       * The radius of the cone’s circular base. Animatable.
	       * @type {number}
	       * @see https://developer.apple.com/reference/scenekit/scncone/1523198-bottomradius
	       */
	      this.bottomRadius = 0;

	      /**
	       * The extent of the cylinder along its y-axis. Animatable.
	       * @type {number}
	       * @see https://developer.apple.com/reference/scenekit/scncone/1523219-height
	       */
	      this.height = 0;

	      // Adjusting Geometric Detail

	      /**
	       * The number of subdivisions around the circumference of the cone. Animatable.
	       * @type {number}
	       * @see https://developer.apple.com/reference/scenekit/scncone/1523942-radialsegmentcount
	       */
	      this.radialSegmentCount = 0;

	      /**
	       * The number of subdivisions in the sides of the cone along its y-axis. Animatable.
	       * @type {number}
	       * @see https://developer.apple.com/reference/scenekit/scncone/1524113-heightsegmentcount
	       */
	      this.heightSegmentCount = 0;
	    }

	    // Creating a Cone

	    /**
	     * Creates a cone geometry with the given top radius, bottom radius, and height.
	     * @access public
	     * @param {number} topRadius - The radius of the cone’s top, forming a circle in the x- and z-axis dimensions of its local coordinate space.
	     * @param {number} bottomRadius - The radius of the cone’s base, forming a circle in the x- and z-axis dimensions of its local coordinate space.
	     * @param {number} height - The height of the cone along the y-axis of its local coordinate space.
	     * @returns {void}
	     * @desc The cone is centered in its local coordinate system. For example, if you create a cone whose bottom radius is 5.0, top radius is 0.0, and height is 10.0, its apex is at the point {0, 5.0, 0}, and its base lies in the plane whose y-coordinate is -5.0, extending from -5.0 to 5.0 along both the x- and z-axes.Pass zero for topRadius or bottomRadius or parameter to create a cone whose sides taper to a single point, or a different value to create a frustum with a circular top.
	     * @see https://developer.apple.com/reference/scenekit/scncone/1522863-init
	     */

	  }, {
	    key: 'init',
	    value: function init(topRadius, bottomRadius, height) {}
	  }]);

	  return SCNCone;
	}(_SCNGeometry3.default);

	exports.default = SCNCone;

/***/ },
/* 113 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _SCNGeometry2 = __webpack_require__(37);

	var _SCNGeometry3 = _interopRequireDefault(_SCNGeometry2);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * A right circular cylinder geometry.
	 * @access public
	 * @extends {SCNGeometry}
	 * @see https://developer.apple.com/reference/scenekit/scncylinder
	 */
	var SCNCylinder = function (_SCNGeometry) {
	  _inherits(SCNCylinder, _SCNGeometry);

	  // Creating a Cylinder

	  /**
	   * Creates a cylinder geometry with the specified radius and height.
	   * @access public
	   * @constructor
	   * @param {number} radius - The radius of the cylinder’s circular cross section in the x- and z-axis dimensions of its local coordinate space.
	   * @param {number} height - The height of the cylinder along the y-axis of its local coordinate space.
	   * @desc The cylinder is centered in its local coordinate system. For example, if you create a cylinder whose radius is 5.0 and height is 10.0, its circular cross section extends from -5.0 to 5.0 along the x- and z-axes, and the y-coordinates of its base and top are -5.0 and 5.0, respectively.
	   * @see https://developer.apple.com/reference/scenekit/scncylinder/1523685-init
	   */
	  function SCNCylinder(radius, height) {
	    _classCallCheck(this, SCNCylinder);

	    // Adjusting a Cylinder’s Dimensions

	    /**
	     * The radius of the cylinder’s circular cross section. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scncylinder/1522674-radius
	     */
	    var _this = _possibleConstructorReturn(this, (SCNCylinder.__proto__ || Object.getPrototypeOf(SCNCylinder)).call(this));

	    _this.radius = radius;

	    /**
	     * The extent of the cylinder along its y-axis. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scncylinder/1523678-height
	     */
	    _this.height = height;

	    // Adjusting Geometric Detail

	    /**
	     * The number of subdivisions around the circumference of the cylinder. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scncylinder/1524002-radialsegmentcount
	     */
	    _this.radialSegmentCount = 0;

	    /**
	     * The number of subdivisions in the sides of the cylinder along its y-axis. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scncylinder/1523330-heightsegmentcount
	     */
	    _this.heightSegmentCount = 0;
	    return _this;
	  }

	  return SCNCylinder;
	}(_SCNGeometry3.default);

	exports.default = SCNCylinder;

/***/ },
/* 114 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _SCNGeometry2 = __webpack_require__(37);

	var _SCNGeometry3 = _interopRequireDefault(_SCNGeometry2);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * An infinite plane that can optionally display a reflection of the scene above it.
	 * @access public
	 * @extends {SCNGeometry}
	 * @see https://developer.apple.com/reference/scenekit/scnfloor
	 */
	var SCNFloor = function (_SCNGeometry) {
	  _inherits(SCNFloor, _SCNGeometry);

	  function SCNFloor() {
	    _classCallCheck(this, SCNFloor);

	    return _possibleConstructorReturn(this, (SCNFloor.__proto__ || Object.getPrototypeOf(SCNFloor)).apply(this, arguments));
	  }

	  _createClass(SCNFloor, [{
	    key: 'init',


	    /**
	     * constructor
	     * @access public
	     * @returns {void}
	     */
	    value: function init() {

	      // Adding Reflections to a Floor

	      /**
	       * The intensity of the scene’s reflection on the floor. Animatable.
	       * @type {number}
	       * @see https://developer.apple.com/reference/scenekit/scnfloor/1524175-reflectivity
	       */
	      this.reflectivity = 0;

	      /**
	       * The distance from the floor at which scene contents are no longer reflected. Animatable.
	       * @type {number}
	       * @see https://developer.apple.com/reference/scenekit/scnfloor/1522781-reflectionfalloffend
	       */
	      this.reflectionFalloffEnd = 0;

	      /**
	       * The distance from the floor at which scene contents are reflected at full intensity. Animatable.
	       * @type {number}
	       * @see https://developer.apple.com/reference/scenekit/scnfloor/1524237-reflectionfalloffstart
	       */
	      this.reflectionFalloffStart = 0;

	      /**
	       * The resolution scale factor of the offscreen buffer that SceneKit uses to render reflections.
	       * @type {number}
	       * @see https://developer.apple.com/reference/scenekit/scnfloor/1522809-reflectionresolutionscalefactor
	       */
	      this.reflectionResolutionScaleFactor = 0;

	      // Instance Properties

	      /**
	       * 
	       * @type {number}
	       * @see https://developer.apple.com/reference/scenekit/scnfloor/2091890-length
	       */
	      this.length = 0;

	      /**
	       * 
	       * @type {number}
	       * @see https://developer.apple.com/reference/scenekit/scnfloor/1845281-reflectioncategorybitmask
	       */
	      this.reflectionCategoryBitMask = 0;

	      /**
	       * 
	       * @type {number}
	       * @see https://developer.apple.com/reference/scenekit/scnfloor/1845280-width
	       */
	      this.width = 0;
	    }
	  }]);

	  return SCNFloor;
	}(_SCNGeometry3.default);

	exports.default = SCNFloor;

/***/ },
/* 115 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _SCNConstraint2 = __webpack_require__(98);

	var _SCNConstraint3 = _interopRequireDefault(_SCNConstraint2);

	var _SCNNode = __webpack_require__(33);

	var _SCNNode2 = _interopRequireDefault(_SCNNode);

	var _SCNVector = __webpack_require__(15);

	var _SCNVector2 = _interopRequireDefault(_SCNVector);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * A constraint that applies inverse kinematics to make a chain of nodes “reach” toward a target point.
	 * @access public
	 * @extends {SCNConstraint}
	 * @see https://developer.apple.com/reference/scenekit/scnikconstraint
	 */
	var SCNIKConstraint = function (_SCNConstraint) {
	  _inherits(SCNIKConstraint, _SCNConstraint);

	  function SCNIKConstraint() {
	    _classCallCheck(this, SCNIKConstraint);

	    return _possibleConstructorReturn(this, (SCNIKConstraint.__proto__ || Object.getPrototypeOf(SCNIKConstraint)).apply(this, arguments));
	  }

	  _createClass(SCNIKConstraint, [{
	    key: 'init',


	    // Creating an Inverse Kinematics Constraint

	    /**
	     * Initializes an inverse kinematics constraint whose chain of nodes begins with the specified node.
	     * @access public
	     * @param {SCNNode} chainRootNode - 
	     * @returns {void}
	     * @desc The root node is the highest node in the hierarchy moved by the constraint. For example, a robot arm may have two arm segments and a hand connected to a body. The upper arm is a child node of the body, the lower arm is a child node of the upper arm, and the hand is a child node of the lower arm. In this case, the upper arm is the chain root node, because the body should not move to follow the hand.The node you apply the constraint to (using that node’s constraints property) is the end effector of the chain—the lowest node in the hierarchy. When you set the constraint’s targetPosition property, SceneKit attempts to move this node toward the target point by rotating it relative to its parent node (and rotating its parent and ancestor nodes, up the chain ending with the chainRoot node). Continuing the above example, the end effector of the robot arm is its hand.
	     * @see https://developer.apple.com/reference/scenekit/scnikconstraint/1468694-init
	     */
	    value: function init(chainRootNode) {

	      // Adjusting the Constraint’s Limits of Motion

	      this._chainRootNode = null;

	      // Applying Inverse Kinematics to the Constrained Node

	      /**
	       * The desired position for the constrained node, in the scene’s world coordinate space. Animatable.
	       * @type {SCNVector3}
	       * @see https://developer.apple.com/reference/scenekit/scnikconstraint/1468651-targetposition
	       */
	      this.targetPosition = null;
	    }

	    /**
	     * Creates an inverse kinematics constraint whose chain of nodes begins with the specified node.
	     * @access public
	     * @param {SCNNode} chainRootNode - 
	     * @returns {SCNIKConstraint} - 
	     * @desc The root node is the highest node in the hierarchy moved by the constraint. For example, a robot arm may have two arm segments and a hand connected to a body. The upper arm is a child node of the body, the lower arm is a child node of the upper arm, and the hand is a child node of the lower arm. In this case, the upper arm is the chain root node, because the body should not move to follow the hand.The node you apply the constraint to (using that node’s constraints property) is the end effector of the chain—the lowest node in the hierarchy. When you set the constraint’s targetPosition property, SceneKit attempts to move this node toward the target point by rotating it relative to its parent node (and rotating its parent and ancestor nodes, up the chain ending with the chainRoot node). Continuing the above example, the end effector of the robot arm is its hand.
	     * @see https://developer.apple.com/reference/scenekit/scnikconstraint/1468653-inversekinematicsconstraint
	     */

	  }, {
	    key: 'maxAllowedRotationAngleForJoint',


	    // Adjusting the Constraint’s Limits of Motion

	    /**
	     * Returns the rotation limit, in degrees, for the specified node.
	     * @access public
	     * @param {SCNNode} node - A node affected by the constraint—either the node whose constraints property references the constraint or one of that node’s parent or ancestor nodes, up to the node specified by the constraint’s chainRootNode property.
	     * @returns {number} - 
	     * @desc When SceneKit evaluates the IK constraint, it checks the target orientations of each node in the chain relative to their initial orientations (as of when the constraint was applied to a node). For each node in the chain, SceneKit limits the rotation (in any direction) between the initial and target orientations to the value returned by this method.The default rotation limit for each joint is 180 degrees in either direction, allowing unconstrained rotation.
	     * @see https://developer.apple.com/reference/scenekit/scnikconstraint/1468681-maxallowedrotationangle
	     */
	    value: function maxAllowedRotationAngleForJoint(node) {
	      return 0;
	    }

	    /**
	     * Sets the rotation limit, in degrees, for the specified node.
	     * @access public
	     * @param {number} angle - The maximum rotation, in degrees, that SceneKit should apply to the specified node when evaluating the constraint.
	     * @param {SCNNode} node - A node affected by the constraint—either the node whose constraints property references the constraint, or one of that node’s parent or ancestor nodes up to the node specified by the constraint’s chainRootNode property.
	     * @returns {void}
	     * @desc When SceneKit evaluates the IK constraint, it checks the target orientations of each node in the chain relative to their initial orientations (as of when the constraint was applied to a node). For each node in the chain, SceneKit limits the rotation (in any direction) between the initial and target orientations to the angle value specified with this method.The default rotation limit for each joint is 180 degrees in either direction, allowing unconstrained rotation.
	     * @see https://developer.apple.com/reference/scenekit/scnikconstraint/1468649-setmaxallowedrotationangle
	     */

	  }, {
	    key: 'setMaxAllowedRotationAngleForJoint',
	    value: function setMaxAllowedRotationAngleForJoint(angle, node) {}
	    /**
	     * The parent node of the hierarchy affected by the constraint.
	     * @type {SCNNode}
	     * @desc The root node is the highest node in the hierarchy moved by the constraint. For example, a robot arm may have two arm segments and a hand connected to a body. The upper arm is a child node of the body, the lower arm is a child node of the upper arm, and the hand is a child node of the lower arm. In this case, the upper arm is the chain root node, because the body should not move to follow the hand.
	     * @see https://developer.apple.com/reference/scenekit/scnikconstraint/1468690-chainrootnode
	     */

	  }, {
	    key: 'chainRootNode',
	    get: function get() {
	      return this._chainRootNode;
	    }
	  }], [{
	    key: 'inverseKinematicsConstraint',
	    value: function inverseKinematicsConstraint(chainRootNode) {
	      return null;
	    }
	  }]);

	  return SCNIKConstraint;
	}(_SCNConstraint3.default);

	exports.default = SCNIKConstraint;

/***/ },
/* 116 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _SCNScene = __webpack_require__(43);

	var _SCNScene2 = _interopRequireDefault(_SCNScene);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	/**
	 * A Core Animation layer that renders a SceneKit scene as its content.
	 * @access public
	 * @see https://developer.apple.com/reference/scenekit/scnlayer
	 */
	var SCNLayer = function () {
	  function SCNLayer() {
	    _classCallCheck(this, SCNLayer);
	  }

	  _createClass(SCNLayer, [{
	    key: 'init',


	    /**
	     * constructor
	     * @access public
	     * @returns {void}
	     */
	    value: function init() {

	      // Specifying a Scene

	      /**
	       * The scene to be displayed in the layer.
	       * @type {?SCNScene}
	       * @see https://developer.apple.com/reference/scenekit/scnlayer/1393188-scene
	       */
	      this.scene = null;
	    }
	  }]);

	  return SCNLayer;
	}();

	exports.default = SCNLayer;

/***/ },
/* 117 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _SCNConstraint2 = __webpack_require__(98);

	var _SCNConstraint3 = _interopRequireDefault(_SCNConstraint2);

	var _SCNNode = __webpack_require__(33);

	var _SCNNode2 = _interopRequireDefault(_SCNNode);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * A constraint that orients a node to always point toward a specified other node. 
	 * @access public
	 * @extends {SCNConstraint}
	 * @see https://developer.apple.com/reference/scenekit/scnlookatconstraint
	 */
	var SCNLookAtConstraint = function (_SCNConstraint) {
	  _inherits(SCNLookAtConstraint, _SCNConstraint);

	  // Creating a Look-At Constraint

	  /**
	   * Creates a look-at constraint for a specified target node.
	   * @access public
	   * @construtor
	   * @param {?SCNNode} target - The node that constrained nodes will be reoriented to point toward.
	   * @desc To attach constraints to an SCNNode object, use its constraints property.
	   * @see https://developer.apple.com/reference/scenekit/scnlookatconstraint/1468683-init
	   */
	  function SCNLookAtConstraint(target) {
	    _classCallCheck(this, SCNLookAtConstraint);

	    // Modifying a Constraint

	    /**
	     * A Boolean value that specifies whether constrained nodes are allowed to rotate.
	     * @type {boolean}
	     * @see https://developer.apple.com/reference/scenekit/scnlookatconstraint/1468675-isgimballockenabled
	     */
	    var _this = _possibleConstructorReturn(this, (SCNLookAtConstraint.__proto__ || Object.getPrototypeOf(SCNLookAtConstraint)).call(this));

	    _this.isGimbalLockEnabled = false;

	    /**
	     * The node toward which constrained nodes will point after being reoriented.
	     * @type {?SCNNode}
	     * @see https://developer.apple.com/reference/scenekit/scnlookatconstraint/1468677-target
	     */
	    _this.target = null;
	    return _this;
	  }

	  return SCNLookAtConstraint;
	}(_SCNConstraint3.default);

	exports.default = SCNLookAtConstraint;

/***/ },
/* 118 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _SCNMatrix = __webpack_require__(17);

	var _SCNMatrix2 = _interopRequireDefault(_SCNMatrix);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Returns a Boolean value that indicates whether the corresponding elements of two matrices are equal.
	 * @access public
	 * @param {SCNMatrix4} a - 
	 * @param {SCNMatrix4} b - 
	 * @returns {boolean} - 
	 * @desc This function performs a numeric (not bitwise) comparison of each pair of elements.
	 * @see https://developer.apple.com/reference/scenekit/1409665-scnmatrix4equaltomatrix4
	 */
	var SCNMatrix4EqualToMatrix4 = function SCNMatrix4EqualToMatrix4(a, b) {
	  if (!(a instanceof _SCNMatrix2.default)) {
	    return false;
	  }
	  return a.equalTo(b);
	};

	exports.default = SCNMatrix4EqualToMatrix4;

/***/ },
/* 119 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _SCNMatrix = __webpack_require__(17);

	var _SCNMatrix2 = _interopRequireDefault(_SCNMatrix);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	//import GLKMatrix4 from '../undefined/GLKMatrix4'

	/**
	 * Returns a SceneKit matrix corresponding to a GLKit matrix.
	 * @access public
	 * @param {GLKMatrix4} mat - A GLKit matrix.
	 * @returns {SCNMatrix4} - 
	 * @see https://developer.apple.com/reference/scenekit/1409699-scnmatrix4fromglkmatrix4
	 */
	var SCNMatrix4FromGLKMatrix4 = function SCNMatrix4FromGLKMatrix4(mat) {
	  return null;
	};

	exports.default = SCNMatrix4FromGLKMatrix4;

/***/ },
/* 120 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _SCNMatrix = __webpack_require__(17);

	var _SCNMatrix2 = _interopRequireDefault(_SCNMatrix);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * 
	 * @access public
	 * @param {number[][]} m - 
	 * @returns {SCNMatrix4} - 
	 * @see https://developer.apple.com/reference/scenekit/1522632-scnmatrix4frommat4
	 */
	var SCNMatrix4FromMat4 = function SCNMatrix4FromMat4(m) {
	  return null;
	};

	exports.default = SCNMatrix4FromMat4;

/***/ },
/* 121 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _SCNMatrix = __webpack_require__(17);

	var _SCNMatrix2 = _interopRequireDefault(_SCNMatrix);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Returns the inverse of the specified matrix.
	 * @access public
	 * @param {SCNMatrix4} m - 
	 * @returns {SCNMatrix4} - 
	 * @see https://developer.apple.com/reference/scenekit/1409682-scnmatrix4invert
	 */
	var SCNMatrix4Invert = function SCNMatrix4Invert(m) {
	  return m.invert();
	};

	exports.default = SCNMatrix4Invert;

/***/ },
/* 122 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _SCNMatrix = __webpack_require__(17);

	var _SCNMatrix2 = _interopRequireDefault(_SCNMatrix);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	//import SCNMatrix4EqualToMatrix4 from './SCNMatrix4EqualToMatrix4'

	var _identity = new _SCNMatrix2.default();

	/**
	 * Returns a Boolean value that indicates whether the specified matrix is equal to the identity matrix.
	 * @access public
	 * @param {SCNMatrix4} m - 
	 * @returns {boolean} - 
	 * @see https://developer.apple.com/reference/scenekit/1409715-scnmatrix4isidentity
	 */
	var SCNMatrix4IsIdentity = function SCNMatrix4IsIdentity(m) {
	  return m.isIdentity();
	};

	exports.default = SCNMatrix4IsIdentity;

/***/ },
/* 123 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _SCNMatrix = __webpack_require__(17);

	var _SCNMatrix2 = _interopRequireDefault(_SCNMatrix);

	var _SCNVector = __webpack_require__(15);

	var _SCNVector2 = _interopRequireDefault(_SCNVector);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Returns a matrix describing a rotation transformation.
	 * @access public
	 * @param {number} angle - The amount of rotation, in radians, measured counterclockwise around the rotation axis.
	 * @param {number} x - The x-component of the rotation axis.
	 * @param {number} y - The y-component of the rotation axis.
	 * @param {number} z - The z-component of the rotation axis.
	 * @returns {SCNMatrix4} - 
	 * @see https://developer.apple.com/reference/scenekit/1409686-scnmatrix4makerotation
	 */
	var SCNMatrix4MakeRotation = function SCNMatrix4MakeRotation(angle, x, y, z) {
	  var c = Math.cos(angle);
	  var s = Math.sin(angle);
	  var v = new _SCNVector2.default(x, y, z);
	  var m = new _SCNMatrix2.default();

	  var nx = v.x;
	  var ny = v.y;
	  var nz = v.z;

	  m.m11 = nx * nx * (1.0 - c) + c;
	  m.m12 = nx * ny * (1.0 - c) - nz * s;
	  m.m13 = nx * nz * (1.0 - c) + ny * s;
	  m.m14 = 0.0;
	  m.m21 = ny * nx * (1.0 - c) + nz * s;
	  m.m22 = ny * ny * (1.0 - c) + c;
	  m.m23 = ny * nz * (1.0 - c) - nx * s;
	  m.m24 = 0.0;
	  m.m31 = nz * nx * (1.0 - c) - ny * s;
	  m.m32 = nz * ny * (1.0 - c) + nx * s;
	  m.m33 = nz * nz * (1.0 - c) + c;
	  m.m34 = 0.0;
	  m.m41 = 0.0;
	  m.m42 = 0.0;
	  m.m43 = 0.0;
	  m.m44 = 1.0;

	  return m;
	};

	exports.default = SCNMatrix4MakeRotation;

/***/ },
/* 124 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _SCNMatrix = __webpack_require__(17);

	var _SCNMatrix2 = _interopRequireDefault(_SCNMatrix);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Returns a matrix describing a scale transformation.
	 * @access public
	 * @param {number} sx - The scale factor in the x-axis direction.
	 * @param {number} sy - The scale factor in the y-axis direction.
	 * @param {number} sz - The scale factor in the z-axis direction.
	 * @returns {SCNMatrix4} - 
	 * @see https://developer.apple.com/reference/scenekit/1409681-scnmatrix4makescale
	 */
	var SCNMatrix4MakeScale = function SCNMatrix4MakeScale(sx, sy, sz) {
	  return null;
	};

	exports.default = SCNMatrix4MakeScale;

/***/ },
/* 125 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _SCNMatrix = __webpack_require__(17);

	var _SCNMatrix2 = _interopRequireDefault(_SCNMatrix);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Returns the product of two matrices.
	 * @access public
	 * @param {SCNMatrix4} a - 
	 * @param {SCNMatrix4} b - 
	 * @returns {SCNMatrix4} - 
	 * @desc Matrix multiplication is not commutative. As a transformation, the result of multiplying a matrix A by a matrix B is the transformation represented by B followed by the transformation represented by A.
	 * @see https://developer.apple.com/reference/scenekit/1409697-scnmatrix4mult
	 */
	var SCNMatrix4Mult = function SCNMatrix4Mult(a, b) {
	  return a.mult(b);
	};

	exports.default = SCNMatrix4Mult;

/***/ },
/* 126 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _SCNMatrix = __webpack_require__(17);

	var _SCNMatrix2 = _interopRequireDefault(_SCNMatrix);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Returns a new matrix created by concatenating the specified matrix with a rotation transformation.
	 * @access public
	 * @param {SCNMatrix4} m - 
	 * @param {number} angle - The amount of rotation, in radians, measured counterclockwise around the rotation axis.
	 * @param {number} x - The x-component of the rotation axis.
	 * @param {number} y - The y-component of the rotation axis.
	 * @param {number} z - The z-component of the rotation axis.
	 * @returns {SCNMatrix4} - 
	 * @desc The resulting transformation consists of the specified rotation followed by the transformation represented by the mat parameter.
	 * @see https://developer.apple.com/reference/scenekit/1409659-scnmatrix4rotate
	 */
	var SCNMatrix4Rotate = function SCNMatrix4Rotate(m, angle, x, y, z) {
	  return m.rotation(x, y, z, angle);
	};

	exports.default = SCNMatrix4Rotate;

/***/ },
/* 127 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _SCNMatrix = __webpack_require__(17);

	var _SCNMatrix2 = _interopRequireDefault(_SCNMatrix);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Returns a new matrix created by concatenating the specified matrix with a scale transformation.
	 * @access public
	 * @param {SCNMatrix4} m - 
	 * @param {number} sx - 
	 * @param {number} sy - 
	 * @param {number} sz - 
	 * @returns {SCNMatrix4} - 
	 * @desc The resulting transformation consists of the specified scale followed by the transformation represented by the mat parameter.
	 * @see https://developer.apple.com/reference/scenekit/1409653-scnmatrix4scale
	 */
	var SCNMatrix4Scale = function SCNMatrix4Scale(m, sx, sy, sz) {
	  return null;
	};

	exports.default = SCNMatrix4Scale;

/***/ },
/* 128 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	//import GLKMatrix4 from '../undefined/GLKMatrix4'

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _SCNMatrix = __webpack_require__(17);

	var _SCNMatrix2 = _interopRequireDefault(_SCNMatrix);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Returns a GLKit matrix corresponding to a SceneKit matrix.
	 * @access public
	 * @param {SCNMatrix4} mat - A SceneKit matrix.
	 * @returns {GLKMatrix4} - 
	 * @see https://developer.apple.com/reference/scenekit/1409703-scnmatrix4toglkmatrix4
	 */
	var SCNMatrix4ToGLKMatrix4 = function SCNMatrix4ToGLKMatrix4(mat) {
	  return null;
	};exports.default = SCNMatrix4ToGLKMatrix4;

/***/ },
/* 129 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _SCNMatrix = __webpack_require__(17);

	var _SCNMatrix2 = _interopRequireDefault(_SCNMatrix);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * @access public
	 * @type {function}
	 * @param {SCNMatrix4} m - 
	 * @returns {number[][]} - 
	 * @see https://developer.apple.com/reference/scenekit/1523928-scnmatrix4tomat4
	 */
	var SCNMatrix4ToMat4 = function SCNMatrix4ToMat4(m) {
	  return null;
	};

	exports.default = SCNMatrix4ToMat4;

/***/ },
/* 130 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _SCNMatrix = __webpack_require__(17);

	var _SCNMatrix2 = _interopRequireDefault(_SCNMatrix);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Returns a new matrix created by concatenating the specified matrix with a translation transformation.
	 * @access public
	 * @param {SCNMatrix4} m - 
	 * @param {number} tx - 
	 * @param {number} ty - 
	 * @param {number} tz - 
	 * @returns {SCNMatrix4} - 
	 * @desc The resulting transformation consists of the specified translation followed by the transformation represented by the mat parameter.
	 * @see https://developer.apple.com/reference/scenekit/1409717-scnmatrix4translate
	 */
	var SCNMatrix4Translate = function SCNMatrix4Translate(m, tx, ty, tz) {
	  return null;
	};

	exports.default = SCNMatrix4Translate;

/***/ },
/* 131 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _SCNPhysicsBehavior2 = __webpack_require__(52);

	var _SCNPhysicsBehavior3 = _interopRequireDefault(_SCNPhysicsBehavior2);

	var _SCNPhysicsBody = __webpack_require__(55);

	var _SCNPhysicsBody2 = _interopRequireDefault(_SCNPhysicsBody);

	var _SCNVector = __webpack_require__(15);

	var _SCNVector2 = _interopRequireDefault(_SCNVector);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * A physics behavior that connects two physics bodies and allows them to pivot around each other in any direction.
	 * @access public
	 * @extends {SCNPhysicsBehavior}
	 * @see https://developer.apple.com/reference/scenekit/scnphysicsballsocketjoint
	 */
	var SCNPhysicsBallSocketJoint = function (_SCNPhysicsBehavior) {
	  _inherits(SCNPhysicsBallSocketJoint, _SCNPhysicsBehavior);

	  // Creating a Ball and Socket Joint

	  /**
	   * Creates a ball and socket joint connecting two physics bodies.
	   * @access public
	   * @constructor
	   * @param {SCNPhysicsBody} bodyA - The first physics body to be connected by the joint.
	   * @param {SCNVector3} anchorA - The point at which the joint connects, relative to the node containing the first body.
	   * @param {SCNPhysicsBody} bodyB - The second physics body to be connected by the joint.
	   * @param {SCNVector3} anchorB - The point at which the joint connects, relative to the node containing the second body.
	   * @desc For a behavior to take effect, add it to the physics simulation by calling the addBehavior(_:) method on your scene’s SCNPhysicsWorld object. The physics bodies constrained by the joint must be attached to nodes in the scene.
	   * @see https://developer.apple.com/reference/scenekit/scnphysicsballsocketjoint/1387926-init
	   */
	  function SCNPhysicsBallSocketJoint(bodyA, anchorA, bodyB, anchorB) {
	    _classCallCheck(this, SCNPhysicsBallSocketJoint);

	    // Managing the Characteristics of a Ball and Socket Joint

	    /**
	     * The point at which the joint connects, relative to the node containing the first body.
	     * @type {SCNVector3}
	     * @see https://developer.apple.com/reference/scenekit/scnphysicsballsocketjoint/1387956-anchora
	     */
	    var _this = _possibleConstructorReturn(this, (SCNPhysicsBallSocketJoint.__proto__ || Object.getPrototypeOf(SCNPhysicsBallSocketJoint)).call(this));

	    _this.anchorA = null;

	    /**
	     * The point at which the joint connects, relative to the node containing the second body.
	     * @type {SCNVector3}
	     * @see https://developer.apple.com/reference/scenekit/scnphysicsballsocketjoint/1387965-anchorb
	     */
	    _this.anchorB = null;

	    _this._bodyA = null;
	    _this._bodyB = null;
	    return _this;
	  }

	  // Managing the Characteristics of a Ball and Socket Joint

	  /**
	   * The first physics body connected by the joint.
	   * @type {SCNPhysicsBody}
	   * @desc 
	   * @see https://developer.apple.com/reference/scenekit/scnphysicsballsocketjoint/1387981-bodya
	   */


	  _createClass(SCNPhysicsBallSocketJoint, [{
	    key: 'bodyA',
	    get: function get() {
	      return this._bodyA;
	    }

	    /**
	     * The second physics body connected by the joint.
	     * @type {?SCNPhysicsBody}
	     * @desc This property’s value is nil if the joint was created using the init(body:anchor:) method.
	     * @see https://developer.apple.com/reference/scenekit/scnphysicsballsocketjoint/1387902-bodyb
	     */

	  }, {
	    key: 'bodyB',
	    get: function get() {
	      return this._bodyB;
	    }
	  }]);

	  return SCNPhysicsBallSocketJoint;
	}(_SCNPhysicsBehavior3.default);

	exports.default = SCNPhysicsBallSocketJoint;

/***/ },
/* 132 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * Default values for a physics body’s categoryBitMask and collisionBitMask properties.
	 * @access public
	 * @see https://developer.apple.com/reference/scenekit/scnphysicscollisioncategory
	 */

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var SCNPhysicsCollisionCategory = function () {
	  function SCNPhysicsCollisionCategory() {
	    _classCallCheck(this, SCNPhysicsCollisionCategory);
	  }

	  _createClass(SCNPhysicsCollisionCategory, [{
	    key: 'init',


	    // Initializers

	    /**
	     * 
	     * @access public
	     * @param {number} rawValue - 
	     * @returns {void}
	     * @see https://developer.apple.com/reference/scenekit/scnphysicscollisioncategory/1523649-init
	     */
	    value: function init(rawValue) {

	      // Constants

	      this._default = null;
	      this._static = null;
	      this._all = null;
	    }
	  }, {
	    key: 'default',


	    // Constants
	    /**
	     * The default categoryBitMask value for dynamic and kinematic bodies.
	     * @type {SCNPhysicsCollisionCategory}
	     * @desc 
	     * @see https://developer.apple.com/reference/scenekit/scnphysicscollisioncategory/1514799-default
	     */
	    get: function get() {
	      return this._default;
	    }
	    /**
	     * The default categoryBitMask value for static bodies.
	     * @type {SCNPhysicsCollisionCategory}
	     * @desc 
	     * @see https://developer.apple.com/reference/scenekit/scnphysicscollisioncategory/1514778-static
	     */

	  }, {
	    key: 'static',
	    get: function get() {
	      return this._static;
	    }
	    /**
	     * This is the default value for a physics body’s collisionBitMask property.
	     * @type {SCNPhysicsCollisionCategory}
	     * @desc With this collision mask, a physics body can collide with all other physics bodies.
	     * @see https://developer.apple.com/reference/scenekit/scnphysicscollisioncategory/1514784-all
	     */

	  }, {
	    key: 'all',
	    get: function get() {
	      return this._all;
	    }
	  }]);

	  return SCNPhysicsCollisionCategory;
	}();

	exports.default = SCNPhysicsCollisionCategory;

/***/ },
/* 133 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _SCNPhysicsBehavior2 = __webpack_require__(52);

	var _SCNPhysicsBehavior3 = _interopRequireDefault(_SCNPhysicsBehavior2);

	var _SCNPhysicsBody = __webpack_require__(55);

	var _SCNPhysicsBody2 = _interopRequireDefault(_SCNPhysicsBody);

	var _SCNVector = __webpack_require__(15);

	var _SCNVector2 = _interopRequireDefault(_SCNVector);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * A physics behavior that connects two bodies and allows them to pivot around each other on a single axis.
	 * @access public
	 * @extends {SCNPhysicsBehavior}
	 * @see https://developer.apple.com/reference/scenekit/scnphysicshingejoint
	 */
	var SCNPhysicsHingeJoint = function (_SCNPhysicsBehavior) {
	  _inherits(SCNPhysicsHingeJoint, _SCNPhysicsBehavior);

	  // Creating a Hinge Joint

	  /**
	   * Creates a hinge joint connecting two physics bodies.
	   * @access public
	   * @constructor
	   * @param {SCNPhysicsBody} bodyA - The first physics body to be connected by the joint.
	   * @param {SCNVector3} axisA - The axis that the hinge pivots around, relative to the node containing the first body.
	   * @param {SCNVector3} anchorA - The point at which the hinge connects, relative to the node containing the first body.
	   * @param {SCNPhysicsBody} bodyB - The second physics body to be connected by the joint.
	   * @param {SCNVector3} axisB - The axis that the hinge pivots around, relative to the node containing the second body.
	   * @param {SCNVector3} anchorB - The point at which the hinge connects, relative to the node containing the second body.
	   * @desc For a behavior to take effect, add it to the physics simulation by calling the addBehavior(_:) method on your scene’s SCNPhysicsWorld object. The physics bodies constrained by the joint must be attached to nodes in the scene.
	   * @see https://developer.apple.com/reference/scenekit/scnphysicshingejoint/1387898-init
	   */
	  function SCNPhysicsHingeJoint(bodyA, axisA, anchorA, bodyB, axisB, anchorB) {
	    _classCallCheck(this, SCNPhysicsHingeJoint);

	    // Managing the Characteristics of a Hinge Joint

	    /**
	     * The axis that the hinge pivots around, relative to the node containing the first body.
	     * @type {SCNVector3}
	     * @see https://developer.apple.com/reference/scenekit/scnphysicshingejoint/1387888-axisa
	     */
	    var _this = _possibleConstructorReturn(this, (SCNPhysicsHingeJoint.__proto__ || Object.getPrototypeOf(SCNPhysicsHingeJoint)).call(this));

	    _this.axisA = null;

	    /**
	     * The point at which the hinge connects, relative to the node containing the first body.
	     * @type {SCNVector3}
	     * @see https://developer.apple.com/reference/scenekit/scnphysicshingejoint/1387936-anchora
	     */
	    _this.anchorA = null;

	    /**
	     * The axis that the hinge pivots around, relative to the node containing the second body.
	     * @type {SCNVector3}
	     * @see https://developer.apple.com/reference/scenekit/scnphysicshingejoint/1387914-axisb
	     */
	    _this.axisB = null;

	    /**
	     * The point at which the hinge connects, relative to the node containing the second body.
	     * @type {SCNVector3}
	     * @see https://developer.apple.com/reference/scenekit/scnphysicshingejoint/1387979-anchorb
	     */
	    _this.anchorB = null;

	    _this._bodyA = null;
	    _this._bodyB = null;
	    return _this;
	  }

	  // Managing the Characteristics of a Hinge Joint

	  /**
	   * The first physics body connected by the joint.
	   * @type {SCNPhysicsBody}
	   * @desc 
	   * @see https://developer.apple.com/reference/scenekit/scnphysicshingejoint/1387973-bodya
	   */


	  _createClass(SCNPhysicsHingeJoint, [{
	    key: 'bodyA',
	    get: function get() {
	      return this._bodyA;
	    }

	    /**
	     * The second physics body connected by the joint.
	     * @type {?SCNPhysicsBody}
	     * @desc This property’s value is nil if the joint was created using the init(body:axis:anchor:) method.
	     * @see https://developer.apple.com/reference/scenekit/scnphysicshingejoint/1387918-bodyb
	     */

	  }, {
	    key: 'bodyB',
	    get: function get() {
	      return this._bodyB;
	    }
	  }]);

	  return SCNPhysicsHingeJoint;
	}(_SCNPhysicsBehavior3.default);

	exports.default = SCNPhysicsHingeJoint;

/***/ },
/* 134 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _SCNPhysicsBehavior2 = __webpack_require__(52);

	var _SCNPhysicsBehavior3 = _interopRequireDefault(_SCNPhysicsBehavior2);

	var _SCNPhysicsBody = __webpack_require__(55);

	var _SCNPhysicsBody2 = _interopRequireDefault(_SCNPhysicsBody);

	var _SCNVector = __webpack_require__(15);

	var _SCNVector2 = _interopRequireDefault(_SCNVector);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * A physics behavior that connects two bodies and allows them to slide against each other and rotate around their connecting points.
	 * @access public
	 * @extends {SCNPhysicsBehavior}
	 * @see https://developer.apple.com/reference/scenekit/scnphysicssliderjoint
	 */
	var SCNPhysicsSliderJoint = function (_SCNPhysicsBehavior) {
	  _inherits(SCNPhysicsSliderJoint, _SCNPhysicsBehavior);

	  // Creating a Slider Joint

	  /**
	   * Creates a slider joint connecting two physics bodies.
	   * @access public
	   * @constructor
	   * @param {SCNPhysicsBody} bodyA - The first physics body to be connected by the joint.
	   * @param {SCNVector3} axisA - The axis along which the first body can slide, relative to the node containing it.
	   * @param {SCNVector3} anchorA - The point at which the joint connects, relative to the node containing the first body.
	   * @param {SCNPhysicsBody} bodyB - The second physics body to be connected by the joint.
	   * @param {SCNVector3} axisB - The axis along which the second body can slide, relative to the node containing it.
	   * @param {SCNVector3} anchorB - The point at which the joint connects, relative to the node containing the second body.
	   * @desc This method defines the location where the bodies are pinned together. To define their sliding or rotation motion relative to that point, use the properties listed in Limiting the Motion of a Slider Joint.For a behavior to take effect, add it to the physics simulation by calling the addBehavior(_:) method on your scene’s SCNPhysicsWorld object. The physics bodies constrained by the joint must be attached to nodes in the scene.
	   * @see https://developer.apple.com/reference/scenekit/scnphysicssliderjoint/1387922-init
	   */
	  function SCNPhysicsSliderJoint(bodyA, axisA, anchorA, bodyB, axisB, anchorB) {
	    _classCallCheck(this, SCNPhysicsSliderJoint);

	    // Managing the Characteristics of a Slider Joint

	    /**
	     * The axis along which the first body can slide, relative to the node containing it.
	     * @type {SCNVector3}
	     * @see https://developer.apple.com/reference/scenekit/scnphysicssliderjoint/1387900-axisa
	     */
	    var _this = _possibleConstructorReturn(this, (SCNPhysicsSliderJoint.__proto__ || Object.getPrototypeOf(SCNPhysicsSliderJoint)).call(this));

	    _this.axisA = null;

	    /**
	     * The point at which the joint connects, relative to the node containing the first body.
	     * @type {SCNVector3}
	     * @see https://developer.apple.com/reference/scenekit/scnphysicssliderjoint/1387958-anchora
	     */
	    _this.anchorA = null;

	    /**
	     * The axis along which the second body can slide, relative to the node containing it.
	     * @type {SCNVector3}
	     * @see https://developer.apple.com/reference/scenekit/scnphysicssliderjoint/1387948-axisb
	     */
	    _this.axisB = null;

	    /**
	     * The point at which the joint connects, relative to the node containing the second body.
	     * @type {SCNVector3}
	     * @see https://developer.apple.com/reference/scenekit/scnphysicssliderjoint/1387916-anchorb
	     */
	    _this.anchorB = null;

	    _this._bodyA = null;
	    _this._bodyB = null;

	    // Limiting the Motion of a Slider Joint

	    /**
	     * The minimum distance between the anchor points of the two bodies, relative to their initial positions.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnphysicssliderjoint/1387920-minimumlinearlimit
	     */
	    _this.minimumLinearLimit = 0;

	    /**
	     * The maximum distance between the anchor points of the two bodies, relative to their initial positions.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnphysicssliderjoint/1387890-maximumlinearlimit
	     */
	    _this.maximumLinearLimit = 0;

	    /**
	     * The minimum rotation angle between the two bodies, measured in radians relative to their initial orientations.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnphysicssliderjoint/1387967-minimumangularlimit
	     */
	    _this.minimumAngularLimit = 0;

	    /**
	     * The maximum rotation angle between the two bodies, measured in radians relative to their initial orientations.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnphysicssliderjoint/1387924-maximumangularlimit
	     */
	    _this.maximumAngularLimit = 0;

	    // Applying Forces and Torques

	    /**
	     * The velocity at which the joint’s connected bodies should slide.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnphysicssliderjoint/1387938-motortargetlinearvelocity
	     */
	    _this.motorTargetLinearVelocity = 0;

	    /**
	     * The maximum linear force that the joint can apply to its connected bodies, in newtons.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnphysicssliderjoint/1387954-motormaximumforce
	     */
	    _this.motorMaximumForce = 0;

	    /**
	     * The angular velocity at which the joint’s connected bodies should rotate around it.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnphysicssliderjoint/1387908-motortargetangularvelocity
	     */
	    _this.motorTargetAngularVelocity = 0;

	    /**
	     * The maximum torque that the joint can apply to its connected bodies, in newton-meters.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnphysicssliderjoint/1387961-motormaximumtorque
	     */
	    _this.motorMaximumTorque = 0;

	    return _this;
	  }

	  // Managing the Characteristics of a Slider Joint

	  /**
	   * The first physics body connected by the joint.
	   * @type {SCNPhysicsBody}
	   * @desc 
	   * @see https://developer.apple.com/reference/scenekit/scnphysicssliderjoint/1387987-bodya
	   */


	  _createClass(SCNPhysicsSliderJoint, [{
	    key: 'bodyA',
	    get: function get() {
	      return this._bodyA;
	    }

	    /**
	     * The second physics body connected by the joint.
	     * @type {?SCNPhysicsBody}
	     * @desc This property’s value is nil if the joint was created using the init(body:axis:anchor:) method.
	     * @see https://developer.apple.com/reference/scenekit/scnphysicssliderjoint/1387896-bodyb
	     */

	  }, {
	    key: 'bodyB',
	    get: function get() {
	      return this._bodyB;
	    }
	  }]);

	  return SCNPhysicsSliderJoint;
	}(_SCNPhysicsBehavior3.default);

	exports.default = SCNPhysicsSliderJoint;

/***/ },
/* 135 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _SCNPhysicsBehavior2 = __webpack_require__(52);

	var _SCNPhysicsBehavior3 = _interopRequireDefault(_SCNPhysicsBehavior2);

	var _SCNPhysicsBody = __webpack_require__(55);

	var _SCNPhysicsBody2 = _interopRequireDefault(_SCNPhysicsBody);

	var _SCNPhysicsVehicleWheel = __webpack_require__(136);

	var _SCNPhysicsVehicleWheel2 = _interopRequireDefault(_SCNPhysicsVehicleWheel);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * A physics behavior that modifies a physics body to behave like a car, motorcycle, or other wheeled vehicle.
	 * @access public
	 * @extends {SCNPhysicsBehavior}
	 * @see https://developer.apple.com/reference/scenekit/scnphysicsvehicle
	 */
	var SCNPhysicsVehicle = function (_SCNPhysicsBehavior) {
	  _inherits(SCNPhysicsVehicle, _SCNPhysicsBehavior);

	  // Creating a Vehicle

	  /**
	   * Creates a vehicle behavior.
	   * @access public
	   * @constructor
	   * @param {SCNPhysicsBody} chassisBody - A physics body to serve as the vehicle’s chassis.
	   * @param {SCNPhysicsVehicleWheel[]} wheels - An array of SCNPhysicsVehicleWheel objects representing the vehicle’s wheels. A vehicle must have at least one wheel.
	   * @desc Each object in the wheels array associates a node with the wheel to serve as its visual representation and defines properties for the wheel’s physical characteristics. Each wheel object must reference a unique node, which should be a child of the node containing the physics body used for the vehicle’s chassis. Typically, you load a node hierarchy representing the vehicle and all of its wheels from a scene file and then designate which nodes serve as the body and wheels.For a behavior to take effect, you must add it to the physics simulation by calling the addBehavior(_:) method on your scene’s SCNPhysicsWorld object.
	   * @see https://developer.apple.com/reference/scenekit/scnphysicsvehicle/1387943-init
	   */
	  function SCNPhysicsVehicle(chassisBody, wheels) {
	    _classCallCheck(this, SCNPhysicsVehicle);

	    // Working with a Vehicle’s Physical Characteristics

	    var _this = _possibleConstructorReturn(this, (SCNPhysicsVehicle.__proto__ || Object.getPrototypeOf(SCNPhysicsVehicle)).call(this));

	    _this._chassisBody = null;
	    _this._wheels = null;

	    // Driving a Vehicle

	    _this._speedInKilometersPerHour = 0;
	    return _this;
	  }

	  // Working with a Vehicle’s Physical Characteristics

	  /**
	   * The physics body representing the vehicle’s chassis.
	   * @type {SCNPhysicsBody}
	   * @desc The vehicle’s chassis must be a dynamic body.
	   * @see https://developer.apple.com/reference/scenekit/scnphysicsvehicle/1387985-chassisbody
	   */


	  _createClass(SCNPhysicsVehicle, [{
	    key: 'applyEngineForceForWheelAt',


	    // Driving a Vehicle

	    /**
	     * Applies a force between the specified wheel and the ground under the vehicle.
	     * @access public
	     * @param {number} value - The magnitude of the force, in newtons.
	     * @param {number} index - The index of the wheel applying the force.
	     * @returns {void}
	     * @desc Applying a positive force turns the wheel in a direction that would move the vehicle forward; applying a negative force moves the vehicle in reverse.As with all physical quantities in SceneKit, you need not use realistic force measurements in your app—the effects of the physics simulation depend on the relative differences between forces, not on their absolute values. You may use whatever values produce the behavior or gameplay you’re looking for as long as you use them consistently.Calling this method applies a force for one step (or frame) of the physics simulation. To continuously accelerate a vehicle, call this method again on subequent simulation steps (for example, from your scene renderer delegate’s renderer(_:updateAtTime:) method) until the vehicle reaches your desired speed.
	     * @see https://developer.apple.com/reference/scenekit/scnphysicsvehicle/1387963-applyengineforce
	     */
	    value: function applyEngineForceForWheelAt(value, index) {}

	    /**
	     * Applies a force between the specified wheel and the ground under the vehicle.
	     * @access public
	     * @param {number} value - The magnitude of the torque, in newton-meters.
	     * @param {number} index - The index of the wheel applying the force.
	     * @returns {void}
	     * @desc Applying a braking force causes the wheel to slow down regardless of the direction it’s currently spinning in.As with all physical quantities in SceneKit, you need not use realistic force measurements in your app—the effects of the physics simulation depend on the relative differences between forces, not on their absolute values. You may use whatever values produce the behavior or gameplay you’re looking for as long as you use them consistently.Calling this method applies a braking force for one step (or frame) of the physics simulation. To continuously decelerate a vehicle, call this method again on subequent simulation steps (for example, from your scene renderer delegate’s renderer(_:updateAtTime:) method) until the vehicle stops or reaches your desired speed.
	     * @see https://developer.apple.com/reference/scenekit/scnphysicsvehicle/1387894-applybrakingforce
	     */

	  }, {
	    key: 'applyBrakingForceForWheelAt',
	    value: function applyBrakingForceForWheelAt(value, index) {}

	    /**
	     * Pivots the specified wheel around its steering axis.
	     * @access public
	     * @param {number} value - The angle to set the wheel at relative to its steering axis, in radians.
	     * @param {number} index - The index, in the vehicle’s wheels array, of the wheel to be pivoted.
	     * @returns {void}
	     * @desc Steering angles are relative to the wheel’s steeringAxis vector. With the default steering axis of {0.0, -1.0, 0.0}, a steering angle of 0.0 represents neutral steering, positive values steer the vehicle to the right, and negative values steer to the left.
	     * @see https://developer.apple.com/reference/scenekit/scnphysicsvehicle/1387952-setsteeringangle
	     */

	  }, {
	    key: 'setSteeringAngleForWheelAt',
	    value: function setSteeringAngleForWheelAt(value, index) {}

	    /**
	     * The vehicle’s ground speed, in kilometers per hour.
	     * @type {number}
	     * @desc 
	     * @see https://developer.apple.com/reference/scenekit/scnphysicsvehicle/1387910-speedinkilometersperhour
	     */

	  }, {
	    key: 'chassisBody',
	    get: function get() {
	      return this._chassisBody;
	    }

	    /**
	     * An array of SCNPhysicsVehicleWheel objects representing the vehicle’s wheels.
	     * @type {SCNPhysicsVehicleWheel[]}
	     * @desc You can dynamically change the suspension and traction properties of a wheel connected to the vehicle by using the corresponding SCNPhysicsVehicleWheel object or by using Key-value coding with a keypath of the form wheels[index].propertyName. For example, the following code changes the size of the first wheel attached to the vehicle, simulating a failed tire:SCNPhysicsVehicle *vehicle = [SCNPhysicsVehicle vehicleWithChassisBody:car wheels:wheels];
	    [vehicle setValue:@0.1 forKeyPath:@"wheels[0].radius"];
	    SCNPhysicsVehicle *vehicle = [SCNPhysicsVehicle vehicleWithChassisBody:car wheels:wheels];
	    [vehicle setValue:@0.1 forKeyPath:@"wheels[0].radius"];
	      * @see https://developer.apple.com/reference/scenekit/scnphysicsvehicle/1387906-wheels
	     */

	  }, {
	    key: 'wheels',
	    get: function get() {
	      return this._wheels;
	    }
	  }, {
	    key: 'speedInKilometersPerHour',
	    get: function get() {
	      return this._speedInKilometersPerHour;
	    }
	  }]);

	  return SCNPhysicsVehicle;
	}(_SCNPhysicsBehavior3.default);

	exports.default = SCNPhysicsVehicle;

/***/ },
/* 136 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _NSObject2 = __webpack_require__(13);

	var _NSObject3 = _interopRequireDefault(_NSObject2);

	var _SCNNode = __webpack_require__(33);

	var _SCNNode2 = _interopRequireDefault(_SCNNode);

	var _SCNVector = __webpack_require__(15);

	var _SCNVector2 = _interopRequireDefault(_SCNVector);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * The appearance and physical characteristics of an individual wheel associated with an physics vehicle behavior.
	 * @access public
	 * @extends {NSObject}
	 * @see https://developer.apple.com/reference/scenekit/scnphysicsvehiclewheel
	 */
	var SCNPhysicsVehicleWheel = function (_NSObject) {
	  _inherits(SCNPhysicsVehicleWheel, _NSObject);

	  // Creating a Wheel

	  /**
	   * Creates a wheel object.
	   * @access public
	   * @constructor
	   * @param {SCNNode} node - The node whose contents provide the wheel’s visual representation.
	   * @desc The node representing a wheel must be a child of the node whose physics body serves as the chassis of the SCNPhysicsVehicle behavior the wheel is attached to. Each wheel object must reference a unique node. To use the wheel, add it to the vehicle behavior using the addWheel: method.SceneKit uses the node’s bounding box to determine the wheel’s initial size, and it uses the node’s position to determine the where the wheel connects to the vehicle’s chassis. You can change attributes using the radius and connectionPosition properties.
	   * @see https://developer.apple.com/reference/scenekit/scnphysicsvehiclewheel/1387989-init
	   */
	  function SCNPhysicsVehicleWheel(node) {
	    _classCallCheck(this, SCNPhysicsVehicleWheel);

	    // Managing a Wheel’s Connection to a Vehicle

	    /**
	     * The position of the wheel’s connection to the vehicle’s chassis.
	     * @type {SCNVector3}
	     * @see https://developer.apple.com/reference/scenekit/scnphysicsvehiclewheel/1387959-connectionposition
	     */
	    var _this = _possibleConstructorReturn(this, (SCNPhysicsVehicleWheel.__proto__ || Object.getPrototypeOf(SCNPhysicsVehicleWheel)).call(this));

	    _this.connectionPosition = null;

	    /**
	     * The direction of the axis that the wheel spins around to move the vehicle.
	     * @type {SCNVector3}
	     * @see https://developer.apple.com/reference/scenekit/scnphysicsvehiclewheel/1387969-axle
	     */
	    _this.axle = null;

	    /**
	     * The direction of the axis that the wheel pivots around to steer the vehicle.
	     * @type {SCNVector3}
	     * @see https://developer.apple.com/reference/scenekit/scnphysicsvehiclewheel/1387882-steeringaxis
	     */
	    _this.steeringAxis = null;

	    // Simulating Wheel Size

	    /**
	     * The radius of the wheel.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnphysicsvehiclewheel/1387991-radius
	     */
	    _this.radius = 0;

	    // Simulating Traction

	    /**
	     * The traction between the wheel and any surface in contact with it.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnphysicsvehiclewheel/1387904-frictionslip
	     */
	    _this.frictionSlip = 0;

	    // Simulating Suspension

	    /**
	     * The spring coefficient of the suspension between the vehicle and the wheel.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnphysicsvehiclewheel/1387983-suspensionstiffness
	     */
	    _this.suspensionStiffness = 0;

	    /**
	     * The coefficient that limits the speed of the suspension returning to its rest length when compressed.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnphysicsvehiclewheel/1387971-suspensioncompression
	     */
	    _this.suspensionCompression = 0;

	    /**
	     * The damping ratio that limits oscillation in the vehicle’s suspension.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnphysicsvehiclewheel/1387886-suspensiondamping
	     */
	    _this.suspensionDamping = 0;

	    /**
	     * The maximum distance that the wheel is allowed to move up or down relative to its connection point, in centimeters.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnphysicsvehiclewheel/1387928-maximumsuspensiontravel
	     */
	    _this.maximumSuspensionTravel = 0;

	    /**
	     * The maximum force of the suspension between the vehicle and the wheel, in newtons.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnphysicsvehiclewheel/1387934-maximumsuspensionforce
	     */
	    _this.maximumSuspensionForce = 0;

	    /**
	     * The resting length of the suspension, in meters.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnphysicsvehiclewheel/1387880-suspensionrestlength
	     */
	    _this.suspensionRestLength = 0;

	    // Inspecting the Wheel Node

	    _this._node = null;
	    return _this;
	  }

	  // Inspecting the Wheel Node

	  /**
	   * The node providing the wheel’s visual representation.
	   * @type {SCNNode}
	   * @desc SceneKit automatically rotates and repositions this node in response to the physics simulation.
	   * @see https://developer.apple.com/reference/scenekit/scnphysicsvehiclewheel/1387892-node
	   */


	  _createClass(SCNPhysicsVehicleWheel, [{
	    key: 'node',
	    get: function get() {
	      return this._node;
	    }
	  }]);

	  return SCNPhysicsVehicleWheel;
	}(_NSObject3.default);

	exports.default = SCNPhysicsVehicleWheel;

/***/ },
/* 137 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _SCNGeometry2 = __webpack_require__(37);

	var _SCNGeometry3 = _interopRequireDefault(_SCNGeometry2);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * A rectangular, one-sided plane geometry of specified width and height.
	 * @access public
	 * @extends {SCNGeometry}
	 * @see https://developer.apple.com/reference/scenekit/scnplane
	 */
	var SCNPlane = function (_SCNGeometry) {
	  _inherits(SCNPlane, _SCNGeometry);

	  // Creating a Plane

	  /**
	   * Creates a plane geometry with the specified width and height.
	   * @access public
	   * @constructor
	   * @param {number} width - The width of the plane along the x-axis of its local coordinate space.
	   * @param {number} height - The height of the plane along the y-axis of its local coordinate space.
	   * @desc The plane is centered in its local coordinate system. For example, if you create a plane whose width and height are both 10.0, it extends from -5.0 to 5.0 along both the x- and y-axes, and the z-coordinate of all points in the plane is zero.
	   * @see https://developer.apple.com/reference/scenekit/scnplane/1523631-init
	   */
	  function SCNPlane(width, height) {
	    _classCallCheck(this, SCNPlane);

	    // Adjusting a Plane’s Dimensions

	    /**
	     * The extent of the plane along its horizontal axis. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnplane/1523782-width
	     */
	    var _this = _possibleConstructorReturn(this, (SCNPlane.__proto__ || Object.getPrototypeOf(SCNPlane)).call(this));

	    _this.width = 0;

	    /**
	     * The extent of the plane along its vertical axis. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnplane/1522837-height
	     */
	    _this.height = 0;

	    // Adjusting Geometric Detail

	    /**
	     * The number of subdivisions in the plane’s surface along its horizontal axis. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnplane/1523991-widthsegmentcount
	     */
	    _this.widthSegmentCount = 0;

	    /**
	     * The number of subdivisions in the plane’s surface along its vertical axis. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnplane/1522889-heightsegmentcount
	     */
	    _this.heightSegmentCount = 0;

	    // Adding Rounded Corners

	    /**
	     * The radius of curvature for the plane’s corners. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnplane/1523005-cornerradius
	     */
	    _this.cornerRadius = 0;

	    /**
	     * The number of line segments used to create each rounded corner of the plane. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnplane/1524234-cornersegmentcount
	     */
	    _this.cornerSegmentCount = 0;

	    return _this;
	  }

	  return SCNPlane;
	}(_SCNGeometry3.default);

	exports.default = SCNPlane;

/***/ },
/* 138 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _SCNGeometry2 = __webpack_require__(37);

	var _SCNGeometry3 = _interopRequireDefault(_SCNGeometry2);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * A right rectangular pyramid geometry.
	 * @access public
	 * @extends {SCNGeometry}
	 * @see https://developer.apple.com/reference/scenekit/scnpyramid
	 */
	var SCNPyramid = function (_SCNGeometry) {
	  _inherits(SCNPyramid, _SCNGeometry);

	  // Creating a Pyramid

	  /**
	   * Creates a pyramid geometry with the specified width, height, and length.
	   * @access public
	   * @constructor
	   * @param {number} width - The width of the pyramid along the x-axis of its local coordinate space.
	   * @param {number} height - The height of the pyramid along the y-axis of its local coordinate space.
	   * @param {number} length - The length of the pyramid along the z-axis of its local coordinate space.
	   * @desc The pyramid’s base is centered in its local coordinate system. For example, if you create a pyramid whose width, height and length are all 10.0, its apex is at the point {0, 10.0, 0}, and its base lies in the plane whose y-coordinate is 0.0, extending from -5.0 to 5.0 along both the x- and z-axes.
	   * @see https://developer.apple.com/reference/scenekit/scnpyramid/1523254-init
	   */
	  function SCNPyramid(width, height, length) {
	    _classCallCheck(this, SCNPyramid);

	    // Adjusting a Pyramid’s Dimensions

	    /**
	     * The extent of the pyramid along its x-axis. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnpyramid/1522613-width
	     */
	    var _this = _possibleConstructorReturn(this, (SCNPyramid.__proto__ || Object.getPrototypeOf(SCNPyramid)).call(this));

	    _this.width = 0;

	    /**
	     * The extent of the pyramid along its y-axis. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnpyramid/1522805-height
	     */
	    _this.height = 0;

	    /**
	     * The extent of the pyramid along its z-axis. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnpyramid/1524203-length
	     */
	    _this.length = 0;

	    // Adjusting Geometric Detail

	    /**
	     * The number of subdivisions in each face of the pyramid along its x-axis. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnpyramid/1523083-widthsegmentcount
	     */
	    _this.widthSegmentCount = 0;

	    /**
	     * The number of subdivisions in each face of the pyramid along its y-axis. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnpyramid/1524059-heightsegmentcount
	     */
	    _this.heightSegmentCount = 0;

	    /**
	     * The number of subdivisions in each face of the pyramid along its z-axis. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnpyramid/1524227-lengthsegmentcount
	     */
	    _this.lengthSegmentCount = 0;

	    return _this;
	  }

	  return SCNPyramid;
	}(_SCNGeometry3.default);

	exports.default = SCNPyramid;

/***/ },
/* 139 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * Options for when to load the reference node’s content, used by the loadingPolicy property.
	 * @typedef {Object} SCNReferenceLoadingPolicy
	 * @property {Symbol} immediate - Load the node’s external content immediately when the reference node is unarchived.
	 * @property {Symbol} onDemand - Load the node’s external comment only when the load() method is called.
	 * @see https://developer.apple.com/reference/scenekit/scnreferenceloadingpolicy
	 */

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var SCNReferenceLoadingPolicy = {
	  immediate: Symbol(),
	  onDemand: Symbol()
	};

	exports.default = SCNReferenceLoadingPolicy;

/***/ },
/* 140 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _SCNNode2 = __webpack_require__(33);

	var _SCNNode3 = _interopRequireDefault(_SCNNode2);

	var _SCNReferenceLoadingPolicy = __webpack_require__(139);

	var _SCNReferenceLoadingPolicy2 = _interopRequireDefault(_SCNReferenceLoadingPolicy);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * A scene graph node that serves as a placeholder for content to be loaded from a separate scene file. 
	 * @access public
	 * @extends {SCNNode}
	 * @see https://developer.apple.com/reference/scenekit/scnreferencenode
	 */
	var SCNReferenceNode = function (_SCNNode) {
	  _inherits(SCNReferenceNode, _SCNNode);

	  function SCNReferenceNode() {
	    _classCallCheck(this, SCNReferenceNode);

	    return _possibleConstructorReturn(this, (SCNReferenceNode.__proto__ || Object.getPrototypeOf(SCNReferenceNode)).apply(this, arguments));
	  }

	  _createClass(SCNReferenceNode, [{
	    key: 'initUrl',


	    // Creating a Reference Node

	    /**
	     * Initializes a node whose content is to be loaded from the referenced URL.
	     * @access public
	     * @param {string} referenceURL - The URL to a scene file from which to load the node’s content.
	     * @returns {void}
	     * @desc Using this initializer does not load the node’s content. To load content from the referenced URL, use the load() method.
	     * @see https://developer.apple.com/reference/scenekit/scnreferencenode/1523967-init
	     */
	    value: function initUrl(referenceURL) {

	      // Loading and Unloading a Reference Node’s Content

	      /**
	       * The URL to a scene file from which to load content for the reference node.
	       * @type {string}
	       * @see https://developer.apple.com/reference/scenekit/scnreferencenode/1522733-referenceurl
	       */
	      this.referenceURL = '';

	      /**
	       * An option for whether to load the node’s content automatically.
	       * @type {SCNReferenceLoadingPolicy}
	       * @see https://developer.apple.com/reference/scenekit/scnreferencenode/1522996-loadingpolicy
	       */
	      this.loadingPolicy = null;

	      this._isLoaded = false;
	    }

	    // Loading and Unloading a Reference Node’s Content

	    /**
	     * Loads content into the node from its referenced external scene file.
	     * @access public
	     * @returns {void}
	     * @desc When SceneKit loads the referenced scene file, all children of the scene file’s root node become children of the reference node.If the node has already been loaded (either automatically, according to the loadingPolicy property, or through a previous call to this method), calling this method has no effect.
	     * @see https://developer.apple.com/reference/scenekit/scnreferencenode/1523204-load
	     */

	  }, {
	    key: 'load',
	    value: function load() {}

	    /**
	     * Removes the node’s children and marks the node as not loaded.
	     * @access public
	     * @returns {void}
	     * @desc Calling this method does not necessarily unload any content associated with the node’s child nodes from memory—it merely removes them from the scene graph. The unlinked nodes and their content are then subject to normal object memory management rules. Under ARC, those objects are deallocated if and only if they are not referenced from elsewhere in your program.
	     * @see https://developer.apple.com/reference/scenekit/scnreferencenode/1523566-unload
	     */

	  }, {
	    key: 'unload',
	    value: function unload() {}
	    /**
	     * A Boolean value that indicates whether the reference node has already loaded its content.
	     * @type {boolean}
	     * @desc 
	     * @see https://developer.apple.com/reference/scenekit/scnreferencenode/1523906-isloaded
	     */

	  }, {
	    key: 'initCoder',


	    // Initializers

	    /**
	     * 
	     * @access public
	     * @param {NSCoder} aDecoder - 
	     * @returns {void}
	     * @see https://developer.apple.com/reference/scenekit/scnreferencenode/1524061-init
	     */
	    value: function initCoder(aDecoder) {

	      // Loading and Unloading a Reference Node’s Content

	      /**
	       * The URL to a scene file from which to load content for the reference node.
	       * @type {string}
	       * @see https://developer.apple.com/reference/scenekit/scnreferencenode/1522733-referenceurl
	       */
	      this.referenceURL = '';

	      /**
	       * An option for whether to load the node’s content automatically.
	       * @type {SCNReferenceLoadingPolicy}
	       * @see https://developer.apple.com/reference/scenekit/scnreferencenode/1522996-loadingpolicy
	       */
	      this.loadingPolicy = null;

	      this._isLoaded = false;
	    }
	  }, {
	    key: 'isLoaded',
	    get: function get() {
	      return this._isLoaded;
	    }
	  }]);

	  return SCNReferenceNode;
	}(_SCNNode3.default);

	exports.default = SCNReferenceNode;

/***/ },
/* 141 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _NSObject2 = __webpack_require__(13);

	var _NSObject3 = _interopRequireDefault(_NSObject2);

	var _SCNScene = __webpack_require__(43);

	var _SCNScene2 = _interopRequireDefault(_SCNScene);

	var _SCNSceneSourceStatusHandler = __webpack_require__(142);

	var _SCNSceneSourceStatusHandler2 = _interopRequireDefault(_SCNSceneSourceStatusHandler);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var _AnimationImportPolicy = {
	  doNotPlay: Symbol(),
	  play: Symbol(),
	  playRepeatedly: Symbol(),
	  playUsingSceneTimeBase: Symbol()
	};

	var _LoadingOption = {
	  animationImportPolicy: Symbol(),
	  assetDirectoryURLs: Symbol(),
	  checkConsistency: Symbol(),
	  convertToYUp: Symbol(),
	  convertUnitsToMeters: Symbol(),
	  createNormalsIfAbsent: Symbol(),
	  flattenScene: Symbol(),
	  overrideAssetURLs: Symbol(),
	  preserveOriginalTopology: Symbol(),
	  strictConformance: Symbol(),
	  useSafeMode: Symbol()
	};

	/**
	 * Manages the data-reading tasks associated with loading scene contents from a file or data.
	 * @access public
	 * @extends {NSObject}
	 * @see https://developer.apple.com/reference/scenekit/scnscenesource
	 */

	var SCNSceneSource = function (_NSObject) {
	  _inherits(SCNSceneSource, _NSObject);

	  // Creating a Scene Source

	  /**
	   * Initializes a scene source for reading the scene graph contained in an NSData object.
	   * @access public
	   * @constructor
	   * @param {Blob} data - A data object containing a scene file in a format recognized by SceneKit.
	   * @param {?Map<SCNSceneSource.LoadingOption, Object>} [options = null] - A dictionary containing options that affect scene loading. See Scene Loading Options for available keys and values. Pass nil to use default options.
	   * @desc The data parameter of this method should contain the same data as directly read from a scene file (such as by using the NSData method dataWithContentsOfURL:). Use this method when you have the contents of a scene file but not the file itself—for example, if your app downloads scene files from the network.
	   * @see https://developer.apple.com/reference/scenekit/scnscenesource/1523500-init
	   */
	  function SCNSceneSource(data) {
	    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

	    _classCallCheck(this, SCNSceneSource);

	    // Getting Information about the Scene

	    var _this = _possibleConstructorReturn(this, (SCNSceneSource.__proto__ || Object.getPrototypeOf(SCNSceneSource)).call(this));

	    _this._url = null;
	    _this._data = data;
	    return _this;
	  }

	  _createClass(SCNSceneSource, [{
	    key: 'scene',


	    // Loading a Complete Scene

	    /**
	     * Loads the entire scene graph from the scene source and calls the specified block to provide progress information.
	     * @access public
	     * @param {?Map<SCNSceneSource.LoadingOption, Object>} [options = null] - A dictionary containing options that affect scene loading. See Scene Loading Options for available keys and values. Pass nil to use default options.
	     * @param {?SCNSceneSourceStatusHandler} [statusHandler = null] - An SCNSceneSourceStatusHandler block. SceneKit calls this block periodically to report progress while loading the scene.
	     * @returns {?SCNScene} - 
	     * @desc Use this method if you need to monitor progress while loading a scene from the scene source. For simpler scene loading, use the scene(options:) method or the SCNScene method init(url:options:).A scene source can contain objects that are not part of its scene graph. To obtain these objects, you must load them individually with the the entryWithIdentifier:withClass: or entries(passingTest:) method. For example, a scene file containing a game character could include several animations for the character geometry (such as running, jumping, and standing idle). Because you typically do not apply multiple animations at once, the scene file contains these animations without their being attached to the character geometry.
	     * @see https://developer.apple.com/reference/scenekit/scnscenesource/1522887-scene
	     */
	    value: function scene() {
	      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
	      var statusHandler = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

	      return null;
	    }

	    // Loading and Inspecting Scene Elements

	    /**
	     * Returns the identifiers for all objects in the scene source of the specified class.
	     * @access public
	     * @param {Object} entryClass - The class of objects to find identifiers for.
	     * @returns {string[]} - 
	     * @desc SceneKit recognizes objects of the following classes in scene files:CAAnimationNSImageSCNCameraSCNGeometrySCNLightSCNMaterialSCNMorpherSCNNodeSCNSceneSCNSkinnerEach object in a scene file has an identifier that is unique for its class. These identifiers are determined by the software that created the scene file—for example, they may be descriptive names assigned by an artist using 3D authoring tools. For SceneKit classes with a name property (such as nodes and geometries), the name of an object loaded from a scene file is based on its identifier in the scene file.Use this method to enumerate all objects in a scene file of a specified class without loading the objects and their content. For example, the following code finds the identifiers for all animations stored in a scene source:NSArray *animations = [sceneSource identifiersOfEntriesWithClass:[CAAnimation class]];
	    NSArray *animations = [sceneSource identifiersOfEntriesWithClass:[CAAnimation class]];
	      * @see https://developer.apple.com/reference/scenekit/scnscenesource/1523656-identifiersofentries
	     */

	  }, {
	    key: 'identifiersOfEntriesWithClass',
	    value: function identifiersOfEntriesWithClass(entryClass) {
	      return null;
	    }

	    /**
	     * Loads and returns all objects in the scene source that pass the test in a given block.
	     * @access public
	     * @param {function(arg1: Object, arg2: string, arg3: UnsafeMutablePointer<ObjCBool>): boolean} predicate - The block to be applied to each object in the scene source.The block takes three parameters:entryThe object to be tested.identifierThe unique identifier of the object in the scene source.stopA reference to a Boolean value. Set *stop to true within the block to abort further processing of the scene source’s contents.The block returns a Boolean value indicating whether the entry object passed the test and should be included in the method’s returned array.
	     * @returns {Object[]} - 
	     * @desc SceneKit recognizes objects of the following classes in scene files:CAAnimationNSImageSCNCameraSCNGeometrySCNLightSCNMaterialSCNMorpherSCNNodeSCNSceneSCNSkinnerEach object in a scene file has an identifier that is unique for its class. These identifiers are determined by the software that created the scene file—for example, they may be descriptive names assigned by an artist using 3D authoring tools. For SceneKit classes with a name property (such as nodes and geometries), the name of an object loaded from a scene file is based on its identifier in the scene file.Use this method to selectively load objects from a scene source matching criteria you specify. For example, the following code loads from a scene file only the nodes that have attached geometry:NSArray *geometryNodes = [sceneSource entriesPassingTest:^BOOL(id entry, NSString *identifier, BOOL *stop) {
	      if ([entry isKindOfClass:[SCNNode class]]) {
	          SCNNode *node = (SCNNode *)entry;
	          return (node.geometry != nil);
	      } else {
	          return NO;
	      }
	    }];
	    NSArray *geometryNodes = [sceneSource entriesPassingTest:^BOOL(id entry, NSString *identifier, BOOL *stop) {
	      if ([entry isKindOfClass:[SCNNode class]]) {
	          SCNNode *node = (SCNNode *)entry;
	          return (node.geometry != nil);
	      } else {
	          return NO;
	      }
	    }];
	      * @see https://developer.apple.com/reference/scenekit/scnscenesource/1523055-entries
	     */

	  }, {
	    key: 'entriesPassingTest',
	    value: function entriesPassingTest(predicate) {
	      return null;
	    }

	    // Getting Information about the Scene

	    /**
	     * Returns metadata about the scene.
	     * @access public
	     * @param {string} key - A constant identifying a metadata property of the scene source. See Scene Source Properties for available keys and the formats of their values.
	     * @returns {?Object} - 
	     * @desc This method returns information about the scene that is defined in the file but is not directly referenced by the scene.
	     * @see https://developer.apple.com/reference/scenekit/scnscenesource/1523277-property
	     */

	  }, {
	    key: 'propertyForKey',
	    value: function propertyForKey(key) {
	      return null;
	    }
	    /**
	     * The URL identifying the file from which the scene source was created.
	     * @type {?string}
	     * @desc The value of this property is nil if the scene source was not created using the sceneSourceWithURL:options: or init(url:options:) method.
	     * @see https://developer.apple.com/reference/scenekit/scnscenesource/1524038-url
	     */

	  }, {
	    key: 'entryWithIdentifierWithClass',


	    // Instance Methods

	    /**
	     * 
	     * @access public
	     * @param {string} uid - 
	     * @param {T.Type} entryClass - 
	     * @returns {Object} - 
	     * @see https://developer.apple.com/reference/scenekit/scnscenesource/2805685-entrywithidentifier
	     */
	    value: function entryWithIdentifierWithClass(uid, entryClass) {
	      return null;
	    }

	    // Structures
	    /**
	     * @type {Object} AnimationImportPolicy
	     * @property {Symbol} doNotPlay Animations are not loaded from the scene file.
	     * @property {Symbol} play Animations loaded from the scene file are immediately added to the scene and played once.
	     * @property {Symbol} playRepeatedly Animations loaded from the scene file are immediately added to the scene and played repeatedly.
	     * @property {Symbol} playUsingSceneTimeBase Animations loaded from the scene file are immediately added to the scene and played according to the scene’s sceneTime property.
	     * @see https://developer.apple.com/reference/scenekit/scnscenesource.animationimportpolicy
	     */

	  }, {
	    key: 'url',
	    get: function get() {
	      return this._url;
	    }
	    /**
	     * The data object from which the scene source loads scene content.
	     * @type {?Data}
	     * @desc If the scene source was created using the sceneSourceWithData:options: or init(data:options:) method, this property’s value is the data from which the scene source was created. If the scene source was created from a scene file using the the sceneSourceWithURL:options: or init(url:options:) method, this property’s value is the data loaded from that URL at the time the scene source was created.
	     * @see https://developer.apple.com/reference/scenekit/scnscenesource/1523061-data
	     */

	  }, {
	    key: 'data',
	    get: function get() {
	      return this._data;
	    }
	  }], [{
	    key: 'sceneSourceWithDataOptions',
	    value: function sceneSourceWithDataOptions(data, options) {
	      return new SCNSceneSource(data, options);
	    }
	  }, {
	    key: 'sceneSourceWithURLOptions',
	    value: function sceneSourceWithURLOptions(url, options) {}
	  }, {
	    key: 'AnimationImportPolicy',
	    get: function get() {
	      return _AnimationImportPolicy;
	    }
	    /**
	     * @type {Object} LoadingOption
	     * @property {Symbol} animationImportPolicy An option for controlling the playback of animations in a scene file.
	     * @property {Symbol} assetDirectoryURLs Locations to use for resolving relative URLs to external resources.
	     * @property {Symbol} checkConsistency An option to validate scene files while loading.
	     * @property {Symbol} convertToYUp An option for whether to transform assets loaded from the scene file for use in a coordinate system where the y-axis points up.
	     * @property {Symbol} convertUnitsToMeters An option for whether to automatically scale the scene’s contents.
	     * @property {Symbol} createNormalsIfAbsent An option for automatically generating surface normals if they are absent when loading geometry.
	     * @property {Symbol} flattenScene An option for automatically merging portions of a scene graph during loading.
	     * @property {Symbol} overrideAssetURLs An option to attempt loading external resources using their URLs as specified in a scene file.
	     * @property {Symbol} preserveOriginalTopology 
	     * @property {Symbol} strictConformance An option to interpret scene files exactly as specified by the scene file format.
	     * @property {Symbol} useSafeMode An option to limit filesystem and network access for external resources referenced by a scene file.
	     * @see https://developer.apple.com/reference/scenekit/scnscenesource.loadingoption
	     */

	  }, {
	    key: 'LoadingOption',
	    get: function get() {
	      return _LoadingOption;
	    }
	  }]);

	  return SCNSceneSource;
	}(_NSObject3.default);

	exports.default = SCNSceneSource;

/***/ },
/* 142 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _SCNSceneSourceStatus = __webpack_require__(143);

	var _SCNSceneSourceStatus2 = _interopRequireDefault(_SCNSceneSourceStatus);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * The signature for the block that SceneKit calls periodically to report progress while loading a scene.
	 * @type {function(totalProgress: number, status: SCNSceneSourceStatus, error: ?Error, stopLoading: UnsafeMutablePointer<ObjCBool>): void}
	 * @param {number} totalProgress - A floating-point number between 0.0 and 1.0 indicating the overall progress of loading the scene. A value of 0.0 indicates that the loading process has just begun, and a value of 1.0 indicates that the process has completed.
	 * @param {SCNSceneSourceStatus} status - A constant identifying one of the distinct phases of SceneKit’s loading procedure. See SCNSceneSourceStatus for possible values.
	 * @param {?Error} error - An error object describing any error that has occurred during scene loading, or nil if no errors has been encountered.
	 * @param {UnsafeMutablePointer<ObjCBool>} stopLoading - A reference to a Boolean value. Set *stop to true within the block to abort further processing of the scene source’s contents.
	 * @returns {void}
	 * @see https://developer.apple.com/reference/scenekit/scnscenesourcestatushandler
	 */
	var SCNSceneSourceStatusHandler = function SCNSceneSourceStatusHandler(totalProgress, status, error, stopLoading) {};

	exports.default = SCNSceneSourceStatusHandler;

/***/ },
/* 143 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * Constants identifying phases of SceneKit’s scene loading process, used in a SCNSceneSourceStatusHandler block.
	 * @typedef {Object} SCNSceneSourceStatus
	 * @property {Symbol} error - An error occurred when SceneKit attempted to load the scene.
	 * @property {Symbol} parsing - SceneKit has begun deserializing the source file.
	 * @property {Symbol} validating - SceneKit has begun validating the scene file’s format.
	 * @property {Symbol} processing - SceneKit has begun generating scene graph objects from the scene file’s contents.
	 * @property {Symbol} complete - SceneKit has successfully finished loading the scene file’s contents.
	 * @see https://developer.apple.com/reference/scenekit/scnscenesourcestatus
	 */

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	var SCNSceneSourceStatus = {
	  error: Symbol(),
	  parsing: Symbol(),
	  validating: Symbol(),
	  processing: Symbol(),
	  complete: Symbol()
	};

	exports.default = SCNSceneSourceStatus;

/***/ },
/* 144 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _SCNGeometry2 = __webpack_require__(37);

	var _SCNGeometry3 = _interopRequireDefault(_SCNGeometry2);

	var _SCNChamferMode = __webpack_require__(111);

	var _SCNChamferMode2 = _interopRequireDefault(_SCNChamferMode);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * A geometry based on a two-dimensional path, optionally extruded to create a three-dimensional object.
	 * @access public
	 * @extends {SCNGeometry}
	 * @see https://developer.apple.com/reference/scenekit/scnshape
	 */
	var SCNShape = function (_SCNGeometry) {
	  _inherits(SCNShape, _SCNGeometry);

	  // Creating a Shape

	  /**
	   * Creates a shape geometry with the specified path and extrusion depth.
	   * @access public
	   * @constructor
	   * @param {?UIBezierPath} path - The two-dimensional path forming the basis of the shape.
	   * @param {number} extrusionDepth - The thickness of the extruded shape along the z-axis.
	   * @desc SceneKit determines the filled area of the path using the even-odd winding rule (see Winding Rules in Cocoa Drawing Guide) and extrudes this area to create a three-dimensional geometry. The result of extruding a self-intersecting path is undefined.The extruded shape is centered at the zero point of its z-axis. For example, an extrusion depth of 1.0 creates a shape that extends from -0.5 to 0.5 along the z-axis. An extrusion depth of zero creates a flat, one-sided shape.The path’s flatness (see flatness in NSBezierPath) determines the level of detail SceneKit uses in building a three-dimensional shape from the path. A larger flatness value results in fewer polygons to render, increasing performance, and a smaller flatness value increases the smoothness of curves at a cost to performance.
	   * @see https://developer.apple.com/reference/scenekit/scnshape/1523432-init
	   */
	  function SCNShape(path, extrusionDepth) {
	    _classCallCheck(this, SCNShape);

	    // Modifying a Shape

	    /**
	     * The thickness of the extruded shape along the z-axis. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnshape/1523365-extrusiondepth
	     */
	    var _this = _possibleConstructorReturn(this, (SCNShape.__proto__ || Object.getPrototypeOf(SCNShape)).call(this));

	    _this.extrusionDepth = 0;

	    /**
	     * The two-dimensional path forming the basis of the shape.
	     * @type {?UIBezierPath}
	     * @see https://developer.apple.com/reference/scenekit/scnshape/1523434-path
	     */
	    _this.path = null;

	    // Chamfering a Shape

	    /**
	     * A constant specifying which ends of the extruded shape’s profile are chamfered.
	     * @type {SCNChamferMode}
	     * @see https://developer.apple.com/reference/scenekit/scnshape/1523989-chamfermode
	     */
	    _this.chamferMode = null;

	    /**
	     * A path that determines the cross-sectional contour of each chamfered edge.
	     * @type {?UIBezierPath}
	     * @see https://developer.apple.com/reference/scenekit/scnshape/1522865-chamferprofile
	     */
	    _this.chamferProfile = null;

	    /**
	     * The width or depth of each chamfered edge. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnshape/1524145-chamferradius
	     */
	    _this.chamferRadius = 0;
	    return _this;
	  }

	  return SCNShape;
	}(_SCNGeometry3.default);

	exports.default = SCNShape;

/***/ },
/* 145 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _SCNGeometry2 = __webpack_require__(37);

	var _SCNGeometry3 = _interopRequireDefault(_SCNGeometry2);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * A sphere (or ball or globe) geometry.
	 * @access public
	 * @extends {SCNGeometry}
	 * @see https://developer.apple.com/reference/scenekit/scnsphere
	 */
	var SCNSphere = function (_SCNGeometry) {
	  _inherits(SCNSphere, _SCNGeometry);

	  // Creating a Sphere

	  /**
	   * Creates a sphere geometry with the specified radius.
	   * @access public
	   * @constructor
	   * @param {number} radius - The radius of the sphere in its local coordinate space.
	   * @desc The sphere is centered in its local coordinate system. For example, if you create a sphere whose radius is 5.0, it extends from -5.0 to 5.0 along each of the the x, y, and z-axes.
	   * @see https://developer.apple.com/reference/scenekit/scnsphere/1522601-init
	   */
	  function SCNSphere(radius) {
	    _classCallCheck(this, SCNSphere);

	    // Adjusting a Sphere’s Dimensions

	    /**
	     * The radius of the sphere. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnsphere/1523787-radius
	     */
	    var _this = _possibleConstructorReturn(this, (SCNSphere.__proto__ || Object.getPrototypeOf(SCNSphere)).call(this));

	    _this.radius = radius;

	    // Adjusting Geometric Detail

	    /**
	     * A Boolean value specifying whether SceneKit uses a geodesic polygon mesh to render the sphere.
	     * @type {boolean}
	     * @see https://developer.apple.com/reference/scenekit/scnsphere/1523268-isgeodesic
	     */
	    _this.isGeodesic = false;

	    /**
	     * A number determining the detail of the polygon mesh SceneKit uses to render the sphere. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnsphere/1523912-segmentcount
	     */
	    _this.segmentCount = 0;
	    return _this;
	  }

	  return SCNSphere;
	}(_SCNGeometry3.default);

	exports.default = SCNSphere;

/***/ },
/* 146 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _SCNGeometry2 = __webpack_require__(37);

	var _SCNGeometry3 = _interopRequireDefault(_SCNGeometry2);

	var _CGRect = __webpack_require__(6);

	var _CGRect2 = _interopRequireDefault(_CGRect);

	var _CGSize = __webpack_require__(7);

	var _CGSize2 = _interopRequireDefault(_CGSize);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * A geometry based on a string of text, optionally extruded to create a three-dimensional object. 
	 * @access public
	 * @extends {SCNGeometry}
	 * @see https://developer.apple.com/reference/scenekit/scntext
	 */
	var SCNText = function (_SCNGeometry) {
	  _inherits(SCNText, _SCNGeometry);

	  // Creating a Text Geometry

	  /**
	   * Creates a text geometry from a specified string, extruded with a specified depth.
	   * @access public
	   * @constructor
	   * @param {?Object} string - An NSString or NSAttributedString object containing text from which to create the geometry.
	   * @param {number} extrusionDepth - The extent of the text geometry in the Z dimension of its local coordinate space. Specify a depth of 0.0 to create 2D text confined to a plane.
	   * @desc In the local coordinate system of the text geometry, the origin corresponds to the lower left corner of the text’s layout rectangle, with the text extending in the x- and y-axis dimensions. (SceneKit computes a layout rectangle automatically, or you can specify one using the containerFrame property.) The geometry is centered along its z-axis. For example, if its extrusionDepth property is 1.0, the geometry extends from -0.5 to 0.5 along the z-axis. An extrusion depth of zero creates a flat, one-sided shape—the geometry is confined to the plane whose z-coordinate is 0.0, and viewable only from its front unless its material’s isDoubleSided property is true.
	   * @see https://developer.apple.com/reference/scenekit/scntext/1522734-init
	   */
	  function SCNText(string, extrusionDepth) {
	    _classCallCheck(this, SCNText);

	    // Managing the Geometry’s Text Content

	    /**
	     * The string object whose text the geometry represents.
	     * @type {?Object}
	     * @see https://developer.apple.com/reference/scenekit/scntext/1523439-string
	     */
	    var _this = _possibleConstructorReturn(this, (SCNText.__proto__ || Object.getPrototypeOf(SCNText)).call(this));

	    _this.string = null;

	    /**
	     * The font that SceneKit uses to create geometry from the text.
	     * @type {!UIFont}
	     * @see https://developer.apple.com/reference/scenekit/scntext/1523273-font
	     */
	    _this.font = null;

	    // Managing Text Layout

	    /**
	     * A rectangle specifying the area in which SceneKit should lay out the text.
	     * @type {CGRect}
	     * @see https://developer.apple.com/reference/scenekit/scntext/1523654-containerframe
	     */
	    _this.containerFrame = null;

	    /**
	     * A Boolean value that specifies whether SceneKit wraps long lines of text.
	     * @type {boolean}
	     * @see https://developer.apple.com/reference/scenekit/scntext/1523585-iswrapped
	     */
	    _this.isWrapped = false;

	    /**
	     * A constant that specifies how SceneKit horizontally aligns each line of text within its container.
	     * @type {string}
	     * @see https://developer.apple.com/reference/scenekit/scntext/1523158-alignmentmode
	     */
	    _this.alignmentMode = '';

	    /**
	     * A constant that specifies how SceneKit truncates text that is too long to fit its container.
	     * @type {string}
	     * @see https://developer.apple.com/reference/scenekit/scntext/1523414-truncationmode
	     */
	    _this.truncationMode = '';

	    _this._textSize = null;

	    // Managing the Text’s 3D Representation

	    /**
	     * A number that determines the accuracy or smoothness of the text geometry.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scntext/1524111-flatness
	     */
	    _this.flatness = 0;

	    /**
	     * The extent of the extruded text in the z-axis direction. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scntext/1522604-extrusiondepth
	     */
	    _this.extrusionDepth = 0;

	    /**
	     * The width or depth of each chamfered edge. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scntext/1522846-chamferradius
	     */
	    _this.chamferRadius = 0;

	    /**
	     * A path that determines the cross-sectional contour of each chamfered edge.
	     * @type {?UIBezierPath}
	     * @see https://developer.apple.com/reference/scenekit/scntext/1523334-chamferprofile
	     */
	    _this.chamferProfile = null;
	    return _this;
	  }

	  // Managing Text Layout

	  /**
	   * The two-dimensional extent of the text after layout.
	   * @type {CGSize}
	   * @desc This property reports the size of the smallest bounding rectangle containing the text. This size does not necessarily match that of the layout rectangle specified by the containerFrame property. A long body of text may overflow the layout rectangle, depending on the values of the isWrapped and truncationMode properties, and a short string of text may fit in an area smaller than the layout rectangle.
	   * @see https://developer.apple.com/reference/scenekit/scntext/1523680-textsize
	   */


	  _createClass(SCNText, [{
	    key: 'textSize',
	    get: function get() {
	      return this._textSize;
	    }
	  }]);

	  return SCNText;
	}(_SCNGeometry3.default);

	exports.default = SCNText;

/***/ },
/* 147 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _SCNGeometry2 = __webpack_require__(37);

	var _SCNGeometry3 = _interopRequireDefault(_SCNGeometry2);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * A torus, or ring-shaped geometry.
	 * @access public
	 * @extends {SCNGeometry}
	 * @see https://developer.apple.com/reference/scenekit/scntorus
	 */
	var SCNTorus = function (_SCNGeometry) {
	  _inherits(SCNTorus, _SCNGeometry);

	  // Creating a Torus

	  /**
	   * Creates a torus geometry with the specified ring radius and pipe radius.
	   * @access public
	   * @constructor
	   * @param {number} ringRadius - The major radius of the torus, defining its circular ring in the x- and z-axis dimensions of its local coordinate space.
	   * @param {number} pipeRadius - The minor radius of the torus, defining the pipe that encircles the ring.
	   * @desc The torus is centered in its local coordinate system. For example, if you create a torus whose ring radius is 5.0 and pipe radius is 1.0, it extends from -6.0 to 6.0 (with a hole through the center from -4.0 to 4.0) in the x- and z-axes and from -1.0 to 1.0 in the y-axis.
	   * @see https://developer.apple.com/reference/scenekit/scntorus/1523833-init
	   */
	  function SCNTorus(ringRadius, pipeRadius) {
	    _classCallCheck(this, SCNTorus);

	    // Adjusting a Torus’ Dimensions

	    /**
	     * The major radius of the torus, defining a circle in the x- and z-axis dimensions. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scntorus/1522906-ringradius
	     */
	    var _this = _possibleConstructorReturn(this, (SCNTorus.__proto__ || Object.getPrototypeOf(SCNTorus)).call(this));

	    _this.ringRadius = 0;

	    /**
	     * The minor radius of the torus, defining the pipe that encircles the torus ring. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scntorus/1522623-piperadius
	     */
	    _this.pipeRadius = 0;

	    // Configuring Torus Properties

	    /**
	     * The number of subdivisions around the torus ring. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scntorus/1523598-ringsegmentcount
	     */
	    _this.ringSegmentCount = 0;

	    /**
	     * The number of subdivisions around the torus pipe. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scntorus/1522807-pipesegmentcount
	     */
	    _this.pipeSegmentCount = 0;
	    return _this;
	  }

	  return SCNTorus;
	}(_SCNGeometry3.default);

	exports.default = SCNTorus;

/***/ },
/* 148 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _NSObject2 = __webpack_require__(13);

	var _NSObject3 = _interopRequireDefault(_NSObject2);

	var _CAMediaTimingFunction = __webpack_require__(22);

	var _CAMediaTimingFunction2 = _interopRequireDefault(_CAMediaTimingFunction);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var _animationDuration = 0;
	var _animationTimingFunction = null;
	var _disableActions = false;
	var _completionBlock = null;

	/**
	 * The SCNTransaction class defines SceneKit’s mechanism for batching scene graph modifications into atomic updates. You use SCNTransaction class methods to control the animation that results from changing animatable properties in the scene graph and to combine sets of changes into nested transactions.
	 * @access public
	 * @extends {NSObject}
	 * @see https://developer.apple.com/reference/scenekit/scntransaction
	 */

	var SCNTransaction = function (_NSObject) {
	  _inherits(SCNTransaction, _NSObject);

	  /**
	   * constructor
	   * @access public
	   * @constructor
	   */
	  function SCNTransaction() {
	    _classCallCheck(this, SCNTransaction);

	    return _possibleConstructorReturn(this, (SCNTransaction.__proto__ || Object.getPrototypeOf(SCNTransaction)).call(this));
	  }

	  // Creating and Committing Transactions

	  /**
	   * Begins a new transaction for the current thread.
	   * @access public
	   * @returns {void}
	   * @desc The new transaction is nested within the thread’s current transaction, if there is one.The first time you modify the scene graph during a pass through the run loop, SceneKit automatically creates a transaction and makes it the current transaction. (SceneKit commits that transaction when the next iteration of the run loops begins.) If you call this method to create a custom transaction before modifying the scene graph, your custom transaction becomes the current transaction.
	   * @see https://developer.apple.com/reference/scenekit/scntransaction/1522820-begin
	   */


	  _createClass(SCNTransaction, null, [{
	    key: 'begin',
	    value: function begin() {}

	    /**
	     * Commits all changes made during the current transaction.
	     * @access public
	     * @returns {void}
	     * @desc If there is no current transaction, this method has no effect.
	     * @see https://developer.apple.com/reference/scenekit/scntransaction/1523436-commit
	     */

	  }, {
	    key: 'commit',
	    value: function commit() {}

	    /**
	     * Applies all changes from the current automatic transaction.
	     * @access public
	     * @returns {void}
	     * @desc SceneKit automatically calls this method at the end of each pass through the run loop, regardless of the run loop mode. If your app does not have a run loop, you must call this method explicitly.If the current transaction has any nested transactions that are still animating, SceneKit waits to commit the current transaction’s changes until those transactions complete.NoteIf possible, avoid calling flush() explicitly. By allowing flush() to execute during the run loop, your app achieves better performance, atomic screen updates are preserved, and transactions and animations that work from transaction to transaction continue to function.
	     * @see https://developer.apple.com/reference/scenekit/scntransaction/1522860-flush
	     */

	  }, {
	    key: 'flush',
	    value: function flush() {}

	    // Overriding Animation Duration and Timing

	    /**
	     * Returns the duration, in seconds, of all animations within the current transaction.
	     * @type {number}
	     * @desc The default duration is zero for transactions automatically created by SceneKit, and 0.25 for animations you create using the begin() method.
	     * @see https://developer.apple.com/reference/scenekit/scntransaction/1523888-animationduration
	     */

	  }, {
	    key: 'lock',


	    // Managing Concurrency

	    /**
	     * Attempts to acquire a recursive spinlock to ensure the validity of values you retrieve during the transaction.
	     * @access public
	     * @returns {void}
	     * @desc SceneKit’s data model is thread-safe in that it ensures that internal data structures will not be corrupted by concurrent attempts to modify their contents from multiple threads. However, this model does not guarantee the validity of values you read from scene graph objects after returning them.For example, consider the following operation:_node.position = SCNVector3Make(_node.position.x, _node.position.y + 10, _node.position.z);
	    The intent of this line is to move a node by ten units. But if another thread modifies the node’s position property concurrently, the new position value could be unexpected. If your app modifies the scene graph from multiple threads, use a transaction lock to ensure that your modifications take effect as intended.[SCNTransaction lock];
	    _node.position = SCNVector3Make(_node.position.x, _node.position.y + 10, _node.position.z);
	    [SCNTransaction unlock];
	    If another thread currently holds a lock on the transaction, calling lock() has no effect._node.position = SCNVector3Make(_node.position.x, _node.position.y + 10, _node.position.z);
	    [SCNTransaction lock];
	    _node.position = SCNVector3Make(_node.position.x, _node.position.y + 10, _node.position.z);
	    [SCNTransaction unlock];
	      * @see https://developer.apple.com/reference/scenekit/scntransaction/1523078-lock
	     */
	    value: function lock() {}

	    /**
	     * Relinquishes a previously acquired transaction lock.
	     * @access public
	     * @returns {void}
	     * @desc See the lock() method for more details on transaction locking.
	     * @see https://developer.apple.com/reference/scenekit/scntransaction/1523166-unlock
	     */

	  }, {
	    key: 'unlock',
	    value: function unlock() {}

	    // Getting and Setting Transaction Properties

	    /**
	     * Associates an arbitrary object with the current transaction using the specified key.
	     * @access public
	     * @param {?Object} value - 
	     * @param {string} key - A unique string identifying the object for later retrieval.
	     * @returns {void}
	     * @desc Nested transactions have nested data scope. Setting a value for a key associates it with the current transaction (or innermost nested transaction) only, and reading the value for a key searches through nested transactions (starting from the innermost).
	     * @see https://developer.apple.com/reference/scenekit/scntransaction/1524124-setvalue
	     */

	  }, {
	    key: 'setValueForKey',
	    value: function setValueForKey(value, key) {}

	    /**
	     * Returns the object previously associated with the current transaction using the specified key.
	     * @access public
	     * @param {string} key - The unique string identifying an object previously associated with the transaction.
	     * @returns {?Object} - 
	     * @desc Nested transactions have nested data scope. Setting a value for a key associates it with the current transaction (or innermost nested transaction) only, but reading the value for a key searches through nested transactions (starting from the innermost).
	     * @see https://developer.apple.com/reference/scenekit/scntransaction/1523919-value
	     */

	  }, {
	    key: 'valueForKey',
	    value: function valueForKey(key) {
	      return null;
	    }
	  }, {
	    key: 'animationDuration',
	    get: function get() {
	      return _animationDuration;
	    }

	    /**
	     * Returns the duration, in seconds, of all animations within the current transaction.
	     * @type {number}
	     * @desc The default duration is zero for transactions automatically created by SceneKit, and 0.25 for animations you create using the begin() method.
	     * @see https://developer.apple.com/reference/scenekit/scntransaction/1523888-animationduration
	     */
	    ,
	    set: function set(newValue) {
	      _animationDuration = newValue;
	    }

	    /**
	     * Returns the timing function that SceneKit uses for all animations within this transaction group. 
	     * @type {?CAMediaTimingFunction}
	     * @desc Media timing functions, also known as animation curves, define the relationship between the elapsed time of an animation and its effect on a property. For example, the kCAMediaTimingFunctionEaseInEaseOut function creates an effect that begins slowly, speeds up, and then finishes slowly.
	     * @see https://developer.apple.com/reference/scenekit/scntransaction/1522614-animationtimingfunction
	     */

	  }, {
	    key: 'animationTimingFunction',
	    get: function get() {
	      return _animationTimingFunction;
	    }

	    /**
	     * Returns the timing function that SceneKit uses for all animations within this transaction group. 
	     * @type {?CAMediaTimingFunction}
	     * @desc Media timing functions, also known as animation curves, define the relationship between the elapsed time of an animation and its effect on a property. For example, the kCAMediaTimingFunctionEaseInEaseOut function creates an effect that begins slowly, speeds up, and then finishes slowly.
	     * @see https://developer.apple.com/reference/scenekit/scntransaction/1522614-animationtimingfunction
	     */
	    ,
	    set: function set(newValue) {
	      _animationTimingFunction = newValue;
	    }

	    // Temporarily Disabling Property Animations

	    /**
	     * Returns a Boolean value indicating whether changes to animatable properties during the transaction are implicitly animated.
	     * @type {boolean}
	     * @desc By default (when this property is false), any changes to animatable properties of objects in the scene graph implicitly create animations. (These animations may not be visible unless you use the animationDuration property to set a nonzero duration for the transaction.) Set this property to true to disable implicit animation during the transaction.Disabling animation applies to all property changes in the current transaction and any nested transactions within it. However, you can use this property again within a nested transaction to enable implicit animation for that transaction.
	     * @see https://developer.apple.com/reference/scenekit/scntransaction/1524238-disableactions
	     */

	  }, {
	    key: 'disableActions',
	    get: function get() {
	      return _disableActions;
	    }

	    /**
	     * Returns a Boolean value indicating whether changes to animatable properties during the transaction are implicitly animated.
	     * @type {boolean}
	     * @desc By default (when this property is false), any changes to animatable properties of objects in the scene graph implicitly create animations. (These animations may not be visible unless you use the animationDuration property to set a nonzero duration for the transaction.) Set this property to true to disable implicit animation during the transaction.Disabling animation applies to all property changes in the current transaction and any nested transactions within it. However, you can use this property again within a nested transaction to enable implicit animation for that transaction.
	     * @see https://developer.apple.com/reference/scenekit/scntransaction/1524238-disableactions
	     */
	    ,
	    set: function set(newValue) {
	      _disableActions = newValue;
	    }

	    // Getting and Setting Completion Block Objects

	    /**
	     * Returns the block previously associated with the current transaction.
	     * @type {?function(): void}
	     * @desc See setCompletionBlock(_:) for a description of the role of the completion block object.
	     * @see https://developer.apple.com/reference/scenekit/scntransaction/1523660-completionblock
	     */

	  }, {
	    key: 'completionBlock',
	    get: function get() {
	      return _completionBlock;
	    }

	    /**
	     * Returns the block previously associated with the current transaction.
	     * @type {?function(): void}
	     * @desc See setCompletionBlock(_:) for a description of the role of the completion block object.
	     * @see https://developer.apple.com/reference/scenekit/scntransaction/1523660-completionblock
	     */
	    ,
	    set: function set(newValue) {
	      _completionBlock = newValue;
	    }
	  }]);

	  return SCNTransaction;
	}(_NSObject3.default);

	exports.default = SCNTransaction;

/***/ },
/* 149 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _SCNConstraint2 = __webpack_require__(98);

	var _SCNConstraint3 = _interopRequireDefault(_SCNConstraint2);

	var _SCNNode = __webpack_require__(33);

	var _SCNNode2 = _interopRequireDefault(_SCNNode);

	var _SCNMatrix = __webpack_require__(17);

	var _SCNMatrix2 = _interopRequireDefault(_SCNMatrix);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * A constraint that runs a specified closure to compute a new transform (position, rotation, and scale) for each node that the constraint affects.
	 * @access public
	 * @extends {SCNConstraint}
	 * @see https://developer.apple.com/reference/scenekit/scntransformconstraint
	 */
	var SCNTransformConstraint = function (_SCNConstraint) {
	  _inherits(SCNTransformConstraint, _SCNConstraint);

	  function SCNTransformConstraint() {
	    _classCallCheck(this, SCNTransformConstraint);

	    return _possibleConstructorReturn(this, (SCNTransformConstraint.__proto__ || Object.getPrototypeOf(SCNTransformConstraint)).apply(this, arguments));
	  }

	  _createClass(SCNTransformConstraint, [{
	    key: 'init',


	    /**
	     * constructor
	     * @access public
	     * @returns {void}
	     */
	    value: function init() {}

	    // Creating a Transform Constraint

	    /**
	     * Creates a new transform constraint.
	     * @access public
	     * @param {boolean} world - true to evaluate the constraint in the scene’s world coordinate space, or false to evaluate it relative to the local coordinate space of each constrained node.
	     * @param {function(arg1: SCNNode, arg2: SCNMatrix4): SCNMatrix4} block - A block to be called when Scene Kit evaluates the constraint.The block takes the following parameters:nodeThe constrained node.transformThe constrained node’s current presentation transformation—the value of the transform property of the constrained node’s presentation object. If the node is affected by an in-progress animation, this value reflects the currently visible state of the node during the animation (rather than its target state that will be visible when the animation completes).The block returns a transformation matrix, which Scene Kit then applies to the node. If you return the transform value passed to the block, your constraint has no effect on the node. 
	     * @returns {void}
	     * @desc The world parameter determines the coordinate space of the transformations passed to and returned by the block parameter.
	     * @see https://developer.apple.com/reference/scenekit/scntransformconstraint/1468679-init
	     */

	  }, {
	    key: 'initInWorldSpaceWith',
	    value: function initInWorldSpaceWith(world, block) {}
	  }]);

	  return SCNTransformConstraint;
	}(_SCNConstraint3.default);

	exports.default = SCNTransformConstraint;

/***/ },
/* 150 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _SCNGeometry2 = __webpack_require__(37);

	var _SCNGeometry3 = _interopRequireDefault(_SCNGeometry2);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	/**
	 * A tube or pipe geometry—a right circular cylinder with a circular hole along its central axis.
	 * @access public
	 * @extends {SCNGeometry}
	 * @see https://developer.apple.com/reference/scenekit/scntube
	 */
	var SCNTube = function (_SCNGeometry) {
	  _inherits(SCNTube, _SCNGeometry);

	  // Creating a Tube

	  /**
	   * Creates a tube geometry with the specified inner radius, outer radius, and height.
	   * @access public
	   * @constructor
	   * @param {number} innerRadius - The radius of the tube’s circular central hole in the x- and z-axes of its local coordinate space.
	   * @param {number} outerRadius - The radius of the tube’s circular cross section in the x- and z-axes of its local coordinate space.
	   * @param {number} height - The height of the tube along the y-axis of its local coordinate space.
	   * @desc The tube is centered in its local coordinate system. For example, if you create a tube whose outer radius is 5.0, inner radius is 1.0, and height is 10.0, its circular cross section extends from -5.0 to 5.0 along the x- and z-axes, the y-coordinates of its base and top are -5.0 and 5.0, and the hole through its center extends from -0.5 to 0.5 along the x- and z-axes.
	   * @see https://developer.apple.com/reference/scenekit/scntube/1522843-init
	   */
	  function SCNTube(innerRadius, outerRadius, height) {
	    _classCallCheck(this, SCNTube);

	    // Adjusting a Tube’s Dimensions

	    /**
	     * The radius of the tube’s outer circular cross section. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scntube/1523270-outerradius
	     */
	    var _this = _possibleConstructorReturn(this, (SCNTube.__proto__ || Object.getPrototypeOf(SCNTube)).call(this));

	    _this.outerRadius = 0;

	    /**
	     * The radius of the circular hole through the tube. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scntube/1524070-innerradius
	     */
	    _this.innerRadius = 0;

	    /**
	     * The extent of the tube along its y-axis. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scntube/1522640-height
	     */
	    _this.height = 0;

	    // Adjusting Geometric Detail

	    /**
	     * The number of subdivisions around the circumference of the tube. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scntube/1523619-radialsegmentcount
	     */
	    _this.radialSegmentCount = 0;

	    /**
	     * The number of subdivisions in the inner and outer surfaces of the tube along its y-axis. Animatable.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scntube/1523080-heightsegmentcount
	     */
	    _this.heightSegmentCount = 0;

	    return _this;
	  }

	  return SCNTube;
	}(_SCNGeometry3.default);

	exports.default = SCNTube;

/***/ },
/* 151 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _SCNVector = __webpack_require__(15);

	var _SCNVector2 = _interopRequireDefault(_SCNVector);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var _epsilon = 0.00001;

	/**
	 * Returns a Boolean value that indicates whether the corresponding components of two vectors are equal.
	 * @access public
	 * @param {SCNVector3} a - The first vector.
	 * @param {SCNVector3} b - The second vector.
	 * @returns {boolean} - 
	 * @desc This function performs a numeric (not bitwise) comparison of each pair of component values.
	 * @see https://developer.apple.com/reference/scenekit/1409643-scnvector3equaltovector3
	 */
	var SCNVector3EqualToVector3 = function SCNVector3EqualToVector3(a, b) {
	  return Math.abs(a.x - b.x) < _epsilon && Math.abs(a.y - b.y) < _epsilon && Math.abs(a.z - b.z) < _epsilon;
	};

	exports.default = SCNVector3EqualToVector3;

/***/ },
/* 152 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _SCNVector = __webpack_require__(15);

	var _SCNVector2 = _interopRequireDefault(_SCNVector);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * 
	 * @access public
	 * @param {number[]} v - 
	 * @returns {SCNVector3} - 
	 * @see https://developer.apple.com/reference/scenekit/1524143-scnvector3fromfloat3
	 */
	var SCNVector3FromFloat3 = function SCNVector3FromFloat3(v) {
	  return new _SCNVector2.default(v);
	};

	exports.default = SCNVector3FromFloat3;

/***/ },
/* 153 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _SCNVector = __webpack_require__(15);

	var _SCNVector2 = _interopRequireDefault(_SCNVector);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	//import GLKVector3 from '../undefined/GLKVector3'

	/**
	 * Returns a three-element SceneKit vector structure corresponding to a GLKit vector structure.
	 * @access public
	 * @param {GLKVector3} vector - A three-element GLKit vector structure.
	 * @returns {SCNVector3} - 
	 * @see https://developer.apple.com/reference/scenekit/1409692-scnvector3fromglkvector3
	 */
	var SCNVector3FromGLKVector3 = function SCNVector3FromGLKVector3(vector) {
	  return null;
	};

	exports.default = SCNVector3FromGLKVector3;

/***/ },
/* 154 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _SCNVector = __webpack_require__(15);

	var _SCNVector2 = _interopRequireDefault(_SCNVector);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Returns a new three-component vector created from individual component values.
	 * @access public
	 * @param {number} x - The first component of the vector.
	 * @param {number} y - The second component of the vector.
	 * @param {number} z - The third component of the vector.
	 * @returns {SCNVector3} - 
	 * @see https://developer.apple.com/reference/scenekit/1409705-scnvector3make
	 */
	var SCNVector3Make = function SCNVector3Make(x, y, z) {
	  return new _SCNVector2.default(x, y, z);
	};

	exports.default = SCNVector3Make;

/***/ },
/* 155 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _SCNVector = __webpack_require__(15);

	var _SCNVector2 = _interopRequireDefault(_SCNVector);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * 
	 * @access public
	 * @param {SCNVector3} v - 
	 * @returns {number[]} - 
	 * @see https://developer.apple.com/reference/scenekit/1523448-scnvector3tofloat3
	 */
	var SCNVector3ToFloat3 = function SCNVector3ToFloat3(v) {
	  return [v.x, v.y, v.z];
	};

	exports.default = SCNVector3ToFloat3;

/***/ },
/* 156 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	//import GLKVector3 from '../undefined/GLKVector3'

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _SCNVector = __webpack_require__(15);

	var _SCNVector2 = _interopRequireDefault(_SCNVector);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Returns a three-element GLKit vector structure corresponding to a SceneKit vector structure.
	 * @access public
	 * @param {SCNVector3} vector - A three-element SceneKit vector structure.
	 * @returns {GLKVector3} - 
	 * @see https://developer.apple.com/reference/scenekit/1409651-scnvector3toglkvector3
	 */
	var SCNVector3ToGLKVector3 = function SCNVector3ToGLKVector3(vector) {
	  return null;
	};exports.default = SCNVector3ToGLKVector3;

/***/ },
/* 157 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _SCNVector = __webpack_require__(16);

	var _SCNVector2 = _interopRequireDefault(_SCNVector);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	var _epsilon = 0.00001;

	/**
	 * Returns a Boolean value that indicates whether the corresponding components of two vectors are equal.
	 * @access public
	 * @param {SCNVector4} a - The first vector.
	 * @param {SCNVector4} b - The second vector.
	 * @returns {boolean} - 
	 * @desc This function performs a numeric (not bitwise) comparison of each pair of component values.
	 * @see https://developer.apple.com/reference/scenekit/1409707-scnvector4equaltovector4
	 */
	var SCNVector4EqualToVector4 = function SCNVector4EqualToVector4(a, b) {
	  return Math.abs(a.x - b.x) < _epsilon && Math.abs(a.y - b.y) < _epsilon && Math.abs(a.z - b.z) < _epsilon && Math.abs(a.w - b.w) < _epsilon;
	};

	exports.default = SCNVector4EqualToVector4;

/***/ },
/* 158 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _SCNVector = __webpack_require__(16);

	var _SCNVector2 = _interopRequireDefault(_SCNVector);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * 
	 * @access public
	 * @param {number[]} v - 
	 * @returns {SCNVector4} - 
	 * @see https://developer.apple.com/reference/scenekit/1523606-scnvector4fromfloat4
	 */
	var SCNVector4FromFloat4 = function SCNVector4FromFloat4(v) {
	  return new _SCNVector2.default(v);
	};

	exports.default = SCNVector4FromFloat4;

/***/ },
/* 159 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _SCNVector = __webpack_require__(16);

	var _SCNVector2 = _interopRequireDefault(_SCNVector);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	//import GLKVector4 from '../undefined/GLKVector4'

	/**
	 * Returns a four-element SceneKit vector structure corresponding to a GLKit vector structure.
	 * @access public
	 * @param {GLKVector4} vector - A four-element GLKit vector structure.
	 * @returns {SCNVector4} - 
	 * @see https://developer.apple.com/reference/scenekit/1409729-scnvector4fromglkvector4
	 */
	var SCNVector4FromGLKVector4 = function SCNVector4FromGLKVector4(vector) {
	  return null;
	};

	exports.default = SCNVector4FromGLKVector4;

/***/ },
/* 160 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _SCNVector = __webpack_require__(16);

	var _SCNVector2 = _interopRequireDefault(_SCNVector);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Returns a new four-component vector created from individual component values.
	 * @access public
	 * @param {number} x - The first component of the vector.
	 * @param {number} y - The second component of the vector.
	 * @param {number} z - The third component of the vector.
	 * @param {number} w - The fourth component of the vector.
	 * @returns {SCNVector4} - 
	 * @see https://developer.apple.com/reference/scenekit/1409677-scnvector4make
	 */
	var SCNVector4Make = function SCNVector4Make(x, y, z, w) {
	  return new SCNVector4Make(x, y, z, w);
	};

	exports.default = SCNVector4Make;

/***/ },
/* 161 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _SCNVector = __webpack_require__(16);

	var _SCNVector2 = _interopRequireDefault(_SCNVector);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * 
	 * @access public
	 * @param {SCNVector4} v - 
	 * @returns {number[]} - 
	 * @see https://developer.apple.com/reference/scenekit/1523001-scnvector4tofloat4
	 */
	var SCNVector4ToFloat4 = function SCNVector4ToFloat4(v) {
	  return [v.x, v.y, v.z, v.w];
	};

	exports.default = SCNVector4ToFloat4;

/***/ },
/* 162 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	//import GLKVector4 from '../undefined/GLKVector4'

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _SCNVector = __webpack_require__(16);

	var _SCNVector2 = _interopRequireDefault(_SCNVector);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	/**
	 * Returns a four-element GLKit vector structure corresponding to a SceneKit vector structure.
	 * @access public
	 * @param {SCNVector4} vector - A four-element SceneKit vector structure.
	 * @returns {GLKVector4} - 
	 * @see https://developer.apple.com/reference/scenekit/1409663-scnvector4toglkvector4
	 */
	var SCNVector4ToGLKVector4 = function SCNVector4ToGLKVector4(vector) {
	  return null;
	};exports.default = SCNVector4ToGLKVector4;

/***/ },
/* 163 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _SCNRenderer = __webpack_require__(41);

	var _SCNRenderer2 = _interopRequireDefault(_SCNRenderer);

	var _SCNTechniqueSupport = __webpack_require__(76);

	var _SCNTechniqueSupport2 = _interopRequireDefault(_SCNTechniqueSupport);

	var _CGRect = __webpack_require__(6);

	var _CGRect2 = _interopRequireDefault(_CGRect);

	var _SCNScene = __webpack_require__(43);

	var _SCNScene2 = _interopRequireDefault(_SCNScene);

	var _SCNRenderingAPI = __webpack_require__(73);

	var _SCNRenderingAPI2 = _interopRequireDefault(_SCNRenderingAPI);

	var _SCNAntialiasingMode = __webpack_require__(79);

	var _SCNAntialiasingMode2 = _interopRequireDefault(_SCNAntialiasingMode);

	var _SCNNode = __webpack_require__(33);

	var _SCNNode2 = _interopRequireDefault(_SCNNode);

	var _SCNCamera = __webpack_require__(80);

	var _SCNCamera2 = _interopRequireDefault(_SCNCamera);

	var _SCNMatrix = __webpack_require__(17);

	var _SCNMatrix2 = _interopRequireDefault(_SCNMatrix);

	var _SCNMatrix4MakeTranslation = __webpack_require__(45);

	var _SCNMatrix4MakeTranslation2 = _interopRequireDefault(_SCNMatrix4MakeTranslation);

	var _SKColor = __webpack_require__(48);

	var _SKColor2 = _interopRequireDefault(_SKColor);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	var _Option = {
	  preferLowPowerDevice: Symbol(),
	  preferredDevice: Symbol(),
	  preferredRenderingAPI: Symbol()
	};

	/**
	 * A view for displaying 3D SceneKit content.
	 * @access public
	 * @implements {SCNSceneRenderer}
	 * @implements {SCNTechniqueSupport}
	 * @see https://developer.apple.com/reference/scenekit/scnview
	 */

	var SCNView = function () {

	  // Initializing a SceneKit View

	  /**
	   * Initializes and returns a newly allocated SceneKit view object with the specified frame rectangle and options.
	   * @access public
	   * @constructor
	   * @param {CGRect} frame - The frame rectangle for the view, measured in points and specified in the coordinate system of its superview.
	   * @param {?Map<string, Object>} [options = null] - Rendering options for the view. See SCNView.
	   * @returns {void}
	   * @see https://developer.apple.com/reference/scenekit/scnview/1524215-init
	   */
	  function SCNView(frame) {
	    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

	    _classCallCheck(this, SCNView);

	    if (frame === undefined) {
	      frame = _CGRect2.default.rectWithXYWidthHeight(0, 0, 300, 300);
	    }

	    // Specifying a Scene

	    /**
	     * The scene to be displayed in the view.
	     * @access private
	     * @type {?SCNScene}
	     * @see https://developer.apple.com/reference/scenekit/scnview/1523904-scene
	     */
	    this._scene = null;

	    // Configuring a View

	    /**
	     * The background color of the view.
	     * @type {SKColor}
	     * @see https://developer.apple.com/reference/scenekit/scnview/1523088-backgroundcolor
	     */
	    this.backgroundColor = _SKColor2.default.white;

	    /**
	     * A Boolean value that determines whether the user can manipulate the current point of view that is used to render the scene. 
	     * @type {boolean}
	     * @see https://developer.apple.com/reference/scenekit/scnview/1523171-allowscameracontrol
	     */
	    this.allowsCameraControl = false;

	    /**
	     * The antialiasing mode used for rendering the view’s scene.
	     * @type {SCNAntialiasingMode}
	     * @see https://developer.apple.com/reference/scenekit/scnview/1524085-antialiasingmode
	     */
	    this.antialiasingMode = _SCNAntialiasingMode2.default.multisampling4X;

	    /**
	     * The animation frame rate that the view uses to render its scene.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnview/1621205-preferredframespersecond
	     */
	    this.preferredFramesPerSecond = 0;

	    // Working with a View’s OpenGL ES Context

	    /**
	     * The OpenGL ES context that the view uses to render its contents.
	     * @type {?EAGLContext}
	     * @see https://developer.apple.com/reference/scenekit/scnview/1621072-eaglcontext
	     */
	    //this.eaglContext = null


	    // Working with a View’s OpenGL Context

	    /**
	     * The OpenGL context that the view uses to render its contents.
	     * @type {?NSOpenGLContext}
	     * @see https://developer.apple.com/reference/scenekit/scnview/1522850-openglcontext
	     */
	    //this.openGLContext = null

	    /**
	     * @access private
	     * @type {WebGL2RenderingContext}
	     */
	    this._context = null;

	    /**
	     * The view’s OpenGL pixel format.
	     * @type {?NSOpenGLPixelFormat}
	     * @see https://developer.apple.com/reference/scenekit/scnview/1523612-pixelformat
	     */
	    this.pixelFormat = null;

	    ////////////////////////////////////////////////
	    // SCNSceneRenderer
	    ////////////////////////////////////////////////

	    /**
	     * Required. The graphics technology SceneKit uses to render the scene.
	     * @access private
	     * @type {SCNRenderingAPI}
	     */
	    this._renderingAPI = _SCNRenderingAPI2.default.webGL;

	    // Participating in the Scene Rendering Process

	    /**
	     * Required. A delegate object that receives messages about SceneKit’s rendering process.
	     * @access private
	     * @type {?SCNSceneRendererDelegate}
	     */
	    this._delegate = null;

	    // Customizing Scene Rendering with Metal

	    //this._currentRenderCommandEncoder = null
	    this._device = null; // MTLIGAccelDevice
	    //this._commandQueue = null // MTLIGAccessCommandQueue
	    //this._colorPixelFormat = null // MTLPixelFormat
	    //this._depthPixelFormat = null // MTLPixelFormat
	    //this._stencilPixelFormat = null // MTLPixelFormat

	    // Rendering Sprite Kit Content over a Scene

	    /**
	     * Required. A Sprite Kit scene to be rendered on top of the SceneKit content.
	     * @type {?SKScene}
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1524051-overlayskscene
	     */
	    //this.overlaySKScene = null

	    // Working With Positional Audio

	    /**
	     * Required. The node representing the listener’s position in the scene for use with positional audio effects.
	     * @type {?SCNNode}
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1523747-audiolistener
	     */
	    //this.audioListener = null

	    //this._audioEnvironmentNode = null
	    //this._audioEngine = null

	    // Instance Properties

	    /**
	     * Required. 
	     * @type {number}
	     * @deprecated
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1522854-currenttime
	     */
	    //this.currentTime = 0


	    ////////////////////////////////////////////////
	    // SCNTechniqueSupport
	    ////////////////////////////////////////////////

	    // Specifying a Technique

	    /**
	     * Required. The technique SceneKit uses when rendering the object.
	     * @type {?SCNTechnique}
	     * @see https://developer.apple.com/reference/scenekit/scntechniquesupport/1520496-technique
	     */
	    this.technique = null;

	    // for JavaScript

	    /**
	     * @access private
	     * @type {CGRect}
	     */
	    this._frame = frame;

	    /**
	     * @access private
	     * @type {HTMLCanvasElement}
	     */
	    this._canvas = document.createElement('canvas');
	    this._canvas.width = frame.width;
	    this._canvas.height = frame.height;

	    /**
	     * @access private
	     * @type {WebGLProgram}
	     */
	    this._program = null;

	    /**
	     * @access private
	     * @type {number}
	     */
	    this._canvasWidth = 0;

	    /**
	     * @access private
	     * @type {number}
	     */
	    this._canvasHeight = 0;

	    /**
	     * @access private
	     * @type {number}
	     */
	    this._currentSystemTime = 0;

	    /**
	     * @access private
	     * @type {number}
	     */
	    this._lastUpdate = 0;

	    /**
	     * @access private
	     * @type {SCNSceneRenderer}
	     */
	    this._renderer = new _SCNRenderer2.default();
	    this._renderer.scene = this._scene;

	    /**
	     * @access private
	     * @type {function(function(timestamp: number))}
	     */
	    this._requestAnimationFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (callback) {
	      window.setTimeout(callback, 1000 / 60);
	    };

	    var preferLowPowerDevice = options ? options[SCNView.Option.preferLowPowerDevice] : null;
	    var preferredDevice = options ? options[SCNView.Option.preferredDevice] : null;
	    var preferredRenderingAPI = options ? options[SCNView.Option.preferredRenderingAPI] : null;
	    var opt = {
	      alpha: true,
	      depth: true,
	      stencil: true,
	      antialias: true,
	      premultipliedAlpha: true,
	      preserveDrawingBuffer: false,
	      preferLowPowerToHighPerformance: Boolean(preferLowPowerDevice),
	      failIfMajorPerformanceCaveat: false
	    };

	    //const contextNames = ['webgl2', 'webgl', 'webkit-3d', 'moz-webgl', 'experimental-webgl']
	    var contextNames = ['webgl2'];
	    var _iteratorNormalCompletion = true;
	    var _didIteratorError = false;
	    var _iteratorError = undefined;

	    try {
	      for (var _iterator = contextNames[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	        var name = _step.value;

	        try {
	          this._context = this._canvas.getContext(name, opt);
	        } catch (e) {/* just ignore and try the next name */}
	        if (this._context) {
	          break;
	        }
	      }
	    } catch (err) {
	      _didIteratorError = true;
	      _iteratorError = err;
	    } finally {
	      try {
	        if (!_iteratorNormalCompletion && _iterator.return) {
	          _iterator.return();
	        }
	      } finally {
	        if (_didIteratorError) {
	          throw _iteratorError;
	        }
	      }
	    }

	    if (!this._context) {
	      throw new Error('can\'t create WebGL context');
	    }
	    this._context.viewport(frame.x, frame.y, frame.width, frame.height);

	    this._program = this._context.createProgram();

	    this._renderer._setContext(this._context);
	    this._renderer.program = this._program;
	    this._renderer._viewRect = frame;
	  }

	  /**
	   *
	   * @access public
	   * @param {HTMLElement} element - parent element to append this view
	   * @returns {void}
	   */


	  _createClass(SCNView, [{
	    key: 'appendTo',
	    value: function appendTo(element) {
	      element.appendChild(this._canvas);
	    }

	    /**
	     * Required. A Boolean value that determines whether the scene is playing.
	     * @type {boolean}
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1523401-isplaying
	     */

	  }, {
	    key: 'pause',


	    // Playing Action and Animation in a View’s Scene

	    /**
	     * Pauses playback of the view’s scene.
	     * @access public
	     * @param {?Object} sender - The object requesting the action (used when connecting a control in Interface Builder). SceneKit ignores this parameter.
	     * @returns {void}
	     * @desc This method has no effect if the scene is already paused.
	     * @see https://developer.apple.com/reference/scenekit/scnview/1522825-pause
	     */
	    value: function pause(sender) {
	      if (!this._isPlaying) {
	        return;
	      }
	      this._isPlaying = false;
	    }

	    /**
	     * Resumes playback of the view’s scene.
	     * @access public
	     * @param {?Object} sender - The object requesting the action (used when connecting a control in Interface Builder). SceneKit ignores this parameter.
	     * @returns {void}
	     * @desc This method has no effect if the scene is not paused.
	     * @see https://developer.apple.com/reference/scenekit/scnview/1523699-play
	     */

	  }, {
	    key: 'play',
	    value: function play(sender) {
	      if (this._isPlaying) {
	        return;
	      }
	      this._isPlaying = true;

	      this.__requestAnimationFrame();
	    }

	    /**
	     * Stops playback of the view’s scene and resets the scene time to its start time.
	     * @access public
	     * @param {?Object} sender - The object requesting the action (used when connecting a control in Interface Builder). SceneKit ignores this parameter.
	     * @returns {void}
	     * @see https://developer.apple.com/reference/scenekit/scnview/1524132-stop
	     */

	  }, {
	    key: 'stop',
	    value: function stop(sender) {
	      this._isPlaying = false;
	    }

	    // Capturing a View Snapshot

	    /**
	     * Renders the view’s scene into a new image object.
	     * @access public
	     * @returns {Image} - 
	     * @desc This method is thread-safe and may be called at any time.
	     * @see https://developer.apple.com/reference/scenekit/scnview/1524031-snapshot
	     */

	  }, {
	    key: 'snapshot',
	    value: function snapshot() {
	      return null;
	    }

	    // Structures
	    /**
	     * @type {Object} Option
	     * @property {Symbol} preferLowPowerDevice An option for whether to select low-power-usage devices for Metal rendering.
	     * @property {Symbol} preferredDevice The device to use for Metal rendering.
	     * @property {Symbol} preferredRenderingAPI The rendering API to use for rendering the view (for example, Metal or OpenGL).
	     * @see https://developer.apple.com/reference/scenekit/scnview.option
	     */

	  }, {
	    key: 'presentWithIncomingPointOfView',


	    ////////////////////////////////////////////////
	    // SCNSceneRenderer
	    ////////////////////////////////////////////////

	    // Presenting a Scene

	    /**
	     * Required. Displays the specified scene with an animated transition.
	     * @access public
	     * @param {SCNScene} scene - The new scene to be displayed.
	     * @param {SKTransition} transition - An object that specifies the duration and style of the animated transition.
	     * @param {?SCNNode} pointOfView - The node to use as the pointOfView property when displaying the new scene.
	     * @param {?function(): void} [completionHandler = null] - A block that SceneKit calls after the transition animation has completed.This block takes no parameters and has no return value.
	     * @returns {void}
	     * @desc Use this method to change the scene displayed in a SceneKit view (or other renderer) with an animated transition. For details on transition styles, see SKTransition.
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1523028-present
	     */
	    value: function presentWithIncomingPointOfView(scene, transition, pointOfView) {
	      var completionHandler = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
	    }

	    // Managing Scene Display

	    /**
	     * Required. The node from which the scene’s contents are viewed for rendering.
	     * @type {?SCNNode}
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1523982-pointofview
	     */

	  }, {
	    key: 'prepareShouldAbortBlock',


	    // Preloading Renderer Resources

	    /**
	     * Required. Prepares a SceneKit object for rendering.
	     * @access public
	     * @param {Object} object - An SCNScene, SCNNode, SCNGeometry, or SCNMaterial instance.
	     * @param {?function(): boolean} [block = null] - A block that SceneKit calls periodically while preparing the object. The block takes no parameters.Your block should return false to tell SceneKit to continue preparing the object, or true to cancel preparation.Pass nil for this parameter if you do not need an opportunity to cancel preparing the object.
	     * @returns {boolean} - 
	     * @desc By default, SceneKit lazily loads resources onto the GPU for rendering. This approach uses memory and GPU bandwidth efficiently, but can lead to stutters in an otherwise smooth frame rate when you add large amounts of new content to an animated scene. To avoid such issues, use this method to prepare content for drawing before adding it to the scene. You can call this method on a secondary thread to prepare content asynchronously. SceneKit prepares all content associated with the object parameter you provide. If you provide an SCNMaterial object, SceneKit loads any texture images assigned to its material properties. If you provide an SCNGeometry object, SceneKit loads all materials attached to the geometry, as well as its vertex data. If you provide an SCNNode or SCNScene object, SceneKit loads all geometries and materials associated with the node and all its child nodes, or with the entire node hierarchy of the scene.You can use the block parameter to cancel preparation if content is no longer needed. For example, in a game you might use this method to preload areas of the game world the player is soon to enter, but if the player character dies before entering those areas, you can return true from the block to cancel preloading.You can observe the progress of this operation with the Progress class. For details, see Progress.
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1522798-prepare
	     */
	    value: function prepareShouldAbortBlock(object) {
	      var block = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

	      return false;
	    }

	    /**
	     * Required. Prepares the specified SceneKit objects for rendering, using a background thread.
	     * @access public
	     * @param {Object[]} objects - An array of containing one or more SCNScene, SCNNode, SCNGeometry, or SCNMaterial instances.
	     * @param {?function(arg1: boolean): void} [completionHandler = null] - A block that SceneKit calls when object preparation fails or completes.The block takes the following parameter:successtrue if all content was successfully prepared for rendering; otherwise, false.
	     * @returns {void}
	     * @desc By default, SceneKit lazily loads resources onto the GPU for rendering. This approach uses memory and GPU bandwidth efficiently, but can lead to stutters in an otherwise smooth frame rate when you add large amounts of new content to an animated scene. To avoid such issues, use this method to prepare content for drawing before adding it to the scene. SceneKit uses a secondary thread to prepare content asynchronously.SceneKit prepares all content associated with the objects you provide. If you provide an SCNMaterial object, SceneKit loads any texture images assigned to its material properties. If you provide an SCNGeometry object, SceneKit loads all materials attached to the geometry, as well as its vertex data. If you provide an SCNNode or SCNScene object, SceneKit loads all geometries and materials associated with the node and all its child nodes, or with the entire node hierarchy of the scene.You can observe the progress of this operation with the Progress class. For details, see Progress.
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1523375-prepare
	     */

	  }, {
	    key: 'prepare',
	    value: function prepare(objects) {
	      var completionHandler = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
	    }

	    // Working With Projected Scene Contents

	    /**
	     * Required. Searches the renderer’s scene for objects corresponding to a point in the rendered image.
	     * @access public
	     * @param {CGPoint} point - 
	     * @param {?Map<SCNHitTestOption, Object>} [options = null] - A dictionary of options affecting the search. See Hit Testing Options Keys for acceptable values.
	     * @returns {SCNHitTestResult[]} - 
	     * @desc A 2D point in the rendered screen coordinate space can refer to any point along a line segment in the 3D scene coordinate space. Hit-testing is the process of finding elements of a scene located along this line segment. For example, you can use this method to find the geometry corresponding to a click event in a SceneKit view.
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1522929-hittest
	     */

	  }, {
	    key: 'hitTest',
	    value: function hitTest(point) {
	      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

	      return null;
	    }

	    /**
	     * Required. Returns a Boolean value indicating whether a node might be visible from a specified point of view.
	     * @access public
	     * @param {SCNNode} node - The node whose visibility is to be tested.
	     * @param {SCNNode} pointOfView - A node defining a point of view, as used by the pointOfView property.
	     * @returns {boolean} - 
	     * @desc Any node containing a camera or spotlight may serve as a point of view (see the pointOfView property for details). Such a node defines a viewing frustum—a portion of the scene’s coordinate space, shaped like a truncated pyramid, that encloses all points visible from that point of view.Use this method to test whether a node lies within the viewing frustum defined by another node (which may or may not be the scene renderer’s current pointOfView node). For example, in a game scene containing multiple camera nodes, you could use this method to determine which camera is currently best for viewing a moving player character.Note that this method does not perform occlusion testing. That is, it returns true if the tested node lies within the specified viewing frustum regardless of whether that node’s contents are obscured by other geometry.
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1522647-isnode
	     */

	  }, {
	    key: 'isNodeInsideFrustumOf',
	    value: function isNodeInsideFrustumOf(node, pointOfView) {
	      return false;
	    }

	    /**
	     * Required. Returns all nodes that might be visible from a specified point of view.
	     * @access public
	     * @param {SCNNode} pointOfView - A node defining a point of view, as used by the pointOfView property.
	     * @returns {SCNNode[]} - 
	     * @desc Any node containing a camera or spotlight may serve as a point of view (see the pointOfView property for details). Such a node defines a viewing frustum—a portion of the scene’s coordinate space, shaped like a truncated pyramid, that encloses all points visible from that point of view.Use this method find all nodes whose content lies within the viewing frustum defined by another node (which may or may not be the scene renderer’s current pointOfView node).Note that this method does not perform occlusion testing. That is, the returned array includes any node that lies within the specified viewing frustum regardless of whether that node’s contents are obscured by other geometry.
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1522942-nodesinsidefrustum
	     */

	  }, {
	    key: 'nodesInsideFrustumOf',
	    value: function nodesInsideFrustumOf(pointOfView) {
	      return null;
	    }

	    /**
	     * Required. Projects a point from the 3D world coordinate system of the scene to the 2D pixel coordinate system of the renderer.
	     * @access public
	     * @param {SCNVector3} point - A point in the world coordinate system of the renderer’s scene.
	     * @returns {SCNVector3} - 
	     * @desc The z-coordinate of the returned point describes the depth of the projected point relative to the near and far clipping planes of the renderer’s viewing frustum (defined by its pointOfView node). Projecting a point on the near clipping plane returns a point whose z-coordinate is 0.0; projecting a point on the far clipping plane returns a point whose z-coordinate is 1.0.
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1524089-projectpoint
	     */

	  }, {
	    key: 'projectPoint',
	    value: function projectPoint(point) {
	      return null;
	    }

	    /**
	     * Required. Unprojects a point from the 2D pixel coordinate system of the renderer to the 3D world coordinate system of the scene.
	     * @access public
	     * @param {SCNVector3} point - A point in the screen-space (view, layer, or GPU viewport) coordinate system of the scene renderer.
	     * @returns {SCNVector3} - 
	     * @desc The z-coordinate of the point parameter describes the depth at which to unproject the point relative to the near and far clipping planes of the renderer’s viewing frustum (defined by its pointOfView node). Unprojecting a point whose z-coordinate is 0.0 returns a point on the near clipping plane; unprojecting a point whose z-coordinate is 1.0 returns a point on the far clipping plane.A 2D point in the rendered screen coordinate space can refer to any point along a line segment in the 3D scene coordinate space. To test for scene contents along this line—for example, to find the geometry corresponding to the location of a click event in a view—use the hitTest(_:options:) method.
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1522631-unprojectpoint
	     */

	  }, {
	    key: 'unprojectPoint',
	    value: function unprojectPoint(point) {
	      return null;
	    }

	    // Customizing Scene Rendering with Metal

	    /**
	     * Required. The Metal render command encoder in use for the current SceneKit rendering pass.
	     * @type {?MTLRenderCommandEncoder}
	     * @desc Use this render command encoder to encode additional rendering commands before or after SceneKit draws its own content.This property is valid only during the SceneKit rendering loop—that is, within one of the methods defined in the SCNSceneRendererDelegate protocol. Accessing this property at any other time returns nil.
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1522609-currentrendercommandencoder
	     */

	  }, {
	    key: 'viewDidMoveToWindow',


	    ////////////////////////////////////////////////
	    // NSView/UIView
	    ////////////////////////////////////////////////
	    // TODO: implement NSView/UIView and extend it
	    value: function viewDidMoveToWindow() {}
	  }, {
	    key: 'setFrameSize',
	    value: function setFrameSize(newSize) {}

	    /**
	     * draw one frame
	     * @access private
	     * @param {number} time - current time
	     * @param {WebGLRenderingContext} context - context to draw frame
	     * @returns {void}
	     */

	  }, {
	    key: '_drawAtTimeWithContext',
	    value: function _drawAtTimeWithContext(time, context) {
	      this._createPresentationNodes();

	      var program = this._program;

	      this._updateTransform();

	      if (this._delegate && this._delegate.rendererUpdateAtTime) {
	        this._delegate.rendererUpdateAtTime(this._renderer, time);
	      }

	      ///////////////////////////////
	      // runs actions & animations //
	      ///////////////////////////////
	      this._runActions();
	      this._runAnimations();

	      this._updateTransform();

	      if (this._delegate && this._delegate.rendererDidApplyAnimationsAtTime) {
	        this._delegate.rendererDidApplyAnimationsAtTime(this._renderer, time);
	      }

	      this._updateTransform();

	      ///////////////////////
	      // simulates physics //
	      ///////////////////////

	      if (this._delegate && this._delegate.rendererDidSimulatePhysicsAtTime) {
	        this._delegate.rendererDidSimulatePhysicsAtTime(this._renderer, time);
	      }

	      ///////////////////////////
	      // evaluates constraints //
	      ///////////////////////////

	      if (this._delegate && this._delegate.rendererWillRenderSceneAtTime) {
	        this._delegate.rendererWillRenderSceneAtTime(this._renderer, this._scene, time);
	      }

	      ///////////////////////
	      // renders the scene //
	      ///////////////////////
	      this._renderer.prepareBuffer();
	      this._updateMorph();
	      this._renderer.render();

	      if (this._delegate && this._delegate.rendererDidRenderSceneAtTime) {
	        this._delegate.rendererDidRenderSceneAtTime(this._renderer, time);
	      }
	    }
	  }, {
	    key: '_createPresentationNodes',
	    value: function _createPresentationNodes() {
	      var arr = [this._scene.rootNode];

	      var _loop = function _loop() {
	        var node = arr.shift();
	        var p = node._presentation;
	        if (p === null) {
	          p = node.copy();
	          p._isPresentationInstance = true;
	          if (node.geometry !== null) {
	            p.geometry = node.geometry.copy();
	            // FIXME: don't access private properties
	            p.geometry._geometryElements = [];
	            node.geometry._geometryElements.forEach(function (element) {
	              p.geometry._geometryElements.push(element.copy());
	            });
	            p.geometry._geometrySources = [];
	            node.geometry._geometrySources.forEach(function (source) {
	              p.geometry._geometrySources.push(source.copy());
	            });
	          }
	          node._presentation = p;
	        }
	        p._position = node._position;
	        p._rotation = node._rotation;
	        p._scale = node._scale;

	        arr.push.apply(arr, _toConsumableArray(node.childNodes));
	      };

	      while (arr.length > 0) {
	        _loop();
	      }
	    }

	    /**
	     * request animation frame repeatedly as long as isPlaying is true
	     * @access private
	     * @returns {void}
	     */

	  }, {
	    key: '__requestAnimationFrame',
	    value: function __requestAnimationFrame() {
	      var _this = this;

	      // Reflect.apply(this._requestAnimationFrame, window, () => {
	      this._requestAnimationFrame.call(window, function () {
	        _this._currentSystemTime = Date.now() * 0.001;
	        _this.currentTime = _this._currentSystemTime;
	        _this._drawAtTimeWithContext(_this.currentTime, _this._context);
	        //console.log('requestAnimationFrame: time: ' + this.currentTime)

	        if (_this._isPlaying) {
	          _this.__requestAnimationFrame();
	        }
	      });
	    }
	  }, {
	    key: '_updateTransform',
	    value: function _updateTransform(node, parentTransform) {
	      this._scene.rootNode._updateWorldTransform();
	    }
	  }, {
	    key: '_updateMorph',
	    value: function _updateMorph(node) {
	      var _this2 = this;

	      if (typeof node === 'undefined') {
	        this._updateMorph(this._scene.rootNode);
	        return;
	      }
	      if (node.morpher !== null) {
	        node.morpher._morph(node);
	      }
	      node.childNodes.forEach(function (child) {
	        _this2._updateMorph(child);
	      });
	    }
	  }, {
	    key: '_runActions',
	    value: function _runActions() {}
	  }, {
	    key: '_runAction',
	    value: function _runAction() {}
	  }, {
	    key: '_runAnimations',
	    value: function _runAnimations() {
	      //console.log('_runAnimations')
	      this._runAnimation(this._scene.rootNode);
	    }
	  }, {
	    key: '_runAnimation',
	    value: function _runAnimation(node) {
	      var _this3 = this;

	      var deleteKeys = [];
	      var time = this.currentTime;
	      //console.log(`time: ${time}`)
	      node._animations.forEach(function (animation, key) {
	        //console.log(`node: ${node.name}, animation: ${key} ${animation}`)
	        animation._applyAnimation(node, time);
	        if (animation._isFinished && animation.isRemovedOnCompletion) {
	          deleteKeys.push(key);
	        }
	      });
	      deleteKeys.forEach(function (key) {
	        node._animations.delete(key);
	      });
	      node.childNodes.forEach(function (child) {
	        return _this3._runAnimation(child);
	      });
	    }
	  }, {
	    key: 'isPlaying',
	    get: function get() {
	      return this._renderer.isPlaying;
	    }

	    /**
	     * Required. A Boolean value that determines whether the scene is playing.
	     * @type {boolean}
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1523401-isplaying
	     */
	    ,
	    set: function set(newValue) {
	      if (newValue) {
	        this.play();
	      } else {
	        this.pause();
	      }
	    }

	    // Specifying a Scene

	    /**
	     * The scene to be displayed in the view.
	     * @access private
	     * @type {?SCNScene}
	     * @see https://developer.apple.com/reference/scenekit/scnview/1523904-scene
	     */

	  }, {
	    key: 'scene',
	    get: function get() {
	      return this._scene;
	    }

	    /**
	     * The scene to be displayed in the view.
	     * @access private
	     * @type {?SCNScene}
	     * @see https://developer.apple.com/reference/scenekit/scnview/1523904-scene
	     */
	    ,
	    set: function set(newValue) {
	      // FIXME: it should not be changed while drawing
	      this._scene = newValue;
	      this._renderer.scene = this._scene;
	    }
	  }, {
	    key: 'pointOfView',
	    get: function get() {
	      return this._renderer.pointOfView;
	    },
	    set: function set(newValue) {
	      this._renderer.pointOfView = newValue;
	    }

	    /**
	     * Required. A Boolean value that determines whether SceneKit automatically adds lights to a scene.
	     * @type {boolean}
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1523812-autoenablesdefaultlighting
	     */

	  }, {
	    key: 'autoenablesDefaultLighting',
	    get: function get() {
	      return this._renderer.autoenablesDefaultLighting;
	    },
	    set: function set(newValue) {
	      this._renderer.autoenablesDefaultLighting = newValue;
	    }

	    /**
	     * Required. A Boolean value that determines whether SceneKit applies jittering to reduce aliasing artifacts.
	     * @type {boolean}
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1524026-isjitteringenabled
	     */

	  }, {
	    key: 'isJitteringEnabled',
	    get: function get() {
	      return this._renderer.isJitteringEnabled;
	    },
	    set: function set(newValue) {
	      this._renderer.isJitteringEnabled = newValue;
	    }

	    /**
	     * Required. A Boolean value that determines whether SceneKit displays rendering performance statistics in an accessory view.
	     * @type {boolean}
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1522763-showsstatistics
	     */

	  }, {
	    key: 'showsStatistics',
	    get: function get() {
	      return this._renderer.showsStatistics;
	    },
	    set: function set(newValue) {
	      this._renderer.showsStatistics = newValue;
	    }

	    /**
	     * Required. Options for drawing overlay content in a scene that can aid debugging.
	     * @type {SCNDebugOptions}
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1523281-debugoptions
	     */

	  }, {
	    key: 'debugOptions',
	    get: function get() {
	      return this._renderer.debugOptions;
	    },
	    set: function set(newValue) {
	      this._renderer.debugOptions = newValue;
	    }

	    /**
	     * Required. The current scene time.
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1522680-scenetime
	     */

	  }, {
	    key: 'sceneTime',
	    get: function get() {
	      return this._renderer.sceneTime;
	    },
	    set: function set(newValue) {
	      this._renderer.sceneTime = newValue;
	    }

	    /**
	     * Required. A Boolean value that determines whether SceneKit restarts the scene time after all animations in the scene have played.
	     * @type {boolean}
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1522878-loops
	     */

	  }, {
	    key: 'loops',
	    get: function get() {
	      return this._renderer.loops;
	    },
	    set: function set(newValue) {
	      this._renderer.loops = newValue;
	    }

	    /**
	     * Required. The graphics technology SceneKit uses to render the scene.
	     * @type {SCNRenderingAPI}
	     * @desc You choose a graphics technology when initializing a scene renderer:When initializing a SCNView object, use the init(frame:options:) initializer and the preferredRenderingAPI key. Alternatively, create a view in Interface Builder and use the Rendering API control in the inspector. During initialization, the view will attempt to use the preferred API, but will fall back to a different API if the preferred one is not supported on the current hardware.To create a SCNRenderer object that renders into your own OpenGL contect, use the init(context:options:) initializer. To create a renderer for use in your own Metal workflow, use the init(device:options:) initializer.The rendering technology used by a SCNLayer object is determined by Core Animation.After initializing a renderer, this property reflects the rendering technology in use.
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1522616-renderingapi
	     */

	  }, {
	    key: 'renderingAPI',
	    get: function get() {
	      return this._renderingAPI;
	    }

	    // Participating in the Scene Rendering Process

	    /**
	     * Required. A delegate object that receives messages about SceneKit’s rendering process.
	     * @type {?SCNSceneRendererDelegate}
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1522671-delegate
	     */

	  }, {
	    key: 'delegate',
	    get: function get() {
	      return this._delegate;
	    }

	    /**
	     * Required. A delegate object that receives messages about SceneKit’s rendering process.
	     * @type {?SCNSceneRendererDelegate}
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1522671-delegate
	     */
	    ,
	    set: function set(newValue) {
	      // FIXME: delegate should not be changed while drawing
	      this._delegate = newValue;
	    }
	  }, {
	    key: 'currentRenderCommandEncoder',
	    get: function get() {
	      return this._renderer.currentRenderCommandEncoder;
	    }

	    /**
	     * Required. The Metal device this renderer uses for rendering.
	     * @type {?MTLDevice}
	     * @desc Use this property to create or look up other Metal resources that use the same device as your SceneKit renderer.NoteThis property is valid only for scene renderers whose renderingAPI value is metal. You create a SceneKit view that renders using Metal with the preferredRenderingAPI initialization option or in Interface Builder, or an SCNRenderer that uses Metal with the init(device:options:) method. For OpenGL-based scene renderers, this property’s value is always nil.
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1523935-device
	     */

	  }, {
	    key: 'device',
	    get: function get() {
	      return this._device;
	    }

	    /**
	     * Required. The Metal command queue this renderer uses for rendering.
	     * @type {?MTLCommandQueue}
	     * @desc Use this property to schedule additional command buffers for the Metal device to execute as part of the render cycle. For example, you can use a compute command encoder to modify the vertex data in a Metal buffer for use by a SCNGeometrySource object.NoteThis property is valid only for scene renderers whose renderingAPI value is metal. You create a SceneKit view that renders using Metal with the preferredRenderingAPI initialization option or in Interface Builder, or an SCNRenderer that uses Metal with the init(device:options:) method. For OpenGL-based scene renderers, this property’s value is always nil.
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1523974-commandqueue
	     */

	  }, {
	    key: 'commandQueue',
	    get: function get() {
	      return this._renderer.commandQueue;
	    }

	    /**
	     * Required. The Metal pixel format for the renderer’s color output.
	     * @type {MTLPixelFormat}
	     * @desc Use this property, along with the depthPixelFormat and stencilPixelFormat properties, if you perform custom drawing with Metal (see the SCNSceneRendererDelegate and SCNNodeRendererDelegate classes) and need to create a new MTLRenderPipelineState object to change the GPU state as part of your rendering.NoteThis property is valid only for scene renderers whose renderingAPI value is metal. You create a SceneKit view that renders using Metal with the preferredRenderingAPI initialization option or in Interface Builder, or an SCNRenderer that uses Metal with the init(device:options:) method. For OpenGL-based scene renderers, this property’s value is always nil.
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1523701-colorpixelformat
	     */

	  }, {
	    key: 'colorPixelFormat',
	    get: function get() {
	      return this._renderer.colorPixelFormat;
	    }

	    /**
	     * Required. The Metal pixel format for the renderer’s depth buffer.
	     * @type {MTLPixelFormat}
	     * @desc Use this property, along with the colorPixelFormat and stencilPixelFormat properties, if you perform custom drawing with Metal (see the SCNSceneRendererDelegate and SCNNodeRendererDelegate classes) and need to create a new MTLRenderPipelineState object to change the GPU state as part of your rendering.NoteThis property is valid only for scene renderers whose renderingAPI value is metal. You create a SceneKit view that renders using Metal with the preferredRenderingAPI initialization option or in Interface Builder, or an SCNRenderer that uses Metal with the init(device:options:) method. For OpenGL-based scene renderers, this property’s value is always nil.
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1523780-depthpixelformat
	     */

	  }, {
	    key: 'depthPixelFormat',
	    get: function get() {
	      return this._renderer.depthPixelFormat;
	    }

	    /**
	     * Required. The Metal pixel format for the renderer’s stencil buffer.
	     * @type {MTLPixelFormat}
	     * @desc Use this property, along with the depthPixelFormat and colorPixelFormat properties, if you perform custom drawing with Metal (see the SCNSceneRendererDelegate and SCNNodeRendererDelegate classes) and need to create a new MTLRenderPipelineState object to change the GPU state as part of your rendering.NoteThis property is valid only for scene renderers whose renderingAPI value is metal. You create a SceneKit view that renders using Metal with the preferredRenderingAPI initialization option or in Interface Builder, or an SCNRenderer that uses Metal with the init(device:options:) method. For OpenGL-based scene renderers, this property’s value is always nil.
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1523315-stencilpixelformat
	     */

	  }, {
	    key: 'stencilPixelFormat',
	    get: function get() {
	      return this._renderer._stencilPixelFormat;
	    }

	    // Customizing Scene Rendering with OpenGL

	    /**
	     * Required. The OpenGL rendering context that SceneKit uses for rendering the scene.
	     * @type {?WebGLRenderingContext}
	     * @desc In macOS, the value of this property is a Core OpenGL cglContextObj object.In iOS, the value of this property is an EAGLContext object.
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1522840-context
	     */

	  }, {
	    key: 'context',
	    get: function get() {
	      return this._renderer.context;
	    }

	    // Rendering Sprite Kit Content over a Scene

	    /**
	     * Required. A Sprite Kit scene to be rendered on top of the SceneKit content.
	     * @type {?SKScene}
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1524051-overlayskscene
	     */

	  }, {
	    key: 'overlaySKScene',
	    get: function get() {
	      return this._renderer.overlaySKScene;
	    },
	    set: function set(newValue) {
	      this._renderer.overlaySKScene = newValue;
	    }

	    // Working With Positional Audio

	    /**
	     * Required. The node representing the listener’s position in the scene for use with positional audio effects.
	     * @type {?SCNNode}
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1523747-audiolistener
	     */

	  }, {
	    key: 'audioListener',
	    get: function get() {
	      return this._renderer.audioListener;
	    },
	    set: function set(newValue) {
	      this._renderer.audioListener = newValue;
	    }

	    /**
	     * Required. The 3D audio mixing node SceneKit uses for positional audio effects.
	     * @type {AVAudioEnvironmentNode}
	     * @desc SceneKit uses this audio node to spatialize sounds from SCNAudioPlayer objects attached to nodes in the scene. You can use this object in conjunction with the audioEngine property to rearrange the audio graph to add other, non-spatialized audio sources or mix in audio processing effects.
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1523582-audioenvironmentnode
	     */

	  }, {
	    key: 'audioEnvironmentNode',
	    get: function get() {
	      return this._renderer.audioEnvironmentNode;
	    }

	    /**
	     * Required. The audio engine SceneKit uses for playing scene sounds.
	     * @type {AVAudioEngine}
	     * @desc SceneKit uses this audio engine to play sounds from SCNAudioPlayer objects attached to nodes in the scene. You can use this object directly to add other sound sources not related to scene contents, or to add other sound processing nodes or mixing nodes to the audio engine. To identify the node SceneKit uses for spatializing scene sounds when connecting other nodes, use the audioEnvironmentNode property.
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1522686-audioengine
	     */

	  }, {
	    key: 'audioEngine',
	    get: function get() {
	      return this._renderer.audioEngine;
	    }

	    // Instance Properties

	    /**
	     * Required. 
	     * @type {number}
	     * @see https://developer.apple.com/reference/scenekit/scnscenerenderer/1522854-currenttime
	     */

	  }, {
	    key: 'currentTime',
	    get: function get() {
	      return this._renderer.currentTime;
	    },
	    set: function set(newValue) {
	      this._renderer.currentTime = newValue;
	    }
	  }], [{
	    key: 'Option',
	    get: function get() {
	      return _Option;
	    }
	  }]);

	  return SCNView;
	}();

	//if (customElements) {
	//  customElements.define('scn-view', SCNView)
	//}


	exports.default = SCNView;

/***/ }
/******/ ]);